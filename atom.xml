<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YZ</title>
  
  <subtitle>这是一名小学生</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-08-09T02:05:18.135Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>YZ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>泛型和通配符</title>
    <link href="http://example.com/2023/08/08/Java%E5%9F%BA%E7%A1%80/%E6%B3%9B%E5%9E%8B%E5%92%8C%E9%80%9A%E9%85%8D%E7%AC%A6/"/>
    <id>http://example.com/2023/08/08/Java%E5%9F%BA%E7%A1%80/%E6%B3%9B%E5%9E%8B%E5%92%8C%E9%80%9A%E9%85%8D%E7%AC%A6/</id>
    <published>2023-08-08T02:17:47.000Z</published>
    <updated>2023-08-09T02:05:18.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h2><p><strong>Java泛型（Generics）</strong>是JDK5中引入的一个新特性，使用泛型参数，可以增强代码的可读性以及稳定性。</p><p>编译器可以对泛型参数进行检测，并且通过泛型参数可以指定对传入的对象类型。比如<code>ArrayList&lt;Person&gt; =new ArrayList()</code></p><p>这行代码就指明了该<code>ArrayList</code>对象只能传入<code>Person</code>对象，如果传入其他类型的对象就会报错。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br></pre></td></tr></table></figure><p>并且，原生<code>List</code>返回类型是<code>Object</code>,需要手动转换类型才能使用，使用泛型后编译器自动转换。</p><h2 id="泛型的使用方式"><a href="#泛型的使用方式" class="headerlink" title="泛型的使用方式"></a>泛型的使用方式</h2><p>泛型一般有三种使用方式:<strong>泛型类</strong>、<strong>泛型接口</strong>、<strong>泛型方法</strong></p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>泛型类允许你在类的定义中使用类型参数，示例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>Box</code> 类可以存储任何类型的数据，并在实例化时指定具体的类型。</p><p>如何实例化泛型类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Box&lt;Interger&gt; box = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;Interger&gt;(<span class="number">123</span>);</span><br></pre></td></tr></table></figure><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>类似于泛型类，你也可以创建泛型接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现泛型接口，不指定类型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现泛型接口，指定类型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>除了泛型类和泛型接口，Java 也支持泛型方法。这意味着你可以在方法中使用类型参数，而不仅仅是在类或接口级别上。示例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(T[] array)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (T element : array) &#123;</span><br><span class="line">        System.out.print(element + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="项目中哪些用到了泛型"><a href="#项目中哪些用到了泛型" class="headerlink" title="项目中哪些用到了泛型"></a>项目中哪些用到了泛型</h2><ul><li>自定义接口通用结果<code>CommonResult</code>通过参数<code>T</code>可根据具体的返回类型动态指定结果的数据类型</li><li>定义<code>Excel</code>处理类<code>ExcelUtil&lt;T&gt;</code>用于动态指定<code>Excel</code>导出的数据类型</li><li>构建集合工具类（参考<code>Collections</code>中的<code>sort</code>，<code>binarySearch</code>方法）</li></ul><h2 id="什么是类型擦除机制"><a href="#什么是类型擦除机制" class="headerlink" title="什么是类型擦除机制"></a>什么是类型擦除机制</h2><p><strong>我们说Java的泛型是伪泛型，那是因为泛型信息只存在于代码编译阶段，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程为类型擦除。</strong></p><p>编译器在编译期间会动态地将泛型<code>T</code>擦除为<code>Object</code>或将<code>T extends xxx</code>擦除为其限定类型<code>xxx</code>。</p><p>因此，泛型本质上其实还是编译器的行为，为了保证引入泛型机制而不创建新的类型，减少虚拟机的运行开销，编译器通过类型擦除将泛型转化为一般类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">      list.add(<span class="number">6</span>);</span><br><span class="line">      <span class="comment">//反射机制实现</span></span><br><span class="line">      Class&lt;? <span class="keyword">extends</span> <span class="title class_">ArrayList</span>&gt; clazz = list.getClass();</span><br><span class="line">      <span class="type">Method</span> <span class="variable">add</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line">      add.invoke(list, <span class="string">&quot;欢迎关注:后端元宇宙&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;list = &quot;</span> + list);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list = [<span class="number">6</span>, 欢迎关注:后端元宇宙]</span><br></pre></td></tr></table></figure><p>因为这里泛型定义为Integer类型集合，所以添加String的时候在编译时期就会直接报错。</p><p>那是不是就一定不能添加了呢？答案是否定的，我们可以通过Java泛型中的类型擦除特点及反射机制实现。</p><p>再举个例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//&#x27;print(List&lt;String&gt;)&#x27; clashes with &#x27;print(List&lt;Integer&gt;)&#x27;; both methods have same erasure</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;String&gt; list)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;Integer&gt; list)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>由于类型擦除之后，<code>List&lt;String&gt;</code>和<code>List&lt;Interger&gt;</code>在编译以后都变成了List</p><h2 id="什么是桥方法"><a href="#什么是桥方法" class="headerlink" title="什么是桥方法"></a>什么是桥方法</h2><p>桥方法（Bridge Method）是在Java中用于解决泛型类型擦除带来的类型安全问题的一种机制，用于继承泛型类是保证多态。</p><p>在Java中，泛型类型在编译时会执行类型擦除，也就是在编译后泛型类型的类型信息会被擦除为其上界类型或者是Object类型。这样做是为了保持Java的向后兼容性。</p><p>然而，泛型方法的类型擦除可能会导致一些类型安全问题，特别是当涉及到子类和父类之间的继承关系以及重写（Override）方法时。为了解决这个问题，Java编译器会在需要的情况下生成桥方法。</p><p>桥方法是由编译器自动生成的方法，被用于保留子类与父类之间在泛型类型上的一致性。它的作用是在子类中重写父类的泛型方法时，为了保持方法签名一致性而生成的额外方法。</p><p>桥方法通常会有以下特点：</p><ol><li>桥方法是由编译器自动生成的，开发者无需手动编写。</li><li>桥方法会使用桥接（Bridge）类型来保持方法重写时的类型一致性。</li><li>桥方法的访问修饰符和返回值类型与父类方法一致，参数类型会根据擦除后的类型进行调整。</li><li>桥方法会调用对应的原始方法（父类方法）以保持行为的一致性。</li></ol><p>通过生成桥方法，Java能够在运行时正确地处理继承和方法重写，以保持泛型类型的类型安全。</p><p>下面是一个使用泛型类型的例子，其中涉及到桥方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySubClass</span> <span class="keyword">extends</span> <span class="title class_">MyClass</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Subclass: &quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，MyClass是一个泛型类，而MySubClass是它的子类。子类MySubClass指定了具体的类型参数String。</p><p>当编译器处理这段代码时，它会生成一个桥方法，确保子类的print方法的参数类型与父类保持一致。生成的桥方法如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySubClass</span> <span class="keyword">extends</span> <span class="title class_">MyClass</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">        print((String) value); <span class="comment">// 调用实际的子类方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，桥方法使用父类的方法签名，并将参数类型强制转换为子类在实际方法中使用的类型。这样就保证了继承泛型类型时的类型安全</p><p>通过桥方法，Java编译器可以确保子类在使用泛型类型时的类型一致性，并避免了类型不匹配的问题。</p><h2 id="常用的-？-T-E-K-V-N的含义"><a href="#常用的-？-T-E-K-V-N的含义" class="headerlink" title="常用的 ？, T, E, K, V, N的含义"></a>常用的 ？, T, E, K, V, N的含义</h2><p>我们在泛型中使用通配符经常看到T、F、U、E，K，V其实这些并没有啥区别,我们可以选 A-Z 之间的任何一个字母都可以，并不会影响程序的正常运行。</p><p>只不过大家心照不宣的在命名上有些约定:</p><ul><li>T (Type) 具体的Java类</li><li>E (Element)在集合中使用，因为集合中存放的是元素</li><li>K V (key value) 分别代表java键值中的Key Value</li><li>N （Number）数值类型</li><li>? 表示不确定的 Java 类型</li></ul><h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><h2 id="什么是通配符"><a href="#什么是通配符" class="headerlink" title="什么是通配符"></a>什么是通配符</h2><p>泛型类型是固定的，在某些场景下使用起来不太灵活，于是，通配符就来了！通配符可以允许类型参数变化，用来解决泛型无法协变的问题。</p><h2 id="通配符？和常用的泛型T之间有什么区别？"><a href="#通配符？和常用的泛型T之间有什么区别？" class="headerlink" title="通配符？和常用的泛型T之间有什么区别？"></a>通配符？和常用的泛型T之间有什么区别？</h2><ul><li>T可以用于声明变量或常量而？不行</li><li>T一般用于声明泛型类或方法，通配符？一般用于泛型方法的调用代码和形参。</li><li>T在编译期间会被擦除为限定类型或Object,通配符用于捕获具体类型。</li></ul><h1 id="什么是无界通配符"><a href="#什么是无界通配符" class="headerlink" title="什么是无界通配符"></a>什么是无界通配符</h1><p>无界通配符可以接收任何泛型类型数据，用于实现不依赖于具体类型参数的简单方法，可以捕获参数类型并交由泛型方法进行处理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">(Person&lt;?&gt; p)</span>&#123;</span><br><span class="line">    <span class="comment">// 泛型方法自行处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>List&lt;?&gt;和List有区别吗？</p><ul><li>List&lt;?&gt; list表示list是持有某种特定类型的List，但是不知道具体是哪种类型。因此，我们添加元素进去的时候就会报错。</li><li>List list 表示list是持有的元素的类型是Object，因此可以添加任何类型的对象，只不过编译器会有警告信息。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;?&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;?&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);<span class="comment">//报错</span></span><br><span class="line">ArrayList&lt;&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list1.add(<span class="number">1</span>); <span class="comment">// 警告信息</span></span><br></pre></td></tr></table></figure><h2 id="上边界通配符-amp-下边界通配符"><a href="#上边界通配符-amp-下边界通配符" class="headerlink" title="上边界通配符&amp;下边界通配符"></a>上边界通配符&amp;下边界通配符</h2><p>在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制。如：<strong>类型参数只准传入某种类型的父类或某种类型的子类</strong></p><h3 id="上边界通配符"><a href="#上边界通配符" class="headerlink" title="上边界通配符"></a>上边界通配符</h3><p>语法：<code>&lt;? extends E&gt;</code></p><p>它表示泛型参数可以是指定类型或其子类型。例如，<code>&lt;? extends E&gt;</code>表示接受E类型或其子类型。 </p><ul><li>add：除了null之外，不允许加入任何元素！</li><li>get: 可以获取元素，可以通过E或者Object接收元素！因为不论传入什么数据类型都是E的子类型</li></ul><h3 id="下边界通配符"><a href="#下边界通配符" class="headerlink" title="下边界通配符"></a>下边界通配符</h3><p>语法： <code>&lt;? super E&gt;</code></p><p>它表示泛型参数可以是指定类型或其父类型。例如，<code>&lt;? super E&gt;</code>表示接受E类型或其父类型。 </p><ul><li>add: 允许添加E和E的子类元素</li><li>get: 可以获取元素，但只能通过以Object类型接收元素！因为传入的类型可能是E到Object之间的任何类型，也就无法确定接收到     的数据类型，所以只能通过Object来接收</li></ul><p>在使用下界边界符时，可以向其中添加指定类型或其子类型的数据，但读取数据时只能以Object类型来进行读取。</p><h2 id="什么是PECS原则"><a href="#什么是PECS原则" class="headerlink" title="什么是PECS原则"></a>什么是PECS原则</h2><p>PECS原则是指“Producer Extends，Consumer Super”的缩写，是一种泛型设计原则，用于指导在进行泛型类型参数限制时的选择。</p><p>简单来说，PECS原则指出：</p><ul><li>当泛型类型参数作为生产者（Producer）时，即只用于获取数据而不修改数据时，应该使用上界通配符（<code>&lt;? extends T&gt;</code>）进行限制；</li><li>当泛型类型参数作为消费者（Consumer）时，即只用于添加数据而不读取数据时，应该使用下界通配符（<code>&lt;? super T&gt;</code>）进行限制。</li></ul><p>这个原则的目的是为了保证在使用泛型的时候，类型的灵活性和安全性都得到保证。使用上界通配符可以确保获取的数据类型的准确性，而使用下界通配符可以确保添加的数据类型的准确性。</p><p>参考PECS原则的示例：</p><ul><li>如果一个方法只需要从列表中获取数据，不会对列表进行修改，那么应该将其参数声明为<code>List&lt;? extends T&gt;</code>；</li><li>如果一个方法只需要往列表中添加数据，不关心具体的数据类型，那么应该将其参数声明为<code>List&lt;? super T&gt;</code>。</li></ul><p>PECS原则能够帮助我们在使用泛型的时候更加灵活地处理数据类型，并提高代码的可读性和安全性。</p><p><strong>示例：</strong></p><p>一个典型的源码例子是Java集合框架中的<code>Collections</code>类的<code>copy</code>方法。该方法用于将一个集合中的元素复制到另一个集合中。</p><p>方法签名如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(List&lt;? <span class="built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span></span><br></pre></td></tr></table></figure></p><p>在<code>copy</code>方法中，使用了PECS原则来限制参数类型。</p><ul><li><code>List&lt;? super T&gt; dest</code>：用于接收元素的目标集合，该集合可以是T类型或T的超类型。这样设计的目的是为了确保我们可以将src集合中的元素安全地添加到dest集合中。</li><li><code>List&lt;? extends T&gt; src</code>：用于提供元素的源集合，该集合可以是T类型或T的子类型。这样设计的目的是为了确保我们可以从源集合中读取到与目标集合兼容的元素。</li></ul><p>这个方法的使用示例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; source = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">List&lt;Number&gt; destination = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">Collections.copy(destination, source);</span><br></pre></td></tr></table></figure></p><p>在上述示例中，<code>source</code>集合的元素类型是<code>Integer</code>，而<code>destination</code>集合的元素类型是<code>Number</code>。根据PECS原则，<code>source</code>作为生产者，使用了上界通配符<code>&lt;? extends T&gt;</code>进行限制，而<code>destination</code>作为消费者，使用了下界通配符<code>&lt;? super T&gt;</code>进行限制。</p><p>通过使用PECS原则，可以确保我们可以将<code>source</code>集合中的<code>Integer</code>元素安全地添加到<code>destination</code>集合中，同时保证类型安全。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;泛型&quot;&gt;&lt;a href=&quot;#泛型&quot; class=&quot;headerlink&quot; title=&quot;泛型&quot;&gt;&lt;/a&gt;泛型&lt;/h1&gt;&lt;h2 id=&quot;什么是泛型&quot;&gt;&lt;a href=&quot;#什么是泛型&quot; class=&quot;headerlink&quot; title=&quot;什么是泛型&quot;&gt;&lt;/a&gt;什么是泛</summary>
      
    
    
    
    <category term="Java基础" scheme="http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>关于ThreadLocal</title>
    <link href="http://example.com/2023/08/01/Java%E5%9F%BA%E7%A1%80/%E5%85%B3%E4%BA%8EThreadLocal/"/>
    <id>http://example.com/2023/08/01/Java%E5%9F%BA%E7%A1%80/%E5%85%B3%E4%BA%8EThreadLocal/</id>
    <published>2023-08-01T03:11:23.000Z</published>
    <updated>2023-08-03T02:05:28.853Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>ThreadLocal</code> 类是用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get和set方法访问)时能够保证各个线程的变量相对独立于其他线程内的变量。<code>ThreadLocal</code> 实例通常来说都是 <code>private static</code>类型的，用来关联线程和线程上下文。</p><p>我们可以得知 <code>ThreadLocal</code>的作用是：提供线程内的局部变量，不同线程之间不会相互干扰，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或组件之间一些公共变量传递的复杂度。</p><p><em>总结</em></p><ol><li>线程并发：在多线程并发的场景下</li><li>传递数据：我们可以<code>ThreadLocal</code>在同一线程，不同组件中传递公共变量</li><li>线程隔离：每个线程的变量都是独立的，不会相互影响</li></ol><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><div class="table-container"><table><thead><tr><th>方法声明</th><th>描述</th></tr></thead><tbody><tr><td>ThreadLocal()</td><td>创建ThreadLocal对象</td></tr><tr><td>public void set(T value)</td><td>设置当前线程绑定的局部变量</td></tr><tr><td>public T get()</td><td>获取当前线程绑定的局部变量</td></tr><tr><td>Public void remove()</td><td>移除当前线程绑定的局部变量</td></tr></tbody></table></div><h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal_Demo_01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContent</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadLocal_Demo_01</span> <span class="variable">demo_01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal_Demo_01</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                demo_01.setContent(Thread.currentThread().getName() + <span class="string">&quot;的数据&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;---------&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;----&gt;&quot;</span> + demo_01.getContent());</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.setName(<span class="string">&quot;线程&quot;</span>+i);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=================</span><br><span class="line">=================</span><br><span class="line"><span class="meta prompt_">t3---&gt;</span><span class="language-bash">t3的数据</span></span><br><span class="line">=================</span><br><span class="line"><span class="meta prompt_">t2---&gt;</span><span class="language-bash">t4的数据</span></span><br><span class="line">=================</span><br><span class="line"><span class="meta prompt_">t1---&gt;</span><span class="language-bash">t4的数据</span></span><br><span class="line">=================</span><br><span class="line"><span class="meta prompt_">t4---&gt;</span><span class="language-bash">t4的数据</span></span><br><span class="line"><span class="meta prompt_">t0---&gt;</span><span class="language-bash">t3的数据</span></span><br></pre></td></tr></table></figure><p>从结果可以看出多个线程在访问同一变量的时候出现异常，线程间的数据没有隔离，接着采用ThreadLocal的方式来解决这个问题</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal_Demo_02</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContent</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        tl.set(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadLocal_Demo_02</span> <span class="variable">demo_02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal_Demo_02</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                demo_02.setContent(Thread.currentThread().getName() + <span class="string">&quot;的数据&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;---------&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;----&gt;&quot;</span> + demo_02.getContent());</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.setName(<span class="string">&quot;线程&quot;</span> + i);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=================</span><br><span class="line">=================</span><br><span class="line"><span class="meta prompt_">t3---&gt;</span><span class="language-bash">t3的数据</span></span><br><span class="line">=================</span><br><span class="line">=================</span><br><span class="line"><span class="meta prompt_">t2---&gt;</span><span class="language-bash">t2的数据</span></span><br><span class="line"><span class="meta prompt_">t1---&gt;</span><span class="language-bash">t1的数据</span></span><br><span class="line"><span class="meta prompt_">t4---&gt;</span><span class="language-bash">t4的数据</span></span><br><span class="line"><span class="meta prompt_">t0---&gt;</span><span class="language-bash">t0的数据</span></span><br></pre></td></tr></table></figure><p>从结果看，使用<code>ThreadLocal</code>很好的解决了多线程之间的数据隔离问题，十分方便</p><h2 id="ThreadLocal和synchronized关键字区别"><a href="#ThreadLocal和synchronized关键字区别" class="headerlink" title="ThreadLocal和synchronized关键字区别"></a>ThreadLocal和synchronized关键字区别</h2><p>使用<code>synchronized</code>关键字同样可以解决线程并发问题</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (ThreadLocal_Demo_01.class) &#123;</span><br><span class="line">                    demo_01.setContent(Thread.currentThread().getName() + <span class="string">&quot;的数据&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;---------&quot;</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;----&gt;&quot;</span> + demo_01.getContent());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.setName(<span class="string">&quot;线程&quot;</span> + i);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在处理多线程并发安全的方法中，最常用的方法就是使用锁，通过锁来控制不同线程对临界区的访问。但是，无论是什么样的锁，乐观锁还是悲观锁，都会在并发冲突的时候对性能产生一定的影响。</p><p><code>ThreadLocal</code>提供了一种与众不同的线程安全方式，它不是在发生线程冲突时想办法解决冲突，而是彻底的避免了冲突的发生</p><p><strong>区别</strong></p><p><code>ThreadLocal</code>和<code>sychronized</code>关键字都用于处理多线程并发访问变量的问题，不过两者的处理问题的角度和思路不同。</p><div class="table-container"><table><thead><tr><th></th><th>sychronized</th><th>ThreadLocal</th></tr></thead><tbody><tr><td>原理</td><td>同步机制采用“以时间换空间”的方式，只提供了一份变量，让不同的线程排队访问</td><td><code>ThreadLocal</code> 采用“以空间换时间”的方式，为每一个线程都提供了一份变量的副本，从而实现同时访问而互不干扰</td></tr><tr><td>侧重点</td><td>多个线程之间访问资源的同步</td><td>多线程中让每个线程之间数据相互隔离</td></tr></tbody></table></div><p><strong>总结</strong></p><p>在刚才的案例中，虽然使用<code>ThreadLocal</code>和<code>sychronized</code>都能解决问题，但是使用<code>ThreadLocal</code>更为合适，因为这样可以使程序拥有更高的并发性</p><p><strong>ThreadLocal的好处</strong> 1、传递数据：保存每个线程保定的数据，在需要的地方可以直接获取，避免参数直接传递带来的代码耦合问题 2、线程隔离：各个线程之间的数据相互隔离却又具备并发性，避免同步方法带来的性能损失</p><h1 id="ThreadLocal的内部结构"><a href="#ThreadLocal的内部结构" class="headerlink" title="ThreadLocal的内部结构"></a>ThreadLocal的内部结构</h1><h2 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h2><p>每个<code>ThreadLocal</code>都创建一个<code>Map</code>，然后用线程作为<code>Map</code>的<code>key</code>，要存储的局部变量作为<code>Map</code>的<code>value</code>，这样能够达到各个线程的局部变量隔离的效果。</p><p><img src="/2023/08/01/Java%E5%9F%BA%E7%A1%80/%E5%85%B3%E4%BA%8EThreadLocal/Snipaste_2023-08-03_09-17-29.png" alt></p><h2 id="JDK1-8之后"><a href="#JDK1-8之后" class="headerlink" title="JDK1.8之后"></a>JDK1.8之后</h2><p>在JDK8中的<code>ThreadLocal</code>的设计是：每个<code>Thread</code>维护一个<code>ThreadLocalMap</code>，这个<code>Map</code>的<code>key</code>是<code>ThreadLocal</code>实例本身，<code>value</code>才是真正要存储的值<code>Object</code>。</p><p>具体的过程是这样的：</p><ol><li><p>每个<code>Thread</code>线程内部都有一个<code>Map</code>（<code>ThreadLocalMap</code>）</p></li><li><p><code>Map</code>里面存储<code>ThreadLocal</code>对象（key) 和线程的变量副本（value)</p></li><li><p><code>Thread</code>内部的<code>Map</code>是由<code>ThreadLocal</code>维护的，由<code>ThreadLocal</code>负责向map获取和设置线程的变量值</p></li><li><p>对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰</p></li></ol><p><img src="/2023/08/01/Java%E5%9F%BA%E7%A1%80/%E5%85%B3%E4%BA%8EThreadLocal/Snipaste_2023-08-03_09-18-15.png" alt></p><h2 id="设计的好处"><a href="#设计的好处" class="headerlink" title="设计的好处"></a>设计的好处</h2><p>1、这样设计之后每个<code>Map</code>存储的<code>Entry</code>数量会变少。因为之前存储的数量由<code>Thread</code>的数量决定，现在由<code>ThreadLocal</code>的数量决定。在实际运用当中，往往<code>ThreadLocal</code>的数量要少于<code>Thread</code>的数量</p><p>2、当<code>Thread</code>销毁之后，对应的<code>ThreadLocalMap</code>也会随之销毁，减少内存的使用</p><h1 id="ThreadLocal中线程隔离原理"><a href="#ThreadLocal中线程隔离原理" class="headerlink" title="ThreadLocal中线程隔离原理"></a>ThreadLocal中线程隔离原理</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">     <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment">     * by the ThreadLocal class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * InheritableThreadLocal values pertaining to this thread. This map is</span></span><br><span class="line"><span class="comment">     * maintained by the InheritableThreadLocal class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">inheritableThreadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Threadlocals 和inheritableThreadLocals 是一个Thread 的两个属性，所以每个Thread 的threadlocales 是孤立的和排他的。在Thread的init方法中，父Thread创建子Thread时，会复制inheritableThreadLocals的值，但不会复制threadlocals的值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程中的init方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ThreadGroup g, Runnable target, String name, </span></span><br><span class="line"><span class="params">                      <span class="type">long</span> stackSize, AccessControlContext acc)</span> &#123; </span><br><span class="line">    ... </span><br><span class="line">        <span class="comment">//当父线程的inheritableThreadLocals值不为null时</span></span><br><span class="line">        <span class="comment">//所有inheritable中的值都会被传递到子线程</span></span><br><span class="line">        <span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="literal">null</span>) </span><br><span class="line">            <span class="built_in">this</span>.inheritableThreadLocals = </span><br><span class="line">               <span class="comment">// </span></span><br><span class="line">                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); </span><br><span class="line">     ... </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">static</span> ThreadLocalMap <span class="title function_">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(parentMap);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="ThreadLocal的核心方法"><a href="#ThreadLocal的核心方法" class="headerlink" title="ThreadLocal的核心方法"></a>ThreadLocal的核心方法</h1><h2 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置当前线程对应的ThreadLocal的值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 将要保存在当前线程对应的ThreadLocal的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">  <span class="comment">// 获取当前线程</span></span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">  <span class="comment">// 获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">  <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">  <span class="comment">// 判断map是否存在</span></span><br><span class="line">  <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">    <span class="comment">// 存在则调用map.set设置此实体的entry</span></span><br><span class="line">    map.set(<span class="built_in">this</span>, value);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">// 1、当前线程Thread 不存在ThreadLocalMap对象</span></span><br><span class="line">    <span class="comment">// 2、则调用createMap进行ThreadLocalMap对象的初始化</span></span><br><span class="line">    <span class="comment">// 3、并将t(当前线程)和value(t对应的值)作为第一个entry存放到ThreadLocalMap对象中</span></span><br><span class="line">    createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前线程Thread对应维护的ThreadLocalMap</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 将要保存在当前线程对应的ThreadLocal的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建当前线程Thread对应维护的ThreadLocalMap</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> t 当前线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> firstValue 存放到map中的第一个entry的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">  <span class="comment">// 这里的this是调用此方法的threadLocal</span></span><br><span class="line">  t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置threadlocal关联的value值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line">  </span><br><span class="line">  Entry[] tab = table;</span><br><span class="line">  <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 查找索引位置</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">       e != <span class="literal">null</span>;</span><br><span class="line">       <span class="comment">// 下一个索引位置</span></span><br><span class="line">       e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">    ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果key相同，则替换value</span></span><br><span class="line">    <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">      e.value = value;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果key为null，取代旧的entry</span></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">      replaceStaleEntry(key, value, i);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">  <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line">  <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">    rehash();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span><br><span class="line"><span class="params">                                       <span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">  Entry[] tab = table;</span><br><span class="line">  <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">  Entry e;</span><br><span class="line"></span><br><span class="line">  .......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nextIndex(staleSlot, len);</span><br><span class="line">       (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">       i = nextIndex(i, len)) &#123;</span><br><span class="line">    ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we find key, then we need to swap it</span></span><br><span class="line">    <span class="comment">// with the stale entry to maintain hash table order.</span></span><br><span class="line">    <span class="comment">// The newly stale slot, or any other stale slot</span></span><br><span class="line">    <span class="comment">// encountered above it, can then be sent to expungeStaleEntry</span></span><br><span class="line">    <span class="comment">// to remove or rehash all of the other entries in run.</span></span><br><span class="line">    <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">      e.value = value;</span><br><span class="line"></span><br><span class="line">      tab[i] = tab[staleSlot];</span><br><span class="line">      tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Start expunge at preceding stale entry if it exists</span></span><br><span class="line">      <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">        slotToExpunge = i;</span><br><span class="line">      cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ........</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除一个陈旧的条目通过再处理任何可能碰撞条目躺陈旧槽和下一个空槽之间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">expungeStaleEntry</span><span class="params">(<span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">  Entry[] tab = table;</span><br><span class="line">  <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除</span></span><br><span class="line">  tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">  tab[staleSlot] = <span class="literal">null</span>;</span><br><span class="line">  size--;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">  Entry e;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">       (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">       i = nextIndex(i, len)) &#123;</span><br><span class="line">    ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">      e.value = <span class="literal">null</span>;</span><br><span class="line">      tab[i] = <span class="literal">null</span>;</span><br><span class="line">      size--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">        tab[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">        <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">        <span class="keyword">while</span> (tab[h] != <span class="literal">null</span>)</span><br><span class="line">          h = nextIndex(h, len);</span><br><span class="line">        tab[h] = e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>代码执行流程</strong></p><ol><li>首先获取当前线程，并根据当前线程获取一个Map</li><li>如果获取的Map不为空，则将参数设置到Map中(当前threadLocal的引用作为key)</li><li>如果Map为空，则给该线程创建Map，并设置初始值</li></ol><h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前线程中保存ThreadLocal的值</span></span><br><span class="line"><span class="comment"> * 如果当前线程没有此ThreadLocal变量</span></span><br><span class="line"><span class="comment"> * 则会通过调用&#123;<span class="doctag">@link</span> #initialValue&#125;方法进行初始化值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回当前线程对应的此ThreadLocal的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 获取当前线程</span></span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">  <span class="comment">// 获取此线程对象中维护的ThreadLocal对象</span></span><br><span class="line">  <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">  <span class="comment">// 如果此map存在</span></span><br><span class="line">  <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 以当前的ThreadLocal为key, 调用getEntry获取对应存储的entry</span></span><br><span class="line">    ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 对e进行判空</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">      <span class="comment">// 获取存储实体e对应的value值</span></span><br><span class="line">      <span class="comment">// 即为我们想要的当前线程对应的ThreadLocal的值</span></span><br><span class="line">      <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  <span class="comment">// 第一种情况：map不存在，表示此线程没有维护的ThreadLocal对象</span></span><br><span class="line">  <span class="comment">// 第二种情况：map存在，但是没有于当前ThreadLocal关联的entry</span></span><br><span class="line">  <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 调用initalValue获取初始化的值</span></span><br><span class="line">  <span class="comment">// 此方法可以被子类重写，如果不重写默认返回为null</span></span><br><span class="line">  <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">  <span class="comment">// 获取当前线程对象</span></span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">  <span class="comment">// 获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">  <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">  <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">    <span class="comment">// 存在则调用map.set设置此实体的entry</span></span><br><span class="line">    map.set(<span class="built_in">this</span>, value);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">// 1）当前线程Thread 不存在ThreadLocalMap对象</span></span><br><span class="line">    <span class="comment">// 2）则调用createMap进行ThreadLocalMap对象的初始化</span></span><br><span class="line">    <span class="comment">// 3）并将 t(当前线程)和value(t对应的值)作为第一个entry存放至ThreadLocalMap中</span></span><br><span class="line">    createMap(t, value);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行流程</strong></p><ol><li>首先获取当前线程，根据当前线程获取一个Map</li><li>如果获取的Map不为空，则在Map中以ThreadLocal的引用作为key来获取Map中对应的Entry，否则转到4</li><li>如果entry不为null，则返回e.value，否则转到4</li><li>Map为空或者e为空，则通过initialValue函数获取初始值value，然后用ThreadLocal的引用和value作为firstKey和firstValue创建新的Map</li></ol><h2 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除当前线程中保存的ThreadLocal对应的实体entry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 获取当前线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">   <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">   <span class="keyword">if</span> (m != <span class="literal">null</span>)</span><br><span class="line">     <span class="comment">// 如果Map存在，则调用remove方法</span></span><br><span class="line">     <span class="comment">// 以当前ThreadLocal为key删除对应的实体entry</span></span><br><span class="line">     m.remove(<span class="built_in">this</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>执行流程</strong></p><ol><li>获取当前线程，并根据当前线程获取一个Map</li><li>如果获取的Map不为空，则移除当前ThreadLocal对应的entry</li></ol><h2 id="initialValue方法"><a href="#initialValue方法" class="headerlink" title="initialValue方法"></a>initialValue方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** * 返回当前线程对应的ThreadLocal的初始值 * </span></span><br><span class="line"><span class="comment">* 此方法的第一此调用发生在当线程通过get方法访问此线程的ThreadLocal值时</span></span><br><span class="line"><span class="comment">* 除非此线程先调用了set方法，在这种情况下，initalValue才不会被这个线程调用</span></span><br><span class="line"><span class="comment">* 通常情况下，每个线程最多调用一次这个方法 * * 这个方法仅仅简单的方法返回null </span></span><br><span class="line"><span class="comment">* 如果程序员向ThreadLocal线程局部变量有一个除null以外的初始值 </span></span><br><span class="line"><span class="comment">* 必须通过子类继承的方法去重写此方法 * 通常可以通过匿名内部类的方式实现</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行流程</strong></p><ol><li>这个方法是一个延迟调用方法，从上面的代码可知，在set方法还未调用而先调用了<code>get</code>方法时才执行，并且仅执行1次</li><li>这个方法缺省实现直接返回一个<code>null</code></li><li>如果要返回除null之外的初始值，可以重写此方法</li></ol><p>可以看出<code>set、get、remove</code>方法的底层原理比较简单，但都包含一个共同的特点，那就是使用<code>ThreadLocalMap</code>。</p><h1 id="ThreadLocalMap源码分析"><a href="#ThreadLocalMap源码分析" class="headerlink" title="ThreadLocalMap源码分析"></a>ThreadLocalMap源码分析</h1><p><code>ThreadLocalMap</code> 是 <code>ThreadLocal</code> 中的一个静态内部类，本质上是一个简单的 <code>Map</code> 结构。 <code>key</code>是<code>ThreadLocal</code>类型，<code>value</code>是<code>ThreadLocal</code>保存的值，底层是一个Entry类型数组组成的数据结构</p><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p><strong>成员变量</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**         * 初始容量         */</span>      </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;     </span><br><span class="line"><span class="comment">/**         * 存放数据的table，Entry类       s</span></span><br><span class="line"><span class="comment">* 必须是2的整数幂         */</span>      </span><br><span class="line"><span class="keyword">private</span> Entry[] table;      </span><br><span class="line"><span class="comment">/**         * 数组中entrys的个数，可以用于判断table当前使用量是否超过阈值         */</span>   </span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;      </span><br><span class="line"><span class="comment">/**         * 进行扩容的阈值，表使用量大于它的时候进行扩容         */</span>       </span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> threshold; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure><p><strong>存储结构-Entry</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* Entry集成WeakReference，并且使用ThreadLocal作为key </span></span><br><span class="line"><span class="comment">* 如果key为null(entry.get() == null), 意味着key不在被引用 </span></span><br><span class="line"><span class="comment">* 因此这时候entry也可以从table中清除 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123; </span><br><span class="line"><span class="comment">/** The value associated with this ThreadLocal. */</span>  </span><br><span class="line">    Object value;  </span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;   </span><br><span class="line">    <span class="built_in">super</span>(k);   </span><br><span class="line">    value = v; </span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><p>在<code>ThreadLocalMap</code>中，也是用Entry来保存K-V结构数据的。不过Entry中的key只能是<code>ThreadLocal</code>对象，这点在构造方法中已经限定死了。</p><p>另外，Entry继承<code>WeakReference</code>，也就是key（<code>ThreadLocal</code>）是弱引用，其目的是将<code>ThreadLocal</code>对象的生命周期和线程生命周期解绑。</p><h2 id="弱引用和内存泄漏"><a href="#弱引用和内存泄漏" class="headerlink" title="弱引用和内存泄漏"></a>弱引用和内存泄漏</h2><p><strong>（1） 内存泄漏相关概念</strong></p><p>内存泄漏主要有两种情况：一种是堆中申请的空间没有释放；另一个是对象不再使用，但仍在内存中。</p><ul><li>Memory overflow:内存溢出，没有足够的内存提供申请者使用。</li><li>Memory leak: 内存泄漏是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。内存泄漏的堆积终将导致内存溢出。</li></ul><p><strong>（2） 弱引用相关概念</strong></p><p>Java中的引用有4种类型： 强、软、弱、虚。当前这个问题主要涉及到强引用和弱引用：</p><p><strong>强引用（“Strong” Reference）</strong>，就是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾回收器就不会回收这种对象。</p><p><strong>弱引用（WeakReference）</strong>，垃圾回收器一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c950f95298947869bd918774455d2e7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image-20210809005358741"></p><p>如果key使用弱引用，在使用完<code>ThreadLocal</code>后，<code>threadLocal Ref</code>被回收了</p><p>由于<code>ThreadLocalMap</code>中只持有<code>ThreadLocal</code>的弱引用，没有任何强引用指向<code>threadLocal</code>实例，所以<code>threadlocal</code>可以被<code>gc</code>回收，此时Entry中的key=null</p><p>但是在没有手动删除这个Entry以及<code>CurrentThread</code>依然运行的前提下，也存在有强引用连<code>CurrentThreadRef</code>-&gt; <code>currentThread</code> -&gt;<code>threadLocalMap</code> -&gt; <code>entry</code> -&gt; <code>value</code>，value不会被回收，而这块value永远不会访问到了，导致value内存泄漏</p><p>弱引用并不能解决内存泄漏问题，实际作用就是标记的不再使用的entry, 便于扫描到进行value置为null</p><p><strong>那既然key为null，调用get/set方法value也会被置为null，那么还有必要remove吗</strong></p><p>可能长时间不执行get、set方法</p><p><strong>假设使用强引用</strong></p><p>假设在业务代码中使用完<code>ThreadLocal</code> ，<code>threadLocal Ref</code>被回收了。</p><p>但是因为<code>threadLocalMap</code>的<code>Entry</code>强引用了<code>threadLocal</code>，造成<code>threadLocal</code>无法被回收。</p><p>在没有手动删除这个Entry以及<code>CurrentThread</code>依然运行的前提下，始终有强引用链 <code>threadRef</code>-&gt;<code>currentThread</code>-&gt;<code>threadLocalMap</code>-&gt;<code>entry</code>，Entry就不会被回收（Entry中包括了<code>ThreadLocal</code>实例和<code>value</code>），导致Entry内存泄漏。</p><p>也就是说，<code>ThreadLocalMap</code>中的key使用了强引用， 是无法完全避免内存泄漏的。</p><p><strong>为什么会出现内存泄漏</strong></p><p>比较以上两种情况，可以发现内存泄漏的发生跟<code>ThreadLocalMap</code>中的key是否使用弱引用是没有关系的，那么内存泄漏的真正原因是什么呢？</p><p>可以发现，在以上两种内存泄漏情况下，都有两个前提</p><ol><li>没有手动删除这个Entry</li><li><code>CurrentThread</code>依然在运行</li></ol><p>第一点很好理解，之哟啊在使用完<code>ThreadLocal</code>，调用remove方法删除对应的Entry，就能避免内存泄漏</p><p>第二点则是因为<code>ThreadLocalMap</code>是Thread的一个属性，被当前线程引用，所以它的声明周期和Thread一样长。那么使用完<code>ThreadLocal</code>，如果当前线程也随之执行结束，<code>ThreadLocalMap</code>自然也会被<code>gc</code>回收，从根源避免了内存泄漏。</p><p>综上，<strong><code>ThreadLocal</code>内存泄漏的根源是</strong>：由于<code>ThreadLocalMap</code>的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏。</p><p><strong>为什么要使用弱引用</strong></p><p>经过根系，发现无论<code>ThreadLocalMap</code>中的key使用哪种类型引用都无法完全避免内存泄漏，跟强弱引用无关。那么为什么要使用弱引用呢</p><p>事实上，在<code>ThreadLocalMap</code>中的set/getEntry方法中，会对key为null（也即是<code>ThreadLocal</code>为null）进行判断，如果为null的话，那么是会对value置为null的。</p><p>这就意味着使用完<code>ThreadLocal</code>，<code>CurrentThread</code>依然运行的前提下，就算忘记调用remove方法，<strong>弱引用比强引用可以多一层保障</strong>：弱引用的<code>ThreadLocal</code>会被回收，对应的value在下一次<code>ThreadLocalMap</code>调用set,get,remove中的任一方法的时候会被清除，从而避免内存泄漏。</p><h2 id="hash冲突"><a href="#hash冲突" class="headerlink" title="hash冲突"></a>hash冲突</h2><p>当多个<code>ThreadLocal</code>对象被同时使用，并且它们在不同的线程中使用相同的<code>ThreadLocalMap</code>，就可能出现哈希冲突的情况。在JDK 1.8之后的<code>ThreadLocal</code>实现中，使用了开放地址法处理哈希冲突。</p><p>哈希冲突发生在<code>ThreadLocalMap</code>中，当多个<code>ThreadLocal</code>对象被放置在同一个<code>ThreadLocalMap</code>中时，它们的哈希值可能相同，从而导致哈希冲突。</p><p><strong>哈希冲突处理</strong></p><p>在处理哈希冲突时，<code>ThreadLocalMap</code>使用了开放地址法（Open Addressing），具体是线性探测法（Linear Probing）。当发生哈希冲突时，<code>ThreadLocalMap</code>会尝试找到下一个可用的槽位，并将<code>ThreadLocal</code>对象插入到该槽位中。</p><p>线性探测法的思路是，如果当前槽位被占用，则继续查找下一个槽位，直到找到一个空槽位为止。这样可以避免链式存储带来的额外开销，同时保持线性访问的性能。</p><p><strong>为什么哈希冲突会影响性能？</strong></p><p>虽然线性探测法可以解决哈希冲突的问题，但是如果哈希冲突发生较频繁，线性探测过程会变得很长，影响了<code>ThreadLocal</code>的性能。</p><p>因此，在使用<code>ThreadLocal</code>时，尽量避免在一个线程中同时使用多个哈希冲突较多的<code>ThreadLocal</code>对象，这样可以减少哈希冲突的概率，提高性能。</p><p><strong>如何避免哈希冲突？</strong></p><ol><li>分散<code>ThreadLocal</code>的哈希值：通过实现<code>ThreadLocal</code>的<code>hashCode</code>方法，使不同的<code>ThreadLocal</code>对象在哈希值上有更好的分散性，减少哈希冲突的概率。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyThreadLocal&lt;T&gt; extends ThreadLocal&lt;T&gt; &#123;</span><br><span class="line">    // 自定义hashCode方法，使哈希值更好地分散</span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        // 返回一个较为均匀分布的哈希值</span><br><span class="line">        return Objects.hash(System.identityHashCode(this));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>尽量减少哈希冲突较多的<code>ThreadLocal</code>对象：避免在一个线程中同时使用多个哈希冲突较多的<code>ThreadLocal</code>对象，可以在设计时合理拆分和管理<code>ThreadLocal</code>对象，减少哈希冲突的发生。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ThreadLocal是Java中处理多线程共享变量问题的有力工具，其独特的线程隔离机制为多线程并发提供了高效的解决方案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&lt;code&gt;ThreadLocal&lt;/code&gt; 类是用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get和set方法访问)时</summary>
      
    
    
    
    <category term="Java基础" scheme="http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://example.com/2023/07/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/07/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-07-30T13:25:30.000Z</published>
    <updated>2023-07-31T06:59:39.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式（Singleton Pattern）是一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一的实例。单例模式通常用于限制一个类的实例化次数，节约系统资源，同时也方便在整个应用程序中共享数据。</p><h1 id="单例模式结构"><a href="#单例模式结构" class="headerlink" title="单例模式结构"></a>单例模式结构</h1><p>单例模式由以下几个元素组成</p><ul><li>私有构造函数：确保其他类不能通过构造函数实例化该类的对象。</li><li>私有静态成员变量：用于存储唯一实例的引用。</li><li>公有静态方法：用于获取唯一实例的位置</li></ul><h1 id="单例模式的实现方式"><a href="#单例模式的实现方式" class="headerlink" title="单例模式的实现方式"></a>单例模式的实现方式</h1><p>在Java中，单例模式有很多实现方式</p><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>饿汉式是指在类加载时就创建实例，因此是线程安全的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EagerSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">EagerSingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EagerSingleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">EagerSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里可以做一些初始化操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EagerSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>懒汉式是指在第一次调用获取实例的方法时才创建实例。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里可以做一些初始化操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懒汉式的一种简单实现方式，并且通过<code>synchronized</code>关键字实现了线程安全。该实现方式在多线程环境下可以保证只有一个实例被创建，并且多个线程获取到的都是同一个实例。</p><p>关键的地方是<code>synchronized</code>修饰的<code>getInstance()</code>方法。通过<code>synchronized</code>关键字将整个实例化过程进行同步，确保在多线程环境下只有一个线程能够进入实例化代码块，从而避免了多个线程同时创建实例的情况。虽然<code>synchronized</code>关键字确保了线程安全，但它也可能带来性能上的一些损耗，因为每次调用<code>getInstance()</code>方法时都会进行同步。在实际应用中，如果对性能有较高要求，可以考虑其他实现方式，如双重检查锁或静态内部类方式，它们在某些情况下可以更好地优化性能。</p><h2 id="双重检查锁"><a href="#双重检查锁" class="headerlink" title="双重检查锁"></a>双重检查锁</h2><p>双重检查锁是为了在多线程环境下保证单例的线程安全，避免不必要的同步开销。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleCheckedSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DoubleCheckedSingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">DoubleCheckedSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里可以做一些初始化操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckedSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckedSingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">DoubleCheckedSingleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的基本思想是在获取实例的方法中进行两次检查，第一次检查在没有创建实例的情况下进行同步，保证只有一个线程进入实例化代码块，创建实例。之后，其他线程再进入获取实例的方法时，由于已经有了实例，就不再进行同步，直接返回已经创建的实例。</p><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>静态内部类方式利用了类加载机制实现了线程安全的单例模式，同时实现了延迟加载。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClassSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">StaticInnerClassSingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticInnerClassSingleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">StaticInnerClassSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里可以做一些初始化操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StaticInnerClassSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类方式能够实现懒加载的原因是静态内部类在类加载过程中不会立即被加载，只有在第一次使用它的时候才会进行初始化，从而实现了懒加载。</p><p>在该实现中，<code>StaticInnerClassSingleton</code>的单例实例是由<code>SingletonHolder</code>类持有的，而<code>SingletonHolder</code>是一个静态内部类。当首次调用<code>getInstance()</code>方法时，<code>SingletonHolder</code>才会被加载，进而实例化<code>StaticInnerClassSingleton</code>的单例对象。</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举单例是一种更加简洁和安全的单例实现方式。在Java中，枚举是线程安全的，并且保证只有一个实例存在。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public enum EnumSingleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    // 其他方法</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        // 在这里实现单例类的其他功能</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用枚举单例时，只需要通过<code>EnumSingleton.INSTANCE</code>来获取唯一实例。<strong>枚举单例在序列化和反序列化时也能保证单例的唯一性。</strong></p><h2 id="容器缓存单例"><a href="#容器缓存单例" class="headerlink" title="容器缓存单例"></a>容器缓存单例</h2><p>容器缓存单例是一种通过容器来管理和缓存单例对象的方式。在Spring框架中，单例模式的默认实现就是通过容器来管理和缓存单例对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonContainer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; singletonMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getInstance</span><span class="params">(Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> clazz.getName();</span><br><span class="line">        <span class="type">T</span> <span class="variable">instance</span> <span class="operator">=</span> (T) singletonMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonContainer.class) &#123;</span><br><span class="line">                instance = (T) singletonMap.get(key);</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        instance = clazz.newInstance();</span><br><span class="line">                        singletonMap.put(key, instance);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用容器缓存单例时，只需将要获取的类的Class对象传入<code>getInstance</code>方法，容器会自动管理和缓存单例对象。</p><h1 id="破坏单例模式的几种方式和解决办法"><a href="#破坏单例模式的几种方式和解决办法" class="headerlink" title="破坏单例模式的几种方式和解决办法"></a>破坏单例模式的几种方式和解决办法</h1><p>单例模式的目标是确保一个类只有一个实例，并提供一个全局访问点来获取该实例。然而，有时候可能会出现一些情况导致单例模式被破坏，即出现了多个实例或无法保证全局唯一性。以下是破坏单例模式的几种常见方式以及相应的解决办法：</p><h2 id="1-多线程环境下的竞态条件"><a href="#1-多线程环境下的竞态条件" class="headerlink" title="1. 多线程环境下的竞态条件"></a>1. 多线程环境下的竞态条件</h2><p>在多线程环境下，如果没有合理的控制实例的创建过程，可能会导致多个线程同时进入实例化代码块，从而创建多个实例。这违背了单例模式的初衷。</p><p><strong>解决办法：</strong></p><ul><li>双重检查锁：通过双重检查锁机制来确保在多线程环境下只有一个线程能够进入实例化代码块，从而避免创建多个实例。</li><li>静态内部类：静态内部类方式能够实现懒加载的同时，也能保证在多线程环境下只有一个实例被创建。</li></ul><h2 id="2-序列化和反序列化"><a href="#2-序列化和反序列化" class="headerlink" title="2. 序列化和反序列化"></a>2. 序列化和反序列化</h2><p>当一个单例类实现了序列化接口时，在反序列化时可能会创建新的实例。</p><p><strong>解决办法：</strong></p><ul><li>实现<code>readResolve()</code>方法：在单例类中添加<code>readResolve()</code>方法，确保在反序列化时返回已有的实例，而不是创建新的实例。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException &#123;</span><br><span class="line">    <span class="keyword">return</span> getInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-反射机制"><a href="#3-反射机制" class="headerlink" title="3. 反射机制"></a>3. 反射机制</h2><p>通过反射机制，可以绕过类的构造方法直接创建新的实例。</p><p><strong>解决办法：</strong></p><ul><li>在构造方法中添加防御逻辑：可以在构造方法中添加逻辑，当检测到已有实例时抛出异常，防止通过反射创建新的实例。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;请使用getInstance()方法获取实例&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-序列化破坏枚举单例"><a href="#4-序列化破坏枚举单例" class="headerlink" title="4. 序列化破坏枚举单例"></a>4. 序列化破坏枚举单例</h2><p>虽然枚举方式是线程安全且不会被反射破坏的单例实现方式，但在序列化和反序列化时，枚举单例也会被破坏。</p><p><strong>解决办法：</strong></p><ul><li>不支持序列化：由于枚举实例在枚举类被加载时就被实例化，不需要担心懒加载问题，因此可以简单地不支持序列化。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumSingleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里实现单例类的其他功能</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不需要实现readResolve()方法，因为枚举本身就不支持序列化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，破坏单例模式可能出现在多线程环境、序列化和反射等情况下。通过合理使用双重检查锁、静态内部类、readResolve()方法以及构造方法防御逻辑等方式，可以避免这些问题，保证单例模式的正确性和稳定性。对于枚举单例，由于其天然的线程安全性和反射安全性，只需要注意不支持序列化即可。</p><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><div class="table-container"><table><thead><tr><th>单例模式</th><th>描述</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>饿汉式</td><td>实例在类加载时创建</td><td>简单，线程安全</td><td>没有懒加载，可能会浪费资源</td></tr><tr><td>懒汉式</td><td>实例在第一次使用时创建</td><td>实现了懒加载</td><td>线程不安全，需要额外的同步开销以实现线程安全</td></tr><tr><td>双重检查锁</td><td>实例在第一次使用时创建，使用两次检查同步以实现线程安全</td><td>实现了懒加载，线程安全</td><td>实现复杂，可能由于JVM内部优化导致问题</td></tr><tr><td>静态内部类</td><td>通过在内部类中创建实例，实现懒加载</td><td>简单，线程安全，实现了懒加载</td><td>不能防止反射攻击</td></tr><tr><td>枚举</td><td>利用枚举的特性，保证实例的唯一性</td><td>简单，线程安全，自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化，可能是实现单例最佳的方法</td><td>没有懒加载</td></tr><tr><td>容器缓存单例</td><td>用容器存储实例，实现单例</td><td>简单，灵活，控制力强</td><td>需要自己管理生命周期，容器如果被误清空，会有问题，线程安全问题需要自己解决</td></tr></tbody></table></div><h1 id="在Spring源码中的应用"><a href="#在Spring源码中的应用" class="headerlink" title="在Spring源码中的应用"></a>在Spring源码中的应用</h1><p>Spring 框架广泛地使用了设计模式，其中包括单例模式。Spring 默认情况下，会将所有的 Bean 定义为单例模式。也就是说，Spring 容器中每种 Bean 类型只存在一个实例。这对于需要在多个组件中共享数据或者服务的 Bean 非常有用。</p><p>Spring 框架中的单例模式主要是通过 <code>SingletonBeanRegistry</code> 接口以及其实现类 <code>DefaultSingletonBeanRegistry</code> 来实现的。<code>SingletonBeanRegistry</code> 接口定义了注册、获取和检查单例对象的方法，如 <code>registerSingleton</code>，<code>getSingleton</code> 和 <code>containsSingleton</code>。</p><p>具体来说，当 Spring 创建一个 Bean 时，它首先会检查这个 Bean 是否已经存在。如果这个 Bean 已经存在，那么它会直接返回这个 Bean 的实例；否则，它会创建一个新的 Bean。创建完新的 Bean 后，Spring 会将其注册到一个全局的注册表中，以便以后可以直接获取。</p><p>此外，Spring 还允许用户通过在 Bean 的定义中设置 <code>scope</code> 属性来改变 Bean 的作用域。如果你想要 Spring 创建多个 Bean 实例，你可以将 Bean 的 <code>scope</code> 属性设置为 <code>prototype</code>。</p><p>请注意，Spring 中的单例并不是传统意义上的单例。传统的单例是在整个应用程序范围内只有一个实例，而 Spring 的单例是在 Spring 容器范围内只有一个实例。如果你有多个 Spring 容器，那么每个容器中都会有一个单例的实例。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>单例模式是一种创建型设计模式，其目的是确保一个类只有一个实例，并提供一个全局访问点来获取该实例。单例模式可以避免多个实例的创建，节约系统资源，并保证全局唯一性和数据共享。</p><p>总结单例模式的特点和优点如下：</p><p><strong>特点：</strong></p><ol><li>类只有一个实例：单例模式确保一个类只有一个实例存在。</li><li>全局访问点：通过提供一个全局访问点（静态方法）来获取单例实例，方便其他类访问。</li></ol><p><strong>优点：</strong></p><ol><li>节约资源：单例模式避免了多个实例的创建，节约了系统资源。</li><li>全局唯一性：确保只有一个实例存在，避免了数据冗余和数据不一致问题。</li><li>数据共享：多个模块可以共享同一个单例实例，方便数据共享和通信。</li><li>懒加载：可以实现懒加载，在需要时才创建实例，提高了性能和资源利用率。</li><li>线程安全：适当实现单例模式可以保证在多线程环境下的线程安全性。</li></ol><p>单例模式的实现方式有多种，包括饿汉式、懒汉式、双重检查锁、静态内部类、枚举、容器缓存单例等。每种实现方式都有其优缺点和适用场景。在选择实现方式时，需要根据具体的业务需求和性能考虑，以确保单例模式的正确性和稳定性。</p><p>然而，滥用单例模式可能会导致全局状态的过多，增加代码的复杂性和维护难度。因此，在使用单例模式时应谨慎权衡利弊，只在真正需要全局唯一实例和共享数据的场景下使用，以确保代码的可维护性和扩展性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h1&gt;&lt;p&gt;单例模式（Singleton Pattern）是一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点来访问这个</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>解释器模式</title>
    <link href="http://example.com/2023/07/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/07/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-07-30T12:20:26.000Z</published>
    <updated>2023-07-30T13:09:46.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h1><p>解释器模式（Interpreter Pattern）是一种行为型设计模式，它用于定义语言的文法规则，并解释语言中的表达式。解释器模式可以用于实现自定义语言或处理特定类型的表达式。它将每个符号和语法规则映射到一个解释器，通过递归地解释表达式，最终得到结果</p><p>特征：为了解释一种语言，而为语言创建的解释器。</p><h1 id="解释器模式的结构"><a href="#解释器模式的结构" class="headerlink" title="解释器模式的结构"></a>解释器模式的结构</h1><ul><li>抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。终结符表达式（Terminal Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。</li><li>非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。</li><li>环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。</li><li>客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>下面以简单的加减乘除为例子实现解释器模式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象角色 定义解释器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">interpret</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberTerminal</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非终结表达式（抽象类）</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">NonTerminal</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Expression left;</span><br><span class="line">    <span class="keyword">protected</span> Expression right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非终结表达式（加法）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PlusNonTerminal</span> <span class="keyword">extends</span> <span class="title class_">NonTerminal</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PlusNonTerminal</span><span class="params">(Expression left, Expression right)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left.interpret() + right.interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非终结表达式（减法）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinusNonTerminal</span> <span class="keyword">extends</span> <span class="title class_">NonTerminal</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinusNonTerminal</span><span class="params">(Expression left, Expression right)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left.interpret() - right.interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非终结表达式（乘法）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MclNonTerminal</span> <span class="keyword">extends</span> <span class="title class_">NonTerminal</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MclNonTerminal</span><span class="params">(Expression left, Expression right)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left.interpret() * right.interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非终结表达式（除法）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DivisionNonTerminal</span> <span class="keyword">extends</span> <span class="title class_">NonTerminal</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DivisionNonTerminal</span><span class="params">(Expression left, Expression right)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left.interpret() / right.interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算器类（实现运算逻辑）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Expression left;</span><br><span class="line">    <span class="keyword">private</span> Expression right;</span><br><span class="line">    <span class="keyword">private</span> Integer result;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cal</span><span class="params">(String expression)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.parse(expression);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Integer <span class="title function_">parse</span><span class="params">(String expression)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取表达式元素</span></span><br><span class="line">        String [] elements = expression.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; elements.length; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> elements[i];</span><br><span class="line">            <span class="comment">// 判断是否是运算符号</span></span><br><span class="line">            <span class="keyword">if</span> (OperatorUtils.isOperator(element)) &#123;</span><br><span class="line">                <span class="comment">// 运算符号的右边就是右终结符</span></span><br><span class="line">                right = <span class="keyword">new</span> <span class="title class_">NumberTerminal</span>(Integer.valueOf(elements[++i]));</span><br><span class="line">                <span class="comment">//计算结果</span></span><br><span class="line">                result = OperatorUtils.getNonTerminal(left, right, element).interpret();</span><br><span class="line">                <span class="comment">// 计算结果重新成为左终结符</span></span><br><span class="line">                left = <span class="keyword">new</span> <span class="title class_">NumberTerminal</span>(result);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = <span class="keyword">new</span> <span class="title class_">NumberTerminal</span>(Integer.valueOf(element));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">cal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 操作工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorUtils</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是不是非终结符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isOperator</span><span class="params">(String symbol)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> symbol.equals(<span class="string">&quot;+&quot;</span>) || symbol.equals(<span class="string">&quot;-&quot;</span>) || symbol.equals(<span class="string">&quot;*&quot;</span>)|| symbol.equals(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 简单工厂</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> NonTerminal <span class="title function_">getNonTerminal</span><span class="params">(Expression left, Expression right, String symbol)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (symbol.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PlusNonTerminal</span>(left, right);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (symbol.equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MinusNonTerminal</span>(left, right);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (symbol.equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MclNonTerminal</span>(left, right);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (symbol.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DivisionNonTerminal</span>(left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 测试</span></span><br><span class="line">    <span class="comment">// PS：此处进行的逻辑仅仅实现从左到右运算，并没有先乘除后加减的逻辑</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Cal</span>(<span class="string">&quot;10 + 20 - 40 * 60&quot;</span>).cal()); <span class="comment">// -600</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Cal</span>(<span class="string">&quot;20 + 50 - 60 * 2&quot;</span>).cal()); <span class="comment">// 20</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="Spring中的解释器模式"><a href="#Spring中的解释器模式" class="headerlink" title="Spring中的解释器模式"></a>Spring中的解释器模式</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExpressionParser</span> <span class="variable">expressionParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class="line">        org.springframework.expression.<span class="type">Expression</span> <span class="variable">expression</span> <span class="operator">=</span> expressionParser.parseExpression(<span class="string">&quot;10 + 20 + 30 * 4&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> expression.getValue(Integer.class);</span><br><span class="line">        System.out.println(value); <span class="comment">// 150</span></span><br><span class="line">        expression = expressionParser.parseExpression(<span class="string">&quot;(10+20+30)*4&quot;</span>);</span><br><span class="line">        value = expression.getValue(Integer.class);</span><br><span class="line">        System.out.println(value); <span class="comment">// 240</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到Spring中解释器写的是比较完善的，不仅有先乘除后加减和先括号进行运算的日常计算规则，而且对于空格也并没有要求，仅需要写出完整的表达式即可运算出来。</p><p>在Spring源码中，解释器模式被广泛应用于Spring Expression Language（SpEL）的实现。SpEL是Spring框架的一部分，它允许在运行时对Spring组件进行动态计算和处理。SpEL支持复杂的表达式和函数调用，这些表达式可以在Spring的XML配置文件或注解中使用。</p><p>在Spring框架中，解释器模式主要应用于Spring Expression Language（SpEL）的实现。SpEL是一种强大的表达式语言，它可以在运行时对Spring组件进行动态计算和处理。SpEL支持复杂的表达式和函数调用，这些表达式可以在Spring的XML配置文件、注解中，甚至在运行时动态生成的代码中使用。</p><p>在SpEL中，解释器模式用于解析表达式并将其转换成一棵表达式树，然后对表达式树进行求值。以下是SpEL在Spring中的主要应用场景：</p><ol><li><p><strong>注解表达式</strong>：SpEL可以在Spring的注解中使用，例如<code>@Value</code>注解和<code>@Conditional</code>注解。通过SpEL表达式，可以在注解中动态地引用Spring bean的属性值、环境变量、系统属性等。</p></li><li><p><strong>XML配置</strong>：SpEL可以在Spring的XML配置文件中使用，例如在<code>&lt;property&gt;</code>元素的<code>value</code>属性中使用SpEL表达式动态设置属性值。</p></li><li><p><strong>动态条件判断</strong>：SpEL可以在<code>@Conditional</code>注解中使用，用于根据条件动态决定是否创建某个bean。</p></li><li><p><strong>动态生成代码</strong>：SpEL可以在运行时动态生成代码，例如通过<code>SpelExpressionParser</code>将SpEL表达式解析成可执行的代码。</p></li><li><p><strong>动态查询</strong>：SpEL可以在动态查询场景中使用，例如在Spring Data JPA的查询方法上使用SpEL表达式指定查询条件。</p></li><li><p><strong>动态属性访问</strong>：SpEL可以用于动态访问Spring bean的属性，例如在运行时通过SpEL表达式获取或设置bean的属性值。</p></li><li><p><strong>Spring Security</strong>：Spring Security框架中也广泛使用了SpEL来定义安全访问规则，用于动态决定用户是否有权访问某个资源。</p></li></ol><p>总的来说，SpEL作为Spring框架的一部分，为Spring提供了强大的动态计算和处理能力，使得Spring组件的配置和行为能够在运行时动态调整，非常灵活和便捷。通过解释器模式的应用，SpEL实现了将表达式解析为可执行的代码，并在运行时对表达式进行求值，提供了丰富的动态特性。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>解释器模式用于定义语言的文法规则，并解释语言中的表达式。通过解释器模式，我们可以实现自定义语言的解析和求值。在Spring源码中，解释器模式被广泛应用于SpEL的实现，实现了Spring组件的动态计算和处理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;解释器模式&quot;&gt;&lt;a href=&quot;#解释器模式&quot; class=&quot;headerlink&quot; title=&quot;解释器模式&quot;&gt;&lt;/a&gt;解释器模式&lt;/h1&gt;&lt;p&gt;解释器模式（Interpreter Pattern）是一种行为型设计模式，它用于定义语言的文法规则，并解释语言中的表</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>备忘录模式</title>
    <link href="http://example.com/2023/07/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/07/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-07-30T12:20:15.000Z</published>
    <updated>2023-07-30T12:54:33.784Z</updated>
    
    <content type="html"><![CDATA[<h1 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h1><p>备忘录模式（Memento Pattern）是一种行为型设计模式，它用于捕获一个对象的内部状态，并在之后恢复该对象到之前的状态。备忘录模式允许在不破坏对象封装的前提下，保存和恢复对象的状态，从而实现撤销、恢复等操作。</p><h1 id="备忘录模式结构"><a href="#备忘录模式结构" class="headerlink" title="备忘录模式结构"></a>备忘录模式结构</h1><p>备忘录模式由以下几个要素组成：</p><ul><li><strong>Originator（发起人）</strong>：负责创建备忘录对象，记录和恢复自身状态。</li><li><strong>Memento（备忘录）</strong>：存储Originator的内部状态，提供给Caretaker进行备份和恢复。</li><li><strong>Caretaker（管理者）</strong>：负责备份和恢复Originator的状态，但不能访问Memento的具体内容。</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>假设我们有一个文本编辑器，用户可以输入文本并进行编辑。我们将使用备忘录模式来实现撤销功能，允许用户撤销之前的编辑操作。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. Originator（发起人）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextEditor</span> &#123;</span><br><span class="line">    private <span class="title class_">StringBuilder</span> content;</span><br><span class="line"></span><br><span class="line">    public <span class="title class_">TextEditor</span>() &#123;</span><br><span class="line">        content = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> <span class="title function_">type</span>(<span class="params"><span class="built_in">String</span> text</span>) &#123;</span><br><span class="line">        content.<span class="title function_">append</span>(text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="title class_">String</span> <span class="title function_">getContent</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> content.<span class="title function_">toString</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="title class_">Memento</span> <span class="title function_">save</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Memento</span>(content.<span class="title function_">toString</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> <span class="title function_">restore</span>(<span class="params">Memento memento</span>) &#123;</span><br><span class="line">        content = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(memento.<span class="title function_">getState</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Memento（备忘录）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memento</span> &#123;</span><br><span class="line">    private final <span class="title class_">String</span> state;</span><br><span class="line"></span><br><span class="line">    public <span class="title class_">Memento</span>(<span class="title class_">String</span> state) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="title class_">String</span> <span class="title function_">getState</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Caretaker（管理者）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">History</span> &#123;</span><br><span class="line">    private <span class="title class_">Stack</span>&lt;<span class="title class_">Memento</span>&gt; mementos;</span><br><span class="line"></span><br><span class="line">    public <span class="title class_">History</span>() &#123;</span><br><span class="line">        mementos = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> <span class="title function_">push</span>(<span class="params">Memento memento</span>) &#123;</span><br><span class="line">        mementos.<span class="title function_">push</span>(memento);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="title class_">Memento</span> <span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mementos.<span class="title function_">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MementoPatternExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TextEditor</span> <span class="variable">textEditor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextEditor</span>();</span><br><span class="line">        <span class="type">History</span> <span class="variable">history</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">History</span>();</span><br><span class="line"></span><br><span class="line">        textEditor.type(<span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line">        history.push(textEditor.save()); <span class="comment">// 保存状态</span></span><br><span class="line"></span><br><span class="line">        textEditor.type(<span class="string">&quot;World!&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前内容：&quot;</span> + textEditor.getContent());</span><br><span class="line"></span><br><span class="line">        textEditor.restore(history.pop()); <span class="comment">// 恢复之前状态</span></span><br><span class="line">        System.out.println(<span class="string">&quot;恢复后内容：&quot;</span> + textEditor.getContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">当前内容：Hello, World!</span><br><span class="line">恢复后内容：Hello, </span><br></pre></td></tr></table></figure><h1 id="在Spring中的应用"><a href="#在Spring中的应用" class="headerlink" title="在Spring中的应用"></a>在Spring中的应用</h1><p>在Spring源码中，备忘录模式被广泛应用于Spring事务管理中的回滚机制。在Spring的事务管理中，事务的回滚是通过事务的保存点（Savepoint）来实现的。当某个方法发生异常时，Spring会将当前事务状态保存为一个保存点，然后进行回滚到该保存点，从而实现事务的回滚操作。</p><p>在Spring的源码中，<code>org.springframework.transaction.support.DefaultTransactionStatus</code> 类负责保存和恢复事务的状态，其内部就包含了备忘录模式的实现。通过备忘录模式，Spring能够在不破坏对象封装的前提下，保存和恢复事务的状态，实现了强大的事务管理功能。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>备忘录模式允许在不破坏对象封装的前提下，保存和恢复对象的状态。在Java中，备忘录模式常常用于实现撤销、恢复等操作，帮助用户处理对象状态的变化。在Spring源码中，备忘录模式被广泛用于Spring事务管理的回滚机制，提供了强大的事务管理功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;备忘录模式&quot;&gt;&lt;a href=&quot;#备忘录模式&quot; class=&quot;headerlink&quot; title=&quot;备忘录模式&quot;&gt;&lt;/a&gt;备忘录模式&lt;/h1&gt;&lt;p&gt;备忘录模式（Memento Pattern）是一种行为型设计模式，它用于捕获一个对象的内部状态，并在之后恢复该对象到</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>访问者模式</title>
    <link href="http://example.com/2023/07/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/07/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-07-30T09:13:46.000Z</published>
    <updated>2023-07-30T09:18:27.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h1><p>访问者模式（Visitor Pattern）是一种行为型设计模式，它用于在不修改已有类的情况下，为其添加新的操作。访问者模式通过定义一个访问者类，该类包含一系列访问方法，每个访问方法对应一个元素类的操作，从而使得元素类的操作可以在访问者类中得以实现。访问者模式通过双重分派来实现在运行时动态确定要调用的方法，从而实现了多态性。</p><h1 id="访问者模式结构"><a href="#访问者模式结构" class="headerlink" title="访问者模式结构"></a>访问者模式结构</h1><p>访问者模式由以下几个要素组成：</p><ul><li><strong>Visitor（抽象访问者）</strong>：定义一个访问接口，包含多个访问方法，每个方法对应一个元素类的操作。</li><li><strong>ConcreteVisitor（具体访问者）</strong>：实现抽象访问者接口中定义的访问方法，即为每个元素类提供具体的操作逻辑。</li><li><strong>Element（抽象元素类）</strong>：定义一个接受访问者对象的接口，即<code>accept</code>方法，该方法传入访问者对象作为参数。</li><li><strong>ConcreteElement（具体元素类）</strong>：实现抽象元素类中的<code>accept</code>方法，将自身作为参数传给访问者的访问方法。</li><li><strong>ObjectStructure（对象结构）</strong>：维护元素类的集合，提供向访问者对象遍历元素的方法。</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>下面，我们将通过一个简单的零件访问示例来演示访问者模式的实现。</p><p>假设我们有一组零件，包括CPU、内存条和显卡等，我们想为这些零件添加一个访问者，用于检查它们的状态。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. Visitor（抽象访问者）</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PartVisitor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visitCPU</span><span class="params">(CPU cpu)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visitMemory</span><span class="params">(Memory memory)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visitGPU</span><span class="params">(GPU gpu)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Element（抽象元素类）</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Part</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(PartVisitor visitor)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. ConcreteElement（具体元素类）- CPU</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span> <span class="keyword">implements</span> <span class="title class_">Part</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(PartVisitor visitor)</span> &#123;</span><br><span class="line">        visitor.visitCPU(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. ConcreteElement（具体元素类）- 内存条</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span> <span class="keyword">implements</span> <span class="title class_">Part</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(PartVisitor visitor)</span> &#123;</span><br><span class="line">        visitor.visitMemory(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. ConcreteElement（具体元素类）- 显卡</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GPU</span> <span class="keyword">implements</span> <span class="title class_">Part</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(PartVisitor visitor)</span> &#123;</span><br><span class="line">        visitor.visitGPU(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. ConcreteVisitor（具体访问者）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PartStatusVisitor</span> <span class="keyword">implements</span> <span class="title class_">PartVisitor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitCPU</span><span class="params">(CPU cpu)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;检查CPU状态...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitMemory</span><span class="params">(Memory memory)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;检查内存条状态...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitGPU</span><span class="params">(GPU gpu)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;检查显卡状态...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. ObjectStructure（对象结构）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Part&gt; parts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Computer</span><span class="params">()</span> &#123;</span><br><span class="line">        parts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        parts.add(<span class="keyword">new</span> <span class="title class_">CPU</span>());</span><br><span class="line">        parts.add(<span class="keyword">new</span> <span class="title class_">Memory</span>());</span><br><span class="line">        parts.add(<span class="keyword">new</span> <span class="title class_">GPU</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(PartVisitor visitor)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Part part : parts) &#123;</span><br><span class="line">            part.accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VisitorPatternExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="type">PartVisitor</span> <span class="variable">visitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PartStatusVisitor</span>();</span><br><span class="line"></span><br><span class="line">        computer.accept(visitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">检查CPU状态...</span><br><span class="line">检查内存条状态...</span><br><span class="line">检查显卡状态...</span><br></pre></td></tr></table></figure><h1 id="在Spring中应用"><a href="#在Spring中应用" class="headerlink" title="在Spring中应用"></a>在Spring中应用</h1><p>在Spring源码中，访问者模式被广泛应用于Spring AOP（面向切面编程）的实现。在AOP中，Spring使用访问者模式来实现横切关注点（Cross-Cutting Concerns）的处理。具体而言，Spring中的AOP功能通过使用访问者模式来访问并织入横切关注点到目标对象的方法中。</p><p>在Spring的AOP实现中，核心的访问者类是<code>org.springframework.aop.framework.ReflectiveMethodInvocation</code>，它负责在目标方法执行前后调用切面逻辑（即具体的访问者）。Spring通过访问者模式，实现了切面逻辑与目标方法的解耦，使得AOP功能能够灵活地应用于各种业务场景。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过访问者模式，我们可以在不修改元素类的情况下，为其添加新的操作。访问者模式通过双重分派实现多态性，提高了系统的可扩展性和灵活性。在Spring源码中，访问者模式被广泛应用于Spring AOP的实现，帮助开发者实现横切关注点的处理和业务逻辑的解耦。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;访问者模式&quot;&gt;&lt;a href=&quot;#访问者模式&quot; class=&quot;headerlink&quot; title=&quot;访问者模式&quot;&gt;&lt;/a&gt;访问者模式&lt;/h1&gt;&lt;p&gt;访问者模式（Visitor Pattern）是一种行为型设计模式，它用于在不修改已有类的情况下，为其添加新的操作。访</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>中介者模式</title>
    <link href="http://example.com/2023/07/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/07/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-07-30T08:16:58.000Z</published>
    <updated>2023-07-30T08:44:20.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><p>中介者模式（Mediator Pattern）是一种行为型设计模式，它用于降低多个对象之间的耦合性，通过引入一个中介者对象，使得各个对象不需要直接相互交互，而是通过中介者来进行通信。中介者模式可以减少对象之间的依赖，从而提高系统的可维护性和灵活性。</p><h1 id="中介者模式结构"><a href="#中介者模式结构" class="headerlink" title="中介者模式结构"></a>中介者模式结构</h1><p>中介者模式由以下几个要素组成：</p><ul><li><strong>Mediator（抽象中介者）</strong>：定义一个接口或抽象类，用于定义各个同事对象之间交互的方法。</li><li><strong>ConcreteMediator（具体中介者）</strong>：实现中介者接口，协调各个具体同事对象的交互关系。</li><li><strong>Colleague（抽象同事类）</strong>：定义一个接口或抽象类，用于各个具体同事类的通信。</li><li><strong>ConcreteColleague（具体同事类）</strong>：实现同事接口，具体的同事对象，需要和其他同事对象进行交互。</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>通过一个租房例子简单实现下逻辑，房主通过中介公司发布自己的房子的信息，而租客则需要通过中介公司获取到房子的信息：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. Mediator（抽象中介者）</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">HouseMediator</span> &#123;</span><br><span class="line">    <span class="built_in">void</span> <span class="title function_">addTenant</span>(<span class="title class_">Tenant</span> tenant);</span><br><span class="line">    <span class="built_in">void</span> <span class="title function_">notifyLandlord</span>(<span class="title class_">String</span> message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Colleague（抽象同事类）</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Tenant</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title class_">HouseMediator</span> mediator;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title class_">String</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">Tenant</span>(<span class="title class_">HouseMediator</span> mediator, <span class="title class_">String</span> name) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">mediator</span> = mediator;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">void</span> <span class="title function_">send</span>(<span class="title class_">String</span> message);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">void</span> <span class="title function_">receive</span>(<span class="title class_">String</span> message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. ConcreteColleague（具体同事类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteTenant</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Tenant</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">ConcreteTenant</span>(<span class="title class_">HouseMediator</span> mediator, <span class="title class_">String</span> name) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(mediator, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">send</span>(<span class="params"><span class="built_in">String</span> message</span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; 发送消息: &quot;</span> + message);</span><br><span class="line">        mediator.<span class="title function_">notifyLandlord</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">receive</span>(<span class="params"><span class="built_in">String</span> message</span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; 收到消息: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. ConcreteMediator（具体中介者）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HouseMediatorImpl</span> <span class="keyword">implements</span> <span class="title class_">HouseMediator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">List</span>&lt;<span class="title class_">Tenant</span>&gt; tenants;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">HouseMediatorImpl</span>() &#123;</span><br><span class="line">        tenants = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">addTenant</span>(<span class="params">Tenant tenant</span>) &#123;</span><br><span class="line">        tenants.<span class="title function_">add</span>(tenant);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">notifyLandlord</span>(<span class="params"><span class="built_in">String</span> message</span>) &#123;</span><br><span class="line">        <span class="comment">// 在这里实现消息广播或特定租房者接收逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="title class_">Tenant</span> tenant : tenants) &#123;</span><br><span class="line">            tenant.<span class="title function_">receive</span>(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MediatorPatternExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HouseMediator</span> <span class="variable">mediator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HouseMediatorImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Tenant</span> <span class="variable">tenant1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteTenant</span>(mediator, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">        <span class="type">Tenant</span> <span class="variable">tenant2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteTenant</span>(mediator, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        <span class="type">Tenant</span> <span class="variable">tenant3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteTenant</span>(mediator, <span class="string">&quot;Charlie&quot;</span>);</span><br><span class="line"></span><br><span class="line">        mediator.addTenant(tenant1);</span><br><span class="line">        mediator.addTenant(tenant2);</span><br><span class="line">        mediator.addTenant(tenant3);</span><br><span class="line"></span><br><span class="line">        tenant1.send(<span class="string">&quot;我想租一个两室一厅的房子。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Alice 发送消息: 我想租一个两室一厅的房子。</span><br><span class="line">Bob 收到消息: 我想租一个两室一厅的房子。</span><br><span class="line">Charlie 收到消息: 我想租一个两室一厅的房子。</span><br></pre></td></tr></table></figure><p>上述示例中，我们使用中介者模式实现了一个租房中介的场景。通过中介者，租房者可以发送消息给房东（在此例中，我们简化为所有租房者收到消息）。这样，租房者和房东之间的交互被解耦，使得系统的可维护性和灵活性得到提高。在真实的应用中，我们可以根据需要在具体中介者中实现更复杂的交互逻辑。</p><h1 id="在Spring源码中的应用"><a href="#在Spring源码中的应用" class="headerlink" title="在Spring源码中的应用"></a>在Spring源码中的应用</h1><p>在Spring中，中介者模式被广泛应用于事件的处理和发布/订阅机制。<code>pring</code>框架中的<code>ApplicationEvent</code>和<code>ApplicationListener</code>就是典型的中介者模式的应用。<code>ApplicationEvent</code>是事件对象，而<code>ApplicationListener</code>是事件的订阅者。通过中介者模式，Spring将事件的发布者和订阅者解耦，实现了高内聚低耦合的目标。</p><p>在Spring的源码中，<code>ApplicationEvent</code>和<code>ApplicationListener</code>的设计和实现体现了中介者模式的思想，提供了一种优雅的事件通知机制，让不同组件之间能够松耦合地进行交互。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过中介者模式，我们可以有效地减少对象之间的直接交互，将其转移到中介者对象中进行协调，从而降低系统的复杂性和耦合性。在Spring源码中，中介者模式被广泛用于实现事件的处理和发布/订阅机制，帮助开发者构建高内聚低耦合的应用程序。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;中介者模式&quot;&gt;&lt;a href=&quot;#中介者模式&quot; class=&quot;headerlink&quot; title=&quot;中介者模式&quot;&gt;&lt;/a&gt;中介者模式&lt;/h1&gt;&lt;p&gt;中介者模式（Mediator Pattern）是一种行为型设计模式，它用于降低多个对象之间的耦合性，通过引入一个中介</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>状态模式</title>
    <link href="http://example.com/2023/07/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/07/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-07-30T07:39:35.000Z</published>
    <updated>2023-07-30T08:16:42.512Z</updated>
    
    <content type="html"><![CDATA[<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><p>状态模式（State Pattern）是一种行为型设计模式，它允许一个对象在其内部状态改变时改变它的行为。状态模式将对象的行为封装成不同的状态类，使得对象在不同状态下可以切换，从而避免了大量的条件判断语句，提高了代码的可读性和可维护性。</p><h1 id="状态模式的结构"><a href="#状态模式的结构" class="headerlink" title="状态模式的结构"></a>状态模式的结构</h1><ul><li>环境（Context）角色：也称为上下文，它定义了客户程序需要的接口，维护一个对具体状态类的引用，并将客户端的请求委托给当前状态对象处理。</li><li>抽象状态（State）角色：定义一个接口或抽象类，用以封装环境对象中的特定状态所对应的行为。</li><li>具体状态（Concrete State）角色：实现State接口，具体处理Context在某个状态下的请求。</li></ul><h1 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h1><p>假设我们有一个电梯控制器，可以控制电梯在不同的状态下运行，包括：停止状态、运行状态、停下状态。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. State（抽象状态类）</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ElevatorState</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. ConcreteState（具体状态类）- 停止状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StoppedState</span> <span class="keyword">implements</span> <span class="title class_">ElevatorState</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯已停止&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. ConcreteState（具体状态类）- 运行状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RunningState</span> <span class="keyword">implements</span> <span class="title class_">ElevatorState</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯正在运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. ConcreteState（具体状态类）- 停下状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StoppingState</span> <span class="keyword">implements</span> <span class="title class_">ElevatorState</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯正在停下&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Context（环境类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElevatorController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ElevatorState currentState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ElevatorController</span><span class="params">()</span> &#123;</span><br><span class="line">        currentState = <span class="keyword">new</span> <span class="title class_">StoppedState</span>(); <span class="comment">// 初始状态为停止状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(ElevatorState state)</span> &#123;</span><br><span class="line">        currentState = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        currentState.handleRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StatePatternExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ElevatorController</span> <span class="variable">controller</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ElevatorController</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始状态为停止状态</span></span><br><span class="line">        controller.request();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切换到运行状态</span></span><br><span class="line">        controller.setState(<span class="keyword">new</span> <span class="title class_">RunningState</span>());</span><br><span class="line">        controller.request();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切换到停下状态</span></span><br><span class="line">        controller.setState(<span class="keyword">new</span> <span class="title class_">StoppingState</span>());</span><br><span class="line">        controller.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">电梯已停止</span><br><span class="line">电梯正在运行</span><br><span class="line">电梯正在停下</span><br></pre></td></tr></table></figure><h1 id="在Spring源码中的应用"><a href="#在Spring源码中的应用" class="headerlink" title="在Spring源码中的应用"></a>在Spring源码中的应用</h1><p>Spring框架中的有些组件和功能可以通过状态模式进行实现，例如在Spring的状态机（spring-statemachine）模块中，它用于实现复杂的状态机逻辑，如订单状态、工作流等。在Spring的状态机模块中，状态模式被广泛应用，将状态抽象为状态类，状态之间的切换由状态机进行控制。</p><p>在Spring源码中，这些状态类和状态机之间的切换逻辑被很好地封装和管理，使得系统逻辑更加清晰、灵活和易于维护。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>通过状态模式，我们可以优雅地处理对象在不同状态下的行为，避免了大量的条件判断语句，使得代码更加简洁、可读性更高。在Spring源码中，状态模式的应用使得复杂的状态管理变得轻松和高效。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;状态模式&quot;&gt;&lt;a href=&quot;#状态模式&quot; class=&quot;headerlink&quot; title=&quot;状态模式&quot;&gt;&lt;/a&gt;状态模式&lt;/h1&gt;&lt;p&gt;状态模式（State Pattern）是一种行为型设计模式，它允许一个对象在其内部状态改变时改变它的行为。状态模式将对象的行</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>命令模式</title>
    <link href="http://example.com/2023/07/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/07/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-07-29T09:01:38.000Z</published>
    <updated>2023-07-30T07:03:18.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p>命令模式是一种行为设计模式，用于将请求（命令）发送者和接收者解耦，从而允许发送者发送命令，而不需要知道实际执行命令的接收者是谁以及如何执行的。</p><h1 id="命令模式的结构"><a href="#命令模式的结构" class="headerlink" title="命令模式的结构"></a>命令模式的结构</h1><ul><li>抽象命令类（Command）角色：定义命令的接口，声明执行的方法。</li><li>具体命令（Concrete Command）角色：具体的命令，实现命令接口；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。</li><li>接收者（Receiver)角色：真正执行命令的对象，任何类都有可能成为一个接收者，只要它能够实现命令要求实现的相应功能。</li><li>请求者（Invoker)角色：要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>假设我们要实现一个简单的遥控器程序，有两个按钮：按钮A用于打开电视，按钮B用于关闭电视。可以使用命令模式来实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命令接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开电视命令</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TurnOnTVCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TV tv;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TurnOnTVCommand</span><span class="params">(TV tv)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        tv.turnOn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭电视命令</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TurnOffTVCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TV tv;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TurnOffTVCommand</span><span class="params">(TV tv)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        tv.turnOff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 电视接收者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TV</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOn</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TV is on&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOff</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TV is off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遥控器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteControl</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Command turnOnCommand;</span><br><span class="line">    <span class="keyword">private</span> Command turnOffCommand;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTurnOnCommand</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        turnOnCommand = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTurnOffCommand</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        turnOffCommand = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pressTurnOnButton</span><span class="params">()</span> &#123;</span><br><span class="line">        turnOnCommand.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pressTurnOffButton</span><span class="params">()</span> &#123;</span><br><span class="line">        turnOffCommand.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TV</span> <span class="variable">tv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TV</span>();</span><br><span class="line">        <span class="type">Command</span> <span class="variable">turnOnCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TurnOnTVCommand</span>(tv);</span><br><span class="line">        <span class="type">Command</span> <span class="variable">turnOffCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TurnOffTVCommand</span>(tv);</span><br><span class="line"></span><br><span class="line">        <span class="type">RemoteControl</span> <span class="variable">remoteControl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteControl</span>();</span><br><span class="line">        remoteControl.setTurnOnCommand(turnOnCommand);</span><br><span class="line">        remoteControl.setTurnOffCommand(turnOffCommand);</span><br><span class="line"></span><br><span class="line">        remoteControl.pressTurnOnButton(); <span class="comment">// 打开电视</span></span><br><span class="line">        remoteControl.pressTurnOffButton(); <span class="comment">// 关闭电视</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring中的应用"><a href="#Spring中的应用" class="headerlink" title="Spring中的应用"></a>Spring中的应用</h1><p>在Spring框架中，命令模式的概念被广泛应用于其事务管理模块。事务管理是Spring框架中的一个关键特性，它允许开发者通过编程式或声明式方式管理事务。</p><p>Spring中的事务管理器（<code>PlatformTransactionManager</code>）是一个命令模式的实际应用。在Spring中，你可以配置多种事务管理器，比如JDBC事务管理器、JPA事务管理器、Hibernate事务管理器等等。每个事务管理器都实现了<code>PlatformTransactionManager</code>接口，并提供了在事务开始、提交或回滚时执行的具体操作。</p><p>Spring的事务管理器作为接收者，执行实际的事务管理操作。而调用者是Spring的事务切面，它在合适的时机调用事务管理器的方法来处理事务。客户端是使用Spring框架的应用程序，它们并不直接与事务管理器交互，而是通过声明式的方式或者AOP配置与之关联。</p><p>通过命令模式，Spring实现了事务管理的解耦，允许应用程序独立于具体的事务管理实现，并且可以轻松切换不同的事务管理器，而不需要修改应用程序的代码。</p><p>在Spring的配置文件中，你可以类似下面的方式配置声明式事务管理：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;serviceMethods&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.example.service.*.*(..))&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;serviceMethods&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的配置中，我们声明了一个事务管理器<code>DataSourceTransactionManager</code>，并通过AOP将事务管理器与<code>com.example.service</code>包下的所有方法关联起来。其中，<code>&lt;tx:advice&gt;</code>标签定义了事务的传播行为和隔离级别，通过配置<code>&lt;tx:method&gt;</code>来设置每个方法的事务属性。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>命令模式是一个有用的设计模式，它可以在许多场景中发挥作用，例如遥控器应用、事务管理器等。通过命令模式，我们可以将请求发送者与接收者解耦，提高代码的可维护性和可扩展性。在Spring源码中的应用，例如事务管理器，展示了命令模式在实际框架中的实际价值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;命令模式&quot;&gt;&lt;a href=&quot;#命令模式&quot; class=&quot;headerlink&quot; title=&quot;命令模式&quot;&gt;&lt;/a&gt;命令模式&lt;/h1&gt;&lt;p&gt;命令模式是一种行为设计模式，用于将请求（命令）发送者和接收者解耦，从而允许发送者发送命令，而不需要知道实际执行命令的接收者是</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="http://example.com/2023/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-07-28T12:30:31.000Z</published>
    <updated>2023-07-28T13:17:27.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>简介: 策略模式（Strategy Pattern）是一种行为型设计模式，它允许在运行时根据不同的情况选择不同的算法或行为。通过将算法封装成独立的可互换的策略，可以使得算法的变化独立于使用它的客户端。</p><h1 id="策略模式结构"><a href="#策略模式结构" class="headerlink" title="策略模式结构"></a>策略模式结构</h1><ul><li>抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</li><li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为。</li><li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li></ul><h1 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h1><h2 id="普通案例（会员卡打折）"><a href="#普通案例（会员卡打折）" class="headerlink" title="普通案例（会员卡打折）"></a>普通案例（会员卡打折）</h2><p>假设我们正在开发一个电商应用，根据用户的会员等级来计算订单的折扣金额。根据会员等级的不同，采用的计算策略也不同。在这种情况下，我们可以使用策略模式来实现不同的折扣策略。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会员卡接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">VipCard</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">discount</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoldCard</span> <span class="keyword">implements</span> <span class="title class_">VipCard</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">discount</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;金卡打7折&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SilverCard</span> <span class="keyword">implements</span> <span class="title class_">VipCard</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">discount</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;银卡打8折&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopperCard</span> <span class="keyword">implements</span> <span class="title class_">VipCard</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">discount</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;铜卡打9折&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Normal</span> <span class="keyword">implements</span> <span class="title class_">VipCard</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">discount</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通会员没有折扣&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 会员卡容器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VipCardFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, VipCard&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="string">&quot;gold&quot;</span>, <span class="keyword">new</span> <span class="title class_">GoldCard</span>());</span><br><span class="line">        map.put(<span class="string">&quot;silver&quot;</span>, <span class="keyword">new</span> <span class="title class_">SilverCard</span>());</span><br><span class="line">        map.put(<span class="string">&quot;copper&quot;</span>, <span class="keyword">new</span> <span class="title class_">CopperCard</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> VipCard <span class="title function_">getVIPCard</span><span class="params">(String level)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(level) != <span class="literal">null</span> ? map.get(level) : <span class="keyword">new</span> <span class="title class_">Normal</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 测试方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//金卡打7折</span></span><br><span class="line">        VipCardFactory.getVIPCard(<span class="string">&quot;gold&quot;</span>).discount();</span><br><span class="line">        <span class="comment">//银卡打8折</span></span><br><span class="line">        VipCardFactory.getVIPCard(<span class="string">&quot;silver&quot;</span>).discount();</span><br><span class="line">        <span class="comment">//普通会员没有折扣</span></span><br><span class="line">        VipCardFactory.getVIPCard(<span class="string">&quot;other&quot;</span>).discount();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>用一个容器（Map）装起来，可以通过传进来的参数直接获取对应的策略，避免了if…else。</p><h2 id="支付方式案例"><a href="#支付方式案例" class="headerlink" title="支付方式案例"></a>支付方式案例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 支付方式抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Payment</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">pay</span><span class="params">(String uid, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">balance</span> <span class="operator">=</span> queryBalance(uid);</span><br><span class="line">        <span class="keyword">if</span> (balance &lt; money) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;支付失败!余额不足!欠&quot;</span> + (money - balance) + <span class="string">&quot;元!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;支付成功!支付金额:&quot;</span> + money + <span class="string">&quot;余额剩余:&quot;</span> + (balance - money);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title function_">getPaymentName</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">queryBalance</span><span class="params">(String uid)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 现金支付 默认方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cash</span> <span class="keyword">extends</span> <span class="title class_">Payment</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">getPaymentName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;现金支付&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">double</span> <span class="title function_">queryBalance</span><span class="params">(String uid)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 支付宝类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliPay</span> <span class="keyword">extends</span> <span class="title class_">Payment</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">getPaymentName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;支付宝&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">double</span> <span class="title function_">queryBalance</span><span class="params">(String uid)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 微信支付类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeChatPay</span> <span class="keyword">extends</span> <span class="title class_">Payment</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">getPaymentName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;微信支付&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">double</span> <span class="title function_">queryBalance</span><span class="params">(String uid)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 支付方式容器策略类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Payment&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="string">&quot;WeChat&quot;</span>, <span class="keyword">new</span> <span class="title class_">WeChatPay</span>());</span><br><span class="line">        map.put(<span class="string">&quot;Ali&quot;</span>, <span class="keyword">new</span> <span class="title class_">AliPay</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Payment <span class="title function_">getPayment</span><span class="params">(String payment)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(payment) == <span class="literal">null</span> ? <span class="keyword">new</span> <span class="title class_">Cash</span>() : map.get(payment);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 订单交易类</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String uid;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> amount;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">pay</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pay(<span class="string">&quot;cash&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">pay</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Payment</span> <span class="variable">payment</span> <span class="operator">=</span> PaymentStrategy.getPayment(key);</span><br><span class="line">        System.out.println(<span class="string">&quot;欢迎使用&quot;</span> + payment.getPaymentName());</span><br><span class="line">        System.out.println(<span class="string">&quot;本次交易金额:&quot;</span> + <span class="built_in">this</span>.amount + <span class="string">&quot;,开始扣款...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> payment.pay(<span class="built_in">this</span>.uid, <span class="built_in">this</span>.amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 测试方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>(<span class="string">&quot;20221014001&quot;</span>, <span class="number">500</span>);</span><br><span class="line">        <span class="comment">//欢迎使用微信支付</span></span><br><span class="line">        <span class="comment">//本次交易金额:500.0,开始扣款...</span></span><br><span class="line">        <span class="comment">//支付失败!余额不足!欠200.0元!</span></span><br><span class="line">        System.out.println(order.pay(<span class="string">&quot;WeChat&quot;</span>));</span><br><span class="line">        <span class="comment">//欢迎使用支付宝</span></span><br><span class="line">        <span class="comment">//本次交易金额:500.0,开始扣款...</span></span><br><span class="line">        <span class="comment">//支付成功!支付金额:500.0余额剩余:0.0</span></span><br><span class="line">        System.out.println(order.pay(<span class="string">&quot;Ali&quot;</span>));</span><br><span class="line">        <span class="comment">//欢迎使用现金支付</span></span><br><span class="line">        <span class="comment">//本次交易金额:500.0,开始扣款...</span></span><br><span class="line">        <span class="comment">//支付成功!支付金额:500.0余额剩余:500.0</span></span><br><span class="line">        System.out.println(order.pay());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="Spring中的应用"><a href="#Spring中的应用" class="headerlink" title="Spring中的应用"></a>Spring中的应用</h1><p>在Spring框架中，策略模式被广泛应用于各个模块和组件中。以下是一些在Spring源码中使用策略模式的示例:</p><ol><li>Spring Security模块中的身份验证策略: Spring Security通过<code>AuthenticationManager</code>接口来实现不同的身份验证策略，比如<code>DaoAuthenticationProvider</code>、<code>LdapAuthenticationProvider</code>等。通过配置和设置<code>AuthenticationManager</code>的实现类，可以灵活地选择和应用不同的身份验证策略。</li><li>Spring MVC模块中的处理器映射策略和处理器适配器策略: Spring MVC通过<code>HandlerMapping</code>接口和<code>HandlerAdapter</code>接口来实现不同的处理器映射策略和处理器适配器策略。比如，<code>RequestMappingHandlerMapping</code>和<code>RequestMappingHandlerAdapter</code>分别提供了基于注解的处理器映射和适配器策略，而<code>SimpleUrlHandlerMapping</code>和<code>SimpleControllerHandlerAdapter</code>则提供了基于URL和Controller接口的处理策略。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>策略模式是一种非常有用的设计模式，它可以将算法的变化与调用方分离，实现代码的解耦和灵活性。在实际应用中，如果有多个相关的算法需要在运行时根据不同的条件进行选择，或者需要将算法的实现从具体的类中抽离出来，那么策略模式是一个很好的选择。在Spring框架中，策略模式的灵活性和可扩展性得到了广泛的应用，使得开发者可以根据自己的需求来选择和配置不同的策略实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;策略模式&quot;&gt;&lt;a href=&quot;#策略模式&quot; class=&quot;headerlink&quot; title=&quot;策略模式&quot;&gt;&lt;/a&gt;策略模式&lt;/h1&gt;&lt;p&gt;简介: 策略模式（Strategy Pattern）是一种行为型设计模式，它允许在运行时根据不同的情况选择不同的算法或行为。</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>职责链模式</title>
    <link href="http://example.com/2023/07/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/07/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-07-11T01:38:53.000Z</published>
    <updated>2023-07-11T02:07:38.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java职责链模式"><a href="#java职责链模式" class="headerlink" title="java职责链模式"></a>java职责链模式</h1><p>在软件开发中，职责链模式是一种行为设计模式，它允许你将请求沿着处理者链进行传递，每个处理者可以决定是否处理请求以及将请求传递给下一个处理者。</p><h1 id="职责链模式结构"><a href="#职责链模式结构" class="headerlink" title="职责链模式结构"></a>职责链模式结构</h1><p>职责链模式由以下几个主要组件组成：</p><ul><li>抽象处理者（Handler）：定义处理请求的接口，包含一个指向下一个处理者的引用。</li><li>具体处理者（ConcreteHandler）：实现抽象处理者接口，并负责处理请求。如果自己不能处理请求，则将请求传递给下一个处理者。</li><li>客户端（Client）：创建职责链，并向链的第一个处理者发送请求。</li></ul><h1 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h1><p>下面以一个简单的登录校验流程来通过代码进行实现：</p><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String Username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String role;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// handler抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line"><span class="keyword">protected</span> Handler next;</span><br><span class="line"><span class="comment">// 返回handler方便链式操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">next</span><span class="params">(Handler next)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.next = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 流程开始的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doHandler</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidateHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doHandler</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(user.getUsername()) || StringUtils.isBlank(user.getPassword())) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户名或者密码为空!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;校验通过&quot;</span>);</span><br><span class="line">        next.doHandler(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doHandler</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">&quot;pyy52hz&quot;</span>.equals(user.getUsername()) || !<span class="string">&quot;123456&quot;</span>.equals(user.getPassword())) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户名或者密码不正确!请检查!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        user.setRole(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;登陆成功!角色为管理员!&quot;</span>);</span><br><span class="line">        next.doHandler(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doHandler</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">&quot;admin&quot;</span>.equals(user.getRole())) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;无权限操作!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;角色为管理员,可以进行下一步操作!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 登录流程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="type">Handler</span> <span class="variable">validateHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ValidateHandler</span>();</span><br><span class="line">        <span class="type">Handler</span> <span class="variable">loginHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginHandler</span>();</span><br><span class="line">        <span class="type">Handler</span> <span class="variable">authHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthHandler</span>();</span><br><span class="line">        validateHandler.next(loginHandler);</span><br><span class="line">        loginHandler.next(authHandler);</span><br><span class="line">        validateHandler.doHandler(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="comment">// 测试方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="comment">//校验通过</span></span><br><span class="line">        <span class="comment">//用户名或者密码不正确!请检查!</span></span><br><span class="line">        user.setUsername(<span class="string">&quot;pyy52hz&quot;</span>);</span><br><span class="line">        user.setPassword(<span class="string">&quot;1234567&quot;</span>);</span><br><span class="line">        <span class="type">LoginService</span> <span class="variable">loginService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginService</span>();</span><br><span class="line">        loginService.login(user);</span><br><span class="line">        <span class="comment">//校验通过</span></span><br><span class="line">        <span class="comment">//登陆成功!角色为管理员!</span></span><br><span class="line">        <span class="comment">//角色为管理员,可以进行下一步操作!</span></span><br><span class="line">        user.setUsername(<span class="string">&quot;pyy52hz&quot;</span>);</span><br><span class="line">        user.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        loginService.login(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">校验通过</span><br><span class="line">用户名或者密码不正确!请检查!</span><br><span class="line">校验通过</span><br><span class="line">登陆成功!角色为管理员!</span><br><span class="line">角色为管理员,可以进行下一步操作!</span><br></pre></td></tr></table></figure><h2 id="结合建造者模式"><a href="#结合建造者模式" class="headerlink" title="结合建造者模式"></a>结合建造者模式</h2><p>与基础版本区别主要是Handler类中新增一个Builder的内部类，以及流程类里改用链式写法，具体如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// handler抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">protected</span> Handler next;</span><br><span class="line">    <span class="comment">// 返回handler方便链式操作</span></span><br><span class="line">    <span class="keyword">public</span> Handler <span class="title function_">next</span><span class="params">(Handler next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 流程开始的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doHandler</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> Handler&lt;T&gt; head;</span><br><span class="line">        <span class="keyword">private</span> Handler&lt;T&gt; tail;</span><br><span class="line">        <span class="keyword">public</span> Builder&lt;T&gt; <span class="title function_">addHandler</span><span class="params">(Handler&lt;T&gt; handler)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.head == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.head = <span class="built_in">this</span>.tail = handler;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.tail.next(handler);</span><br><span class="line">            <span class="built_in">this</span>.tail = handler;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Handler&lt;T&gt; <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        Handler.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>.Builder();</span><br><span class="line">        builder.addHandler(<span class="keyword">new</span> <span class="title class_">ValidateHandler</span>())</span><br><span class="line">            .addHandler(<span class="keyword">new</span> <span class="title class_">LoginHandler</span>())</span><br><span class="line">            .addHandler(<span class="keyword">new</span> <span class="title class_">AuthHandler</span>());</span><br><span class="line">        builder.build().doHandler(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>适用场景：</p><ul><li>当一个请求需要被多个对象处理时，可以使用职责链模式将对象的处理流程串起来。</li><li>当不希望指定请求的处理者时，可以使用职责链模式动态地决定由哪个处理者处理请求。</li></ul><p>优点：</p><ul><li>将请求与处理解耦。</li><li>请求处理者（节点对象）只需关注自己感兴趣的请求进行处理即可，对于不感兴趣的请求，直接转发给下一级节点对象。</li><li>具备链式传递处理请求功能，请求发送者无需知晓链路结构，只需等待请求处理结果。</li><li>链路结构灵活，可以通过改变链路结构动态地新增或删减责任。</li><li>易于扩展新的请求处理类（节点），符合开闭原则。</li></ul><p>缺点：</p><ul><li>责任链太长或者处理时间过长，会影响整体性能。</li><li>如果节点对象存在循环引用时，会造成死循环，导致系统崩溃。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java职责链模式&quot;&gt;&lt;a href=&quot;#java职责链模式&quot; class=&quot;headerlink&quot; title=&quot;java职责链模式&quot;&gt;&lt;/a&gt;java职责链模式&lt;/h1&gt;&lt;p&gt;在软件开发中，职责链模式是一种行为设计模式，它允许你将请求沿着处理者链进行传递，每个</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>ciic_mes项目开发记录</title>
    <link href="http://example.com/2023/07/06/%E9%A1%B9%E7%9B%AE/ciic_mes%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2023/07/06/%E9%A1%B9%E7%9B%AE/ciic_mes%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/</id>
    <published>2023-07-06T02:20:06.000Z</published>
    <updated>2023-07-10T08:43:54.041Z</updated>
    
    <content type="html"><![CDATA[<h1 id="请求发送到后端的一系列操作"><a href="#请求发送到后端的一系列操作" class="headerlink" title="请求发送到后端的一系列操作"></a>请求发送到后端的一系列操作</h1><h2 id="请求先经过网关"><a href="#请求先经过网关" class="headerlink" title="请求先经过网关"></a>请求先经过网关</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">    <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">    <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> request.getURI().getPath();</span><br><span class="line">    <span class="comment">// 放行忽略token的url</span></span><br><span class="line">    <span class="keyword">if</span> (gatewaySecurityProperties.getPassTokenUrl().contains(url)) &#123;</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// token校验</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> getToken(request);</span><br><span class="line">    <span class="keyword">if</span> (ObjectUtils.isEmpty(token) || JwtUtils.isTokenExpired(token)) &#123;</span><br><span class="line">        <span class="keyword">return</span> unAuthenticationResponse(response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">userId</span> <span class="operator">=</span> JwtUtils.getUserIdFromToken(token);</span><br><span class="line">    <span class="keyword">if</span> (!RedisUtils.hasCacheObject(CacheKeyConstants.LOGIN_USER_KEY + userId)) &#123;</span><br><span class="line">        <span class="keyword">return</span> unAuthenticationResponse(response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加请求头</span></span><br><span class="line">    addHeader(request.mutate(), SecurityConstants.LOGIN_USER_ID, userId);</span><br><span class="line">    <span class="keyword">return</span> chain.filter(exchange.mutate().request(request.mutate().build()).build());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.获取请求信息和相应信息，获取URL路径</p><p>2.判断是否放行忽略token的URL（比如login），若是则chain.filter(exchange)放行请求</p><p>3.获取请求中的token，并判断是否为空或者已经过期，若是则返回未认证的响应</p><p>4.从token中获取用户id</p><p>5.判断用户id是否存在于Redis缓存中，若不存在，则返回未认证的响应</p><p>6.若存在，则在请求头中添加用户id</p><p>7.最后通过chain.filter()方法将请求继续传递下去</p><h2 id="到达下一个过滤器链中的过滤器来继续处理请求"><a href="#到达下一个过滤器链中的过滤器来继续处理请求" class="headerlink" title="到达下一个过滤器链中的过滤器来继续处理请求"></a>到达下一个过滤器链中的过滤器来继续处理请求</h2><h3 id="到达AuthenticationInterceptor认证拦截器"><a href="#到达AuthenticationInterceptor认证拦截器" class="headerlink" title="到达AuthenticationInterceptor认证拦截器"></a>到达AuthenticationInterceptor认证拦截器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> (HandlerMethod) handler;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> handlerMethod.getMethod();</span><br><span class="line">        <span class="comment">// 接口存在忽略token校验注解</span></span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(PassToken.class)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从线程私有尝试取出当前登录用户</span></span><br><span class="line">        <span class="type">LoginUserCache</span> <span class="variable">loginUserCache</span> <span class="operator">=</span> SecurityContextHolder.get();</span><br><span class="line">        <span class="keyword">if</span> (loginUserCache == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 无法取到说明未经LoginUser注解处理，需校验token并从Redis取出当前登录用户</span></span><br><span class="line">            <span class="comment">// token校验</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(SecurityConstants.TOKEN_HEADER_NAME);</span><br><span class="line">            <span class="keyword">if</span> (ObjectUtils.isEmpty(token)) &#123;</span><br><span class="line">                token = request.getParameter(SecurityConstants.TOKEN_HEADER_NAME);</span><br><span class="line">                <span class="keyword">if</span> (!ObjectUtils.isEmpty(token) &amp;&amp; token.startsWith(SecurityConstants.TOKEN_PREFIX)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        token = URLDecoder.decode(token, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                        unAuthenticationResponse(response);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    unAuthenticationResponse(response);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            token = token.substring(SecurityConstants.TOKEN_PREFIX.length());</span><br><span class="line">            <span class="keyword">if</span> (JwtUtils.isTokenExpired(token)) &#123;</span><br><span class="line">                unAuthenticationResponse(response);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从Redis中取出当前登录用户</span></span><br><span class="line">            loginUserCache = RedisUtils.getCacheObject(CacheKeyConstants.LOGIN_USER_KEY + JwtUtils.getUserIdFromToken(token));</span><br><span class="line">            <span class="keyword">if</span> (loginUserCache == <span class="literal">null</span>) &#123;</span><br><span class="line">                unAuthenticationResponse(response);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                SecurityContextHolder.set(loginUserCache);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 能取到说明已在LoginUser注解处理中校验过token并从Redis中取出当前登录用户</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个Spring MVC的拦截器，用于实现基于JWT的token校验和获取当前登录用户信息。下面是代码的详细解释：</p><ol><li>首先获取请求和响应对象。</li><li>获取处理当前请求的方法。</li><li>判断方法是否标有@PassToken注解，如果有，则跳过token校验，直接返回true。</li><li>如果方法没有标有@PassToken注解，则尝试从线程私有对象SecurityContextHolder中获取当前登录用户信息LoginUserCache。</li><li>如果获取不到当前登录用户信息LoginUserCache，则说明未经LoginUser注解处理，需要进行token校验并从Redis中获取当前登录用户信息。</li><li>首先从请求头或请求参数中获取token。</li><li>如果获取到了token，则进行进一步处理，包括对token格式的验证、解码等操作。</li><li>如果token已过期，则返回未认证的响应。</li><li>从Redis缓存中获取对应的当前登录用户信息LoginUserCache。</li><li>如果获取不到当前登录用户信息LoginUserCache，则返回未认证的响应。</li><li>如果获取到了当前登录用户信息LoginUserCache，则将其设置到线程私有对象SecurityContextHolder中。</li><li>返回true，表示通过token认证，可以继续处理请求。</li><li>如果能够从SecurityContextHolder中获取到当前登录用户信息LoginUserCache，则说明在LoginUser注解处理中已经进行了token校验并从Redis中获取了当前登录用户信息，直接返回true。</li></ol><h3 id="到达AuthorizationInterceptor鉴权拦截器"><a href="#到达AuthorizationInterceptor鉴权拦截器" class="headerlink" title="到达AuthorizationInterceptor鉴权拦截器"></a>到达AuthorizationInterceptor鉴权拦截器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> (HandlerMethod) handler;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> handlerMethod.getMethod();</span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(HasPermissions.class)) &#123;</span><br><span class="line">            <span class="comment">// 需要权限校验</span></span><br><span class="line">            <span class="type">HasPermissions</span> <span class="variable">hasPermissions</span> <span class="operator">=</span> method.getAnnotation(HasPermissions.class);</span><br><span class="line">            <span class="comment">// 方法需要的权限</span></span><br><span class="line">            List&lt;String&gt; methodPermissions = Arrays.asList(hasPermissions.value());</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isEmpty(methodPermissions)) &#123;</span><br><span class="line">                <span class="comment">// 方法需要的权限为空</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 用户具有的权限</span></span><br><span class="line">                List&lt;String&gt; userPermissions = SecurityContextHolder.get().getPermissions();</span><br><span class="line">                <span class="keyword">if</span> (methodPermissions.stream().anyMatch(userPermissions::contains)) &#123;</span><br><span class="line">                    <span class="comment">// 用户权限包含方法需要的权限之一</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 用户权限不存在方法需要的权限</span></span><br><span class="line">                    unAuthorizationResponse(response);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 无需授权</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个Spring MVC的拦截器，用于实现基于权限的授权校验。下面是代码的详细解释：</p><ol><li>首先获取请求和响应对象。</li><li>获取当前请求所对应的方法。</li><li>判断方法是否标有@HasPermissions注解，如果有，则表示该方法需要进行权限校验。</li><li>如果方法需要进行权限校验，则获取注解中定义的方法需要的权限列表。</li><li>判断方法需要的权限列表是否为空，如果为空，则表示方法不需要进行权限校验，直接返回true。</li><li>如果方法需要的权限列表不为空，则获取当前登录用户的权限列表。</li><li>检查当前登录用户的权限列表是否存在与方法需要的权限列表匹配的权限，如果存在匹配的权限，则表示当前登录用户具有所需的权限，返回true。</li><li>如果当前登录用户的权限列表不存在与方法需要的权限列表匹配的权限，则表示当前登录用户没有权限访问该方法，返回未授权的响应并返回false。</li><li>如果方法没有标有@HasPermissions注解，则表示该方法不需要进行权限校验，直接返回true。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;请求发送到后端的一系列操作&quot;&gt;&lt;a href=&quot;#请求发送到后端的一系列操作&quot; class=&quot;headerlink&quot; title=&quot;请求发送到后端的一系列操作&quot;&gt;&lt;/a&gt;请求发送到后端的一系列操作&lt;/h1&gt;&lt;h2 id=&quot;请求先经过网关&quot;&gt;&lt;a href=&quot;#请求</summary>
      
    
    
    
    <category term="项目" scheme="http://example.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>享元模式</title>
    <link href="http://example.com/2023/07/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/07/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-07-02T02:11:06.000Z</published>
    <updated>2023-07-02T02:47:56.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><p>享元模式又称为轻量级模式，是对象池的一种实现，类似于线程池，线程池可以避免不停的创建和销毁多个对象，消耗性能。提供了减少对象数量从而改善应用所宿舍的对象结构的方式。宗旨：共享细粒度对象，将多个同一对象的访问集中起来。</p><p>享元模式（Flyweight Pattern）存在以下俩种状态：</p><ul><li>内部状态，即不会随着环境的改变而改变的可共享部分。</li><li>外部状态，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的俩种状态，并使外部状态外部化。</li></ul><p>享元模式主要有以下角色：</p><ol><li>抽象享元角色（Flyweight）：通常是一个接口或抽象类，在抽象享元中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。</li><li>具体享元角色（Concrete Flyweight): 它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。</li><li>飞享元角色（Unsharable Flyweight): 并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类，当需要一个非共享享元类的对象时可以直接通过实例化创建。</li><li>享元工厂角色（Flyweight Factory)： 负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检查系统中是否存在符合的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。</li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p> 下面通过查询火车票的例子来用代码进行模拟实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITicket</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String seat)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainTicket</span> <span class="keyword">implements</span> <span class="title class_">ITicket</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line">    <span class="keyword">private</span> String to;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TrainTicket</span><span class="params">(String from, String to)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.from = from;</span><br><span class="line">        <span class="built_in">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String seat)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">500</span>);</span><br><span class="line">        System.out.println(from + <span class="string">&quot;-&gt;&quot;</span> + to + <span class="string">&quot;:&quot;</span> + seat + <span class="string">&quot;价格:&quot;</span> + <span class="built_in">this</span>.price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TicketFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, ITicket&gt; pool = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ITicket <span class="title function_">getTicket</span><span class="params">(String from, String to)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> from + <span class="string">&quot;-&gt;&quot;</span> + to;</span><br><span class="line">        <span class="keyword">if</span> (pool.containsKey(key)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;使用缓存获取火车票:&quot;</span> + key);</span><br><span class="line">            <span class="keyword">return</span> pool.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用数据库获取火车票:&quot;</span> + key);</span><br><span class="line">        <span class="type">ITicket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainTicket</span>(from, to);</span><br><span class="line">        pool.put(key, ticket);</span><br><span class="line">        <span class="keyword">return</span> ticket;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ITicket</span> <span class="variable">ticket</span> <span class="operator">=</span> TicketFactory.getTicket(<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ticket.show(<span class="string">&quot;二等座&quot;</span>);</span><br><span class="line">        <span class="type">ITicket</span> <span class="variable">ticket1</span> <span class="operator">=</span> TicketFactory.getTicket(<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ticket1.show(<span class="string">&quot;商务座&quot;</span>);</span><br><span class="line">        <span class="type">ITicket</span> <span class="variable">ticket2</span> <span class="operator">=</span> TicketFactory.getTicket(<span class="string">&quot;上海&quot;</span>, <span class="string">&quot;北京&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ticket2.show(<span class="string">&quot;一等座&quot;</span>);</span><br><span class="line">        System.out.println(ticket == ticket1);<span class="comment">//true</span></span><br><span class="line">        System.out.println(ticket == ticket2);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">使用数据库获取火车票:北京-&gt;上海</span><br><span class="line">北京-&gt;上海:二等座价格:<span class="number">306</span></span><br><span class="line">使用缓存获取火车票:北京-&gt;上海</span><br><span class="line">北京-&gt;上海:商务座价格:<span class="number">145</span></span><br><span class="line">使用数据库获取火车票:上海-&gt;北京</span><br><span class="line">上海-&gt;北京:一等座价格:<span class="number">152</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure><p>可以看到ticket和ticket2是使用数据库查询的，而ticket1是使用缓存查询的，同时ticket == ticket1返回的是true，ticket == ticket2返回的是false，证明ticket和ticket1是共享的对象。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>适用场景：</p><ul><li>一个系统有大量相同或者相似的对象，造成内存的大量耗费。</li><li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。</li><li>在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。</li></ul><p>优点：</p><ul><li>减少对象的创建，降低内存中对象的数量，降低系统的内存，提高效率。</li><li>减少内存之外的其他资源占用。</li></ul><p>缺点：</p><ul><li>关注内、外部状态。</li><li>关注线程安全问题。</li><li>使系统、程序的逻辑复杂化。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;享元模式&quot;&gt;&lt;a href=&quot;#享元模式&quot; class=&quot;headerlink&quot; title=&quot;享元模式&quot;&gt;&lt;/a&gt;享元模式&lt;/h1&gt;&lt;p&gt;享元模式又称为轻量级模式，是对象池的一种实现，类似于线程池，线程池可以避免不停的创建和销毁多个对象，消耗性能。提供了减少对象</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>组合模式</title>
    <link href="http://example.com/2023/06/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/06/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-06-30T12:17:19.000Z</published>
    <updated>2023-06-30T13:17:53.991Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><p>组合模式（Composite Pattern）也称为整体-不分模式，它的宗旨是通过将单个对象（叶子结点）和组合对象（树枝节点）同相同的接口进行表示、</p><p>作用：使客户端对单个对象和组合对象保持一致的方式处理。</p><p>组合模式的主要三种角色：</p><ol><li>抽象根节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。</li><li>树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。</li><li>叶子节点（Leaf):叶子节点对象，其下再无分支，使系统层次遍历的最小单位。</li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>下面通过一个添加菜单的例子通过代码实现：</p><h2 id="透明模式"><a href="#透明模式" class="headerlink" title="透明模式"></a>透明模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 菜单组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MenuComponent</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Integer level;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(MenuComponent menuComponent)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;不支持添加操作!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(MenuComponent menuComponent)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;不支持删除操作!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> MenuComponent <span class="title function_">getChild</span><span class="params">(Integer i)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;不支持获取子菜单操作!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;不支持获取名字操作!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;不支持打印操作!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 菜单类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Menu</span> <span class="keyword">extends</span> <span class="title class_">MenuComponent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;MenuComponent&gt; menuComponentList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Menu</span><span class="params">(String name,<span class="type">int</span> level)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(MenuComponent menuComponent)</span> &#123;</span><br><span class="line">        menuComponentList.add(menuComponent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(MenuComponent menuComponent)</span> &#123;</span><br><span class="line">        menuComponentList.remove(menuComponent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MenuComponent <span class="title function_">getChild</span><span class="params">(Integer i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> menuComponentList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; level; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;--&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="keyword">for</span> (MenuComponent menuComponent : menuComponentList) &#123;</span><br><span class="line">            menuComponent.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 子菜单类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MenuItem</span> <span class="keyword">extends</span> <span class="title class_">MenuComponent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MenuItem</span><span class="params">(String name,<span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; level; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;--&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一级菜单</span></span><br><span class="line">        <span class="type">MenuComponent</span> <span class="variable">component</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Menu</span>(<span class="string">&quot;系统管理&quot;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">MenuComponent</span> <span class="variable">menu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Menu</span>(<span class="string">&quot;用户管理&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        menu1.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;新增用户&quot;</span>,<span class="number">3</span>));</span><br><span class="line">        menu1.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;修改用户&quot;</span>,<span class="number">3</span>));</span><br><span class="line">        menu1.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;删除用户&quot;</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">MenuComponent</span> <span class="variable">menu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Menu</span>(<span class="string">&quot;角色管理&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        menu2.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;新增角色&quot;</span>,<span class="number">3</span>));</span><br><span class="line">        menu2.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;修改角色&quot;</span>,<span class="number">3</span>));</span><br><span class="line">        menu2.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;删除角色&quot;</span>,<span class="number">3</span>));</span><br><span class="line">        menu2.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;绑定用户&quot;</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将二级菜单添加到一级菜单中</span></span><br><span class="line">        component.add(menu1);</span><br><span class="line">        component.add(menu2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印菜单名称(如果有子菜单一块打印)</span></span><br><span class="line">        component.print();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">系统管理</span><br><span class="line">--用户管理</span><br><span class="line">----新增用户</span><br><span class="line">----修改用户</span><br><span class="line">----删除用户</span><br><span class="line">--角色管理</span><br><span class="line">----新增角色</span><br><span class="line">----修改角色</span><br><span class="line">----删除角色</span><br><span class="line">----绑定用户</span><br></pre></td></tr></table></figure><h2 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MenuComponent</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Integer level;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Menu</span> <span class="keyword">extends</span> <span class="title class_">MenuComponent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;MenuComponent&gt; menuComponentList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Menu</span><span class="params">(String name, <span class="type">int</span> level)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(MenuComponent menuComponent)</span> &#123;</span><br><span class="line">        menuComponentList.add(menuComponent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(MenuComponent menuComponent)</span> &#123;</span><br><span class="line">        menuComponentList.remove(menuComponent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> MenuComponent <span class="title function_">getChild</span><span class="params">(Integer i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> menuComponentList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; level; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;--&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="keyword">for</span> (MenuComponent menuComponent : menuComponentList) &#123;</span><br><span class="line">            menuComponent.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MenuItem</span> <span class="keyword">extends</span> <span class="title class_">MenuComponent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MenuItem</span><span class="params">(String name, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; level; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;--&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Menu</span> <span class="variable">component</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Menu</span>(<span class="string">&quot;系统管理&quot;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Menu</span> <span class="variable">menu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Menu</span>(<span class="string">&quot;用户管理&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        menu1.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;新增用户&quot;</span>,<span class="number">3</span>));</span><br><span class="line">        menu1.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;修改用户&quot;</span>,<span class="number">3</span>));</span><br><span class="line">        menu1.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;删除用户&quot;</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Menu</span> <span class="variable">menu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Menu</span>(<span class="string">&quot;角色管理&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        menu2.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;新增角色&quot;</span>,<span class="number">3</span>));</span><br><span class="line">        menu2.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;修改角色&quot;</span>,<span class="number">3</span>));</span><br><span class="line">        menu2.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;删除角色&quot;</span>,<span class="number">3</span>));</span><br><span class="line">        menu2.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;绑定用户&quot;</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将二级菜单添加到一级菜单中</span></span><br><span class="line">        component.add(menu1);</span><br><span class="line">        component.add(menu2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印菜单名称(如果有子菜单一块打印)</span></span><br><span class="line">        component.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">系统管理</span><br><span class="line">--用户管理</span><br><span class="line">----新增用户</span><br><span class="line">----修改用户</span><br><span class="line">----删除用户</span><br><span class="line">--角色管理</span><br><span class="line">----新增角色</span><br><span class="line">----修改角色</span><br><span class="line">----删除角色</span><br><span class="line">----绑定用户</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>分类</p><ul><li>透明组合模式<ul><li>透明组合模式中，抽象根节点角色中声明了所有用于管理成员对象的方法，比如在示例中MenuComponent声明了add() 、 remove() 、getChild()方法，这样做的好处是确保所有的构件类都有相同的接口。透明组合模式也是组合模式的标准形式。</li><li>透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供 add()、remove() 等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）</li></ul></li><li>安全组合模式<ul><li>在安全组合模式中，在抽象构件角色中没有声明任何用于管理成员对象的方法，而是在树枝节点Menu类中声明并实现这些方法。安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;组合模式&quot;&gt;&lt;a href=&quot;#组合模式&quot; class=&quot;headerlink&quot; title=&quot;组合模式&quot;&gt;&lt;/a&gt;组合模式&lt;/h1&gt;&lt;p&gt;组合模式（Composite Pattern）也称为整体-不分模式，它的宗旨是通过将单个对象（叶子结点）和组合对象（树枝节点</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>外观模式</title>
    <link href="http://example.com/2023/06/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/06/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-06-29T11:51:21.000Z</published>
    <updated>2023-06-29T13:25:54.119Z</updated>
    
    <content type="html"><![CDATA[<h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><p>外观模式为子系统中的一组接口提供了一个统一的接口，使得子系统更容易使用。通过使用外观模式，我们可以减少系统的相互依赖性，并增加系统的灵活性。</p><p>外观模式（Facade Pattern）的角色：</p><ol><li>外观角色：为多个子系统对外提供一个共同的接口。</li><li>子系统角色：实现系统的部分功能，客户可以通过外观角色访问它。</li></ol><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p>在以下情况可以考虑适用外观模式：</p><ol><li>当需要为一组复杂的子系统提供一个简单的统一接口。</li><li>当希望将子系统的分层进行隐藏，只暴露必要的功能接口。</li><li>当要简化调用者和子系统之间的依赖关系。</li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>下面以一个智能音箱实现起床睡觉一键操作电器的场景，通过代码模拟一下这个场景：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Light</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开灯&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关灯&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tv</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开电视&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关电视&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fan</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开风扇&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关风扇&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmartSpeaker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line">    <span class="keyword">private</span> Tv tv;</span><br><span class="line">    <span class="keyword">private</span> Fan fan;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmartSpeaker</span><span class="params">()</span> &#123;</span><br><span class="line">        light = <span class="keyword">new</span> <span class="title class_">Light</span>();</span><br><span class="line">        tv = <span class="keyword">new</span> <span class="title class_">Tv</span>();</span><br><span class="line">        fan = <span class="keyword">new</span> <span class="title class_">Fan</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(String order)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (order.contains(<span class="string">&quot;起床&quot;</span>)) &#123;</span><br><span class="line">            getUp();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (order.contains(<span class="string">&quot;睡觉&quot;</span>)) &#123;</span><br><span class="line">            sleep();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我还听不懂你说的啥！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getUp</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;起床&quot;</span>);</span><br><span class="line">        light.on();</span><br><span class="line">        tv.on();</span><br><span class="line">        fan.off();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;睡觉&quot;</span>);</span><br><span class="line">        light.off();</span><br><span class="line">        tv.off();</span><br><span class="line">        fan.on();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SmartSpeaker</span> <span class="variable">smartSpeaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmartSpeaker</span>();</span><br><span class="line">        smartSpeaker.say(<span class="string">&quot;我要睡觉了!&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">        smartSpeaker.say(<span class="string">&quot;我起床了!&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">        smartSpeaker.say(<span class="string">&quot;Emmm&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">睡觉</span><br><span class="line">关灯</span><br><span class="line">关电视</span><br><span class="line">开风扇</span><br><span class="line">--------</span><br><span class="line">起床</span><br><span class="line">开灯</span><br><span class="line">开电视</span><br><span class="line">关风扇</span><br><span class="line">--------</span><br><span class="line">我还听不懂你说的啥！</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;外观模式&quot;&gt;&lt;a href=&quot;#外观模式&quot; class=&quot;headerlink&quot; title=&quot;外观模式&quot;&gt;&lt;/a&gt;外观模式&lt;/h1&gt;&lt;p&gt;外观模式为子系统中的一组接口提供了一个统一的接口，使得子系统更容易使用。通过使用外观模式，我们可以减少系统的相互依赖性，并增</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>桥接模式</title>
    <link href="http://example.com/2023/06/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/06/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-06-29T06:23:03.000Z</published>
    <updated>2023-06-29T06:53:03.506Z</updated>
    
    <content type="html"><![CDATA[<h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><p>桥接模式是一种重要的设计模式，它能够将抽象部分和实现部分分离开来，使得他们可以独立地变化，通过组合的方式建立俩个类之间的联系，而不是继承。</p><p>桥接模式（Bridge Pattern）包含以下主要角色：</p><ol><li>抽象化（Abstraction）:定义了抽象部分的接口，并包含对一个实现类的引用。</li><li>扩展抽象化（Refined Abstraction）：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</li><li>实现化（Implementor）:定义实现化角色的接口。供扩展抽象化角色调用。</li><li>具体实现化（Concrete Implementor）角色：给出实例化角色接口的具体实现。</li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>假设我们要设计一个形状类（Shape），它有两个子类：圆形（Circle）和矩形（Rectangle）。同时，我们还有两个颜色类（Color）：红色（Red）和蓝色（Blue）。我们希望用户可以根据需要选择不同的颜色来绘制不同的形状。</p><p>首先，我们定义一个抽象类Shape，它包含一个对Color的引用，并声明了一个绘制方法draw()：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Color color;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Shape</span><span class="params">(Color color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们定义一个具体的形状类Circle，它继承自Shape并实现了draw()方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(Color color)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(color);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;绘制一个圆形，&quot;</span>);</span><br><span class="line">        color.paint();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们定义一个具体的形状类Rectangle，它也继承自Shape并实现了draw()方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(Color color)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(color);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;绘制一个矩形，&quot;</span>);</span><br><span class="line">        color.paint();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们定义一个抽象实现接口Color，它声明了一个绘制方法paint()：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们定义两个具体的颜色类Red和Blue，它们实现了Color接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Red</span> <span class="keyword">implements</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用红色画笔绘制。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Blue</span> <span class="keyword">implements</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用蓝色画笔绘制。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们可以编写一个测试类来验证桥接模式的使用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="keyword">new</span> <span class="title class_">Red</span>()).draw();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="keyword">new</span> <span class="title class_">Blue</span>()).draw();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="keyword">new</span> <span class="title class_">Red</span>()).draw();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="keyword">new</span> <span class="title class_">Blue</span>()).draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以上代码，输出结果如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">绘制一个圆形, 使用红色画笔绘制。</span><br><span class="line">绘制一个圆形, 使用蓝色画笔绘制。</span><br><span class="line">绘制一个矩形，使用红色画笔绘制。</span><br><span class="line">绘制一个矩形，使用蓝色画笔绘制。</span><br></pre></td></tr></table></figure><p>具体形状类和Color类通过Shape桥接关联起来</p><p>以上就是桥接模式在Java中的具体实现示例。通过使用桥接模式，我们可以将抽象部分和实现部分分离开来，使得它们可以独立变化。这种灵活的设计模式能够使我们的代码结构更加可扩展和可维护。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;桥接模式&quot;&gt;&lt;a href=&quot;#桥接模式&quot; class=&quot;headerlink&quot; title=&quot;桥接模式&quot;&gt;&lt;/a&gt;桥接模式&lt;/h1&gt;&lt;p&gt;桥接模式是一种重要的设计模式，它能够将抽象部分和实现部分分离开来，使得他们可以独立地变化，通过组合的方式建立俩个类之间的联系</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>装饰模式</title>
    <link href="http://example.com/2023/06/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/06/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-06-28T12:07:12.000Z</published>
    <updated>2023-06-28T13:35:25.551Z</updated>
    
    <content type="html"><![CDATA[<p>什么是装饰器模式？ 装饰器模式是一种结构型设计模式，它允许向现有对象添加新的功能，而无需修改其源代码或直接继承该对象。装饰器模式通过将对象进行包装来实现功能的扩展，通常将扩展的功能与原始对象的功能进行解耦，以便更灵活地添加、移除或组合功能。</p><h1 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h1><p>装饰器模式包含以下角色：</p><ol><li><p>抽象构件 (Component)：定义一个抽象接口，用于定义装饰器和具体构件的公共方法。</p></li><li><p>具体构件 (Concrete Component)：实现抽象构件接口，定义被装饰的类。</p></li><li><p>抽象装饰器 (Decorator)：继承或实现抽象构件接口，并持有一个抽象构件的引用。它的主要作用是定义装饰器的公共方法。</p></li><li><p>具体装饰器 (Concrete Decorator)：继承抽象装饰器，并根据需要进行具体的装饰，可以动态地扩展或修改具体构件的行为。</p></li></ol><p>在装饰器模式中，具体构件是被装饰的对象，抽象装饰器和具体装饰器在使用时与具体构件具有相同的接口，但是具体装饰器可以在调用被装饰对象的方法之前或之后加上自己的逻辑，从而实现功能的扩展和变化。</p><p>这种角色的分离使得装饰器模式可以在不修改原有代码的情况下，动态地给对象增加新的责任。同时，装饰器模式也遵循”开放-关闭”原则，使得系统更加灵活和可扩展。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>举一个简单的例子，假如现在有一碟炒饭，每个人的口味不一样，有些人喜欢加鸡蛋，有些人喜欢加鸡蛋火腿，有些人喜欢加鸡蛋火腿胡萝卜等。</p><h2 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriedRice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;炒饭&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriedRiceAddEgg</span> <span class="keyword">extends</span> <span class="title class_">FriedRice</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDescription() + <span class="string">&quot;加鸡蛋&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.cost() + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriedRiceAddEggAndHam</span> <span class="keyword">extends</span> <span class="title class_">FriedRiceAddEgg</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDescription() + <span class="string">&quot;加火腿&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.cost() + <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FriedRice</span> <span class="variable">friedRice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedRice</span>();</span><br><span class="line">        System.out.println(friedRice.getDescription()+<span class="string">&quot; 价格：&quot;</span>+friedRice.cost());</span><br><span class="line"></span><br><span class="line">        <span class="type">FriedRiceAddEgg</span> <span class="variable">friedRiceAddEgg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedRiceAddEgg</span>();</span><br><span class="line">        System.out.println(friedRiceAddEgg.getDescription()+<span class="string">&quot; 价格：&quot;</span>+friedRiceAddEgg.cost());</span><br><span class="line"></span><br><span class="line">        <span class="type">FriedRiceAddEggAndHam</span> <span class="variable">friedRiceAddEggAndHam</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedRiceAddEggAndHam</span>();</span><br><span class="line">        System.out.println(friedRiceAddEggAndHam.getDescription()+<span class="string">&quot; 价格：&quot;</span>+friedRiceAddEggAndHam.cost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">炒饭 价格：<span class="number">10.0</span></span><br><span class="line">炒饭加鸡蛋 价格：<span class="number">12.0</span></span><br><span class="line">炒饭加鸡蛋加火腿 价格：<span class="number">15.0</span></span><br></pre></td></tr></table></figure><p>那么就会发现，如果采用继承的方式去实现这个例子，那么每加一个配料，都需要创建新的配料类去继承上一个旧的配料类，那么久而久之，就会产生很多类了，而且还不利于扩展。可以从上面看到，如果我们只需要炒饭加火腿，那么我们还需要创建一个FriedRiceAddHam类去继承FriedRice类，所以继承的方式扩展性非常不好，且需要定义非常多的子类，下面就可以用装饰器模式去改进它。</p><h2 id="装饰模式实现"><a href="#装饰模式实现" class="headerlink" title="装饰模式实现"></a>装饰模式实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象构建</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FriedRice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//具体构建</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriedRiceImpl</span> <span class="keyword">implements</span> <span class="title class_">FriedRice</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;炒饭&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象装饰器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">FriedRiceDecorator</span> <span class="keyword">implements</span> <span class="title class_">FriedRice</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> FriedRice docoratedFriedRice;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FriedRiceDecorator</span><span class="params">(FriedRice docoratedFriedRice)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.docoratedFriedRice = docoratedFriedRice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> docoratedFriedRice.getDescription();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> docoratedFriedRice.getCost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//具体装饰器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriedRiceAddEggDecorator</span> <span class="keyword">extends</span> <span class="title class_">FriedRiceDecorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FriedRiceAddEggDecorator</span><span class="params">(FriedRice docoratedFriedRice)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(docoratedFriedRice);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDescription() + <span class="string">&quot;加鸡蛋&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getCost() + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//具体装饰器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriedRiceAddEggAndHamDecorator</span> <span class="keyword">extends</span> <span class="title class_">FriedRiceDecorator</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FriedRiceAddEggAndHamDecorator</span><span class="params">(FriedRice docoratedFriedRice)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(docoratedFriedRice);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDescription()+<span class="string">&quot;加鸡蛋加火腿&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getCost() + <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FriedRice</span> <span class="variable">friedRice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedRiceImpl</span>();</span><br><span class="line">        System.out.println(friedRice.getDescription()+<span class="string">&quot; 价格：&quot;</span>+friedRice.getCost());</span><br><span class="line"></span><br><span class="line">        <span class="type">FriedRice</span> <span class="variable">friedRiceAddEggDecorator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedRiceAddEggDecorator</span>(friedRice);</span><br><span class="line">        System.out.println(friedRiceAddEggDecorator.getDescription()+<span class="string">&quot; 价格：&quot;</span>+friedRiceAddEggDecorator.getCost());</span><br><span class="line"></span><br><span class="line">        <span class="type">FriedRice</span> <span class="variable">friedRiceAddEggAndHamDecorator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedRiceAddEggAndHamDecorator</span>(friedRice);</span><br><span class="line">        System.out.println(friedRiceAddEggAndHamDecorator.getDescription() + <span class="string">&quot; 价格：&quot;</span> + friedRiceAddEggAndHamDecorator.getCost());</span><br><span class="line"></span><br><span class="line">        <span class="type">FriedRice</span> <span class="variable">friedRiceAddEggDecorator1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedRiceAddEggDecorator</span>(friedRiceAddEggAndHamDecorator);</span><br><span class="line">        System.out.println(friedRiceAddEggDecorator1.getDescription() + <span class="string">&quot; 价格：&quot;</span> + friedRiceAddEggDecorator1.getCost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">炒饭 价格：<span class="number">10.0</span></span><br><span class="line">炒饭加鸡蛋 价格：<span class="number">12.0</span></span><br><span class="line">炒饭加鸡蛋加火腿 价格：<span class="number">15.0</span></span><br><span class="line">炒饭加鸡蛋加火腿加鸡蛋 价格：<span class="number">17.0</span></span><br></pre></td></tr></table></figure><p>可以看到，使用装饰器模式的方法实现，与普通的继承方法实现，最大的区别就是一种配料只有一个类，而且在加配料的时候，也可以直接想加多少就加多少，不需要说一个鸡蛋一个类，两个鸡蛋也要创建一个类，这样可以带来比继承更加灵活的扩展功能，使用也更加方便。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>装饰器模式和代理模式在一定程度上是相似的，它们都是结构型设计模式，都可以在不修改原始对象的情况下为其添加额外的功能。然而，它们之间有几个关键的区别：</p><ol><li><p>目的不同：</p><ul><li>装饰器模式的主要目的是在不改变接口的前提下，动态地为对象添加新的功能。它通常用于以透明的方式增强对象的功能。</li><li>代理模式的主要目的是通过代理控制对对象的访问。代理在客户端和目标对象之间充当中介，可以用于实现访问控制、远程访问、延迟加载等功能。</li></ul></li><li><p>关注点不同：</p><ul><li>装饰器模式关注于为对象添加功能，强调对对象的增强和扩展。</li><li>代理模式关注于控制对对象的访问，强调对对象的控制和隐藏。</li></ul></li><li><p>关系不同：</p><ul><li>装饰器模式使用组合关系，装饰器和被装饰对象共同实现同一个接口，以便能够替代原始对象。装饰器模式在运行时动态地组合对象，使得对象可以具有不同的行为。</li><li>代理模式使用聚合关系，代理对象持有对目标对象的引用，并在需要时调用目标对象。代理模式常用于隐藏目标对象的内部实现、实现访问控制、实现远程服务请求等。</li></ul></li></ol><p>总结来说，装饰器模式侧重于为对象添加功能，而代理模式侧重于控制对对象的访问。装饰器模式通过组合关系动态地对对象进行扩展，而代理模式通过聚合关系为对象提供了一个替代者。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;什么是装饰器模式？ 装饰器模式是一种结构型设计模式，它允许向现有对象添加新的功能，而无需修改其源代码或直接继承该对象。装饰器模式通过将对象进行包装来实现功能的扩展，通常将扩展的功能与原始对象的功能进行解耦，以便更灵活地添加、移除或组合功能。&lt;/p&gt;
&lt;h1 id=&quot;装饰模式</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>迭代器模式</title>
    <link href="http://example.com/2023/06/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/06/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-06-27T02:13:11.000Z</published>
    <updated>2023-06-27T02:59:51.457Z</updated>
    
    <content type="html"><![CDATA[<p>迭代器模式又称为游标模式（Cursor Pattern），它提供一种顺序访问集合/容器对象元素的方法，而又无须暴露结合内部表示。</p><h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><p>本质：抽离集合对象迭代行为到迭代器中，提供一致访问接口。</p><p>迭代器模式主要包含以下角色：</p><ul><li>抽象集合（Aggregate）角色：定义存储、添加、删除聚合元素以及创建迭代器对象的接口。</li><li>具体集合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。</li><li>抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、next() 等方法。</li><li>具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Aggregate</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T obj)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(T obj)</span>;</span><br><span class="line"></span><br><span class="line">    Iterator&lt;T&gt; <span class="title function_">getIterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteAggregate</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Aggregate</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T obj)</span> &#123;</span><br><span class="line">        list.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(T obj)</span> &#123;</span><br><span class="line">        list.remove(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">getIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteIterator</span>&lt;T&gt;(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    T <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteIterator</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt;&#123;</span><br><span class="line">    List&lt;T&gt; list;</span><br><span class="line">    <span class="type">int</span> cursor;</span><br><span class="line">    T element;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteIterator</span><span class="params">(List&lt;T&gt; list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &lt; list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        element = list.get(cursor);</span><br><span class="line">        cursor++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        ConcreteAggregate&lt;String&gt; aggregate = <span class="keyword">new</span> <span class="title class_">ConcreteAggregate</span>&lt;&gt;();</span><br><span class="line">        aggregate.add(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">        aggregate.add(<span class="string">&quot;小红&quot;</span>);</span><br><span class="line">        aggregate.add(<span class="string">&quot;小刚&quot;</span>);</span><br><span class="line">        aggregate.remove(<span class="string">&quot;小刚&quot;</span>);</span><br><span class="line">        Iterator&lt;String&gt; iterator = aggregate.getIterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">小明</span><br><span class="line">小红</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>适用场景：</p><ul><li>访问一个集合对象的内容而无需暴露它的内部表示。</li><li>为遍历不同的集合结构提供一个统一的访问接口。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;迭代器模式又称为游标模式（Cursor Pattern），它提供一种顺序访问集合/容器对象元素的方法，而又无须暴露结合内部表示。&lt;/p&gt;
&lt;h1 id=&quot;迭代器模式&quot;&gt;&lt;a href=&quot;#迭代器模式&quot; class=&quot;headerlink&quot; title=&quot;迭代器模式&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>观察者模式</title>
    <link href="http://example.com/2023/06/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/06/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-06-26T11:49:14.000Z</published>
    <updated>2023-06-27T02:05:09.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>观察者模式（Observer Pattern）是一种行为型设计模式，它定义了对象之间的一对多依赖关系，使得当一个对象的状态发生改变时，所有依赖它的对象都会自动通知并更新。</p><p>观察者模式中涉及以下角色：</p><ul><li>主题（Subject）：也称为被观察者，负责管理所有观察者对象的注册、删除和通知操作。当主题的状态发生改变时，会通知所有观察者。</li><li>观察者（Observer）：定义了一个更新接口，用于接收主题通知的更新。当观察者接收到主题的通知后，可以执行相应的操作。</li><li>具体主题（ConcreteSubject）：实现主题接口，负责具体的主题业务逻辑，并维护观察者列表。具体主题通常会在其状态发生变化时，通知观察者。</li><li>具体观察者（ConcreteObserver）：实现观察者接口，具体定义当接收到主题通知时的更新行为。每个具体观察者都会在主题状态发生变化时被通知，并执行相应的操作。</li></ul><h1 id="使用Java接口和回调函数实现"><a href="#使用Java接口和回调函数实现" class="headerlink" title="使用Java接口和回调函数实现"></a>使用Java接口和回调函数实现</h1><p>通过定义一个包含通知方法的观察者接口，然后将观察者通过回调函数注册到主题中。当主题的状态发生改变时，调用观察者的回调方法通知其进行相应的处理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unRegisterObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    ArrayList&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line">    String message;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unRegisterObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteObserver</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;观察者: &quot;</span> + name + <span class="string">&quot; 收到通知：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConcreteSubject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteSubject</span>();</span><br><span class="line">        subject.registerObserver(<span class="keyword">new</span> <span class="title class_">ConcreteObserver</span>(<span class="string">&quot;小明&quot;</span>));</span><br><span class="line">        subject.registerObserver(<span class="keyword">new</span> <span class="title class_">ConcreteObserver</span>(<span class="string">&quot;小红&quot;</span>));</span><br><span class="line">        subject.registerObserver(<span class="keyword">new</span> <span class="title class_">ConcreteObserver</span>(<span class="string">&quot;小刚&quot;</span>));</span><br><span class="line">        subject.setState(<span class="string">&quot;明天放假&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">观察者: 小明 收到通知：明天放假</span><br><span class="line">观察者: 小红 收到通知：明天放假</span><br><span class="line">观察者: 小刚 收到通知：明天放假</span><br></pre></td></tr></table></figure><p>运行以上代码，观察者1和观察者2都会收到主题状态的改变通知并进行相应的操作。</p><h1 id="JDK实现"><a href="#JDK实现" class="headerlink" title="JDK实现"></a>JDK实现</h1><p>在 Java 中，通过java.util.Observable类和 java.util.Observer接口定义了观察者模式，只要实现它们的子类就可以编写观察者模式实例。</p><h2 id="Observable类"><a href="#Observable类" class="headerlink" title="Observable类"></a>Observable类</h2><p>Observable类是抽象目标类（被观察者），它有一个Vector集合成员变量，用于保存所有要通知的观察者对象，下面是它最重要的 3 个方法：</p><ul><li>void addObserver(Observer o) 方法：用于将新的观察者对象添加到集合中。</li><li>void notifyObservers(Object arg) 方法：调用集合中的所有观察者对象的update方法，通知它们数据发生改变。通常越晚加入集合的观察者越先得到通知。</li><li>void setChange() 方法：用来设置一个boolean类型的内部标志，注明目标对象发生了变化。当它为true时，notifyObservers() 才会通知观察者。</li></ul><h2 id="Observer-接口"><a href="#Observer-接口" class="headerlink" title="Observer 接口"></a>Observer 接口</h2><p>Observer 接口是抽象观察者，它监视目标对象的变化，当目标对象发生变化时，观察者得到通知，并调用 update 方法，进行相应的工作。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subject</span> <span class="keyword">extends</span> <span class="title class_">java</span>.util.Observable &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;被观察者: &quot;</span> + name + <span class="string">&quot; 发送通知：&quot;</span> + message);</span><br><span class="line">        setChanged();</span><br><span class="line">        notifyObservers(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">java</span>.util.Observer &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Observable o, Object arg)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;关注了 &quot;</span> + ((Subject) o).getName() + <span class="string">&quot; ,收到通知：&quot;</span> + arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Subject</span>(<span class="string">&quot;公众号&quot;</span>);</span><br><span class="line">        subject.addObserver(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;小明&quot;</span>));</span><br><span class="line">        subject.addObserver(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;小红&quot;</span>));</span><br><span class="line">        subject.addObserver(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;小刚&quot;</span>));</span><br><span class="line">        subject.notifyMessage(<span class="string">&quot;明天放假&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">被观察者: 公众号 发送通知：明天放假</span><br><span class="line">小刚关注了 公众号 ,收到通知：明天放假</span><br><span class="line">小红关注了 公众号 ,收到通知：明天放假</span><br><span class="line">小明关注了 公众号 ,收到通知：明天放假</span><br></pre></td></tr></table></figure><h1 id="Google的Guava实现"><a href="#Google的Guava实现" class="headerlink" title="Google的Guava实现"></a>Google的Guava实现</h1><div class="table-container"><table><thead><tr><th>EventBus术语</th><th>解释</th><th>备注</th></tr></thead><tbody><tr><td>事件（消息）</td><td>可以向事件总线（EventBus）发布的对象</td><td>通常是一个类，不同的消息事件用不同的类来代替，消息内容就是类里面的属性</td></tr><tr><td>订阅</td><td>向事件总线注册监听者，以接受事件的行为</td><td>EventBus.register(Object)，参数就是监听者</td></tr><tr><td>监听者</td><td>提供一个处理方法，希望接受和处理事件的对象</td><td>通常也是一个类，里面有消息的处理方法</td></tr><tr><td>处理方法</td><td>监听者提供的公共方法，事件总线使用该方法向监听者发送事件；该方法应使用 Subscribe 注解</td><td>监听者里面添加一个 Subscribe 注解的方法，就可以认为是消息的处理方法</td></tr><tr><td>发布消息</td><td>通过事件总线向所有匹配的监听者提供事件</td><td>EventBus.post(Object)</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Object arg)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; 收到通知：&quot;</span> + arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">EventBus</span> <span class="variable">eventBus</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EventBus</span>();</span><br><span class="line">        eventBus.register(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;小明&quot;</span>));</span><br><span class="line">        eventBus.register(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;小红&quot;</span>));</span><br><span class="line">        eventBus.register(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;小刚&quot;</span>));</span><br><span class="line">        eventBus.post(<span class="string">&quot;明天放假&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">小明 收到通知：明天放假</span><br><span class="line">小红 收到通知：明天放假</span><br><span class="line">小刚 收到通知：明天放假</span><br></pre></td></tr></table></figure><blockquote><p>关于<code>com.google.common.eventbus.Subscribe</code>被标记为<code>@Beta</code>不稳定的事情是指它处于实验性阶段，可能在将来的版本中进行更改或删除。<code>@Beta</code>注解用于标记Google Guava库中的实验性功能。这意味着开发者可以使用这些功能，但需要注意它们的稳定性和将来的变化。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>适用场景：</p><ul><li>当一个抽象模型包含两个方面内容，其中一个方面依赖于另一个方面。</li><li>其他一个或多个对象的变化依赖于另一个对象的变化。</li><li>实现类似广播机制的功能，无需知道具体收听者，只需分发广播，系统中感兴趣的对象会自动接收该广播。</li></ul><p>多层级嵌套使用，形成一种链式触发机制，使得事件具备跨域（跨越两种观察者类型）通知。</p><p>优点：</p><ul><li>观察者和被观察者是松耦合（抽象耦合）的，符合依赖倒置原则。</li><li>分离了表示层（观察者）和数据逻辑层（被观察者），并且建立了一套触发机制，使得数据的变化可以相应到多个表示层上。</li><li>实现了一对多的通讯机制，支持事件注册机制，支持兴趣分发机制，当被观察者触发事件时，只有感兴趣的观察者可以接收到通知。</li></ul><p>缺点：</p><ul><li>如果观察者数量过多，则事件通知会耗时较长。</li><li>事件通知呈线性关系，如果其中一个观察者处理事件卡壳，会影响后续的观察者接收该事件。</li><li>如果观察者和被观察者之间存在循环依赖，则可能造成两者之间的循环调用，导致系统崩溃。</li></ul><p>​<br>​<br>​<br>​<br>​        </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;观察者模式&quot;&gt;&lt;a href=&quot;#观察者模式&quot; class=&quot;headerlink&quot; title=&quot;观察者模式&quot;&gt;&lt;/a&gt;观察者模式&lt;/h1&gt;&lt;p&gt;观察者模式（Observer Pattern）是一种行为型设计模式，它定义了对象之间的一对多依赖关系，使得当一个对象</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>适配器模式</title>
    <link href="http://example.com/2023/06/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/06/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-06-25T12:44:50.000Z</published>
    <updated>2023-06-25T13:06:32.385Z</updated>
    
    <content type="html"><![CDATA[<p>标题：深入解析Java适配器模式：源码实现及在Spring中的应用</p><p>导语：适配器模式是一种常见的设计模式，可以帮助我们封装不兼容的接口，让它们能够一起工作。本文将详细介绍Java适配器模式的实现原理，以及在Spring框架中的应用场景，为读者提供全方位的了解和应用指导。</p><h1 id="适配器模式简介"><a href="#适配器模式简介" class="headerlink" title="适配器模式简介"></a>适配器模式简介</h1><p>适配器模式旨在解决两个已有接口之间的不兼容性问题。它通过将一个类的接口转换成客户端所期望的另一个接口，使得原本由于接口不匹配而无法一起工作的类能够协同工作。</p><p>在Java中，适配器模式通常由两种形式来实现：类适配器和对象适配器。类适配器使用多重继承的方式，通过实现目标接口并继承源类来完成适配；对象适配器则使用对象组合，通过持有源类的实例来实现适配。前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p><p>适配器模式（Adapter）包含以下主要角色：</p><ul><li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li><li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li><li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li></ul><h1 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h1><ol><li>定义目标接口：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>实现源类：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">specificRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行被适配类的特殊请求&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>实现适配器类：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">extends</span> <span class="title class_">Adaptee</span> <span class="keyword">implements</span> <span class="title class_">Target</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用适配器：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adapter</span>();</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于Java是单继承的原因，如果不断的新增适配者，那么就要无限的新增适配器，于是就有了对象适配器。</p><h1 id="对象适配器示例"><a href="#对象适配器示例" class="headerlink" title="对象适配器示例"></a>对象适配器示例</h1><ol><li><p>定义目标接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现源类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">specificRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行被适配类的特殊请求&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现适配器类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">implements</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Adapter</span><span class="params">(Adaptee adaptee)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用适配器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Adaptee</span> <span class="variable">adaptee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adaptee</span>();</span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adapter</span>(adaptee);</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>可以看到，上面代码中，只实现了目标接口，并没有继承适配者，而是将适配者类实现适配者接口，在适配器中引入适配者接口，当我们需要使用不同的适配者通过适配器进行转换时，就无需再新建适配器类了</p><h1 id="在Spring中的适配器模式应用"><a href="#在Spring中的适配器模式应用" class="headerlink" title="在Spring中的适配器模式应用"></a>在Spring中的适配器模式应用</h1><p>Spring作为一个功能强大的开发框架，广泛应用了适配器模式来对外提供一致的接口。下面将介绍Spring中几个常见的适配器模式应用场景：</p><ol><li><p>Controller适配器<br>Spring MVC框架使用了Controller适配器来处理用户请求。用户请求首先进入DispatcherServlet，DispatcherServlet通过适配器将请求转发给具体的Controller。适配器根据请求的URL等信息选择合适的Controller进行处理，并返回响应结果。</p></li><li><p>MessageListener适配器<br>在Spring中使用消息队列进行消息传递时，通过MessageListener适配器将消息队列的消息转换为具体的业务处理代码。MessageListener适配器负责将不同类型的消息转换为统一的接口形式，从而简化消息处理的开发工作。</p></li><li><p>HandlerAdapter适配器<br>在Spring AOP中，通过HandlerAdapter适配器来处理各类增强器。HandlerAdapter根据增强器的类型和配置，决定适配器如何调用增强器中的方法，并在合适的时间点执行。</p></li></ol><p>通过以上几个例子，我们可以看到在Spring中适配器模式的灵活应用。Spring通过适配器模式将不同组件间的参数、接口、调用方式等进行统一，使得整个框架更加灵活、可扩展、易于维护。</p><h1 id="结语："><a href="#结语：" class="headerlink" title="结语："></a>结语：</h1><p>本文首先介绍了适配器模式的定义和两种形式的实现方式，其次通过一个代码示例详细解释了适配器模式的实际运用。最后，从Spring框架的角度给出了几个适配器模式在实际开发中的应用示例。希望本文对读者理解和应用适配器模式有所帮助。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;标题：深入解析Java适配器模式：源码实现及在Spring中的应用&lt;/p&gt;
&lt;p&gt;导语：适配器模式是一种常见的设计模式，可以帮助我们封装不兼容的接口，让它们能够一起工作。本文将详细介绍Java适配器模式的实现原理，以及在Spring框架中的应用场景，为读者提供全方位的了解和</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
</feed>
