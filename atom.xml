<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YZ</title>
  
  <subtitle>这是一名小学生</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-07-31T03:27:34.802Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>YZ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>单例模式</title>
    <link href="http://example.com/2023/07/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/07/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-07-30T13:25:30.000Z</published>
    <updated>2023-07-31T03:27:34.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式（Singleton Pattern）是一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一的实例。单例模式通常用于限制一个类的实例化次数，节约系统资源，同时也方便在整个应用程序中共享数据。</p><h1 id="单例模式结构"><a href="#单例模式结构" class="headerlink" title="单例模式结构"></a>单例模式结构</h1><p>单例模式由以下几个元素组成</p><ul><li>私有构造函数：确保其他类不能通过构造函数实例化该类的对象。</li><li>私有静态成员变量：用于存储唯一实例的引用。</li><li>公有静态方法：用于获取唯一实例的位置</li></ul><h1 id="单例模式的实现方式"><a href="#单例模式的实现方式" class="headerlink" title="单例模式的实现方式"></a>单例模式的实现方式</h1><p>在Java中，单例模式有很多实现方式</p><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>饿汉式是指在类加载时就创建实例，因此是线程安全的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EagerSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">EagerSingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EagerSingleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">EagerSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里可以做一些初始化操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EagerSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>懒汉式是指在第一次调用获取实例的方法时才创建实例。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里可以做一些初始化操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懒汉式的一种简单实现方式，并且通过<code>synchronized</code>关键字实现了线程安全。该实现方式在多线程环境下可以保证只有一个实例被创建，并且多个线程获取到的都是同一个实例。</p><p>关键的地方是<code>synchronized</code>修饰的<code>getInstance()</code>方法。通过<code>synchronized</code>关键字将整个实例化过程进行同步，确保在多线程环境下只有一个线程能够进入实例化代码块，从而避免了多个线程同时创建实例的情况。虽然<code>synchronized</code>关键字确保了线程安全，但它也可能带来性能上的一些损耗，因为每次调用<code>getInstance()</code>方法时都会进行同步。在实际应用中，如果对性能有较高要求，可以考虑其他实现方式，如双重检查锁或静态内部类方式，它们在某些情况下可以更好地优化性能。</p><h2 id="双重检查锁"><a href="#双重检查锁" class="headerlink" title="双重检查锁"></a>双重检查锁</h2><p>双重检查锁是为了在多线程环境下保证单例的线程安全，避免不必要的同步开销。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleCheckedSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DoubleCheckedSingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">DoubleCheckedSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里可以做一些初始化操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckedSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckedSingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">DoubleCheckedSingleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的基本思想是在获取实例的方法中进行两次检查，第一次检查在没有创建实例的情况下进行同步，保证只有一个线程进入实例化代码块，创建实例。之后，其他线程再进入获取实例的方法时，由于已经有了实例，就不再进行同步，直接返回已经创建的实例。</p><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>静态内部类方式利用了类加载机制实现了线程安全的单例模式，同时实现了延迟加载。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClassSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">StaticInnerClassSingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticInnerClassSingleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">StaticInnerClassSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里可以做一些初始化操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StaticInnerClassSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类方式能够实现懒加载的原因是静态内部类在类加载过程中不会立即被加载，只有在第一次使用它的时候才会进行初始化，从而实现了懒加载。</p><p>在该实现中，<code>StaticInnerClassSingleton</code>的单例实例是由<code>SingletonHolder</code>类持有的，而<code>SingletonHolder</code>是一个静态内部类。当首次调用<code>getInstance()</code>方法时，<code>SingletonHolder</code>才会被加载，进而实例化<code>StaticInnerClassSingleton</code>的单例对象。</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举单例是一种更加简洁和安全的单例实现方式。在Java中，枚举是线程安全的，并且保证只有一个实例存在。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public enum EnumSingleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    // 其他方法</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        // 在这里实现单例类的其他功能</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用枚举单例时，只需要通过<code>EnumSingleton.INSTANCE</code>来获取唯一实例。<strong>枚举单例在序列化和反序列化时也能保证单例的唯一性。</strong></p><h2 id="容器缓存单例"><a href="#容器缓存单例" class="headerlink" title="容器缓存单例"></a>容器缓存单例</h2><p>容器缓存单例是一种通过容器来管理和缓存单例对象的方式。在Spring框架中，单例模式的默认实现就是通过容器来管理和缓存单例对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonContainer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; singletonMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getInstance</span><span class="params">(Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> clazz.getName();</span><br><span class="line">        <span class="type">T</span> <span class="variable">instance</span> <span class="operator">=</span> (T) singletonMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonContainer.class) &#123;</span><br><span class="line">                instance = (T) singletonMap.get(key);</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        instance = clazz.newInstance();</span><br><span class="line">                        singletonMap.put(key, instance);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用容器缓存单例时，只需将要获取的类的Class对象传入<code>getInstance</code>方法，容器会自动管理和缓存单例对象。</p><h1 id="破坏单例模式的几种方式和解决办法"><a href="#破坏单例模式的几种方式和解决办法" class="headerlink" title="破坏单例模式的几种方式和解决办法"></a>破坏单例模式的几种方式和解决办法</h1><p>单例模式的目标是确保一个类只有一个实例，并提供一个全局访问点来获取该实例。然而，有时候可能会出现一些情况导致单例模式被破坏，即出现了多个实例或无法保证全局唯一性。以下是破坏单例模式的几种常见方式以及相应的解决办法：</p><h3 id="1-多线程环境下的竞态条件"><a href="#1-多线程环境下的竞态条件" class="headerlink" title="1. 多线程环境下的竞态条件"></a>1. 多线程环境下的竞态条件</h3><p>在多线程环境下，如果没有合理的控制实例的创建过程，可能会导致多个线程同时进入实例化代码块，从而创建多个实例。这违背了单例模式的初衷。</p><p><strong>解决办法：</strong></p><ul><li>双重检查锁：通过双重检查锁机制来确保在多线程环境下只有一个线程能够进入实例化代码块，从而避免创建多个实例。</li><li>静态内部类：静态内部类方式能够实现懒加载的同时，也能保证在多线程环境下只有一个实例被创建。</li></ul><h3 id="2-序列化和反序列化"><a href="#2-序列化和反序列化" class="headerlink" title="2. 序列化和反序列化"></a>2. 序列化和反序列化</h3><p>当一个单例类实现了序列化接口时，在反序列化时可能会创建新的实例。</p><p><strong>解决办法：</strong></p><ul><li>实现<code>readResolve()</code>方法：在单例类中添加<code>readResolve()</code>方法，确保在反序列化时返回已有的实例，而不是创建新的实例。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException &#123;</span><br><span class="line">    <span class="keyword">return</span> getInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-反射机制"><a href="#3-反射机制" class="headerlink" title="3. 反射机制"></a>3. 反射机制</h3><p>通过反射机制，可以绕过类的构造方法直接创建新的实例。</p><p><strong>解决办法：</strong></p><ul><li>在构造方法中添加防御逻辑：可以在构造方法中添加逻辑，当检测到已有实例时抛出异常，防止通过反射创建新的实例。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;请使用getInstance()方法获取实例&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-序列化破坏枚举单例"><a href="#4-序列化破坏枚举单例" class="headerlink" title="4. 序列化破坏枚举单例"></a>4. 序列化破坏枚举单例</h3><p>虽然枚举方式是线程安全且不会被反射破坏的单例实现方式，但在序列化和反序列化时，枚举单例也会被破坏。</p><p><strong>解决办法：</strong></p><ul><li>不支持序列化：由于枚举实例在枚举类被加载时就被实例化，不需要担心懒加载问题，因此可以简单地不支持序列化。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumSingleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里实现单例类的其他功能</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不需要实现readResolve()方法，因为枚举本身就不支持序列化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，破坏单例模式可能出现在多线程环境、序列化和反射等情况下。通过合理使用双重检查锁、静态内部类、readResolve()方法以及构造方法防御逻辑等方式，可以避免这些问题，保证单例模式的正确性和稳定性。对于枚举单例，由于其天然的线程安全性和反射安全性，只需要注意不支持序列化即可。</p><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><div class="table-container"><table><thead><tr><th>单例模式</th><th>描述</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>饿汉式</td><td>实例在类加载时创建</td><td>简单，线程安全</td><td>没有懒加载，可能会浪费资源</td></tr><tr><td>懒汉式</td><td>实例在第一次使用时创建</td><td>实现了懒加载</td><td>线程不安全，需要额外的同步开销以实现线程安全</td></tr><tr><td>双重检查锁</td><td>实例在第一次使用时创建，使用两次检查同步以实现线程安全</td><td>实现了懒加载，线程安全</td><td>实现复杂，可能由于JVM内部优化导致问题</td></tr><tr><td>静态内部类</td><td>通过在内部类中创建实例，实现懒加载</td><td>简单，线程安全，实现了懒加载</td><td>不能防止反射攻击</td></tr><tr><td>枚举</td><td>利用枚举的特性，保证实例的唯一性</td><td>简单，线程安全，自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化，可能是实现单例最佳的方法</td><td>没有懒加载</td></tr><tr><td>容器缓存单例</td><td>用容器存储实例，实现单例</td><td>简单，灵活，控制力强</td><td>需要自己管理生命周期，容器如果被误清空，会有问题，线程安全问题需要自己解决</td></tr></tbody></table></div><h1 id="在Spring源码中的应用"><a href="#在Spring源码中的应用" class="headerlink" title="在Spring源码中的应用"></a>在Spring源码中的应用</h1><p>Spring 框架广泛地使用了设计模式，其中包括单例模式。Spring 默认情况下，会将所有的 Bean 定义为单例模式。也就是说，Spring 容器中每种 Bean 类型只存在一个实例。这对于需要在多个组件中共享数据或者服务的 Bean 非常有用。</p><p>Spring 框架中的单例模式主要是通过 <code>SingletonBeanRegistry</code> 接口以及其实现类 <code>DefaultSingletonBeanRegistry</code> 来实现的。<code>SingletonBeanRegistry</code> 接口定义了注册、获取和检查单例对象的方法，如 <code>registerSingleton</code>，<code>getSingleton</code> 和 <code>containsSingleton</code>。</p><p>具体来说，当 Spring 创建一个 Bean 时，它首先会检查这个 Bean 是否已经存在。如果这个 Bean 已经存在，那么它会直接返回这个 Bean 的实例；否则，它会创建一个新的 Bean。创建完新的 Bean 后，Spring 会将其注册到一个全局的注册表中，以便以后可以直接获取。</p><p>此外，Spring 还允许用户通过在 Bean 的定义中设置 <code>scope</code> 属性来改变 Bean 的作用域。如果你想要 Spring 创建多个 Bean 实例，你可以将 Bean 的 <code>scope</code> 属性设置为 <code>prototype</code>。</p><p>请注意，Spring 中的单例并不是传统意义上的单例。传统的单例是在整个应用程序范围内只有一个实例，而 Spring 的单例是在 Spring 容器范围内只有一个实例。如果你有多个 Spring 容器，那么每个容器中都会有一个单例的实例。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>单例模式是一种创建型设计模式，其目的是确保一个类只有一个实例，并提供一个全局访问点来获取该实例。单例模式可以避免多个实例的创建，节约系统资源，并保证全局唯一性和数据共享。</p><p>总结单例模式的特点和优点如下：</p><p><strong>特点：</strong></p><ol><li>类只有一个实例：单例模式确保一个类只有一个实例存在。</li><li>全局访问点：通过提供一个全局访问点（静态方法）来获取单例实例，方便其他类访问。</li></ol><p><strong>优点：</strong></p><ol><li>节约资源：单例模式避免了多个实例的创建，节约了系统资源。</li><li>全局唯一性：确保只有一个实例存在，避免了数据冗余和数据不一致问题。</li><li>数据共享：多个模块可以共享同一个单例实例，方便数据共享和通信。</li><li>懒加载：可以实现懒加载，在需要时才创建实例，提高了性能和资源利用率。</li><li>线程安全：适当实现单例模式可以保证在多线程环境下的线程安全性。</li></ol><p>单例模式的实现方式有多种，包括饿汉式、懒汉式、双重检查锁、静态内部类、枚举、容器缓存单例等。每种实现方式都有其优缺点和适用场景。在选择实现方式时，需要根据具体的业务需求和性能考虑，以确保单例模式的正确性和稳定性。</p><p>然而，滥用单例模式可能会导致全局状态的过多，增加代码的复杂性和维护难度。因此，在使用单例模式时应谨慎权衡利弊，只在真正需要全局唯一实例和共享数据的场景下使用，以确保代码的可维护性和扩展性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h1&gt;&lt;p&gt;单例模式（Singleton Pattern）是一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点来访问这个</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>解释器模式</title>
    <link href="http://example.com/2023/07/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/07/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-07-30T12:20:26.000Z</published>
    <updated>2023-07-30T13:09:46.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h1><p>解释器模式（Interpreter Pattern）是一种行为型设计模式，它用于定义语言的文法规则，并解释语言中的表达式。解释器模式可以用于实现自定义语言或处理特定类型的表达式。它将每个符号和语法规则映射到一个解释器，通过递归地解释表达式，最终得到结果</p><p>特征：为了解释一种语言，而为语言创建的解释器。</p><h1 id="解释器模式的结构"><a href="#解释器模式的结构" class="headerlink" title="解释器模式的结构"></a>解释器模式的结构</h1><ul><li>抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。终结符表达式（Terminal Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。</li><li>非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。</li><li>环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。</li><li>客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>下面以简单的加减乘除为例子实现解释器模式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象角色 定义解释器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">interpret</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberTerminal</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非终结表达式（抽象类）</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">NonTerminal</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Expression left;</span><br><span class="line">    <span class="keyword">protected</span> Expression right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非终结表达式（加法）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PlusNonTerminal</span> <span class="keyword">extends</span> <span class="title class_">NonTerminal</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PlusNonTerminal</span><span class="params">(Expression left, Expression right)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left.interpret() + right.interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非终结表达式（减法）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinusNonTerminal</span> <span class="keyword">extends</span> <span class="title class_">NonTerminal</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinusNonTerminal</span><span class="params">(Expression left, Expression right)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left.interpret() - right.interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非终结表达式（乘法）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MclNonTerminal</span> <span class="keyword">extends</span> <span class="title class_">NonTerminal</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MclNonTerminal</span><span class="params">(Expression left, Expression right)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left.interpret() * right.interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非终结表达式（除法）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DivisionNonTerminal</span> <span class="keyword">extends</span> <span class="title class_">NonTerminal</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DivisionNonTerminal</span><span class="params">(Expression left, Expression right)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left.interpret() / right.interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算器类（实现运算逻辑）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Expression left;</span><br><span class="line">    <span class="keyword">private</span> Expression right;</span><br><span class="line">    <span class="keyword">private</span> Integer result;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cal</span><span class="params">(String expression)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.parse(expression);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Integer <span class="title function_">parse</span><span class="params">(String expression)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取表达式元素</span></span><br><span class="line">        String [] elements = expression.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; elements.length; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> elements[i];</span><br><span class="line">            <span class="comment">// 判断是否是运算符号</span></span><br><span class="line">            <span class="keyword">if</span> (OperatorUtils.isOperator(element)) &#123;</span><br><span class="line">                <span class="comment">// 运算符号的右边就是右终结符</span></span><br><span class="line">                right = <span class="keyword">new</span> <span class="title class_">NumberTerminal</span>(Integer.valueOf(elements[++i]));</span><br><span class="line">                <span class="comment">//计算结果</span></span><br><span class="line">                result = OperatorUtils.getNonTerminal(left, right, element).interpret();</span><br><span class="line">                <span class="comment">// 计算结果重新成为左终结符</span></span><br><span class="line">                left = <span class="keyword">new</span> <span class="title class_">NumberTerminal</span>(result);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = <span class="keyword">new</span> <span class="title class_">NumberTerminal</span>(Integer.valueOf(element));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">cal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 操作工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorUtils</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是不是非终结符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isOperator</span><span class="params">(String symbol)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> symbol.equals(<span class="string">&quot;+&quot;</span>) || symbol.equals(<span class="string">&quot;-&quot;</span>) || symbol.equals(<span class="string">&quot;*&quot;</span>)|| symbol.equals(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 简单工厂</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> NonTerminal <span class="title function_">getNonTerminal</span><span class="params">(Expression left, Expression right, String symbol)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (symbol.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PlusNonTerminal</span>(left, right);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (symbol.equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MinusNonTerminal</span>(left, right);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (symbol.equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MclNonTerminal</span>(left, right);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (symbol.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DivisionNonTerminal</span>(left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 测试</span></span><br><span class="line">    <span class="comment">// PS：此处进行的逻辑仅仅实现从左到右运算，并没有先乘除后加减的逻辑</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Cal</span>(<span class="string">&quot;10 + 20 - 40 * 60&quot;</span>).cal()); <span class="comment">// -600</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Cal</span>(<span class="string">&quot;20 + 50 - 60 * 2&quot;</span>).cal()); <span class="comment">// 20</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="Spring中的解释器模式"><a href="#Spring中的解释器模式" class="headerlink" title="Spring中的解释器模式"></a>Spring中的解释器模式</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExpressionParser</span> <span class="variable">expressionParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class="line">        org.springframework.expression.<span class="type">Expression</span> <span class="variable">expression</span> <span class="operator">=</span> expressionParser.parseExpression(<span class="string">&quot;10 + 20 + 30 * 4&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> expression.getValue(Integer.class);</span><br><span class="line">        System.out.println(value); <span class="comment">// 150</span></span><br><span class="line">        expression = expressionParser.parseExpression(<span class="string">&quot;(10+20+30)*4&quot;</span>);</span><br><span class="line">        value = expression.getValue(Integer.class);</span><br><span class="line">        System.out.println(value); <span class="comment">// 240</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到Spring中解释器写的是比较完善的，不仅有先乘除后加减和先括号进行运算的日常计算规则，而且对于空格也并没有要求，仅需要写出完整的表达式即可运算出来。</p><p>在Spring源码中，解释器模式被广泛应用于Spring Expression Language（SpEL）的实现。SpEL是Spring框架的一部分，它允许在运行时对Spring组件进行动态计算和处理。SpEL支持复杂的表达式和函数调用，这些表达式可以在Spring的XML配置文件或注解中使用。</p><p>在Spring框架中，解释器模式主要应用于Spring Expression Language（SpEL）的实现。SpEL是一种强大的表达式语言，它可以在运行时对Spring组件进行动态计算和处理。SpEL支持复杂的表达式和函数调用，这些表达式可以在Spring的XML配置文件、注解中，甚至在运行时动态生成的代码中使用。</p><p>在SpEL中，解释器模式用于解析表达式并将其转换成一棵表达式树，然后对表达式树进行求值。以下是SpEL在Spring中的主要应用场景：</p><ol><li><p><strong>注解表达式</strong>：SpEL可以在Spring的注解中使用，例如<code>@Value</code>注解和<code>@Conditional</code>注解。通过SpEL表达式，可以在注解中动态地引用Spring bean的属性值、环境变量、系统属性等。</p></li><li><p><strong>XML配置</strong>：SpEL可以在Spring的XML配置文件中使用，例如在<code>&lt;property&gt;</code>元素的<code>value</code>属性中使用SpEL表达式动态设置属性值。</p></li><li><p><strong>动态条件判断</strong>：SpEL可以在<code>@Conditional</code>注解中使用，用于根据条件动态决定是否创建某个bean。</p></li><li><p><strong>动态生成代码</strong>：SpEL可以在运行时动态生成代码，例如通过<code>SpelExpressionParser</code>将SpEL表达式解析成可执行的代码。</p></li><li><p><strong>动态查询</strong>：SpEL可以在动态查询场景中使用，例如在Spring Data JPA的查询方法上使用SpEL表达式指定查询条件。</p></li><li><p><strong>动态属性访问</strong>：SpEL可以用于动态访问Spring bean的属性，例如在运行时通过SpEL表达式获取或设置bean的属性值。</p></li><li><p><strong>Spring Security</strong>：Spring Security框架中也广泛使用了SpEL来定义安全访问规则，用于动态决定用户是否有权访问某个资源。</p></li></ol><p>总的来说，SpEL作为Spring框架的一部分，为Spring提供了强大的动态计算和处理能力，使得Spring组件的配置和行为能够在运行时动态调整，非常灵活和便捷。通过解释器模式的应用，SpEL实现了将表达式解析为可执行的代码，并在运行时对表达式进行求值，提供了丰富的动态特性。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>解释器模式用于定义语言的文法规则，并解释语言中的表达式。通过解释器模式，我们可以实现自定义语言的解析和求值。在Spring源码中，解释器模式被广泛应用于SpEL的实现，实现了Spring组件的动态计算和处理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;解释器模式&quot;&gt;&lt;a href=&quot;#解释器模式&quot; class=&quot;headerlink&quot; title=&quot;解释器模式&quot;&gt;&lt;/a&gt;解释器模式&lt;/h1&gt;&lt;p&gt;解释器模式（Interpreter Pattern）是一种行为型设计模式，它用于定义语言的文法规则，并解释语言中的表</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>备忘录模式</title>
    <link href="http://example.com/2023/07/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/07/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-07-30T12:20:15.000Z</published>
    <updated>2023-07-30T12:54:33.784Z</updated>
    
    <content type="html"><![CDATA[<h1 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h1><p>备忘录模式（Memento Pattern）是一种行为型设计模式，它用于捕获一个对象的内部状态，并在之后恢复该对象到之前的状态。备忘录模式允许在不破坏对象封装的前提下，保存和恢复对象的状态，从而实现撤销、恢复等操作。</p><h1 id="备忘录模式结构"><a href="#备忘录模式结构" class="headerlink" title="备忘录模式结构"></a>备忘录模式结构</h1><p>备忘录模式由以下几个要素组成：</p><ul><li><strong>Originator（发起人）</strong>：负责创建备忘录对象，记录和恢复自身状态。</li><li><strong>Memento（备忘录）</strong>：存储Originator的内部状态，提供给Caretaker进行备份和恢复。</li><li><strong>Caretaker（管理者）</strong>：负责备份和恢复Originator的状态，但不能访问Memento的具体内容。</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>假设我们有一个文本编辑器，用户可以输入文本并进行编辑。我们将使用备忘录模式来实现撤销功能，允许用户撤销之前的编辑操作。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. Originator（发起人）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextEditor</span> &#123;</span><br><span class="line">    private <span class="title class_">StringBuilder</span> content;</span><br><span class="line"></span><br><span class="line">    public <span class="title class_">TextEditor</span>() &#123;</span><br><span class="line">        content = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> <span class="title function_">type</span>(<span class="params"><span class="built_in">String</span> text</span>) &#123;</span><br><span class="line">        content.<span class="title function_">append</span>(text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="title class_">String</span> <span class="title function_">getContent</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> content.<span class="title function_">toString</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="title class_">Memento</span> <span class="title function_">save</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Memento</span>(content.<span class="title function_">toString</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> <span class="title function_">restore</span>(<span class="params">Memento memento</span>) &#123;</span><br><span class="line">        content = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(memento.<span class="title function_">getState</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Memento（备忘录）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memento</span> &#123;</span><br><span class="line">    private final <span class="title class_">String</span> state;</span><br><span class="line"></span><br><span class="line">    public <span class="title class_">Memento</span>(<span class="title class_">String</span> state) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="title class_">String</span> <span class="title function_">getState</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Caretaker（管理者）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">History</span> &#123;</span><br><span class="line">    private <span class="title class_">Stack</span>&lt;<span class="title class_">Memento</span>&gt; mementos;</span><br><span class="line"></span><br><span class="line">    public <span class="title class_">History</span>() &#123;</span><br><span class="line">        mementos = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> <span class="title function_">push</span>(<span class="params">Memento memento</span>) &#123;</span><br><span class="line">        mementos.<span class="title function_">push</span>(memento);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="title class_">Memento</span> <span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mementos.<span class="title function_">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MementoPatternExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TextEditor</span> <span class="variable">textEditor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextEditor</span>();</span><br><span class="line">        <span class="type">History</span> <span class="variable">history</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">History</span>();</span><br><span class="line"></span><br><span class="line">        textEditor.type(<span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line">        history.push(textEditor.save()); <span class="comment">// 保存状态</span></span><br><span class="line"></span><br><span class="line">        textEditor.type(<span class="string">&quot;World!&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前内容：&quot;</span> + textEditor.getContent());</span><br><span class="line"></span><br><span class="line">        textEditor.restore(history.pop()); <span class="comment">// 恢复之前状态</span></span><br><span class="line">        System.out.println(<span class="string">&quot;恢复后内容：&quot;</span> + textEditor.getContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">当前内容：Hello, World!</span><br><span class="line">恢复后内容：Hello, </span><br></pre></td></tr></table></figure><h1 id="在Spring中的应用"><a href="#在Spring中的应用" class="headerlink" title="在Spring中的应用"></a>在Spring中的应用</h1><p>在Spring源码中，备忘录模式被广泛应用于Spring事务管理中的回滚机制。在Spring的事务管理中，事务的回滚是通过事务的保存点（Savepoint）来实现的。当某个方法发生异常时，Spring会将当前事务状态保存为一个保存点，然后进行回滚到该保存点，从而实现事务的回滚操作。</p><p>在Spring的源码中，<code>org.springframework.transaction.support.DefaultTransactionStatus</code> 类负责保存和恢复事务的状态，其内部就包含了备忘录模式的实现。通过备忘录模式，Spring能够在不破坏对象封装的前提下，保存和恢复事务的状态，实现了强大的事务管理功能。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>备忘录模式允许在不破坏对象封装的前提下，保存和恢复对象的状态。在Java中，备忘录模式常常用于实现撤销、恢复等操作，帮助用户处理对象状态的变化。在Spring源码中，备忘录模式被广泛用于Spring事务管理的回滚机制，提供了强大的事务管理功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;备忘录模式&quot;&gt;&lt;a href=&quot;#备忘录模式&quot; class=&quot;headerlink&quot; title=&quot;备忘录模式&quot;&gt;&lt;/a&gt;备忘录模式&lt;/h1&gt;&lt;p&gt;备忘录模式（Memento Pattern）是一种行为型设计模式，它用于捕获一个对象的内部状态，并在之后恢复该对象到</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>访问者模式</title>
    <link href="http://example.com/2023/07/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/07/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-07-30T09:13:46.000Z</published>
    <updated>2023-07-30T09:18:27.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h1><p>访问者模式（Visitor Pattern）是一种行为型设计模式，它用于在不修改已有类的情况下，为其添加新的操作。访问者模式通过定义一个访问者类，该类包含一系列访问方法，每个访问方法对应一个元素类的操作，从而使得元素类的操作可以在访问者类中得以实现。访问者模式通过双重分派来实现在运行时动态确定要调用的方法，从而实现了多态性。</p><h1 id="访问者模式结构"><a href="#访问者模式结构" class="headerlink" title="访问者模式结构"></a>访问者模式结构</h1><p>访问者模式由以下几个要素组成：</p><ul><li><strong>Visitor（抽象访问者）</strong>：定义一个访问接口，包含多个访问方法，每个方法对应一个元素类的操作。</li><li><strong>ConcreteVisitor（具体访问者）</strong>：实现抽象访问者接口中定义的访问方法，即为每个元素类提供具体的操作逻辑。</li><li><strong>Element（抽象元素类）</strong>：定义一个接受访问者对象的接口，即<code>accept</code>方法，该方法传入访问者对象作为参数。</li><li><strong>ConcreteElement（具体元素类）</strong>：实现抽象元素类中的<code>accept</code>方法，将自身作为参数传给访问者的访问方法。</li><li><strong>ObjectStructure（对象结构）</strong>：维护元素类的集合，提供向访问者对象遍历元素的方法。</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>下面，我们将通过一个简单的零件访问示例来演示访问者模式的实现。</p><p>假设我们有一组零件，包括CPU、内存条和显卡等，我们想为这些零件添加一个访问者，用于检查它们的状态。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. Visitor（抽象访问者）</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PartVisitor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visitCPU</span><span class="params">(CPU cpu)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visitMemory</span><span class="params">(Memory memory)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visitGPU</span><span class="params">(GPU gpu)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Element（抽象元素类）</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Part</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(PartVisitor visitor)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. ConcreteElement（具体元素类）- CPU</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span> <span class="keyword">implements</span> <span class="title class_">Part</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(PartVisitor visitor)</span> &#123;</span><br><span class="line">        visitor.visitCPU(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. ConcreteElement（具体元素类）- 内存条</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span> <span class="keyword">implements</span> <span class="title class_">Part</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(PartVisitor visitor)</span> &#123;</span><br><span class="line">        visitor.visitMemory(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. ConcreteElement（具体元素类）- 显卡</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GPU</span> <span class="keyword">implements</span> <span class="title class_">Part</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(PartVisitor visitor)</span> &#123;</span><br><span class="line">        visitor.visitGPU(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. ConcreteVisitor（具体访问者）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PartStatusVisitor</span> <span class="keyword">implements</span> <span class="title class_">PartVisitor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitCPU</span><span class="params">(CPU cpu)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;检查CPU状态...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitMemory</span><span class="params">(Memory memory)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;检查内存条状态...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitGPU</span><span class="params">(GPU gpu)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;检查显卡状态...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. ObjectStructure（对象结构）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Part&gt; parts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Computer</span><span class="params">()</span> &#123;</span><br><span class="line">        parts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        parts.add(<span class="keyword">new</span> <span class="title class_">CPU</span>());</span><br><span class="line">        parts.add(<span class="keyword">new</span> <span class="title class_">Memory</span>());</span><br><span class="line">        parts.add(<span class="keyword">new</span> <span class="title class_">GPU</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(PartVisitor visitor)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Part part : parts) &#123;</span><br><span class="line">            part.accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VisitorPatternExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="type">PartVisitor</span> <span class="variable">visitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PartStatusVisitor</span>();</span><br><span class="line"></span><br><span class="line">        computer.accept(visitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">检查CPU状态...</span><br><span class="line">检查内存条状态...</span><br><span class="line">检查显卡状态...</span><br></pre></td></tr></table></figure><h1 id="在Spring中应用"><a href="#在Spring中应用" class="headerlink" title="在Spring中应用"></a>在Spring中应用</h1><p>在Spring源码中，访问者模式被广泛应用于Spring AOP（面向切面编程）的实现。在AOP中，Spring使用访问者模式来实现横切关注点（Cross-Cutting Concerns）的处理。具体而言，Spring中的AOP功能通过使用访问者模式来访问并织入横切关注点到目标对象的方法中。</p><p>在Spring的AOP实现中，核心的访问者类是<code>org.springframework.aop.framework.ReflectiveMethodInvocation</code>，它负责在目标方法执行前后调用切面逻辑（即具体的访问者）。Spring通过访问者模式，实现了切面逻辑与目标方法的解耦，使得AOP功能能够灵活地应用于各种业务场景。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过访问者模式，我们可以在不修改元素类的情况下，为其添加新的操作。访问者模式通过双重分派实现多态性，提高了系统的可扩展性和灵活性。在Spring源码中，访问者模式被广泛应用于Spring AOP的实现，帮助开发者实现横切关注点的处理和业务逻辑的解耦。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;访问者模式&quot;&gt;&lt;a href=&quot;#访问者模式&quot; class=&quot;headerlink&quot; title=&quot;访问者模式&quot;&gt;&lt;/a&gt;访问者模式&lt;/h1&gt;&lt;p&gt;访问者模式（Visitor Pattern）是一种行为型设计模式，它用于在不修改已有类的情况下，为其添加新的操作。访</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>中介者模式</title>
    <link href="http://example.com/2023/07/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/07/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-07-30T08:16:58.000Z</published>
    <updated>2023-07-30T08:44:20.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><p>中介者模式（Mediator Pattern）是一种行为型设计模式，它用于降低多个对象之间的耦合性，通过引入一个中介者对象，使得各个对象不需要直接相互交互，而是通过中介者来进行通信。中介者模式可以减少对象之间的依赖，从而提高系统的可维护性和灵活性。</p><h1 id="中介者模式结构"><a href="#中介者模式结构" class="headerlink" title="中介者模式结构"></a>中介者模式结构</h1><p>中介者模式由以下几个要素组成：</p><ul><li><strong>Mediator（抽象中介者）</strong>：定义一个接口或抽象类，用于定义各个同事对象之间交互的方法。</li><li><strong>ConcreteMediator（具体中介者）</strong>：实现中介者接口，协调各个具体同事对象的交互关系。</li><li><strong>Colleague（抽象同事类）</strong>：定义一个接口或抽象类，用于各个具体同事类的通信。</li><li><strong>ConcreteColleague（具体同事类）</strong>：实现同事接口，具体的同事对象，需要和其他同事对象进行交互。</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>通过一个租房例子简单实现下逻辑，房主通过中介公司发布自己的房子的信息，而租客则需要通过中介公司获取到房子的信息：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. Mediator（抽象中介者）</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">HouseMediator</span> &#123;</span><br><span class="line">    <span class="built_in">void</span> <span class="title function_">addTenant</span>(<span class="title class_">Tenant</span> tenant);</span><br><span class="line">    <span class="built_in">void</span> <span class="title function_">notifyLandlord</span>(<span class="title class_">String</span> message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Colleague（抽象同事类）</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Tenant</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title class_">HouseMediator</span> mediator;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title class_">String</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">Tenant</span>(<span class="title class_">HouseMediator</span> mediator, <span class="title class_">String</span> name) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">mediator</span> = mediator;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">void</span> <span class="title function_">send</span>(<span class="title class_">String</span> message);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">void</span> <span class="title function_">receive</span>(<span class="title class_">String</span> message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. ConcreteColleague（具体同事类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteTenant</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Tenant</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">ConcreteTenant</span>(<span class="title class_">HouseMediator</span> mediator, <span class="title class_">String</span> name) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(mediator, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">send</span>(<span class="params"><span class="built_in">String</span> message</span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; 发送消息: &quot;</span> + message);</span><br><span class="line">        mediator.<span class="title function_">notifyLandlord</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">receive</span>(<span class="params"><span class="built_in">String</span> message</span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; 收到消息: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. ConcreteMediator（具体中介者）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HouseMediatorImpl</span> <span class="keyword">implements</span> <span class="title class_">HouseMediator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">List</span>&lt;<span class="title class_">Tenant</span>&gt; tenants;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">HouseMediatorImpl</span>() &#123;</span><br><span class="line">        tenants = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">addTenant</span>(<span class="params">Tenant tenant</span>) &#123;</span><br><span class="line">        tenants.<span class="title function_">add</span>(tenant);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">notifyLandlord</span>(<span class="params"><span class="built_in">String</span> message</span>) &#123;</span><br><span class="line">        <span class="comment">// 在这里实现消息广播或特定租房者接收逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="title class_">Tenant</span> tenant : tenants) &#123;</span><br><span class="line">            tenant.<span class="title function_">receive</span>(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MediatorPatternExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HouseMediator</span> <span class="variable">mediator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HouseMediatorImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Tenant</span> <span class="variable">tenant1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteTenant</span>(mediator, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">        <span class="type">Tenant</span> <span class="variable">tenant2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteTenant</span>(mediator, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        <span class="type">Tenant</span> <span class="variable">tenant3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteTenant</span>(mediator, <span class="string">&quot;Charlie&quot;</span>);</span><br><span class="line"></span><br><span class="line">        mediator.addTenant(tenant1);</span><br><span class="line">        mediator.addTenant(tenant2);</span><br><span class="line">        mediator.addTenant(tenant3);</span><br><span class="line"></span><br><span class="line">        tenant1.send(<span class="string">&quot;我想租一个两室一厅的房子。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Alice 发送消息: 我想租一个两室一厅的房子。</span><br><span class="line">Bob 收到消息: 我想租一个两室一厅的房子。</span><br><span class="line">Charlie 收到消息: 我想租一个两室一厅的房子。</span><br></pre></td></tr></table></figure><p>上述示例中，我们使用中介者模式实现了一个租房中介的场景。通过中介者，租房者可以发送消息给房东（在此例中，我们简化为所有租房者收到消息）。这样，租房者和房东之间的交互被解耦，使得系统的可维护性和灵活性得到提高。在真实的应用中，我们可以根据需要在具体中介者中实现更复杂的交互逻辑。</p><h1 id="在Spring源码中的应用"><a href="#在Spring源码中的应用" class="headerlink" title="在Spring源码中的应用"></a>在Spring源码中的应用</h1><p>在Spring中，中介者模式被广泛应用于事件的处理和发布/订阅机制。<code>pring</code>框架中的<code>ApplicationEvent</code>和<code>ApplicationListener</code>就是典型的中介者模式的应用。<code>ApplicationEvent</code>是事件对象，而<code>ApplicationListener</code>是事件的订阅者。通过中介者模式，Spring将事件的发布者和订阅者解耦，实现了高内聚低耦合的目标。</p><p>在Spring的源码中，<code>ApplicationEvent</code>和<code>ApplicationListener</code>的设计和实现体现了中介者模式的思想，提供了一种优雅的事件通知机制，让不同组件之间能够松耦合地进行交互。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过中介者模式，我们可以有效地减少对象之间的直接交互，将其转移到中介者对象中进行协调，从而降低系统的复杂性和耦合性。在Spring源码中，中介者模式被广泛用于实现事件的处理和发布/订阅机制，帮助开发者构建高内聚低耦合的应用程序。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;中介者模式&quot;&gt;&lt;a href=&quot;#中介者模式&quot; class=&quot;headerlink&quot; title=&quot;中介者模式&quot;&gt;&lt;/a&gt;中介者模式&lt;/h1&gt;&lt;p&gt;中介者模式（Mediator Pattern）是一种行为型设计模式，它用于降低多个对象之间的耦合性，通过引入一个中介</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>状态模式</title>
    <link href="http://example.com/2023/07/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/07/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-07-30T07:39:35.000Z</published>
    <updated>2023-07-30T08:16:42.512Z</updated>
    
    <content type="html"><![CDATA[<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><p>状态模式（State Pattern）是一种行为型设计模式，它允许一个对象在其内部状态改变时改变它的行为。状态模式将对象的行为封装成不同的状态类，使得对象在不同状态下可以切换，从而避免了大量的条件判断语句，提高了代码的可读性和可维护性。</p><h1 id="状态模式的结构"><a href="#状态模式的结构" class="headerlink" title="状态模式的结构"></a>状态模式的结构</h1><ul><li>环境（Context）角色：也称为上下文，它定义了客户程序需要的接口，维护一个对具体状态类的引用，并将客户端的请求委托给当前状态对象处理。</li><li>抽象状态（State）角色：定义一个接口或抽象类，用以封装环境对象中的特定状态所对应的行为。</li><li>具体状态（Concrete State）角色：实现State接口，具体处理Context在某个状态下的请求。</li></ul><h1 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h1><p>假设我们有一个电梯控制器，可以控制电梯在不同的状态下运行，包括：停止状态、运行状态、停下状态。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. State（抽象状态类）</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ElevatorState</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. ConcreteState（具体状态类）- 停止状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StoppedState</span> <span class="keyword">implements</span> <span class="title class_">ElevatorState</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯已停止&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. ConcreteState（具体状态类）- 运行状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RunningState</span> <span class="keyword">implements</span> <span class="title class_">ElevatorState</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯正在运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. ConcreteState（具体状态类）- 停下状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StoppingState</span> <span class="keyword">implements</span> <span class="title class_">ElevatorState</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯正在停下&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Context（环境类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElevatorController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ElevatorState currentState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ElevatorController</span><span class="params">()</span> &#123;</span><br><span class="line">        currentState = <span class="keyword">new</span> <span class="title class_">StoppedState</span>(); <span class="comment">// 初始状态为停止状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(ElevatorState state)</span> &#123;</span><br><span class="line">        currentState = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        currentState.handleRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StatePatternExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ElevatorController</span> <span class="variable">controller</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ElevatorController</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始状态为停止状态</span></span><br><span class="line">        controller.request();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切换到运行状态</span></span><br><span class="line">        controller.setState(<span class="keyword">new</span> <span class="title class_">RunningState</span>());</span><br><span class="line">        controller.request();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切换到停下状态</span></span><br><span class="line">        controller.setState(<span class="keyword">new</span> <span class="title class_">StoppingState</span>());</span><br><span class="line">        controller.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">电梯已停止</span><br><span class="line">电梯正在运行</span><br><span class="line">电梯正在停下</span><br></pre></td></tr></table></figure><h1 id="在Spring源码中的应用"><a href="#在Spring源码中的应用" class="headerlink" title="在Spring源码中的应用"></a>在Spring源码中的应用</h1><p>Spring框架中的有些组件和功能可以通过状态模式进行实现，例如在Spring的状态机（spring-statemachine）模块中，它用于实现复杂的状态机逻辑，如订单状态、工作流等。在Spring的状态机模块中，状态模式被广泛应用，将状态抽象为状态类，状态之间的切换由状态机进行控制。</p><p>在Spring源码中，这些状态类和状态机之间的切换逻辑被很好地封装和管理，使得系统逻辑更加清晰、灵活和易于维护。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>通过状态模式，我们可以优雅地处理对象在不同状态下的行为，避免了大量的条件判断语句，使得代码更加简洁、可读性更高。在Spring源码中，状态模式的应用使得复杂的状态管理变得轻松和高效。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;状态模式&quot;&gt;&lt;a href=&quot;#状态模式&quot; class=&quot;headerlink&quot; title=&quot;状态模式&quot;&gt;&lt;/a&gt;状态模式&lt;/h1&gt;&lt;p&gt;状态模式（State Pattern）是一种行为型设计模式，它允许一个对象在其内部状态改变时改变它的行为。状态模式将对象的行</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>命令模式</title>
    <link href="http://example.com/2023/07/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/07/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-07-29T09:01:38.000Z</published>
    <updated>2023-07-30T07:03:18.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p>命令模式是一种行为设计模式，用于将请求（命令）发送者和接收者解耦，从而允许发送者发送命令，而不需要知道实际执行命令的接收者是谁以及如何执行的。</p><h1 id="命令模式的结构"><a href="#命令模式的结构" class="headerlink" title="命令模式的结构"></a>命令模式的结构</h1><ul><li>抽象命令类（Command）角色：定义命令的接口，声明执行的方法。</li><li>具体命令（Concrete Command）角色：具体的命令，实现命令接口；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。</li><li>接收者（Receiver)角色：真正执行命令的对象，任何类都有可能成为一个接收者，只要它能够实现命令要求实现的相应功能。</li><li>请求者（Invoker)角色：要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>假设我们要实现一个简单的遥控器程序，有两个按钮：按钮A用于打开电视，按钮B用于关闭电视。可以使用命令模式来实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命令接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开电视命令</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TurnOnTVCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TV tv;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TurnOnTVCommand</span><span class="params">(TV tv)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        tv.turnOn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭电视命令</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TurnOffTVCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TV tv;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TurnOffTVCommand</span><span class="params">(TV tv)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        tv.turnOff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 电视接收者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TV</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOn</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TV is on&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOff</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TV is off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遥控器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteControl</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Command turnOnCommand;</span><br><span class="line">    <span class="keyword">private</span> Command turnOffCommand;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTurnOnCommand</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        turnOnCommand = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTurnOffCommand</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        turnOffCommand = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pressTurnOnButton</span><span class="params">()</span> &#123;</span><br><span class="line">        turnOnCommand.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pressTurnOffButton</span><span class="params">()</span> &#123;</span><br><span class="line">        turnOffCommand.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TV</span> <span class="variable">tv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TV</span>();</span><br><span class="line">        <span class="type">Command</span> <span class="variable">turnOnCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TurnOnTVCommand</span>(tv);</span><br><span class="line">        <span class="type">Command</span> <span class="variable">turnOffCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TurnOffTVCommand</span>(tv);</span><br><span class="line"></span><br><span class="line">        <span class="type">RemoteControl</span> <span class="variable">remoteControl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteControl</span>();</span><br><span class="line">        remoteControl.setTurnOnCommand(turnOnCommand);</span><br><span class="line">        remoteControl.setTurnOffCommand(turnOffCommand);</span><br><span class="line"></span><br><span class="line">        remoteControl.pressTurnOnButton(); <span class="comment">// 打开电视</span></span><br><span class="line">        remoteControl.pressTurnOffButton(); <span class="comment">// 关闭电视</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring中的应用"><a href="#Spring中的应用" class="headerlink" title="Spring中的应用"></a>Spring中的应用</h1><p>在Spring框架中，命令模式的概念被广泛应用于其事务管理模块。事务管理是Spring框架中的一个关键特性，它允许开发者通过编程式或声明式方式管理事务。</p><p>Spring中的事务管理器（<code>PlatformTransactionManager</code>）是一个命令模式的实际应用。在Spring中，你可以配置多种事务管理器，比如JDBC事务管理器、JPA事务管理器、Hibernate事务管理器等等。每个事务管理器都实现了<code>PlatformTransactionManager</code>接口，并提供了在事务开始、提交或回滚时执行的具体操作。</p><p>Spring的事务管理器作为接收者，执行实际的事务管理操作。而调用者是Spring的事务切面，它在合适的时机调用事务管理器的方法来处理事务。客户端是使用Spring框架的应用程序，它们并不直接与事务管理器交互，而是通过声明式的方式或者AOP配置与之关联。</p><p>通过命令模式，Spring实现了事务管理的解耦，允许应用程序独立于具体的事务管理实现，并且可以轻松切换不同的事务管理器，而不需要修改应用程序的代码。</p><p>在Spring的配置文件中，你可以类似下面的方式配置声明式事务管理：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;serviceMethods&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.example.service.*.*(..))&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;serviceMethods&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的配置中，我们声明了一个事务管理器<code>DataSourceTransactionManager</code>，并通过AOP将事务管理器与<code>com.example.service</code>包下的所有方法关联起来。其中，<code>&lt;tx:advice&gt;</code>标签定义了事务的传播行为和隔离级别，通过配置<code>&lt;tx:method&gt;</code>来设置每个方法的事务属性。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>命令模式是一个有用的设计模式，它可以在许多场景中发挥作用，例如遥控器应用、事务管理器等。通过命令模式，我们可以将请求发送者与接收者解耦，提高代码的可维护性和可扩展性。在Spring源码中的应用，例如事务管理器，展示了命令模式在实际框架中的实际价值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;命令模式&quot;&gt;&lt;a href=&quot;#命令模式&quot; class=&quot;headerlink&quot; title=&quot;命令模式&quot;&gt;&lt;/a&gt;命令模式&lt;/h1&gt;&lt;p&gt;命令模式是一种行为设计模式，用于将请求（命令）发送者和接收者解耦，从而允许发送者发送命令，而不需要知道实际执行命令的接收者是</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="http://example.com/2023/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-07-28T12:30:31.000Z</published>
    <updated>2023-07-28T13:17:27.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>简介: 策略模式（Strategy Pattern）是一种行为型设计模式，它允许在运行时根据不同的情况选择不同的算法或行为。通过将算法封装成独立的可互换的策略，可以使得算法的变化独立于使用它的客户端。</p><h1 id="策略模式结构"><a href="#策略模式结构" class="headerlink" title="策略模式结构"></a>策略模式结构</h1><ul><li>抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</li><li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为。</li><li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li></ul><h1 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h1><h2 id="普通案例（会员卡打折）"><a href="#普通案例（会员卡打折）" class="headerlink" title="普通案例（会员卡打折）"></a>普通案例（会员卡打折）</h2><p>假设我们正在开发一个电商应用，根据用户的会员等级来计算订单的折扣金额。根据会员等级的不同，采用的计算策略也不同。在这种情况下，我们可以使用策略模式来实现不同的折扣策略。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会员卡接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">VipCard</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">discount</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoldCard</span> <span class="keyword">implements</span> <span class="title class_">VipCard</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">discount</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;金卡打7折&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SilverCard</span> <span class="keyword">implements</span> <span class="title class_">VipCard</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">discount</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;银卡打8折&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopperCard</span> <span class="keyword">implements</span> <span class="title class_">VipCard</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">discount</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;铜卡打9折&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Normal</span> <span class="keyword">implements</span> <span class="title class_">VipCard</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">discount</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通会员没有折扣&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 会员卡容器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VipCardFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, VipCard&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="string">&quot;gold&quot;</span>, <span class="keyword">new</span> <span class="title class_">GoldCard</span>());</span><br><span class="line">        map.put(<span class="string">&quot;silver&quot;</span>, <span class="keyword">new</span> <span class="title class_">SilverCard</span>());</span><br><span class="line">        map.put(<span class="string">&quot;copper&quot;</span>, <span class="keyword">new</span> <span class="title class_">CopperCard</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> VipCard <span class="title function_">getVIPCard</span><span class="params">(String level)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(level) != <span class="literal">null</span> ? map.get(level) : <span class="keyword">new</span> <span class="title class_">Normal</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 测试方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//金卡打7折</span></span><br><span class="line">        VipCardFactory.getVIPCard(<span class="string">&quot;gold&quot;</span>).discount();</span><br><span class="line">        <span class="comment">//银卡打8折</span></span><br><span class="line">        VipCardFactory.getVIPCard(<span class="string">&quot;silver&quot;</span>).discount();</span><br><span class="line">        <span class="comment">//普通会员没有折扣</span></span><br><span class="line">        VipCardFactory.getVIPCard(<span class="string">&quot;other&quot;</span>).discount();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>用一个容器（Map）装起来，可以通过传进来的参数直接获取对应的策略，避免了if…else。</p><h2 id="支付方式案例"><a href="#支付方式案例" class="headerlink" title="支付方式案例"></a>支付方式案例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 支付方式抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Payment</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">pay</span><span class="params">(String uid, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">balance</span> <span class="operator">=</span> queryBalance(uid);</span><br><span class="line">        <span class="keyword">if</span> (balance &lt; money) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;支付失败!余额不足!欠&quot;</span> + (money - balance) + <span class="string">&quot;元!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;支付成功!支付金额:&quot;</span> + money + <span class="string">&quot;余额剩余:&quot;</span> + (balance - money);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title function_">getPaymentName</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">queryBalance</span><span class="params">(String uid)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 现金支付 默认方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cash</span> <span class="keyword">extends</span> <span class="title class_">Payment</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">getPaymentName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;现金支付&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">double</span> <span class="title function_">queryBalance</span><span class="params">(String uid)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 支付宝类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliPay</span> <span class="keyword">extends</span> <span class="title class_">Payment</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">getPaymentName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;支付宝&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">double</span> <span class="title function_">queryBalance</span><span class="params">(String uid)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 微信支付类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeChatPay</span> <span class="keyword">extends</span> <span class="title class_">Payment</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">getPaymentName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;微信支付&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">double</span> <span class="title function_">queryBalance</span><span class="params">(String uid)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 支付方式容器策略类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Payment&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="string">&quot;WeChat&quot;</span>, <span class="keyword">new</span> <span class="title class_">WeChatPay</span>());</span><br><span class="line">        map.put(<span class="string">&quot;Ali&quot;</span>, <span class="keyword">new</span> <span class="title class_">AliPay</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Payment <span class="title function_">getPayment</span><span class="params">(String payment)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(payment) == <span class="literal">null</span> ? <span class="keyword">new</span> <span class="title class_">Cash</span>() : map.get(payment);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 订单交易类</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String uid;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> amount;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">pay</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pay(<span class="string">&quot;cash&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">pay</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Payment</span> <span class="variable">payment</span> <span class="operator">=</span> PaymentStrategy.getPayment(key);</span><br><span class="line">        System.out.println(<span class="string">&quot;欢迎使用&quot;</span> + payment.getPaymentName());</span><br><span class="line">        System.out.println(<span class="string">&quot;本次交易金额:&quot;</span> + <span class="built_in">this</span>.amount + <span class="string">&quot;,开始扣款...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> payment.pay(<span class="built_in">this</span>.uid, <span class="built_in">this</span>.amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 测试方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>(<span class="string">&quot;20221014001&quot;</span>, <span class="number">500</span>);</span><br><span class="line">        <span class="comment">//欢迎使用微信支付</span></span><br><span class="line">        <span class="comment">//本次交易金额:500.0,开始扣款...</span></span><br><span class="line">        <span class="comment">//支付失败!余额不足!欠200.0元!</span></span><br><span class="line">        System.out.println(order.pay(<span class="string">&quot;WeChat&quot;</span>));</span><br><span class="line">        <span class="comment">//欢迎使用支付宝</span></span><br><span class="line">        <span class="comment">//本次交易金额:500.0,开始扣款...</span></span><br><span class="line">        <span class="comment">//支付成功!支付金额:500.0余额剩余:0.0</span></span><br><span class="line">        System.out.println(order.pay(<span class="string">&quot;Ali&quot;</span>));</span><br><span class="line">        <span class="comment">//欢迎使用现金支付</span></span><br><span class="line">        <span class="comment">//本次交易金额:500.0,开始扣款...</span></span><br><span class="line">        <span class="comment">//支付成功!支付金额:500.0余额剩余:500.0</span></span><br><span class="line">        System.out.println(order.pay());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="Spring中的应用"><a href="#Spring中的应用" class="headerlink" title="Spring中的应用"></a>Spring中的应用</h1><p>在Spring框架中，策略模式被广泛应用于各个模块和组件中。以下是一些在Spring源码中使用策略模式的示例:</p><ol><li>Spring Security模块中的身份验证策略: Spring Security通过<code>AuthenticationManager</code>接口来实现不同的身份验证策略，比如<code>DaoAuthenticationProvider</code>、<code>LdapAuthenticationProvider</code>等。通过配置和设置<code>AuthenticationManager</code>的实现类，可以灵活地选择和应用不同的身份验证策略。</li><li>Spring MVC模块中的处理器映射策略和处理器适配器策略: Spring MVC通过<code>HandlerMapping</code>接口和<code>HandlerAdapter</code>接口来实现不同的处理器映射策略和处理器适配器策略。比如，<code>RequestMappingHandlerMapping</code>和<code>RequestMappingHandlerAdapter</code>分别提供了基于注解的处理器映射和适配器策略，而<code>SimpleUrlHandlerMapping</code>和<code>SimpleControllerHandlerAdapter</code>则提供了基于URL和Controller接口的处理策略。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>策略模式是一种非常有用的设计模式，它可以将算法的变化与调用方分离，实现代码的解耦和灵活性。在实际应用中，如果有多个相关的算法需要在运行时根据不同的条件进行选择，或者需要将算法的实现从具体的类中抽离出来，那么策略模式是一个很好的选择。在Spring框架中，策略模式的灵活性和可扩展性得到了广泛的应用，使得开发者可以根据自己的需求来选择和配置不同的策略实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;策略模式&quot;&gt;&lt;a href=&quot;#策略模式&quot; class=&quot;headerlink&quot; title=&quot;策略模式&quot;&gt;&lt;/a&gt;策略模式&lt;/h1&gt;&lt;p&gt;简介: 策略模式（Strategy Pattern）是一种行为型设计模式，它允许在运行时根据不同的情况选择不同的算法或行为。</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>职责链模式</title>
    <link href="http://example.com/2023/07/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/07/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-07-11T01:38:53.000Z</published>
    <updated>2023-07-11T02:07:38.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java职责链模式"><a href="#java职责链模式" class="headerlink" title="java职责链模式"></a>java职责链模式</h1><p>在软件开发中，职责链模式是一种行为设计模式，它允许你将请求沿着处理者链进行传递，每个处理者可以决定是否处理请求以及将请求传递给下一个处理者。</p><h1 id="职责链模式结构"><a href="#职责链模式结构" class="headerlink" title="职责链模式结构"></a>职责链模式结构</h1><p>职责链模式由以下几个主要组件组成：</p><ul><li>抽象处理者（Handler）：定义处理请求的接口，包含一个指向下一个处理者的引用。</li><li>具体处理者（ConcreteHandler）：实现抽象处理者接口，并负责处理请求。如果自己不能处理请求，则将请求传递给下一个处理者。</li><li>客户端（Client）：创建职责链，并向链的第一个处理者发送请求。</li></ul><h1 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h1><p>下面以一个简单的登录校验流程来通过代码进行实现：</p><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String Username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String role;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// handler抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line"><span class="keyword">protected</span> Handler next;</span><br><span class="line"><span class="comment">// 返回handler方便链式操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">next</span><span class="params">(Handler next)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.next = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 流程开始的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doHandler</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidateHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doHandler</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(user.getUsername()) || StringUtils.isBlank(user.getPassword())) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户名或者密码为空!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;校验通过&quot;</span>);</span><br><span class="line">        next.doHandler(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doHandler</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">&quot;pyy52hz&quot;</span>.equals(user.getUsername()) || !<span class="string">&quot;123456&quot;</span>.equals(user.getPassword())) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户名或者密码不正确!请检查!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        user.setRole(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;登陆成功!角色为管理员!&quot;</span>);</span><br><span class="line">        next.doHandler(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doHandler</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">&quot;admin&quot;</span>.equals(user.getRole())) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;无权限操作!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;角色为管理员,可以进行下一步操作!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 登录流程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="type">Handler</span> <span class="variable">validateHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ValidateHandler</span>();</span><br><span class="line">        <span class="type">Handler</span> <span class="variable">loginHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginHandler</span>();</span><br><span class="line">        <span class="type">Handler</span> <span class="variable">authHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthHandler</span>();</span><br><span class="line">        validateHandler.next(loginHandler);</span><br><span class="line">        loginHandler.next(authHandler);</span><br><span class="line">        validateHandler.doHandler(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="comment">// 测试方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="comment">//校验通过</span></span><br><span class="line">        <span class="comment">//用户名或者密码不正确!请检查!</span></span><br><span class="line">        user.setUsername(<span class="string">&quot;pyy52hz&quot;</span>);</span><br><span class="line">        user.setPassword(<span class="string">&quot;1234567&quot;</span>);</span><br><span class="line">        <span class="type">LoginService</span> <span class="variable">loginService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginService</span>();</span><br><span class="line">        loginService.login(user);</span><br><span class="line">        <span class="comment">//校验通过</span></span><br><span class="line">        <span class="comment">//登陆成功!角色为管理员!</span></span><br><span class="line">        <span class="comment">//角色为管理员,可以进行下一步操作!</span></span><br><span class="line">        user.setUsername(<span class="string">&quot;pyy52hz&quot;</span>);</span><br><span class="line">        user.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        loginService.login(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">校验通过</span><br><span class="line">用户名或者密码不正确!请检查!</span><br><span class="line">校验通过</span><br><span class="line">登陆成功!角色为管理员!</span><br><span class="line">角色为管理员,可以进行下一步操作!</span><br></pre></td></tr></table></figure><h2 id="结合建造者模式"><a href="#结合建造者模式" class="headerlink" title="结合建造者模式"></a>结合建造者模式</h2><p>与基础版本区别主要是Handler类中新增一个Builder的内部类，以及流程类里改用链式写法，具体如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// handler抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">protected</span> Handler next;</span><br><span class="line">    <span class="comment">// 返回handler方便链式操作</span></span><br><span class="line">    <span class="keyword">public</span> Handler <span class="title function_">next</span><span class="params">(Handler next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 流程开始的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doHandler</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> Handler&lt;T&gt; head;</span><br><span class="line">        <span class="keyword">private</span> Handler&lt;T&gt; tail;</span><br><span class="line">        <span class="keyword">public</span> Builder&lt;T&gt; <span class="title function_">addHandler</span><span class="params">(Handler&lt;T&gt; handler)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.head == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.head = <span class="built_in">this</span>.tail = handler;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.tail.next(handler);</span><br><span class="line">            <span class="built_in">this</span>.tail = handler;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Handler&lt;T&gt; <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        Handler.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>.Builder();</span><br><span class="line">        builder.addHandler(<span class="keyword">new</span> <span class="title class_">ValidateHandler</span>())</span><br><span class="line">            .addHandler(<span class="keyword">new</span> <span class="title class_">LoginHandler</span>())</span><br><span class="line">            .addHandler(<span class="keyword">new</span> <span class="title class_">AuthHandler</span>());</span><br><span class="line">        builder.build().doHandler(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>适用场景：</p><ul><li>当一个请求需要被多个对象处理时，可以使用职责链模式将对象的处理流程串起来。</li><li>当不希望指定请求的处理者时，可以使用职责链模式动态地决定由哪个处理者处理请求。</li></ul><p>优点：</p><ul><li>将请求与处理解耦。</li><li>请求处理者（节点对象）只需关注自己感兴趣的请求进行处理即可，对于不感兴趣的请求，直接转发给下一级节点对象。</li><li>具备链式传递处理请求功能，请求发送者无需知晓链路结构，只需等待请求处理结果。</li><li>链路结构灵活，可以通过改变链路结构动态地新增或删减责任。</li><li>易于扩展新的请求处理类（节点），符合开闭原则。</li></ul><p>缺点：</p><ul><li>责任链太长或者处理时间过长，会影响整体性能。</li><li>如果节点对象存在循环引用时，会造成死循环，导致系统崩溃。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java职责链模式&quot;&gt;&lt;a href=&quot;#java职责链模式&quot; class=&quot;headerlink&quot; title=&quot;java职责链模式&quot;&gt;&lt;/a&gt;java职责链模式&lt;/h1&gt;&lt;p&gt;在软件开发中，职责链模式是一种行为设计模式，它允许你将请求沿着处理者链进行传递，每个</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>ciic_mes项目开发记录</title>
    <link href="http://example.com/2023/07/06/%E9%A1%B9%E7%9B%AE/ciic_mes%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2023/07/06/%E9%A1%B9%E7%9B%AE/ciic_mes%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/</id>
    <published>2023-07-06T02:20:06.000Z</published>
    <updated>2023-07-10T08:43:54.041Z</updated>
    
    <content type="html"><![CDATA[<h1 id="请求发送到后端的一系列操作"><a href="#请求发送到后端的一系列操作" class="headerlink" title="请求发送到后端的一系列操作"></a>请求发送到后端的一系列操作</h1><h2 id="请求先经过网关"><a href="#请求先经过网关" class="headerlink" title="请求先经过网关"></a>请求先经过网关</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">    <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">    <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> request.getURI().getPath();</span><br><span class="line">    <span class="comment">// 放行忽略token的url</span></span><br><span class="line">    <span class="keyword">if</span> (gatewaySecurityProperties.getPassTokenUrl().contains(url)) &#123;</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// token校验</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> getToken(request);</span><br><span class="line">    <span class="keyword">if</span> (ObjectUtils.isEmpty(token) || JwtUtils.isTokenExpired(token)) &#123;</span><br><span class="line">        <span class="keyword">return</span> unAuthenticationResponse(response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">userId</span> <span class="operator">=</span> JwtUtils.getUserIdFromToken(token);</span><br><span class="line">    <span class="keyword">if</span> (!RedisUtils.hasCacheObject(CacheKeyConstants.LOGIN_USER_KEY + userId)) &#123;</span><br><span class="line">        <span class="keyword">return</span> unAuthenticationResponse(response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加请求头</span></span><br><span class="line">    addHeader(request.mutate(), SecurityConstants.LOGIN_USER_ID, userId);</span><br><span class="line">    <span class="keyword">return</span> chain.filter(exchange.mutate().request(request.mutate().build()).build());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.获取请求信息和相应信息，获取URL路径</p><p>2.判断是否放行忽略token的URL（比如login），若是则chain.filter(exchange)放行请求</p><p>3.获取请求中的token，并判断是否为空或者已经过期，若是则返回未认证的响应</p><p>4.从token中获取用户id</p><p>5.判断用户id是否存在于Redis缓存中，若不存在，则返回未认证的响应</p><p>6.若存在，则在请求头中添加用户id</p><p>7.最后通过chain.filter()方法将请求继续传递下去</p><h2 id="到达下一个过滤器链中的过滤器来继续处理请求"><a href="#到达下一个过滤器链中的过滤器来继续处理请求" class="headerlink" title="到达下一个过滤器链中的过滤器来继续处理请求"></a>到达下一个过滤器链中的过滤器来继续处理请求</h2><h3 id="到达AuthenticationInterceptor认证拦截器"><a href="#到达AuthenticationInterceptor认证拦截器" class="headerlink" title="到达AuthenticationInterceptor认证拦截器"></a>到达AuthenticationInterceptor认证拦截器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> (HandlerMethod) handler;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> handlerMethod.getMethod();</span><br><span class="line">        <span class="comment">// 接口存在忽略token校验注解</span></span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(PassToken.class)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从线程私有尝试取出当前登录用户</span></span><br><span class="line">        <span class="type">LoginUserCache</span> <span class="variable">loginUserCache</span> <span class="operator">=</span> SecurityContextHolder.get();</span><br><span class="line">        <span class="keyword">if</span> (loginUserCache == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 无法取到说明未经LoginUser注解处理，需校验token并从Redis取出当前登录用户</span></span><br><span class="line">            <span class="comment">// token校验</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(SecurityConstants.TOKEN_HEADER_NAME);</span><br><span class="line">            <span class="keyword">if</span> (ObjectUtils.isEmpty(token)) &#123;</span><br><span class="line">                token = request.getParameter(SecurityConstants.TOKEN_HEADER_NAME);</span><br><span class="line">                <span class="keyword">if</span> (!ObjectUtils.isEmpty(token) &amp;&amp; token.startsWith(SecurityConstants.TOKEN_PREFIX)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        token = URLDecoder.decode(token, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                        unAuthenticationResponse(response);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    unAuthenticationResponse(response);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            token = token.substring(SecurityConstants.TOKEN_PREFIX.length());</span><br><span class="line">            <span class="keyword">if</span> (JwtUtils.isTokenExpired(token)) &#123;</span><br><span class="line">                unAuthenticationResponse(response);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从Redis中取出当前登录用户</span></span><br><span class="line">            loginUserCache = RedisUtils.getCacheObject(CacheKeyConstants.LOGIN_USER_KEY + JwtUtils.getUserIdFromToken(token));</span><br><span class="line">            <span class="keyword">if</span> (loginUserCache == <span class="literal">null</span>) &#123;</span><br><span class="line">                unAuthenticationResponse(response);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                SecurityContextHolder.set(loginUserCache);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 能取到说明已在LoginUser注解处理中校验过token并从Redis中取出当前登录用户</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个Spring MVC的拦截器，用于实现基于JWT的token校验和获取当前登录用户信息。下面是代码的详细解释：</p><ol><li>首先获取请求和响应对象。</li><li>获取处理当前请求的方法。</li><li>判断方法是否标有@PassToken注解，如果有，则跳过token校验，直接返回true。</li><li>如果方法没有标有@PassToken注解，则尝试从线程私有对象SecurityContextHolder中获取当前登录用户信息LoginUserCache。</li><li>如果获取不到当前登录用户信息LoginUserCache，则说明未经LoginUser注解处理，需要进行token校验并从Redis中获取当前登录用户信息。</li><li>首先从请求头或请求参数中获取token。</li><li>如果获取到了token，则进行进一步处理，包括对token格式的验证、解码等操作。</li><li>如果token已过期，则返回未认证的响应。</li><li>从Redis缓存中获取对应的当前登录用户信息LoginUserCache。</li><li>如果获取不到当前登录用户信息LoginUserCache，则返回未认证的响应。</li><li>如果获取到了当前登录用户信息LoginUserCache，则将其设置到线程私有对象SecurityContextHolder中。</li><li>返回true，表示通过token认证，可以继续处理请求。</li><li>如果能够从SecurityContextHolder中获取到当前登录用户信息LoginUserCache，则说明在LoginUser注解处理中已经进行了token校验并从Redis中获取了当前登录用户信息，直接返回true。</li></ol><h3 id="到达AuthorizationInterceptor鉴权拦截器"><a href="#到达AuthorizationInterceptor鉴权拦截器" class="headerlink" title="到达AuthorizationInterceptor鉴权拦截器"></a>到达AuthorizationInterceptor鉴权拦截器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> (HandlerMethod) handler;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> handlerMethod.getMethod();</span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(HasPermissions.class)) &#123;</span><br><span class="line">            <span class="comment">// 需要权限校验</span></span><br><span class="line">            <span class="type">HasPermissions</span> <span class="variable">hasPermissions</span> <span class="operator">=</span> method.getAnnotation(HasPermissions.class);</span><br><span class="line">            <span class="comment">// 方法需要的权限</span></span><br><span class="line">            List&lt;String&gt; methodPermissions = Arrays.asList(hasPermissions.value());</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isEmpty(methodPermissions)) &#123;</span><br><span class="line">                <span class="comment">// 方法需要的权限为空</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 用户具有的权限</span></span><br><span class="line">                List&lt;String&gt; userPermissions = SecurityContextHolder.get().getPermissions();</span><br><span class="line">                <span class="keyword">if</span> (methodPermissions.stream().anyMatch(userPermissions::contains)) &#123;</span><br><span class="line">                    <span class="comment">// 用户权限包含方法需要的权限之一</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 用户权限不存在方法需要的权限</span></span><br><span class="line">                    unAuthorizationResponse(response);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 无需授权</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个Spring MVC的拦截器，用于实现基于权限的授权校验。下面是代码的详细解释：</p><ol><li>首先获取请求和响应对象。</li><li>获取当前请求所对应的方法。</li><li>判断方法是否标有@HasPermissions注解，如果有，则表示该方法需要进行权限校验。</li><li>如果方法需要进行权限校验，则获取注解中定义的方法需要的权限列表。</li><li>判断方法需要的权限列表是否为空，如果为空，则表示方法不需要进行权限校验，直接返回true。</li><li>如果方法需要的权限列表不为空，则获取当前登录用户的权限列表。</li><li>检查当前登录用户的权限列表是否存在与方法需要的权限列表匹配的权限，如果存在匹配的权限，则表示当前登录用户具有所需的权限，返回true。</li><li>如果当前登录用户的权限列表不存在与方法需要的权限列表匹配的权限，则表示当前登录用户没有权限访问该方法，返回未授权的响应并返回false。</li><li>如果方法没有标有@HasPermissions注解，则表示该方法不需要进行权限校验，直接返回true。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;请求发送到后端的一系列操作&quot;&gt;&lt;a href=&quot;#请求发送到后端的一系列操作&quot; class=&quot;headerlink&quot; title=&quot;请求发送到后端的一系列操作&quot;&gt;&lt;/a&gt;请求发送到后端的一系列操作&lt;/h1&gt;&lt;h2 id=&quot;请求先经过网关&quot;&gt;&lt;a href=&quot;#请求</summary>
      
    
    
    
    <category term="项目" scheme="http://example.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>享元模式</title>
    <link href="http://example.com/2023/07/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/07/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-07-02T02:11:06.000Z</published>
    <updated>2023-07-02T02:47:56.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><p>享元模式又称为轻量级模式，是对象池的一种实现，类似于线程池，线程池可以避免不停的创建和销毁多个对象，消耗性能。提供了减少对象数量从而改善应用所宿舍的对象结构的方式。宗旨：共享细粒度对象，将多个同一对象的访问集中起来。</p><p>享元模式（Flyweight Pattern）存在以下俩种状态：</p><ul><li>内部状态，即不会随着环境的改变而改变的可共享部分。</li><li>外部状态，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的俩种状态，并使外部状态外部化。</li></ul><p>享元模式主要有以下角色：</p><ol><li>抽象享元角色（Flyweight）：通常是一个接口或抽象类，在抽象享元中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。</li><li>具体享元角色（Concrete Flyweight): 它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。</li><li>飞享元角色（Unsharable Flyweight): 并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类，当需要一个非共享享元类的对象时可以直接通过实例化创建。</li><li>享元工厂角色（Flyweight Factory)： 负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检查系统中是否存在符合的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。</li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p> 下面通过查询火车票的例子来用代码进行模拟实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITicket</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String seat)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainTicket</span> <span class="keyword">implements</span> <span class="title class_">ITicket</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line">    <span class="keyword">private</span> String to;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TrainTicket</span><span class="params">(String from, String to)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.from = from;</span><br><span class="line">        <span class="built_in">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String seat)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">500</span>);</span><br><span class="line">        System.out.println(from + <span class="string">&quot;-&gt;&quot;</span> + to + <span class="string">&quot;:&quot;</span> + seat + <span class="string">&quot;价格:&quot;</span> + <span class="built_in">this</span>.price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TicketFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, ITicket&gt; pool = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ITicket <span class="title function_">getTicket</span><span class="params">(String from, String to)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> from + <span class="string">&quot;-&gt;&quot;</span> + to;</span><br><span class="line">        <span class="keyword">if</span> (pool.containsKey(key)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;使用缓存获取火车票:&quot;</span> + key);</span><br><span class="line">            <span class="keyword">return</span> pool.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用数据库获取火车票:&quot;</span> + key);</span><br><span class="line">        <span class="type">ITicket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainTicket</span>(from, to);</span><br><span class="line">        pool.put(key, ticket);</span><br><span class="line">        <span class="keyword">return</span> ticket;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ITicket</span> <span class="variable">ticket</span> <span class="operator">=</span> TicketFactory.getTicket(<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ticket.show(<span class="string">&quot;二等座&quot;</span>);</span><br><span class="line">        <span class="type">ITicket</span> <span class="variable">ticket1</span> <span class="operator">=</span> TicketFactory.getTicket(<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ticket1.show(<span class="string">&quot;商务座&quot;</span>);</span><br><span class="line">        <span class="type">ITicket</span> <span class="variable">ticket2</span> <span class="operator">=</span> TicketFactory.getTicket(<span class="string">&quot;上海&quot;</span>, <span class="string">&quot;北京&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ticket2.show(<span class="string">&quot;一等座&quot;</span>);</span><br><span class="line">        System.out.println(ticket == ticket1);<span class="comment">//true</span></span><br><span class="line">        System.out.println(ticket == ticket2);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">使用数据库获取火车票:北京-&gt;上海</span><br><span class="line">北京-&gt;上海:二等座价格:<span class="number">306</span></span><br><span class="line">使用缓存获取火车票:北京-&gt;上海</span><br><span class="line">北京-&gt;上海:商务座价格:<span class="number">145</span></span><br><span class="line">使用数据库获取火车票:上海-&gt;北京</span><br><span class="line">上海-&gt;北京:一等座价格:<span class="number">152</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure><p>可以看到ticket和ticket2是使用数据库查询的，而ticket1是使用缓存查询的，同时ticket == ticket1返回的是true，ticket == ticket2返回的是false，证明ticket和ticket1是共享的对象。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>适用场景：</p><ul><li>一个系统有大量相同或者相似的对象，造成内存的大量耗费。</li><li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。</li><li>在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。</li></ul><p>优点：</p><ul><li>减少对象的创建，降低内存中对象的数量，降低系统的内存，提高效率。</li><li>减少内存之外的其他资源占用。</li></ul><p>缺点：</p><ul><li>关注内、外部状态。</li><li>关注线程安全问题。</li><li>使系统、程序的逻辑复杂化。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;享元模式&quot;&gt;&lt;a href=&quot;#享元模式&quot; class=&quot;headerlink&quot; title=&quot;享元模式&quot;&gt;&lt;/a&gt;享元模式&lt;/h1&gt;&lt;p&gt;享元模式又称为轻量级模式，是对象池的一种实现，类似于线程池，线程池可以避免不停的创建和销毁多个对象，消耗性能。提供了减少对象</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>组合模式</title>
    <link href="http://example.com/2023/06/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/06/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-06-30T12:17:19.000Z</published>
    <updated>2023-06-30T13:17:53.991Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><p>组合模式（Composite Pattern）也称为整体-不分模式，它的宗旨是通过将单个对象（叶子结点）和组合对象（树枝节点）同相同的接口进行表示、</p><p>作用：使客户端对单个对象和组合对象保持一致的方式处理。</p><p>组合模式的主要三种角色：</p><ol><li>抽象根节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。</li><li>树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。</li><li>叶子节点（Leaf):叶子节点对象，其下再无分支，使系统层次遍历的最小单位。</li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>下面通过一个添加菜单的例子通过代码实现：</p><h2 id="透明模式"><a href="#透明模式" class="headerlink" title="透明模式"></a>透明模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 菜单组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MenuComponent</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Integer level;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(MenuComponent menuComponent)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;不支持添加操作!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(MenuComponent menuComponent)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;不支持删除操作!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> MenuComponent <span class="title function_">getChild</span><span class="params">(Integer i)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;不支持获取子菜单操作!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;不支持获取名字操作!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;不支持打印操作!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 菜单类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Menu</span> <span class="keyword">extends</span> <span class="title class_">MenuComponent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;MenuComponent&gt; menuComponentList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Menu</span><span class="params">(String name,<span class="type">int</span> level)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(MenuComponent menuComponent)</span> &#123;</span><br><span class="line">        menuComponentList.add(menuComponent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(MenuComponent menuComponent)</span> &#123;</span><br><span class="line">        menuComponentList.remove(menuComponent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MenuComponent <span class="title function_">getChild</span><span class="params">(Integer i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> menuComponentList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; level; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;--&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="keyword">for</span> (MenuComponent menuComponent : menuComponentList) &#123;</span><br><span class="line">            menuComponent.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 子菜单类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MenuItem</span> <span class="keyword">extends</span> <span class="title class_">MenuComponent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MenuItem</span><span class="params">(String name,<span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; level; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;--&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一级菜单</span></span><br><span class="line">        <span class="type">MenuComponent</span> <span class="variable">component</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Menu</span>(<span class="string">&quot;系统管理&quot;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">MenuComponent</span> <span class="variable">menu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Menu</span>(<span class="string">&quot;用户管理&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        menu1.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;新增用户&quot;</span>,<span class="number">3</span>));</span><br><span class="line">        menu1.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;修改用户&quot;</span>,<span class="number">3</span>));</span><br><span class="line">        menu1.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;删除用户&quot;</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">MenuComponent</span> <span class="variable">menu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Menu</span>(<span class="string">&quot;角色管理&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        menu2.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;新增角色&quot;</span>,<span class="number">3</span>));</span><br><span class="line">        menu2.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;修改角色&quot;</span>,<span class="number">3</span>));</span><br><span class="line">        menu2.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;删除角色&quot;</span>,<span class="number">3</span>));</span><br><span class="line">        menu2.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;绑定用户&quot;</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将二级菜单添加到一级菜单中</span></span><br><span class="line">        component.add(menu1);</span><br><span class="line">        component.add(menu2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印菜单名称(如果有子菜单一块打印)</span></span><br><span class="line">        component.print();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">系统管理</span><br><span class="line">--用户管理</span><br><span class="line">----新增用户</span><br><span class="line">----修改用户</span><br><span class="line">----删除用户</span><br><span class="line">--角色管理</span><br><span class="line">----新增角色</span><br><span class="line">----修改角色</span><br><span class="line">----删除角色</span><br><span class="line">----绑定用户</span><br></pre></td></tr></table></figure><h2 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MenuComponent</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Integer level;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Menu</span> <span class="keyword">extends</span> <span class="title class_">MenuComponent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;MenuComponent&gt; menuComponentList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Menu</span><span class="params">(String name, <span class="type">int</span> level)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(MenuComponent menuComponent)</span> &#123;</span><br><span class="line">        menuComponentList.add(menuComponent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(MenuComponent menuComponent)</span> &#123;</span><br><span class="line">        menuComponentList.remove(menuComponent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> MenuComponent <span class="title function_">getChild</span><span class="params">(Integer i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> menuComponentList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; level; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;--&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="keyword">for</span> (MenuComponent menuComponent : menuComponentList) &#123;</span><br><span class="line">            menuComponent.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MenuItem</span> <span class="keyword">extends</span> <span class="title class_">MenuComponent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MenuItem</span><span class="params">(String name, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; level; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;--&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Menu</span> <span class="variable">component</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Menu</span>(<span class="string">&quot;系统管理&quot;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Menu</span> <span class="variable">menu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Menu</span>(<span class="string">&quot;用户管理&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        menu1.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;新增用户&quot;</span>,<span class="number">3</span>));</span><br><span class="line">        menu1.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;修改用户&quot;</span>,<span class="number">3</span>));</span><br><span class="line">        menu1.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;删除用户&quot;</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Menu</span> <span class="variable">menu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Menu</span>(<span class="string">&quot;角色管理&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        menu2.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;新增角色&quot;</span>,<span class="number">3</span>));</span><br><span class="line">        menu2.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;修改角色&quot;</span>,<span class="number">3</span>));</span><br><span class="line">        menu2.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;删除角色&quot;</span>,<span class="number">3</span>));</span><br><span class="line">        menu2.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;绑定用户&quot;</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将二级菜单添加到一级菜单中</span></span><br><span class="line">        component.add(menu1);</span><br><span class="line">        component.add(menu2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印菜单名称(如果有子菜单一块打印)</span></span><br><span class="line">        component.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">系统管理</span><br><span class="line">--用户管理</span><br><span class="line">----新增用户</span><br><span class="line">----修改用户</span><br><span class="line">----删除用户</span><br><span class="line">--角色管理</span><br><span class="line">----新增角色</span><br><span class="line">----修改角色</span><br><span class="line">----删除角色</span><br><span class="line">----绑定用户</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>分类</p><ul><li>透明组合模式<ul><li>透明组合模式中，抽象根节点角色中声明了所有用于管理成员对象的方法，比如在示例中MenuComponent声明了add() 、 remove() 、getChild()方法，这样做的好处是确保所有的构件类都有相同的接口。透明组合模式也是组合模式的标准形式。</li><li>透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供 add()、remove() 等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）</li></ul></li><li>安全组合模式<ul><li>在安全组合模式中，在抽象构件角色中没有声明任何用于管理成员对象的方法，而是在树枝节点Menu类中声明并实现这些方法。安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;组合模式&quot;&gt;&lt;a href=&quot;#组合模式&quot; class=&quot;headerlink&quot; title=&quot;组合模式&quot;&gt;&lt;/a&gt;组合模式&lt;/h1&gt;&lt;p&gt;组合模式（Composite Pattern）也称为整体-不分模式，它的宗旨是通过将单个对象（叶子结点）和组合对象（树枝节点</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>外观模式</title>
    <link href="http://example.com/2023/06/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/06/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-06-29T11:51:21.000Z</published>
    <updated>2023-06-29T13:25:54.119Z</updated>
    
    <content type="html"><![CDATA[<h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><p>外观模式为子系统中的一组接口提供了一个统一的接口，使得子系统更容易使用。通过使用外观模式，我们可以减少系统的相互依赖性，并增加系统的灵活性。</p><p>外观模式（Facade Pattern）的角色：</p><ol><li>外观角色：为多个子系统对外提供一个共同的接口。</li><li>子系统角色：实现系统的部分功能，客户可以通过外观角色访问它。</li></ol><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p>在以下情况可以考虑适用外观模式：</p><ol><li>当需要为一组复杂的子系统提供一个简单的统一接口。</li><li>当希望将子系统的分层进行隐藏，只暴露必要的功能接口。</li><li>当要简化调用者和子系统之间的依赖关系。</li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>下面以一个智能音箱实现起床睡觉一键操作电器的场景，通过代码模拟一下这个场景：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Light</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开灯&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关灯&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tv</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开电视&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关电视&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fan</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开风扇&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关风扇&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmartSpeaker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line">    <span class="keyword">private</span> Tv tv;</span><br><span class="line">    <span class="keyword">private</span> Fan fan;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmartSpeaker</span><span class="params">()</span> &#123;</span><br><span class="line">        light = <span class="keyword">new</span> <span class="title class_">Light</span>();</span><br><span class="line">        tv = <span class="keyword">new</span> <span class="title class_">Tv</span>();</span><br><span class="line">        fan = <span class="keyword">new</span> <span class="title class_">Fan</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(String order)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (order.contains(<span class="string">&quot;起床&quot;</span>)) &#123;</span><br><span class="line">            getUp();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (order.contains(<span class="string">&quot;睡觉&quot;</span>)) &#123;</span><br><span class="line">            sleep();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我还听不懂你说的啥！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getUp</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;起床&quot;</span>);</span><br><span class="line">        light.on();</span><br><span class="line">        tv.on();</span><br><span class="line">        fan.off();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;睡觉&quot;</span>);</span><br><span class="line">        light.off();</span><br><span class="line">        tv.off();</span><br><span class="line">        fan.on();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SmartSpeaker</span> <span class="variable">smartSpeaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmartSpeaker</span>();</span><br><span class="line">        smartSpeaker.say(<span class="string">&quot;我要睡觉了!&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">        smartSpeaker.say(<span class="string">&quot;我起床了!&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">        smartSpeaker.say(<span class="string">&quot;Emmm&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">睡觉</span><br><span class="line">关灯</span><br><span class="line">关电视</span><br><span class="line">开风扇</span><br><span class="line">--------</span><br><span class="line">起床</span><br><span class="line">开灯</span><br><span class="line">开电视</span><br><span class="line">关风扇</span><br><span class="line">--------</span><br><span class="line">我还听不懂你说的啥！</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;外观模式&quot;&gt;&lt;a href=&quot;#外观模式&quot; class=&quot;headerlink&quot; title=&quot;外观模式&quot;&gt;&lt;/a&gt;外观模式&lt;/h1&gt;&lt;p&gt;外观模式为子系统中的一组接口提供了一个统一的接口，使得子系统更容易使用。通过使用外观模式，我们可以减少系统的相互依赖性，并增</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>桥接模式</title>
    <link href="http://example.com/2023/06/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/06/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-06-29T06:23:03.000Z</published>
    <updated>2023-06-29T06:53:03.506Z</updated>
    
    <content type="html"><![CDATA[<h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><p>桥接模式是一种重要的设计模式，它能够将抽象部分和实现部分分离开来，使得他们可以独立地变化，通过组合的方式建立俩个类之间的联系，而不是继承。</p><p>桥接模式（Bridge Pattern）包含以下主要角色：</p><ol><li>抽象化（Abstraction）:定义了抽象部分的接口，并包含对一个实现类的引用。</li><li>扩展抽象化（Refined Abstraction）：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</li><li>实现化（Implementor）:定义实现化角色的接口。供扩展抽象化角色调用。</li><li>具体实现化（Concrete Implementor）角色：给出实例化角色接口的具体实现。</li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>假设我们要设计一个形状类（Shape），它有两个子类：圆形（Circle）和矩形（Rectangle）。同时，我们还有两个颜色类（Color）：红色（Red）和蓝色（Blue）。我们希望用户可以根据需要选择不同的颜色来绘制不同的形状。</p><p>首先，我们定义一个抽象类Shape，它包含一个对Color的引用，并声明了一个绘制方法draw()：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Color color;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Shape</span><span class="params">(Color color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们定义一个具体的形状类Circle，它继承自Shape并实现了draw()方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(Color color)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(color);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;绘制一个圆形，&quot;</span>);</span><br><span class="line">        color.paint();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们定义一个具体的形状类Rectangle，它也继承自Shape并实现了draw()方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(Color color)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(color);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;绘制一个矩形，&quot;</span>);</span><br><span class="line">        color.paint();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们定义一个抽象实现接口Color，它声明了一个绘制方法paint()：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们定义两个具体的颜色类Red和Blue，它们实现了Color接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Red</span> <span class="keyword">implements</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用红色画笔绘制。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Blue</span> <span class="keyword">implements</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用蓝色画笔绘制。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们可以编写一个测试类来验证桥接模式的使用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="keyword">new</span> <span class="title class_">Red</span>()).draw();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="keyword">new</span> <span class="title class_">Blue</span>()).draw();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="keyword">new</span> <span class="title class_">Red</span>()).draw();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="keyword">new</span> <span class="title class_">Blue</span>()).draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以上代码，输出结果如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">绘制一个圆形, 使用红色画笔绘制。</span><br><span class="line">绘制一个圆形, 使用蓝色画笔绘制。</span><br><span class="line">绘制一个矩形，使用红色画笔绘制。</span><br><span class="line">绘制一个矩形，使用蓝色画笔绘制。</span><br></pre></td></tr></table></figure><p>具体形状类和Color类通过Shape桥接关联起来</p><p>以上就是桥接模式在Java中的具体实现示例。通过使用桥接模式，我们可以将抽象部分和实现部分分离开来，使得它们可以独立变化。这种灵活的设计模式能够使我们的代码结构更加可扩展和可维护。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;桥接模式&quot;&gt;&lt;a href=&quot;#桥接模式&quot; class=&quot;headerlink&quot; title=&quot;桥接模式&quot;&gt;&lt;/a&gt;桥接模式&lt;/h1&gt;&lt;p&gt;桥接模式是一种重要的设计模式，它能够将抽象部分和实现部分分离开来，使得他们可以独立地变化，通过组合的方式建立俩个类之间的联系</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>装饰模式</title>
    <link href="http://example.com/2023/06/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/06/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-06-28T12:07:12.000Z</published>
    <updated>2023-06-28T13:35:25.551Z</updated>
    
    <content type="html"><![CDATA[<p>什么是装饰器模式？ 装饰器模式是一种结构型设计模式，它允许向现有对象添加新的功能，而无需修改其源代码或直接继承该对象。装饰器模式通过将对象进行包装来实现功能的扩展，通常将扩展的功能与原始对象的功能进行解耦，以便更灵活地添加、移除或组合功能。</p><h1 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h1><p>装饰器模式包含以下角色：</p><ol><li><p>抽象构件 (Component)：定义一个抽象接口，用于定义装饰器和具体构件的公共方法。</p></li><li><p>具体构件 (Concrete Component)：实现抽象构件接口，定义被装饰的类。</p></li><li><p>抽象装饰器 (Decorator)：继承或实现抽象构件接口，并持有一个抽象构件的引用。它的主要作用是定义装饰器的公共方法。</p></li><li><p>具体装饰器 (Concrete Decorator)：继承抽象装饰器，并根据需要进行具体的装饰，可以动态地扩展或修改具体构件的行为。</p></li></ol><p>在装饰器模式中，具体构件是被装饰的对象，抽象装饰器和具体装饰器在使用时与具体构件具有相同的接口，但是具体装饰器可以在调用被装饰对象的方法之前或之后加上自己的逻辑，从而实现功能的扩展和变化。</p><p>这种角色的分离使得装饰器模式可以在不修改原有代码的情况下，动态地给对象增加新的责任。同时，装饰器模式也遵循”开放-关闭”原则，使得系统更加灵活和可扩展。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>举一个简单的例子，假如现在有一碟炒饭，每个人的口味不一样，有些人喜欢加鸡蛋，有些人喜欢加鸡蛋火腿，有些人喜欢加鸡蛋火腿胡萝卜等。</p><h2 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriedRice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;炒饭&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriedRiceAddEgg</span> <span class="keyword">extends</span> <span class="title class_">FriedRice</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDescription() + <span class="string">&quot;加鸡蛋&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.cost() + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriedRiceAddEggAndHam</span> <span class="keyword">extends</span> <span class="title class_">FriedRiceAddEgg</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDescription() + <span class="string">&quot;加火腿&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.cost() + <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FriedRice</span> <span class="variable">friedRice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedRice</span>();</span><br><span class="line">        System.out.println(friedRice.getDescription()+<span class="string">&quot; 价格：&quot;</span>+friedRice.cost());</span><br><span class="line"></span><br><span class="line">        <span class="type">FriedRiceAddEgg</span> <span class="variable">friedRiceAddEgg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedRiceAddEgg</span>();</span><br><span class="line">        System.out.println(friedRiceAddEgg.getDescription()+<span class="string">&quot; 价格：&quot;</span>+friedRiceAddEgg.cost());</span><br><span class="line"></span><br><span class="line">        <span class="type">FriedRiceAddEggAndHam</span> <span class="variable">friedRiceAddEggAndHam</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedRiceAddEggAndHam</span>();</span><br><span class="line">        System.out.println(friedRiceAddEggAndHam.getDescription()+<span class="string">&quot; 价格：&quot;</span>+friedRiceAddEggAndHam.cost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">炒饭 价格：<span class="number">10.0</span></span><br><span class="line">炒饭加鸡蛋 价格：<span class="number">12.0</span></span><br><span class="line">炒饭加鸡蛋加火腿 价格：<span class="number">15.0</span></span><br></pre></td></tr></table></figure><p>那么就会发现，如果采用继承的方式去实现这个例子，那么每加一个配料，都需要创建新的配料类去继承上一个旧的配料类，那么久而久之，就会产生很多类了，而且还不利于扩展。可以从上面看到，如果我们只需要炒饭加火腿，那么我们还需要创建一个FriedRiceAddHam类去继承FriedRice类，所以继承的方式扩展性非常不好，且需要定义非常多的子类，下面就可以用装饰器模式去改进它。</p><h2 id="装饰模式实现"><a href="#装饰模式实现" class="headerlink" title="装饰模式实现"></a>装饰模式实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象构建</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FriedRice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//具体构建</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriedRiceImpl</span> <span class="keyword">implements</span> <span class="title class_">FriedRice</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;炒饭&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象装饰器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">FriedRiceDecorator</span> <span class="keyword">implements</span> <span class="title class_">FriedRice</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> FriedRice docoratedFriedRice;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FriedRiceDecorator</span><span class="params">(FriedRice docoratedFriedRice)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.docoratedFriedRice = docoratedFriedRice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> docoratedFriedRice.getDescription();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> docoratedFriedRice.getCost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//具体装饰器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriedRiceAddEggDecorator</span> <span class="keyword">extends</span> <span class="title class_">FriedRiceDecorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FriedRiceAddEggDecorator</span><span class="params">(FriedRice docoratedFriedRice)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(docoratedFriedRice);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDescription() + <span class="string">&quot;加鸡蛋&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getCost() + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//具体装饰器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriedRiceAddEggAndHamDecorator</span> <span class="keyword">extends</span> <span class="title class_">FriedRiceDecorator</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FriedRiceAddEggAndHamDecorator</span><span class="params">(FriedRice docoratedFriedRice)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(docoratedFriedRice);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDescription()+<span class="string">&quot;加鸡蛋加火腿&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getCost() + <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FriedRice</span> <span class="variable">friedRice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedRiceImpl</span>();</span><br><span class="line">        System.out.println(friedRice.getDescription()+<span class="string">&quot; 价格：&quot;</span>+friedRice.getCost());</span><br><span class="line"></span><br><span class="line">        <span class="type">FriedRice</span> <span class="variable">friedRiceAddEggDecorator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedRiceAddEggDecorator</span>(friedRice);</span><br><span class="line">        System.out.println(friedRiceAddEggDecorator.getDescription()+<span class="string">&quot; 价格：&quot;</span>+friedRiceAddEggDecorator.getCost());</span><br><span class="line"></span><br><span class="line">        <span class="type">FriedRice</span> <span class="variable">friedRiceAddEggAndHamDecorator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedRiceAddEggAndHamDecorator</span>(friedRice);</span><br><span class="line">        System.out.println(friedRiceAddEggAndHamDecorator.getDescription() + <span class="string">&quot; 价格：&quot;</span> + friedRiceAddEggAndHamDecorator.getCost());</span><br><span class="line"></span><br><span class="line">        <span class="type">FriedRice</span> <span class="variable">friedRiceAddEggDecorator1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedRiceAddEggDecorator</span>(friedRiceAddEggAndHamDecorator);</span><br><span class="line">        System.out.println(friedRiceAddEggDecorator1.getDescription() + <span class="string">&quot; 价格：&quot;</span> + friedRiceAddEggDecorator1.getCost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">炒饭 价格：<span class="number">10.0</span></span><br><span class="line">炒饭加鸡蛋 价格：<span class="number">12.0</span></span><br><span class="line">炒饭加鸡蛋加火腿 价格：<span class="number">15.0</span></span><br><span class="line">炒饭加鸡蛋加火腿加鸡蛋 价格：<span class="number">17.0</span></span><br></pre></td></tr></table></figure><p>可以看到，使用装饰器模式的方法实现，与普通的继承方法实现，最大的区别就是一种配料只有一个类，而且在加配料的时候，也可以直接想加多少就加多少，不需要说一个鸡蛋一个类，两个鸡蛋也要创建一个类，这样可以带来比继承更加灵活的扩展功能，使用也更加方便。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>装饰器模式和代理模式在一定程度上是相似的，它们都是结构型设计模式，都可以在不修改原始对象的情况下为其添加额外的功能。然而，它们之间有几个关键的区别：</p><ol><li><p>目的不同：</p><ul><li>装饰器模式的主要目的是在不改变接口的前提下，动态地为对象添加新的功能。它通常用于以透明的方式增强对象的功能。</li><li>代理模式的主要目的是通过代理控制对对象的访问。代理在客户端和目标对象之间充当中介，可以用于实现访问控制、远程访问、延迟加载等功能。</li></ul></li><li><p>关注点不同：</p><ul><li>装饰器模式关注于为对象添加功能，强调对对象的增强和扩展。</li><li>代理模式关注于控制对对象的访问，强调对对象的控制和隐藏。</li></ul></li><li><p>关系不同：</p><ul><li>装饰器模式使用组合关系，装饰器和被装饰对象共同实现同一个接口，以便能够替代原始对象。装饰器模式在运行时动态地组合对象，使得对象可以具有不同的行为。</li><li>代理模式使用聚合关系，代理对象持有对目标对象的引用，并在需要时调用目标对象。代理模式常用于隐藏目标对象的内部实现、实现访问控制、实现远程服务请求等。</li></ul></li></ol><p>总结来说，装饰器模式侧重于为对象添加功能，而代理模式侧重于控制对对象的访问。装饰器模式通过组合关系动态地对对象进行扩展，而代理模式通过聚合关系为对象提供了一个替代者。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;什么是装饰器模式？ 装饰器模式是一种结构型设计模式，它允许向现有对象添加新的功能，而无需修改其源代码或直接继承该对象。装饰器模式通过将对象进行包装来实现功能的扩展，通常将扩展的功能与原始对象的功能进行解耦，以便更灵活地添加、移除或组合功能。&lt;/p&gt;
&lt;h1 id=&quot;装饰模式</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>迭代器模式</title>
    <link href="http://example.com/2023/06/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/06/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-06-27T02:13:11.000Z</published>
    <updated>2023-06-27T02:59:51.457Z</updated>
    
    <content type="html"><![CDATA[<p>迭代器模式又称为游标模式（Cursor Pattern），它提供一种顺序访问集合/容器对象元素的方法，而又无须暴露结合内部表示。</p><h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><p>本质：抽离集合对象迭代行为到迭代器中，提供一致访问接口。</p><p>迭代器模式主要包含以下角色：</p><ul><li>抽象集合（Aggregate）角色：定义存储、添加、删除聚合元素以及创建迭代器对象的接口。</li><li>具体集合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。</li><li>抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、next() 等方法。</li><li>具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Aggregate</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T obj)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(T obj)</span>;</span><br><span class="line"></span><br><span class="line">    Iterator&lt;T&gt; <span class="title function_">getIterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteAggregate</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Aggregate</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T obj)</span> &#123;</span><br><span class="line">        list.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(T obj)</span> &#123;</span><br><span class="line">        list.remove(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">getIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteIterator</span>&lt;T&gt;(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    T <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteIterator</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt;&#123;</span><br><span class="line">    List&lt;T&gt; list;</span><br><span class="line">    <span class="type">int</span> cursor;</span><br><span class="line">    T element;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteIterator</span><span class="params">(List&lt;T&gt; list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &lt; list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        element = list.get(cursor);</span><br><span class="line">        cursor++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        ConcreteAggregate&lt;String&gt; aggregate = <span class="keyword">new</span> <span class="title class_">ConcreteAggregate</span>&lt;&gt;();</span><br><span class="line">        aggregate.add(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">        aggregate.add(<span class="string">&quot;小红&quot;</span>);</span><br><span class="line">        aggregate.add(<span class="string">&quot;小刚&quot;</span>);</span><br><span class="line">        aggregate.remove(<span class="string">&quot;小刚&quot;</span>);</span><br><span class="line">        Iterator&lt;String&gt; iterator = aggregate.getIterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">小明</span><br><span class="line">小红</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>适用场景：</p><ul><li>访问一个集合对象的内容而无需暴露它的内部表示。</li><li>为遍历不同的集合结构提供一个统一的访问接口。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;迭代器模式又称为游标模式（Cursor Pattern），它提供一种顺序访问集合/容器对象元素的方法，而又无须暴露结合内部表示。&lt;/p&gt;
&lt;h1 id=&quot;迭代器模式&quot;&gt;&lt;a href=&quot;#迭代器模式&quot; class=&quot;headerlink&quot; title=&quot;迭代器模式&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>观察者模式</title>
    <link href="http://example.com/2023/06/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/06/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-06-26T11:49:14.000Z</published>
    <updated>2023-06-27T02:05:09.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>观察者模式（Observer Pattern）是一种行为型设计模式，它定义了对象之间的一对多依赖关系，使得当一个对象的状态发生改变时，所有依赖它的对象都会自动通知并更新。</p><p>观察者模式中涉及以下角色：</p><ul><li>主题（Subject）：也称为被观察者，负责管理所有观察者对象的注册、删除和通知操作。当主题的状态发生改变时，会通知所有观察者。</li><li>观察者（Observer）：定义了一个更新接口，用于接收主题通知的更新。当观察者接收到主题的通知后，可以执行相应的操作。</li><li>具体主题（ConcreteSubject）：实现主题接口，负责具体的主题业务逻辑，并维护观察者列表。具体主题通常会在其状态发生变化时，通知观察者。</li><li>具体观察者（ConcreteObserver）：实现观察者接口，具体定义当接收到主题通知时的更新行为。每个具体观察者都会在主题状态发生变化时被通知，并执行相应的操作。</li></ul><h1 id="使用Java接口和回调函数实现"><a href="#使用Java接口和回调函数实现" class="headerlink" title="使用Java接口和回调函数实现"></a>使用Java接口和回调函数实现</h1><p>通过定义一个包含通知方法的观察者接口，然后将观察者通过回调函数注册到主题中。当主题的状态发生改变时，调用观察者的回调方法通知其进行相应的处理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unRegisterObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    ArrayList&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line">    String message;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unRegisterObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteObserver</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;观察者: &quot;</span> + name + <span class="string">&quot; 收到通知：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConcreteSubject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteSubject</span>();</span><br><span class="line">        subject.registerObserver(<span class="keyword">new</span> <span class="title class_">ConcreteObserver</span>(<span class="string">&quot;小明&quot;</span>));</span><br><span class="line">        subject.registerObserver(<span class="keyword">new</span> <span class="title class_">ConcreteObserver</span>(<span class="string">&quot;小红&quot;</span>));</span><br><span class="line">        subject.registerObserver(<span class="keyword">new</span> <span class="title class_">ConcreteObserver</span>(<span class="string">&quot;小刚&quot;</span>));</span><br><span class="line">        subject.setState(<span class="string">&quot;明天放假&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">观察者: 小明 收到通知：明天放假</span><br><span class="line">观察者: 小红 收到通知：明天放假</span><br><span class="line">观察者: 小刚 收到通知：明天放假</span><br></pre></td></tr></table></figure><p>运行以上代码，观察者1和观察者2都会收到主题状态的改变通知并进行相应的操作。</p><h1 id="JDK实现"><a href="#JDK实现" class="headerlink" title="JDK实现"></a>JDK实现</h1><p>在 Java 中，通过java.util.Observable类和 java.util.Observer接口定义了观察者模式，只要实现它们的子类就可以编写观察者模式实例。</p><h2 id="Observable类"><a href="#Observable类" class="headerlink" title="Observable类"></a>Observable类</h2><p>Observable类是抽象目标类（被观察者），它有一个Vector集合成员变量，用于保存所有要通知的观察者对象，下面是它最重要的 3 个方法：</p><ul><li>void addObserver(Observer o) 方法：用于将新的观察者对象添加到集合中。</li><li>void notifyObservers(Object arg) 方法：调用集合中的所有观察者对象的update方法，通知它们数据发生改变。通常越晚加入集合的观察者越先得到通知。</li><li>void setChange() 方法：用来设置一个boolean类型的内部标志，注明目标对象发生了变化。当它为true时，notifyObservers() 才会通知观察者。</li></ul><h2 id="Observer-接口"><a href="#Observer-接口" class="headerlink" title="Observer 接口"></a>Observer 接口</h2><p>Observer 接口是抽象观察者，它监视目标对象的变化，当目标对象发生变化时，观察者得到通知，并调用 update 方法，进行相应的工作。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subject</span> <span class="keyword">extends</span> <span class="title class_">java</span>.util.Observable &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;被观察者: &quot;</span> + name + <span class="string">&quot; 发送通知：&quot;</span> + message);</span><br><span class="line">        setChanged();</span><br><span class="line">        notifyObservers(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">java</span>.util.Observer &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Observable o, Object arg)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;关注了 &quot;</span> + ((Subject) o).getName() + <span class="string">&quot; ,收到通知：&quot;</span> + arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Subject</span>(<span class="string">&quot;公众号&quot;</span>);</span><br><span class="line">        subject.addObserver(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;小明&quot;</span>));</span><br><span class="line">        subject.addObserver(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;小红&quot;</span>));</span><br><span class="line">        subject.addObserver(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;小刚&quot;</span>));</span><br><span class="line">        subject.notifyMessage(<span class="string">&quot;明天放假&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">被观察者: 公众号 发送通知：明天放假</span><br><span class="line">小刚关注了 公众号 ,收到通知：明天放假</span><br><span class="line">小红关注了 公众号 ,收到通知：明天放假</span><br><span class="line">小明关注了 公众号 ,收到通知：明天放假</span><br></pre></td></tr></table></figure><h1 id="Google的Guava实现"><a href="#Google的Guava实现" class="headerlink" title="Google的Guava实现"></a>Google的Guava实现</h1><div class="table-container"><table><thead><tr><th>EventBus术语</th><th>解释</th><th>备注</th></tr></thead><tbody><tr><td>事件（消息）</td><td>可以向事件总线（EventBus）发布的对象</td><td>通常是一个类，不同的消息事件用不同的类来代替，消息内容就是类里面的属性</td></tr><tr><td>订阅</td><td>向事件总线注册监听者，以接受事件的行为</td><td>EventBus.register(Object)，参数就是监听者</td></tr><tr><td>监听者</td><td>提供一个处理方法，希望接受和处理事件的对象</td><td>通常也是一个类，里面有消息的处理方法</td></tr><tr><td>处理方法</td><td>监听者提供的公共方法，事件总线使用该方法向监听者发送事件；该方法应使用 Subscribe 注解</td><td>监听者里面添加一个 Subscribe 注解的方法，就可以认为是消息的处理方法</td></tr><tr><td>发布消息</td><td>通过事件总线向所有匹配的监听者提供事件</td><td>EventBus.post(Object)</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Object arg)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; 收到通知：&quot;</span> + arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">EventBus</span> <span class="variable">eventBus</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EventBus</span>();</span><br><span class="line">        eventBus.register(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;小明&quot;</span>));</span><br><span class="line">        eventBus.register(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;小红&quot;</span>));</span><br><span class="line">        eventBus.register(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;小刚&quot;</span>));</span><br><span class="line">        eventBus.post(<span class="string">&quot;明天放假&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">小明 收到通知：明天放假</span><br><span class="line">小红 收到通知：明天放假</span><br><span class="line">小刚 收到通知：明天放假</span><br></pre></td></tr></table></figure><blockquote><p>关于<code>com.google.common.eventbus.Subscribe</code>被标记为<code>@Beta</code>不稳定的事情是指它处于实验性阶段，可能在将来的版本中进行更改或删除。<code>@Beta</code>注解用于标记Google Guava库中的实验性功能。这意味着开发者可以使用这些功能，但需要注意它们的稳定性和将来的变化。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>适用场景：</p><ul><li>当一个抽象模型包含两个方面内容，其中一个方面依赖于另一个方面。</li><li>其他一个或多个对象的变化依赖于另一个对象的变化。</li><li>实现类似广播机制的功能，无需知道具体收听者，只需分发广播，系统中感兴趣的对象会自动接收该广播。</li></ul><p>多层级嵌套使用，形成一种链式触发机制，使得事件具备跨域（跨越两种观察者类型）通知。</p><p>优点：</p><ul><li>观察者和被观察者是松耦合（抽象耦合）的，符合依赖倒置原则。</li><li>分离了表示层（观察者）和数据逻辑层（被观察者），并且建立了一套触发机制，使得数据的变化可以相应到多个表示层上。</li><li>实现了一对多的通讯机制，支持事件注册机制，支持兴趣分发机制，当被观察者触发事件时，只有感兴趣的观察者可以接收到通知。</li></ul><p>缺点：</p><ul><li>如果观察者数量过多，则事件通知会耗时较长。</li><li>事件通知呈线性关系，如果其中一个观察者处理事件卡壳，会影响后续的观察者接收该事件。</li><li>如果观察者和被观察者之间存在循环依赖，则可能造成两者之间的循环调用，导致系统崩溃。</li></ul><p>​<br>​<br>​<br>​<br>​        </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;观察者模式&quot;&gt;&lt;a href=&quot;#观察者模式&quot; class=&quot;headerlink&quot; title=&quot;观察者模式&quot;&gt;&lt;/a&gt;观察者模式&lt;/h1&gt;&lt;p&gt;观察者模式（Observer Pattern）是一种行为型设计模式，它定义了对象之间的一对多依赖关系，使得当一个对象</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>适配器模式</title>
    <link href="http://example.com/2023/06/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/06/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-06-25T12:44:50.000Z</published>
    <updated>2023-06-25T13:06:32.385Z</updated>
    
    <content type="html"><![CDATA[<p>标题：深入解析Java适配器模式：源码实现及在Spring中的应用</p><p>导语：适配器模式是一种常见的设计模式，可以帮助我们封装不兼容的接口，让它们能够一起工作。本文将详细介绍Java适配器模式的实现原理，以及在Spring框架中的应用场景，为读者提供全方位的了解和应用指导。</p><h1 id="适配器模式简介"><a href="#适配器模式简介" class="headerlink" title="适配器模式简介"></a>适配器模式简介</h1><p>适配器模式旨在解决两个已有接口之间的不兼容性问题。它通过将一个类的接口转换成客户端所期望的另一个接口，使得原本由于接口不匹配而无法一起工作的类能够协同工作。</p><p>在Java中，适配器模式通常由两种形式来实现：类适配器和对象适配器。类适配器使用多重继承的方式，通过实现目标接口并继承源类来完成适配；对象适配器则使用对象组合，通过持有源类的实例来实现适配。前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p><p>适配器模式（Adapter）包含以下主要角色：</p><ul><li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li><li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li><li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li></ul><h1 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h1><ol><li>定义目标接口：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>实现源类：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">specificRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行被适配类的特殊请求&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>实现适配器类：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">extends</span> <span class="title class_">Adaptee</span> <span class="keyword">implements</span> <span class="title class_">Target</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用适配器：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adapter</span>();</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于Java是单继承的原因，如果不断的新增适配者，那么就要无限的新增适配器，于是就有了对象适配器。</p><h1 id="对象适配器示例"><a href="#对象适配器示例" class="headerlink" title="对象适配器示例"></a>对象适配器示例</h1><ol><li><p>定义目标接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现源类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">specificRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行被适配类的特殊请求&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现适配器类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">implements</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Adapter</span><span class="params">(Adaptee adaptee)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用适配器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Adaptee</span> <span class="variable">adaptee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adaptee</span>();</span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adapter</span>(adaptee);</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>可以看到，上面代码中，只实现了目标接口，并没有继承适配者，而是将适配者类实现适配者接口，在适配器中引入适配者接口，当我们需要使用不同的适配者通过适配器进行转换时，就无需再新建适配器类了</p><h1 id="在Spring中的适配器模式应用"><a href="#在Spring中的适配器模式应用" class="headerlink" title="在Spring中的适配器模式应用"></a>在Spring中的适配器模式应用</h1><p>Spring作为一个功能强大的开发框架，广泛应用了适配器模式来对外提供一致的接口。下面将介绍Spring中几个常见的适配器模式应用场景：</p><ol><li><p>Controller适配器<br>Spring MVC框架使用了Controller适配器来处理用户请求。用户请求首先进入DispatcherServlet，DispatcherServlet通过适配器将请求转发给具体的Controller。适配器根据请求的URL等信息选择合适的Controller进行处理，并返回响应结果。</p></li><li><p>MessageListener适配器<br>在Spring中使用消息队列进行消息传递时，通过MessageListener适配器将消息队列的消息转换为具体的业务处理代码。MessageListener适配器负责将不同类型的消息转换为统一的接口形式，从而简化消息处理的开发工作。</p></li><li><p>HandlerAdapter适配器<br>在Spring AOP中，通过HandlerAdapter适配器来处理各类增强器。HandlerAdapter根据增强器的类型和配置，决定适配器如何调用增强器中的方法，并在合适的时间点执行。</p></li></ol><p>通过以上几个例子，我们可以看到在Spring中适配器模式的灵活应用。Spring通过适配器模式将不同组件间的参数、接口、调用方式等进行统一，使得整个框架更加灵活、可扩展、易于维护。</p><h1 id="结语："><a href="#结语：" class="headerlink" title="结语："></a>结语：</h1><p>本文首先介绍了适配器模式的定义和两种形式的实现方式，其次通过一个代码示例详细解释了适配器模式的实际运用。最后，从Spring框架的角度给出了几个适配器模式在实际开发中的应用示例。希望本文对读者理解和应用适配器模式有所帮助。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;标题：深入解析Java适配器模式：源码实现及在Spring中的应用&lt;/p&gt;
&lt;p&gt;导语：适配器模式是一种常见的设计模式，可以帮助我们封装不兼容的接口，让它们能够一起工作。本文将详细介绍Java适配器模式的实现原理，以及在Spring框架中的应用场景，为读者提供全方位的了解和</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>建造者模式</title>
    <link href="http://example.com/2023/06/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/06/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-06-25T06:48:28.000Z</published>
    <updated>2023-06-29T12:06:22.190Z</updated>
    
    <content type="html"><![CDATA[<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>Java建造者模式是指将一个复杂对象的构建过程封装在一个单独的类中，使得同样的构建过程可以创建不同的表示，从而实现对象的构建和表示分离。</p><p>建造者（Builder）模式包含如下角色：</p><ul><li>抽象建造者类（Builder）：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的部件对象的创建。</li><li>具体建造者类（ConcreteBuilder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。</li><li>产品类（Product）：要创建的复杂对象。</li><li>指挥者类（Director）：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. Product</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">House</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String foundation;</span><br><span class="line">    <span class="keyword">private</span> String structure;</span><br><span class="line">    <span class="keyword">private</span> String roof;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFoundation</span><span class="params">(String foundation)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.foundation = foundation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStructure</span><span class="params">(String structure)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.structure = structure;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoof</span><span class="params">(String roof)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.roof = roof;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// other operations...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HouseBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildFoundation</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildStructure</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildRoof</span><span class="params">()</span>;</span><br><span class="line">    House <span class="title function_">getHouse</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. ConcreteBuilder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteHouseBuilder</span> <span class="keyword">implements</span> <span class="title class_">HouseBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> House house;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteHouseBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">        house = <span class="keyword">new</span> <span class="title class_">House</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildFoundation</span><span class="params">()</span> &#123;</span><br><span class="line">        house.setFoundation(<span class="string">&quot;Concrete&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildStructure</span><span class="params">()</span> &#123;</span><br><span class="line">        house.setStructure(<span class="string">&quot;Brick Walls&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildRoof</span><span class="params">()</span> &#123;</span><br><span class="line">        house.setRoof(<span class="string">&quot;Tiles&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> House <span class="title function_">getHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> house;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. Director</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Architect</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HouseBuilder houseBuilder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Architect</span><span class="params">(HouseBuilder houseBuilder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.houseBuilder = houseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> House <span class="title function_">construct</span><span class="params">()</span> &#123;</span><br><span class="line">        houseBuilder.buildFoundation();</span><br><span class="line">        houseBuilder.buildStructure();</span><br><span class="line">        houseBuilder.buildRoof();</span><br><span class="line">        <span class="keyword">return</span> houseBuilder.getHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. Client</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HouseBuilder</span> <span class="variable">houseBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteHouseBuilder</span>();</span><br><span class="line">        <span class="type">Architect</span> <span class="variable">architect</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Architect</span>(houseBuilder);</span><br><span class="line">        <span class="type">House</span> <span class="variable">house</span> <span class="operator">=</span> architect.construct();</span><br><span class="line">        <span class="comment">// Do something with the created house...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p>与工厂模式的区别：</p><ul><li>建造者模式更注重方法的调用顺序，工厂模式更注重创建对象。</li><li>创建对象的力度不同，建造者模式创建复杂的对象，由各种复杂的部件组成，工厂模式创建出来的都一样。</li><li>关注点不同，工厂模式只需要把对象创建出来就可以了，而建造者模式中不仅要创建出这个对象，还要知道这个对象由哪些部件组成。</li><li>建造者模式根据建造过程中的顺序不一样，最终的对象部件组成也不一样。</li></ul><p>与抽象工厂模式的区别：</p><ul><li>抽象工厂模式实现对产品族的创建，一个产品族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。</li><li>建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。</li><li>建造者模式所有函数加到一起才能生成一个对象，抽象工厂一个函数生成一个对象</li></ul><p>三、Spring中的建造者模式应用示例</p><ol><li><p>Spring框架本身<br>在Spring框架的核心模块中，我们可以看到大量的使用建造者模式的代码。例如，在XMLBeanDefinitionReader类中，使用了BeanDefinitionBuilder来构建BeanDefinition对象。Builder模式使得配置信息的解析和对象的构建能够更加一致和可扩展。</p></li><li><p>Spring MVC中的RequestMappingHandlerAdapter<br>RequestMappingHandlerAdapter是Spring MVC框架中的一个关键组件，通过使用HandlerAdapterBuilder构造器，它可以根据不同的配置和需求来构建适配器。建造者模式的使用使得构建适配器的过程得到了很好的封装，同时也方便了维护和扩展。</p></li><li><p>Spring对JDBC的支持<br>在Spring的JDBC模块中，可以看到大量使用建造者模式的情况。比如，使用SimpleJdbcInsert类和JdbcInsertBuilder建造者来构建插入语句，可以更加灵活地定义表、列和参数。</p></li></ol><p>结语：<br>本篇文章通过详细介绍了Java建造者模式的实现方式和在Spring框架中的应用场景。建造者模式的优势在于能够提供一种动态创建对象的方式，将对象的构建过程封装在单独的类中，使得代码更加灵活、可维护和可扩展。通过Spring框架的实际应用例子，我们可以进一步理解建造者模式的具体用法和作用。希望本篇文章能帮助读者更好地理解和使用Java建造者模式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;建造者模式&quot;&gt;&lt;a href=&quot;#建造者模式&quot; class=&quot;headerlink&quot; title=&quot;建造者模式&quot;&gt;&lt;/a&gt;建造者模式&lt;/h1&gt;&lt;p&gt;Java建造者模式是指将一个复杂对象的构建过程封装在一个单独的类中，使得同样的构建过程可以创建不同的表示，从而实现对</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>抽象工厂模式</title>
    <link href="http://example.com/2023/06/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/06/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-06-25T01:48:35.000Z</published>
    <updated>2023-06-25T06:09:28.768Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>抽象工厂模式（Abstract Factory Pattern）是一种创建型设计模式，旨在为客户端提供一个接口，用于创建相关或依赖对象的家族，而无需指定具体实现类。它通过提供一个抽象工厂类作为接口，使得客户端可以使用不同的具体工厂类来创建不同的产品对象。与之对比的是工厂方法模式（Factory Method Pattern），它通过提供一个抽象产品类和一个抽象工厂类，使得客户端可以通过具体工厂类来创建具体产品对象。</p><h1 id="抽象工厂模式的实现"><a href="#抽象工厂模式的实现" class="headerlink" title="抽象工厂模式的实现"></a>抽象工厂模式的实现</h1><p>工厂方法模式中考虑的是一类产品的生产，如电脑厂只生产电脑，电话厂只生产电话，这种工厂只生产同种类的产品，同种类产品称为同等级产品，也就是说，工厂方法模式只考虑生产同等级的产品，但是现实生活中许多工厂都是综合型工厂，能生产多等级（种类）的产品，如上面说的电脑和电话，本质上他们都属于电器，那么他们就能在电器厂里生产出来，而抽象工厂模式就将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，如上图所示纵轴是产品等级，也就是同一类产品；横轴是产品族，也就是同一品牌的产品，同一品牌的产品产自同一个工厂。</p><p>抽象工厂模式的实现需要以下几个要素：</p><ol><li>抽象产品类（Abstract Product）：它是工厂所创建的对象的共同接口，声明了产品的一些通用操作方法。</li><li>具体产品类（Concrete Product）：实现了抽象产品类的具体产品，通过工厂创建和提供。</li><li>抽象工厂类（Abstract Factory）：定义了创建抽象产品对象的接口，可以包含一组用于创建产品的方法。</li><li>具体工厂类（Concrete Factory）：实现了抽象工厂类的方法，通过调用具体产品类的构造函数来创建产品对象。</li></ol><p>下面是一个简单的Java代码示例：</p><p>一个抽象工厂模式的示例可以是一个汽车制造工厂。假设有两个品牌的汽车：奔驰和宝马，每个品牌都有两个型号：轿车和SUV。</p><p>首先，我们需要定义一个抽象的汽车工厂接口，其中包含创建轿车和创建SUV的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CarFactory</span> &#123;</span><br><span class="line">    Car <span class="title function_">createSedan</span><span class="params">()</span>;</span><br><span class="line">    Car <span class="title function_">createSUV</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们可以实现该接口来创建具体的汽车工厂，如奔驰工厂和宝马工厂：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MercedesFactory</span> <span class="keyword">implements</span> <span class="title class_">CarFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Car <span class="title function_">createSedan</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MercedesSedan</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Car <span class="title function_">createSUV</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MercedesSUV</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BMWFactory</span> <span class="keyword">implements</span> <span class="title class_">CarFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Car <span class="title function_">createSedan</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BMWSedan</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Car <span class="title function_">createSUV</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BMWSUV</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们定义汽车的抽象类以及具体的汽车类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="comment">// 汽车属性和行为</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MercedesSedan</span> <span class="keyword">extends</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="comment">// 奔驰轿车的具体实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MercedesSUV</span> <span class="keyword">extends</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="comment">// 奔驰SUV的具体实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BMWSedan</span> <span class="keyword">extends</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="comment">// 宝马轿车的具体实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BMWSUV</span> <span class="keyword">extends</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="comment">// 宝马SUV的具体实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们可以使用抽象工厂来创建具体的汽车对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CarFactory</span> <span class="variable">mercedesFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MercedesFactory</span>();</span><br><span class="line">        <span class="type">Car</span> <span class="variable">mercedesSedan</span> <span class="operator">=</span> mercedesFactory.createSedan();</span><br><span class="line">        <span class="type">Car</span> <span class="variable">mercedesSUV</span> <span class="operator">=</span> mercedesFactory.createSUV();</span><br><span class="line"></span><br><span class="line">        <span class="type">CarFactory</span> <span class="variable">bmwFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BMWFactory</span>();</span><br><span class="line">        <span class="type">Car</span> <span class="variable">bmwSedan</span> <span class="operator">=</span> bmwFactory.createSedan();</span><br><span class="line">        <span class="type">Car</span> <span class="variable">bmwSUV</span> <span class="operator">=</span> bmwFactory.createSUV();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过抽象工厂模式，我们可以将汽车的创建和具体实现分离开来，实现了高内聚低耦合的设计。</p><h1 id="抽象工厂模式与工厂方法模式的区别"><a href="#抽象工厂模式与工厂方法模式的区别" class="headerlink" title="抽象工厂模式与工厂方法模式的区别"></a>抽象工厂模式与工厂方法模式的区别</h1><p>抽象工厂模式与工厂方法模式在实现上的主要区别在于对产品种类的关注点不同。在抽象工厂模式中，一个工厂类可以创建多个产品种类的对象；而在工厂方法模式中，一个工厂类只能创建一种产品种类的对象。</p><p>具体来说，抽象工厂模式的抽象工厂类可以声明多个创建产品的抽象方法，每个方法对应一种产品。而工厂方法模式的抽象工厂类只声明了一个创建产品的抽象方法。</p><p>对于抽象工厂模式的优点有：</p><ul><li>客户端可以创建一个产品家族，而不需要知道具体的实现类。</li><li>增加新的具体工厂和产品类很方便，符合开闭原则。</li></ul><p>而对于工厂方法模式的优点有：</p><ul><li>适合产品结构稳定但经常增加新的产品种类的场景。</li><li>符合开闭原则，新增产品只需增加相应的具体产品类和具体工厂类即可，无需修改已有代码。</li></ul><h1 id="在Spring中的应用"><a href="#在Spring中的应用" class="headerlink" title="在Spring中的应用"></a>在Spring中的应用</h1><p>在Spring框架中，抽象工厂模式被广泛应用于依赖注入和Bean的创建。</p><p>Spring框架中的抽象工厂模式使用了多个接口和类来实现具体的工厂和产品。其中，主要涉及以下几个关键角色：</p><ol><li>抽象工厂接口（Factory）：定义了创建产品对象的方法。</li><li>具体工厂实现类（ConcreteFactory）：实现了抽象工厂接口，用于创建具体的产品对象。</li><li>抽象产品接口（Product）：定义了产品对象的共同方法。</li><li>具体产品实现类（ConcreteProduct）：实现了抽象产品接口，提供产品的具体实现。</li></ol><p>举例来说，在Spring中，我们可以定义一个抽象工厂接口来创建数据源对象，并定义相应的抽象产品接口和具体产品实现类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DataSourceFactory</span> &#123;</span><br><span class="line">    DataSource <span class="title function_">createDataSource</span><span class="params">()</span>;</span><br><span class="line">    Connection <span class="title function_">createConnection</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySQLFactory</span> <span class="keyword">implements</span> <span class="title class_">DataSourceFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">createDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MySQLDataSource</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">createConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MySQLConnection</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OracleFactory</span> <span class="keyword">implements</span> <span class="title class_">DataSourceFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">createDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OracleDataSource</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">createConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OracleConnection</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DataSource</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySQLDataSource</span> <span class="keyword">implements</span> <span class="title class_">DataSource</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 连接MySQL数据库</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OracleDataSource</span> <span class="keyword">implements</span> <span class="title class_">DataSource</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 连接Oracle数据库</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Connection</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">getConnection</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySQLConnection</span> <span class="keyword">implements</span> <span class="title class_">Connection</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取MySQL数据库连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OracleConnection</span> <span class="keyword">implements</span> <span class="title class_">Connection</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取Oracle数据库连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在抽象工厂模式中，不同的具体工厂实现类负责创建不同种类的产品，即MySQLFactory负责创建MySQLDataSource和MySQLConnection，OracleFactory负责创建OracleDataSource和OracleConnection。</p><p>在Spring中也可以使用抽象工厂模式来实现对象的创建和管理，但是相对来说，在Spring框架中更常使用工厂方法模式。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>抽象工厂模式是一种创建型设计模式，通过提供一个抽象工厂类来创建相关产品的家族，以隐藏产品的具体实现细节。与工厂方法模式相比，抽象工厂模式可以创建多种产品，适用于产品种类较多且需动态扩展的场景。</p><p>在Spring框架中，抽象工厂模式被广泛应用于Bean的创建和管理，可以方便地实现依赖注入和面向接口编程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;抽象工厂模式（Abstract Factory Pattern）是一种创建型设计模式，旨在为客户端提供一个接口，用于创建相关或依赖对象的家族</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
</feed>
