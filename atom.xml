<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YZ</title>
  
  <subtitle>这是一名小学生</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-10-28T15:34:44.945Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>YZ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/"/>
    <id>http://example.com/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/</id>
    <published>2022-10-28T15:29:34.881Z</published>
    <updated>2022-10-28T15:34:44.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第13章-事务基础知识"><a href="#第13章-事务基础知识" class="headerlink" title="第13章_事务基础知识"></a>第13章_事务基础知识</h1><h2 id="1-数据库事务概述"><a href="#1-数据库事务概述" class="headerlink" title="1. 数据库事务概述"></a>1. 数据库事务概述</h2><h3 id="1-1-存储引擎支持情况"><a href="#1-1-存储引擎支持情况" class="headerlink" title="1.1 存储引擎支持情况"></a>1.1 存储引擎支持情况</h3><p><code>SHOW ENGINES</code> 命令来查看当前 MySQL 支持的存储引擎都有哪些，以及这些存储引擎是否支持事务。</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220708124306444.png" alt="image-20220708124306444"></p><p>能看出在 MySQL 中，只有InnoDB 是支持事务的。</p><h3 id="1-2-基本概念"><a href="#1-2-基本概念" class="headerlink" title="1.2 基本概念"></a>1.2 基本概念</h3><p><strong>事务：</strong>一组逻辑操作单元，使数据从一种状态变换到另一种状态。</p><p><strong>事务处理的原则：</strong>保证所有事务都作为 <code>一个工作单元</code> 来执行，即使出现了故障，都不能改变这种执行方 式。当在一个事务中执行多个操作时，要么所有的事务都被提交( <code>commit</code> )，那么这些修改就 <code>永久</code> 地保 <code>存下来</code>；要么数据库管理系统将 <code>放弃</code> 所作的所有 <code>修改</code> ，整个事务回滚( rollback )到最初状态。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 案例：AA用户给BB用户转账100</span><br><span class="line">update account set money = money - 100 where name = &#x27;AA&#x27;;</span><br><span class="line"># 服务器宕机</span><br><span class="line">update account set money = money + 100 where name = &#x27;BB&#x27;;</span><br></pre></td></tr></table></figure><h3 id="1-3-事物的ACID特性"><a href="#1-3-事物的ACID特性" class="headerlink" title="1.3 事物的ACID特性"></a>1.3 事物的ACID特性</h3><ul><li><strong>原子性（atomicity）：</strong></li></ul><p>原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。即要么转账成功，要么转账失败，是不存在中间的状态。如果无法保证原子性会怎么样？就会出现数据不一致的情形，A账户减去100元，而B账户增加100元操作失败，系统将无故丢失100元。</p><ul><li><strong>一致性（consistency）：</strong></li></ul><p>（国内很多网站上对一致性的阐述有误，具体你可以参考 Wikipedia 对Consistency的阐述）</p><p>根据定义，一致性是指事务执行前后，数据从一个 <code>合法性状态</code> 变换到另外一个 <code>合法性状态</code> 。这种状态是 <code>语义上</code> 的而不是语法上的，跟具体的业务有关。</p><p>那什么是合法的数据状态呢？满足 <code>预定的约束</code> 的状态就叫做合法的状态。通俗一点，这状态是由你自己来定义的（比如满足现实世界中的约束）。满足这个状态，数据就是一致的，不满足这个状态，数据就 是不一致的！如果事务中的某个操作失败了，系统就会自动撤销当前正在执行的事务，返回到事务操作之前的状态。</p><p><strong>举例1：</strong>A账户有200元，转账300元出去，此时A账户余额为-100元。你自然就发现此时数据是不一致的，为什么呢？因为你定义了一个状态，余额这列必须&gt;=0。</p><p><strong>举例2：</strong>A账户有200元，转账50元给B账户，A账户的钱扣了，但是B账户因为各种意外，余额并没有增加。你也知道此时的数据是不一致的，为什么呢？因为你定义了一个状态，要求A+B的总余额必须不变。</p><p><strong>举例3：</strong>在数据表中我们将<code>姓名</code>字段设置为<code>唯一性约束</code>，这时当事务进行提交或者事务发生回滚的时候，如果数据表的姓名不唯一，就破坏了事物的一致性要求。</p><ul><li><strong>隔离型（isolation）：</strong></li></ul><p>事务的隔离性是指一个事务的执行<code>不能被其他事务干扰</code>，即一个事务内部的操作及使用的数据对<code>并发</code>的其他事务是隔离的，并发执行的各个事务之间不能相互干扰。</p><p>如果无法保证隔离性会怎么样？假设A账户有200元，B账户0元。A账户往B账户转账两次，每次金额为50 元，分别在两个事务中执行。如果无法保证隔离性，会出现下面的情形：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE accounts SET money = money - 50 WHERE NAME = &#x27;AA&#x27;;</span><br><span class="line">UPDATE accounts SET money = money + 50 WHERE NAME = &#x27;BB&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220708164610193.png" alt="image-20220708164610193"></p><p><strong>持久性（durability）：</strong></p><p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是<code>永久性的</code> ，接下来的其他操作和数据库 故障不应该对其有任何影响。</p><p>持久性是通过 <code>事务日志</code> 来保证的。日志包括了 <code>重做日志</code> 和 <code>回滚日志</code> 。当我们通过事务对数据进行修改 的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。</p><blockquote><p>总结</p><p>ACID是事务的四大特征，在这四个特性中，原子性是基础，隔离性是手段，一致性是约束条件， 而持久性是我们的目的。</p><p>数据库事务，其实就是数据库设计者为了方便起见，把需要保证<code>原子性</code>、<code>隔离性</code>、<code>一致性</code>和<code>持久性</code>的一个或多个数据库操作称为一个事务。</p></blockquote><h3 id="1-4-事务的状态"><a href="#1-4-事务的状态" class="headerlink" title="1.4 事务的状态"></a>1.4 事务的状态</h3><p>我们现在知道 <code>事务</code> 是一个抽象的概念，它其实对应着一个或多个数据库操作，MySQL根据这些操作所执行的不同阶段把 <code>事务</code> 大致划分成几个状态：</p><ul><li><p><strong>活动的（active）</strong></p><p>事务对应的数据库操作正在执行过程中时，我们就说该事务处在 <code>活动的</code> 状态。</p></li><li><p><strong>部分提交的（partially committed）</strong></p><p>当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并 <code>没有刷新到磁盘</code> 时，我们就说该事务处在 <code>部分提交的</code> 状态。</p></li><li><p><strong>失败的（failed）</strong></p><p>当事务处在 <code>活动的</code> 或者<code>部分提交的</code>状态时，可能遇到了某些错误（数据库自身的错误、操作系统 错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在 <code>失败的</code>状态。</p></li><li><p><strong>中止的（aborted）</strong></p><p>如果事务执行了一部分而变为 <code>失败的</code> 状态，那么就需要把已经修改的事务中的操作还原到事务执行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为 <code>回滚</code> 。当 <code>回滚</code> 操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了 <code>中止的</code> 状态。</p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE accounts SET money = money - 50 WHERE NAME = &#x27;AA&#x27;;</span><br><span class="line"></span><br><span class="line">UPDATE accounts SET money = money + 50 WHERE NAME = &#x27;BB&#x27;;</span><br></pre></td></tr></table></figure></li><li><p><strong>提交的（committed）</strong></p><p>当一个处在 <code>部分提交的</code> 状态的事务将修改过的数据都 <code>同步到磁盘</code> 上之后，我们就可以说该事务处在了 <code>提交的</code> 状态。</p><p>一个基本的状态转换图如下所示：</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220708171859055.png" alt="image-20220708171859055" style="zoom:80%;"></p><p>图中可见，只有当事物处于<code>提交的</code>或者<code>中止的</code>状态时，一个事务的生命周期才算是结束了。对于已经提交的事务来说，该事务对数据库所做的修改将永久生效，对于处于中止状态的事物，该事务对数据库所做的所有修改都会被回滚到没执行该事物之前的状态。</p></li></ul><h2 id="2-如何使用事务"><a href="#2-如何使用事务" class="headerlink" title="2. 如何使用事务"></a>2. 如何使用事务</h2><p>使用事务有两种方式，分别为 <code>显式事务</code> 和 <code>隐式事务</code> 。</p><h3 id="2-1-显式事务"><a href="#2-1-显式事务" class="headerlink" title="2.1 显式事务"></a>2.1 显式事务</h3><p><strong>步骤1：</strong> START TRANSACTION 或者 BEGIN ，作用是显式开启一个事务。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; BEGIN;</span><br><span class="line">#或者</span><br><span class="line">mysql&gt; START TRANSACTION;</span><br></pre></td></tr></table></figure><p><code>START TRANSACTION</code> 语句相较于 <code>BEGIN</code> 特别之处在于，后边能跟随几个 <code>修饰符</code> ：</p><p>① <code>READ ONLY</code> ：标识当前事务是一个 <code>只读事务</code> ，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。</p><blockquote><p>补充：只读事务中只是不允许修改那些其他事务也能访问到的表中的数据，对于临时表来说（我们使用 CREATE TMEPORARY TABLE 创建的表），由于它们只能再当前会话中可见，所有只读事务其实也是可以对临时表进行增、删、改操作的。</p></blockquote><p>② <code>READ WRITE</code> ：标识当前事务是一个 <code>读写事务</code> ，也就是属于该事务的数据库操作既可以读取数据， 也可以修改数据。</p><p>③ <code>WITH CONSISTENT SNAPSHOT</code> ：启动一致性读。</p><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">START TRANSACTION READ ONLY; # 开启一个只读事务</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">START TRANSACTION READ ONLY, WITH CONSISTENT SNAPSHOT # 开启只读事务和一致性读</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">START TRANSACTION READ WRITE, WITH CONSISTENT SNAPSHOT # 开启读写事务和一致性读</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>READ ONLY</code>和<code>READ WRITE</code>是用来设置所谓的事物<code>访问模式</code>的，就是以只读还是读写的方式来访问数据库中的数据，一个事务的访问模式不能同时即设置为<code>只读</code>的也设置为<code>读写</code>的，所以不能同时把<code>READ ONLY</code>和<code>READ WRITE</code>放到<code>START TRANSACTION</code>语句后边。</li><li>如果我们不显式指定事务的访问模式，那么该事务的访问模式就是<code>读写</code>模式</li></ul><p><strong>步骤2：</strong>一系列事务中的操作（主要是DML，不含DDL）</p><p><strong>步骤3：</strong>提交事务 或 中止事务（即回滚事务）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 提交事务。当提交事务后，对数据库的修改是永久性的。</span><br><span class="line">mysql&gt; COMMIT;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 回滚事务。即撤销正在进行的所有没有提交的修改</span><br><span class="line">mysql&gt; ROLLBACK;</span><br><span class="line"></span><br><span class="line"># 将事务回滚到某个保存点。</span><br><span class="line">mysql&gt; ROLLBACK TO [SAVEPOINT]</span><br></pre></td></tr></table></figure><p>其中关于SAVEPOINT相关操作有：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在事务中创建保存点，方便后续针对保存点进行回滚。一个事务中可以存在多个保存点。</span><br><span class="line">SAVEPOINT 保存点名称;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 删除某个保存点</span><br><span class="line">RELEASE SAVEPOINT 保存点名称;</span><br></pre></td></tr></table></figure><h3 id="2-2-隐式事务"><a href="#2-2-隐式事务" class="headerlink" title="2.2 隐式事务"></a>2.2 隐式事务</h3><p>MySQL中有一个系统变量 <code>autocommit</code> ：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;autocommit&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| autocommit    |  ON   |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>当然，如果我们想关闭这种 <code>自动提交</code> 的功能，可以使用下边两种方法之一：</p><ul><li><p>显式的的使用 <code>START TRANSACTION</code> 或者 <code>BEGIN</code> 语句开启一个事务。这样在本次事务提交或者回滚前会暂时关闭掉自动提交的功能。</p></li><li><p>把系统变量 <code>autocommit</code> 的值设置为 <code>OFF</code> ，就像这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET autocommit = OFF;</span><br><span class="line">#或</span><br><span class="line">SET autocommit = 0;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3-隐式提交数据的情况"><a href="#2-3-隐式提交数据的情况" class="headerlink" title="2.3 隐式提交数据的情况"></a>2.3 隐式提交数据的情况</h3><ul><li><p>数据定义语言（Data definition language，缩写为：DDL）</p><p>数据库对象，指的就是<code>数据库、表、视图、存储过程</code>等结构。当我们<code>CREATE、ALTER、DROP</code>等语句去修改数据库对象时，就会隐式的提交前边语句所属于的事物。即：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">SELECT ... # 事务中的一条语句</span><br><span class="line">UPDATE ... # 事务中的一条语句</span><br><span class="line">... # 事务中的其他语句</span><br><span class="line"></span><br><span class="line">CREATE TABLE ... # 此语句会隐式的提交前边语句所属于的事务</span><br></pre></td></tr></table></figure></li><li><p>隐式使用或修改mysql数据库中的表</p><p>当我们使用<code>ALTER USER</code>、<code>CREATE USER</code>、<code>DROP USER</code>、<code>GRANT</code>、<code>RENAME USER</code>、<code>REVOKE</code>、<code>SET PASSWORD</code>等语句时也会隐式的提交前边语句所属于的事务。</p></li><li><p>事务控制或关于锁定的语句</p><p>① 当我们在一个事务还没提交或者回滚时就又使用 START TRANSACTION 或者 BEGIN 语句开启了另一个事务时，会隐式的提交上一个事务。即：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">SELECT ... # 事务中的一条语句</span><br><span class="line">UPDATE ... # 事务中的一条语句</span><br><span class="line">... # 事务中的其他语句</span><br><span class="line"></span><br><span class="line">BEGIN; # 此语句会隐式的提交前边语句所属于的事务</span><br></pre></td></tr></table></figure><p>② 当前的 autocommit 系统变量的值为 OFF ，我们手动把它调为 ON 时，也会 隐式的提交前边语句所属的事务。</p><p>③ 使用 LOCK TABLES 、 UNLOCK TABLES 等关于锁定的语句也会 隐式的提交 前边语句所属的事务。</p></li><li><p>加载数据的语句</p><p>使用<code>LOAD DATA</code>语句来批量往数据库中导入数据时，也会<code>隐式的提交</code>前边语句所属的事务。</p></li><li><p>关于MySQL复制的一些语句</p><p>使用<code>START SLAVE、STOP SLAVE、RESET SLAVE、CHANGE MASTER TO</code>等语句会隐式的提交前边语句所属的事务</p></li><li><p>其他的一些语句</p><p>使用<code>ANALYZE TABLE、CACHE INDEX、CAECK TABLE、FLUSH、LOAD INDEX INTO CACHE、OPTIMIZE TABLE、REPAIR TABLE、RESET</code>等语句也会隐式的提交前边语句所属的事务。</p></li></ul><h3 id="2-4-使用举例1：提交与回滚"><a href="#2-4-使用举例1：提交与回滚" class="headerlink" title="2.4 使用举例1：提交与回滚"></a>2.4 使用举例1：提交与回滚</h3><p>我们看下在 MySQL 的默认状态下，下面这个事务最后的处理结果是什么。</p><p><strong>情况1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE user(name varchar(20), PRIMARY KEY (name)) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">BEGIN;</span><br><span class="line">INSERT INTO user SELECT &#x27;张三&#x27;;</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">BEGIN;</span><br><span class="line">INSERT INTO user SELECT &#x27;李四&#x27;;</span><br><span class="line">INSERT INTO user SELECT &#x27;李四&#x27;;</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">SELECT * FROM user;</span><br></pre></td></tr></table></figure><p>运行结果（1 行数据）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; commit;</span><br><span class="line">Query OK, 0 rows affected (0.00 秒)</span><br><span class="line"></span><br><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 秒)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO user SELECT &#x27;李四&#x27;;</span><br><span class="line">Query OK, 1 rows affected (0.00 秒)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO user SELECT &#x27;李四&#x27;;</span><br><span class="line">Duplicate entry &#x27;李四&#x27; for key &#x27;user.PRIMARY&#x27;</span><br><span class="line">mysql&gt; ROLLBACK;</span><br><span class="line">Query OK, 0 rows affected (0.01 秒)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from user;</span><br><span class="line">+--------+</span><br><span class="line">| name   |</span><br><span class="line">+--------+</span><br><span class="line">| 张三    |</span><br><span class="line">+--------+</span><br><span class="line">1 行于数据集 (0.01 秒)</span><br></pre></td></tr></table></figure><p><strong>情况2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE user (name varchar(20), PRIMARY KEY (name)) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">BEGIN;</span><br><span class="line">INSERT INTO user SELECT &#x27;张三&#x27;;</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">INSERT INTO user SELECT &#x27;李四&#x27;;</span><br><span class="line">INSERT INTO user SELECT &#x27;李四&#x27;;</span><br><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure><p>运行结果（2 行数据）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM user;</span><br><span class="line">+--------+</span><br><span class="line">| name   |</span><br><span class="line">+--------+</span><br><span class="line">| 张三    |</span><br><span class="line">| 李四    |</span><br><span class="line">+--------+</span><br><span class="line">2 行于数据集 (0.01 秒)</span><br></pre></td></tr></table></figure><p><strong>情况3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE user(name varchar(255), PRIMARY KEY (name)) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">SET @@completion_type = 1;</span><br><span class="line">BEGIN;</span><br><span class="line">INSERT INTO user SELECT &#x27;张三&#x27;;</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">INSERT INTO user SELECT &#x27;李四&#x27;;</span><br><span class="line">INSERT INTO user SELECT &#x27;李四&#x27;;</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">SELECT * FROM user;</span><br></pre></td></tr></table></figure><p>运行结果（1 行数据）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM user;</span><br><span class="line">+--------+</span><br><span class="line">| name   |</span><br><span class="line">+--------+</span><br><span class="line">| 张三    |</span><br><span class="line">+--------+</span><br><span class="line">1 行于数据集 (0.01 秒)</span><br></pre></td></tr></table></figure><p>你能看到相同的sQL代码，只是在事务开始之前设置了SET @@completion_type = 1;，结果就和我们第一次处理的一样，只有一个“张三”。这是为什么呢?<br>这里我讲解下MySQL中completion_type参数的作用，实际上这个参数有3种可能:</p><ol><li><code>completion=0</code>，这是<code>默认情况</code>。当我们执行COMMIT的时候会提交事务，在执行下一个事务时，还需要使用<code>START TRANSACTION</code>或者<code>BEGIN</code>来开启。</li><li><code>ompletion=1</code>，这种情况下，当我们提交事务后，相当于执行了<code>COMMIT AND CHAIN</code>，也就是开启一个链式事务，即当我们提交事务之后会开启一个相同隔离级别的事务。</li><li><code>completion=2</code>，这种情况下<code>OMMIT=COMMIT AND RELEASE</code>，也就是当我们提交后，会自动与服务器断开连接。</li></ol><blockquote><p>当我们设置 autocommit=0 时，不论是否采用 START TRANSACTION 或者 BEGIN 的方式来开启事 务，都需要用 COMMIT 进行提交，让事务生效，使用 ROLLBACK 对事务进行回滚。</p><p>当我们设置 autocommit=1 时，每条 SQL 语句都会自动进行提交。 不过这时，如果你采用 START TRANSACTION 或者 BEGIN 的方式来显式地开启事务，那么这个事务只有在 COMMIT 时才会生效， 在 ROLLBACK 时才会回滚。</p></blockquote><h3 id="2-5-使用举例2：测试不支持事务的engine"><a href="#2-5-使用举例2：测试不支持事务的engine" class="headerlink" title="2.5 使用举例2：测试不支持事务的engine"></a>2.5 使用举例2：测试不支持事务的engine</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test1(i INT) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">CREATE TABLE test2(i INT) ENGINE=MYISAM;</span><br></pre></td></tr></table></figure><p>针对于InnoDB表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">INSERT INTO test1 VALUES(1);</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">SELECT * FROM test1;</span><br></pre></td></tr></table></figure><p>结果：没有数据</p><p>针对于MYISAM表：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">INSERT INTO test1 VALUES(1);</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">SELECT * FROM test2;</span><br></pre></td></tr></table></figure><p>结果：有一条数据</p><h3 id="2-6-使用举例3：SAVEPOINT"><a href="#2-6-使用举例3：SAVEPOINT" class="headerlink" title="2.6 使用举例3：SAVEPOINT"></a>2.6 使用举例3：SAVEPOINT</h3><p>创建表并添加数据：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE account(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">NAME VARCHAR(15),</span><br><span class="line">balance DECIMAL(10,2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO account(NAME,balance)</span><br><span class="line">VALUES</span><br><span class="line">(&#x27;张三&#x27;,1000),</span><br><span class="line">(&#x27;李四&#x27;,1000);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">UPDATE account SET balance = balance - 100 WHERE NAME = &#x27;张三&#x27;;</span><br><span class="line">UPDATE account SET balance = balance - 100 WHERE NAME = &#x27;张三&#x27;;</span><br><span class="line">SAVEPOINT s1; # 设置保存点</span><br><span class="line">UPDATE account SET balance = balance + 1 WHERE NAME = &#x27;张三&#x27;;</span><br><span class="line">ROLLBACK TO s1; # 回滚到保存点</span><br></pre></td></tr></table></figure><p>结果：张三：800.00</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure><p>结果：张三：1000.00</p><h2 id="3-事务隔离级别"><a href="#3-事务隔离级别" class="headerlink" title="3. 事务隔离级别"></a>3. 事务隔离级别</h2><p>MySQL是一个 <code>客户端／服务器</code> 架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每 个客户端与服务器连接上之后，就可以称为一个会话（ <code>Session</code> ）。每个客户端都可以在自己的会话中 向服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是对于服务器来说可能同时处理多个事务。事务有 <code>隔离性</code> 的特性，理论上在某个事务 <code>对某个数据进行访问</code> 时，其他事务应该进行<code>排队</code> ，当该事务提交之后，其他事务才可以继续访问这个数据。但是这样对 <code>性能影响太大</code> ，我们既想保持事务的隔离性，又想让服务器在处理访问同一数据的多个事务时 <code>性能尽量高些</code> ，那就看二者如何权衡取 舍了。</p><h3 id="3-1-数据准备"><a href="#3-1-数据准备" class="headerlink" title="3.1 数据准备"></a>3.1 数据准备</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE student (</span><br><span class="line">    studentno INT,</span><br><span class="line">    name VARCHAR(20),</span><br><span class="line">    class varchar(20),</span><br><span class="line">    PRIMARY KEY (studentno)</span><br><span class="line">) Engine=InnoDB CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>然后向这个表里插入一条数据：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO student VALUES(1, &#x27;小谷&#x27;, &#x27;1班&#x27;);</span><br></pre></td></tr></table></figure><p>现在表里的数据就是这样的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student;</span><br><span class="line">+-----------+--------+-------+</span><br><span class="line">| studentno | name   | class |</span><br><span class="line">+-----------+--------+-------+</span><br><span class="line">|      1    |   小谷  | 1班   |</span><br><span class="line">+-----------+--------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="3-2-数据并发问题"><a href="#3-2-数据并发问题" class="headerlink" title="3.2 数据并发问题"></a>3.2 数据并发问题</h3><p>针对事务的隔离性和并发性，我们怎么做取舍呢？先看一下访问相同数据的事务在 不保证串行执行 （也 就是执行完一个再执行另一个）的情况下可能会出现哪些问题：</p><p><strong>1. 脏写（ Dirty Write ）</strong></p><p>对于两个事务 Session A、Session B，如果事务Session A <code>修改了</code> 另一个 <code>未提交</code> 事务Session B <code>修改过</code> 的数据，那就意味着发生了 <code>脏写</code>，示意图如下：</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220708214453902.png" alt="image-20220708214453902"></p><p>Session A 和 Session B 各开启了一个事务，Sesssion B 中的事务先将studentno列为1的记录的name列更新为’李四’，然后Session A中的事务接着又把这条studentno列为1的记录的name列更新为’张三’。如果之后Session B中的事务进行了回滚，那么Session A中的更新也将不复存在，这种现象称之为脏写。这时Session A中的事务就没有效果了，明明把数据更新了，最后也提交事务了，最后看到的数据什么变化也没有。这里大家对事务的隔离性比较了解的话，会发现默认隔离级别下，上面Session A中的更新语句会处于等待状态，这里只是跟大家说明一下会出现这样的现象。</p><p><strong>2. 脏读（ Dirty Read ）</strong></p><p> 对于两个事务 Session A、Session B，Session A <code>读取</code> 了已经被 Session B <code>更新</code> 但还 <code>没有被提交</code> 的字段。 之后若 Session B <code>回滚</code> ，Session A <code>读取</code>的内容就是 <code>临时且无效</code> 的。</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220708215109480.png" alt="image-20220708215109480"></p><p>Session A和Session B各开启了一个事务，Session B中的事务先将studentno列为1的记录的name列更新 为’张三’，然后Session A中的事务再去查询这条studentno为1的记录，如果读到列name的值为’张三’，而 Session B中的事务稍后进行了回滚，那么Session A中的事务相当于读到了一个不存在的数据，这种现象就称之为 <code>脏读</code> 。</p><p><strong>3. 不可重复读（ Non-Repeatable Read ）</strong></p><p>对于两个事务Session A、Session B，Session A <code>读取</code>了一个字段，然后 Session B <code>更新</code>了该字段。 之后 Session A <code>再次读取</code> 同一个字段， <code>值就不同</code> 了。那就意味着发生了不可重复读。</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220708215626435.png" alt="image-20220708215626435"></p><p>我们在Session B中提交了几个 <code>隐式事务</code> （注意是隐式事务，意味着语句结束事务就提交了），这些事务 都修改了studentno列为1的记录的列name的值，每次事务提交之后，如果Session A中的事务都可以查看到最新的值，这种现象也被称之为 <code>不可重复读</code>。</p><p><strong>4. 幻读（ Phantom ）</strong></p><p>对于两个事务Session A、Session B, Session A 从一个表中 <code>读取</code> 了一个字段, 然后 Session B 在该表中 <code>插入</code>了一些新的行。 之后, 如果 Session A <code>再次读取</code> 同一个表, 就会多出几行。那就意味着发生了<code>幻读</code>。</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220708220102342.png" alt="image-20220708220102342"></p><p>Session A中的事务先根据条件 studentno &gt; 0这个条件查询表student，得到了name列值为’张三’的记录； 之后Session B中提交了一个 <code>隐式事务</code> ，该事务向表student中插入了一条新记录；之后Session A中的事务 再根据相同的条件 studentno &gt; 0查询表student，得到的结果集中包含Session B中的事务新插入的那条记 录，这种现象也被称之为 幻读 。我们把新插入的那些记录称之为 <code>幻影记录</code> 。</p><p><strong>注意1:</strong><br>有的同学会有疑问，那如果SessionB中<code>删除了</code>一些符合<code>studentno &gt;0</code>的记录而不是插入新记录，那Session A之后再根据<code>studentno &gt; 0</code>的条件读取的<code>记录变少了</code>，这种现象算不算幻读呢?这种现象不属于<code>幻读</code>，幻读强调的是一个事务按照某个<code>相同条件多次读取</code>记录时，后读取时读到了之前<code>没有读到的记录</code>。</p><p><strong>注意2:</strong><br>那对于先前已经读到的记录，之后又读取不到这种情况，算啥呢?这相当于对每一条记录都发生了<code>不可重复读</code>的现象。幻读只是重点强调了读取到了之前读取没有获取到的记录。</p><h3 id="3-3-SQL中的四种隔离级别"><a href="#3-3-SQL中的四种隔离级别" class="headerlink" title="3.3 SQL中的四种隔离级别"></a>3.3 SQL中的四种隔离级别</h3><p>上面介绍了几种并发事务执行过程中可能遇到的一些问题，这些问题有轻重缓急之分，我们给这些问题按照严重性来排一下序：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读</span><br></pre></td></tr></table></figure><p>我们愿意舍弃一部分隔离性来换取一部分性能在这里就体现在：设立一些隔离级别，隔离级别越低，并发问题发生的就越多。 <code>SQL标准</code> 中设立了4个 <code>隔离级别</code> ：</p><ul><li><code>READ UNCOMMITTED</code> ：读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结 果。不能避免脏读、不可重复读、幻读。 </li><li><code>READ COMMITTED</code> ：读已提交，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做 的改变。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可 重复读、幻读问题仍然存在。 </li><li><code>REPEATABLE READ</code> ：可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提 交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍 然存在。这是MySQL的默认隔离级别。 </li><li><code>SERIALIZABLE</code> ：可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止 其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避 免脏读、不可重复读和幻读。</li></ul><p><code>SQL标准</code> 中规定，针对不同的隔离级别，并发事务可以发生不同严重程度的问题，具体情况如下：</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220708220917267.png" alt="image-20220708220917267"></p><p><code>脏写</code>怎么没涉及到？因为脏写这个问题太严重了，不论是哪种隔离级别，都不允许脏写的情况发生。</p><p>不同的隔离级别有不同的现象，并有不同的锁和并发机制，隔离级别越高，数据库的并发性能就越差，4 种事务隔离级别与并发性能的关系如下：</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220708220957108.png" alt="image-20220708220957108" style="zoom:80%;"></p><h3 id="3-4-MySQL支持的四种隔离级别"><a href="#3-4-MySQL支持的四种隔离级别" class="headerlink" title="3.4 MySQL支持的四种隔离级别"></a>3.4 MySQL支持的四种隔离级别</h3><p>不同的数据库厂商对SQL标准中规定的四种隔离级别支持不一样。比如,<code>Oracle</code>就只支持<code>READ COMMITTED（默认隔离级别）</code>和<code>SERIALIZABLE隔离级别</code>。MySQL虽然支持4种隔离级别，但与sQL标准中所规定的各级隔离级别允许发生的问题却有些出入，MySQL在REPEATABLE READ隔离级别下，是可以禁止幻读问题的发生的，禁止幻读的原因我们在第16章讲解。</p><p>MySQL的默认隔离级别为REPEATABLE READ，我们可以手动修改一下事务的隔离级别。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看隔离级别，MySQL 5.7.20的版本之前：</span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;tx_isolation&#x27;;</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| Variable_name | Value           |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| tx_isolation  | REPEATABLE-READ |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"># MySQL 5.7.20版本之后，引入transaction_isolation来替换tx_isolation</span><br><span class="line"></span><br><span class="line"># 查看隔离级别，MySQL 5.7.20的版本及之后：</span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;transaction_isolation&#x27;;</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| Variable_name         | Value           |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| transaction_isolation | REPEATABLE-READ |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">1 row in set (0.02 sec)</span><br><span class="line"></span><br><span class="line">#或者不同MySQL版本中都可以使用的：</span><br><span class="line">SELECT @@transaction_isolation;</span><br></pre></td></tr></table></figure><h3 id="3-5-如何设置事务的隔离级别"><a href="#3-5-如何设置事务的隔离级别" class="headerlink" title="3.5 如何设置事务的隔离级别"></a>3.5 如何设置事务的隔离级别</h3><p><strong>通过下面的语句修改事务的隔离级别：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL 隔离级别;</span><br><span class="line">#其中，隔离级别格式：</span><br><span class="line">&gt; READ UNCOMMITTED</span><br><span class="line">&gt; READ COMMITTED</span><br><span class="line">&gt; REPEATABLE READ</span><br><span class="line">&gt; SERIALIZABLE</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET [GLOBAL|SESSION] TRANSACTION_ISOLATION = &#x27;隔离级别&#x27;</span><br><span class="line">#其中，隔离级别格式：</span><br><span class="line">&gt; READ-UNCOMMITTED</span><br><span class="line">&gt; READ-COMMITTED</span><br><span class="line">&gt; REPEATABLE-READ</span><br><span class="line">&gt; SERIALIZABLE</span><br></pre></td></tr></table></figure><p><strong>关于设置时使用GLOBAL或SESSION的影响：</strong></p><ul><li><p>使用 GLOBAL 关键字（在全局范围影响）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line">#或</span><br><span class="line">SET GLOBAL TRANSACTION_ISOLATION = &#x27;SERIALIZABLE&#x27;;</span><br></pre></td></tr></table></figure><p>则：</p><ul><li>当前已经存在的会话无效</li><li>只对执行完该语句之后产生的会话起作用</li></ul></li><li><p>使用 <code>SESSION</code> 关键字（在会话范围影响）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line">#或</span><br><span class="line">SET SESSION TRANSACTION_ISOLATION = &#x27;SERIALIZABLE&#x27;;</span><br></pre></td></tr></table></figure><p>则：</p><ul><li>对当前会话的所有后续的事务有效</li><li>如果在事务之间执行，则对后续的事务有效</li><li>该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务</li></ul></li></ul><p>如果在服务器启动时想改变事务的默认隔离级别，可以修改启动参数<code>transaction_isolation</code>的值。比如，在启动服务器时指定了<code>transaction_isolation=SERIALIZABLE</code>，那么事务的默认隔离界别就从原来的<code>REPEATABLE-READ</code>变成了<code>SERIALIZABLE</code>。</p><blockquote><p>小结： </p><p>数据库规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱。</p></blockquote><h3 id="3-6-不同隔离级别举例"><a href="#3-6-不同隔离级别举例" class="headerlink" title="3.6 不同隔离级别举例"></a>3.6 不同隔离级别举例</h3><p>初始化数据：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TRUNCATE TABLE account;</span><br><span class="line">INSERT INTO account VALUES (1,&#x27;张三&#x27;,&#x27;100&#x27;), (2,&#x27;李四&#x27;,&#x27;0&#x27;);</span><br></pre></td></tr></table></figure><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220708223250773.png" alt="image-20220708223250773" style="float:left;"></p><p><strong>演示1. 读未提交之脏读</strong></p><p>设置隔离级别为未提交读：</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220710193920008.png" alt="image-20220710193920008"></p><p>脏读就是指当前事务就在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问了这个数据，然后使用了这个数据。</p><p><strong>演示2：读已提交</strong></p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220710194440101.png" alt="image-20220710194440101"></p><p><strong>演示3. 不可重复读</strong></p><p>设置隔离级别为可重复读，事务的执行流程如下：</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220710194144826.png" alt="image-20220710194144826"></p><p>当我们将当前会话的隔离级别设置为可重复读的时候，当前会话可以重复读，就是每次读取的结果集都相同，而不管其他事务有没有提交。但是在可重复读的隔离级别上会出现幻读的问题。</p><p><strong>演示4：幻读</strong></p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220710194042096.png" alt="image-20220710194042096"></p><p>这里要灵活的<code>理解读取</code>的意思，第一次select是读取，第二次的insert其实也属于隐式的读取，只不过是在mysql的机制中读取的，插入数据也是要先读取一下有没有主键冲突才能决定是否执行插入。</p><p>幻读，并不是说两次读取获取的结果集不同，幻读侧重的方面是某一次的select操作得到的结果所表征的数据状态无法支撑后续的业务操作。更为具体一些: select某记录是否存在，不存在，准备插入此记录，但执行insert时发现此记录已存在，无法插入，此时就发生了幻读。</p><p>在RR隔离级别下，step1、step2是会正常执行的，step3则会报错主键冲突对于事务1的业务来说是执行失败的，这里事务1就是发生了幻读，因为事务1在step1中读取的数据状态并不能支撑后续的业务操作，事务1:“见鬼了，我刚才读到的结果应该可以支持我这样操作才对啊，为什么现在不可以”。事务1不敢相信的又执行了step4，发现和setp1读取的结果是一样的(RR下的MVCC机制)。此时，幻读无疑已经发生，事务1无论读取多少次，都查不到id=3的记录，但它的确无法插入这条他通过读取来认定不存在的记录（此数据已被事务2插入)，对于事务1来说，它幻读了。</p><p>其实RR也是可以避免幻读的，通过对select操作手动加<code>行X锁(独占锁)</code> (SELECT … FOR UPDATE这也正是SERIALIZABLE隔离级别下会隐式为你做的事情)。同时，即便当前记录不存在，比如id =3是不存在的，当前事务也会获得一把记录锁（因为InnoDB的行锁锁定的是索引，故记录实体存在与否没关系，存在就加<code>行X锁</code>，不存在就加<code>间隙锁</code>），其他事务则无法插入此索引的记录，故杜绝了幻读。</p><p>在 <code>SERIALIZABLE</code>隔离级别下，step1执行时是会隐式的添加<code>行(X)锁</code>/ <code>gap(X)</code>锁的，从而step2会被阻塞，step3 会正常执行，待事务1提交后，事务2才能继续执行（主键冲突执行失败)，对于事务1来说业务是正确的，成功的阻塞扼杀了扰乱业务的事务2，对于事务1来说他前期读取的结果是可以支撑其后续业务的。</p><p>所以MySQL的幻读并非什么读取两次返回结果集不同，而是事务在插入事先检测不存在的记录时，惊奇的发现这些数据已经存在了，之前的检测读获取到的数据如同鬼影一般。</p><h2 id="4-事务的常见分类"><a href="#4-事务的常见分类" class="headerlink" title="4. 事务的常见分类"></a>4. 事务的常见分类</h2><p>从事务理论的角度来看，可以把事务分为以下几种类型：</p><ul><li>扁平事务（Flat Transactions） </li><li>带有保存点的扁平事务（Flat Transactions with Savepoints） </li><li>链事务（Chained Transactions） </li><li>嵌套事务（Nested Transactions） </li><li>分布式事务（Distributed Transactions）</li></ul><h1 id="第14章-MySQL事务日志"><a href="#第14章-MySQL事务日志" class="headerlink" title="第14章_MySQL事务日志"></a>第14章_MySQL事务日志</h1><p>事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？</p><ul><li>事务的隔离性由 <code>锁机制</code> 实现。</li><li>而事务的原子性、一致性和持久性由事务的 redo 日志和undo 日志来保证。<ul><li>REDO LOG 称为 <code>重做日志</code>，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。</li><li>UNDO LOG 称为 <code>回滚日志</code> ，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。</li></ul></li></ul><p>有的DBA或许会认为 UNDO 是 REDO 的逆过程，其实不然。REDO 和 UNDO都可以视为是一种 <code>恢复操作</code>，但是：</p><ul><li>redo log: 是存储引擎层 (innodb) 生成的日志，记录的是<code>&quot;物理级别&quot;</code>上的页修改操作，比如页号xxx，偏移量yyy写入了’zzz’数据。主要为了保证数据的可靠性。</li><li>undo log: 是存储引擎层 (innodb) 生成的日志，记录的是 <code>逻辑操作</code> 日志，比如对某一行数据进行了INSERT语句操作，那么undo log就记录一条与之相反的DELETE操作。主要用于 <code>事务的回滚</code> (undo log 记录的是每个修改操作的 <code>逆操作</code>) 和 <code>一致性非锁定读</code> (undo log 回滚行记录到某种特定的版本——MVCC，即多版本并发控制)。</li></ul><h2 id="1-redo日志"><a href="#1-redo日志" class="headerlink" title="1. redo日志"></a>1. redo日志</h2><p>InnoDB存储引擎是以<code>页为单位</code>来管理存储空间的。在真正访问页面之前，需要把在<code>磁盘上</code>的页缓存到内存中的<code>Buffer Pool</code>之后才可以访问。所有的变更都必须<code>先更新缓冲池</code>中的数据，然后缓冲池中的<code>脏页</code>会以一定的频率被刷入磁盘 (<code>checkPoint</code>机制)，通过缓冲池来优化CPU和磁盘之间的鸿沟，这样就可以保证整体的性能不会下降太快。</p><h3 id="1-1-为什么需要REDO日志"><a href="#1-1-为什么需要REDO日志" class="headerlink" title="1.1 为什么需要REDO日志"></a>1.1 为什么需要REDO日志</h3><p>一方面，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然 而由于checkpoint <code>并不是每次变更的时候就触发</code> 的，而是master线程隔一段时间去处理的。所以最坏的情 况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。</p><p>另一方面，事务包含 <code>持久性</code> 的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。</p><p>那么如何保证这个持久性呢？ <code>一个简单的做法</code> ：在事务提交完成之前把该事务所修改的所有页面都刷新 到磁盘，但是这个简单粗暴的做法有些问题:</p><ul><li><p><strong>修改量与刷新磁盘工作量严重不成比例</strong></p><p>有时候我们仅仅修改了某个页面中的一个字节，但是我们知道在InnoDB中是以页为单位来进行磁盘IO的，也就是说我们在该事务提交时不得不将一个完整的页面从内存中刷新到磁盘，我们又知道一个默认页面时16KB大小，只修改一个字节就要刷新16KB的数据到磁盘上显然是小题大做了。</p></li><li><p><strong>随机IO刷新较慢</strong></p><p>一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，假如该事务修改的这些页面可能并不相邻，这就意味着在将某个事务修改的Buffer Pool中的页面<code>刷新到磁盘</code>时，需要进行很多的<code>随机IO</code>，随机IO比顺序IO要慢，尤其对于传统的机械硬盘来说。</p></li></ul><p><code>另一个解决的思路</code> ：我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系 统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内 存中修改过的全部页面刷新到磁盘，只需要把 修改 了哪些东西 记录一下 就好。比如，某个事务将系统 表空间中 第10号 页面中偏移量为 100 处的那个字节的值 1 改成 2 。我们只需要记录一下：将第0号表 空间的10号页面的偏移量为100处的值更新为 2 </p><p>InnoDB引擎的事务采用了WAL技术 (<code>Write-Ahead Logging</code>)，这种技术的思想就是先写日志，再写磁盘，只有日志写入成功，才算事务提交成功，这里的日志就是redo log。当发生宕机且数据未刷到磁盘的时候，可以通过redo log来恢复，保证ACID中的D，这就是redo log的作用。</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220710202517977.png" alt="image-20220710202517977"></p><h3 id="1-2-REDO日志的好处、特点"><a href="#1-2-REDO日志的好处、特点" class="headerlink" title="1.2 REDO日志的好处、特点"></a>1.2 REDO日志的好处、特点</h3><h4 id="1-好处"><a href="#1-好处" class="headerlink" title="1. 好处"></a>1. 好处</h4><ul><li>redo日志降低了刷盘频率 </li><li>redo日志占用的空间非常小</li></ul><p>存储表空间ID、页号、偏移量以及需要更新的值，所需的存储空间是很小的，刷盘快。</p><h4 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h4><ul><li><p><strong>redo日志是顺序写入磁盘的</strong></p><p>在执行事务的过程中，每执行一条语句，就可能产生若干条redo日志，这些日志是按照<code>产生的顺序写入磁盘的</code>，也就是使用顺序ID，效率比随机IO快。</p></li><li><p><strong>事务执行过程中，redo log不断记录</strong></p><p>redo log跟bin log的区别，redo log是<code>存储引擎层</code>产生的，而bin log是<code>数据库层</code>产生的。假设一个事务，对表做10万行的记录插入，在这个过程中，一直不断的往redo log顺序记录，而bin log不会记录，直到这个事务提交，才会一次写入到bin log文件中。</p></li></ul><h3 id="1-3-redo的组成"><a href="#1-3-redo的组成" class="headerlink" title="1.3 redo的组成"></a>1.3 redo的组成</h3><p>Redo log可以简单分为以下两个部分：</p><ul><li><code>重做日志的缓冲 (redo log buffer)</code> ，保存在内存中，是易失的。</li></ul><p>在服务器启动时就会向操作系统申请了一大片称之为 redo log buffer 的 <code>连续内存</code> 空间，翻译成中文就是redo日志缓冲区。这片内存空间被划分为若干个连续的<code>redo log block</code>。一个redo log block占用<code>512字节</code>大小。</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220710204114543.png" alt="image-20220710204114543"></p><p><strong>参数设置：innodb_log_buffer_size：</strong></p><p>redo log buffer 大小，默认 <code>16M</code> ，最大值是4096M，最小值为1M。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%innodb_log_buffer_size%&#x27;;</span><br><span class="line">+------------------------+----------+</span><br><span class="line">| Variable_name          | Value    |</span><br><span class="line">+------------------------+----------+</span><br><span class="line">| innodb_log_buffer_size | 16777216 |</span><br><span class="line">+------------------------+----------+</span><br></pre></td></tr></table></figure><ul><li><code>重做日志文件 (redo log file)</code>，保存在硬盘中，是持久的。</li></ul><p>REDO日志文件如图所示，其中<code>ib_logfile0</code>和<code>ib_logfile1</code>即为REDO日志。</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220710204427616.png" alt="image-20220710204427616"></p><h3 id="1-4-redo的整体流程"><a href="#1-4-redo的整体流程" class="headerlink" title="1.4 redo的整体流程"></a>1.4 redo的整体流程</h3><p>以一个更新事务为例，redo log 流转过程，如下图所示：</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220710204810264-16574572910841.png" alt="image-20220710204810264"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝</span><br><span class="line">第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值</span><br><span class="line">第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加写的方式</span><br><span class="line">第4步：定期将内存中修改的数据刷新到磁盘中</span><br></pre></td></tr></table></figure><blockquote><p>体会： Write-Ahead Log(预先日志持久化)：在持久化一个数据页之前，先将内存中相应的日志页持久化。</p></blockquote><h3 id="1-5-redo-log的刷盘策略"><a href="#1-5-redo-log的刷盘策略" class="headerlink" title="1.5 redo log的刷盘策略"></a>1.5 redo log的刷盘策略</h3><p>redo log的写入并不是直接写入磁盘的，InnoDB引擎会在写redo log的时候先写redo log buffer，之后以<code>一 定的频率</code>刷入到真正的redo log file 中。这里的一定频率怎么看待呢？这就是我们要说的刷盘策略。</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220710205015302.png" alt="image-20220710205015302"></p><p>注意，redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到 <code>文件系统缓存 （page cache）</code>中去（这是现代操作系统为了提高文件写入效率做的一个优化），真正的写入会交给系统自己来决定（比如page cache足够大了）。那么对于InnoDB来说就存在一个问题，如果交给系统来同 步，同样如果系统宕机，那么数据也丢失了（虽然整个系统宕机的概率还是比较小的）。</p><p>针对这种情况，InnoDB给出 <code>innodb_flush_log_at_trx_commit</code> 参数，该参数控制 commit提交事务 时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略：</p><ul><li><code>设置为0</code> ：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日 志的同步） 第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝 第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值 第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加 写的方式 第4步：定期将内存中修改的数据刷新到磁盘中 </li><li><code>设置为1</code> ：表示每次事务提交时都将进行同步，刷盘操作（ 默认值 ） </li><li><code>设置为2</code> ：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自 己决定什么时候同步到磁盘文件。</li></ul><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220710205948156.png" alt="image-20220710205948156" style="float:left;"></p><p>另外，InnoDB存储引擎有一个后台线程，每隔<code>1秒</code>，就会把<code>redo log buffer</code>中的内容写到文件系统缓存(<code>page cache</code>)，然后调用刷盘操作。</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220710210339724.png" alt="image-20220710210339724"></p><p>也就是说，一个没有提交事务的<code>redo log</code>记录，也可能会刷盘。因为在事务执行过程 redo log 记录是会写入 <code>redo log buffer</code>中，这些redo log 记录会被<code>后台线程</code>刷盘。</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220710210532805.png" alt="image-20220710210532805"></p><p>除了后台线程每秒<code>1次</code>的轮询操作，还有一种情况，当<code>redo log buffer</code>占用的空间即将达到<code>innodb_log_buffer_size</code>（这个参数默认是16M）的一半的时候，后台线程会主动刷盘。</p><h3 id="1-6-不同刷盘策略演示"><a href="#1-6-不同刷盘策略演示" class="headerlink" title="1.6 不同刷盘策略演示"></a>1.6 不同刷盘策略演示</h3><h4 id="1-流程图"><a href="#1-流程图" class="headerlink" title="1. 流程图"></a>1. 流程图</h4><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220710210751414.png" alt="image-20220710210751414" style="float:left;"></p><blockquote><p>小结: innodb_flush_log_at_trx_commit=1</p><p>为1时，只要事务提交成功,<code>redo log</code>记录就一定在硬盘里，不会有任何数据丢失。</p><p>如果事务执行期间<code>MySQL</code>挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。可以保证ACID的D，数据绝对不会丢失，但是<code>效率最差</code>的。</p><p>建议使用默认值，虽然操作系统宕机的概率理论小于数据库宕机的概率，但是一般既然使用了事务，那么数据的安全相对来说更重要些。</p></blockquote><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220710211335379.png" alt="image-20220710211335379" style="float:left;"></p><blockquote><p>小结innodb_flush_log_at_trx_commit=2</p><p>为<code>2</code>时，只要事务提交成功,<code>redo log buffer</code>中的内容只写入文件系统缓存（ <code>page cache</code>) 。</p><p>如果仅仅只是<code>MySQL</code>挂了不会有任何数据丢失，但是操作系统宕机可能会有<code>1</code>秒数据的丢失，这种情况下无法满足ACID中的D。但是数值2肯定是效率最高的。</p></blockquote><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220710211831675.png" alt="image-20220710211831675" style="float:left;"></p><blockquote><p>小结: innodb_flush_log_at_trx_commit=0</p><p>为<code>0</code>时,master thread中每1秒进行一次重做日志的fsync操作，因此实例crash最多丢失1秒钟内的事务。( master thread是负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性)</p><p>数值0的话，是一种折中的做法，它的IO效率理论是高于1的，低于2的，这种策略也有丢失数据的风险，也无法保证D。</p></blockquote><h4 id="2-举例"><a href="#2-举例" class="headerlink" title="2. 举例"></a>2. 举例</h4><p>比较innodb_flush_log_at_trx_commit对事务的影响。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_load(</span><br><span class="line">a INT,</span><br><span class="line">b CHAR(80)</span><br><span class="line">)ENGINE=INNODB;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER//</span><br><span class="line">CREATE PROCEDURE p_load(COUNT INT UNSIGNED)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE s INT UNSIGNED DEFAULT 1;</span><br><span class="line">DECLARE c CHAR(80) DEFAULT REPEAT(&#x27;a&#x27;,80);</span><br><span class="line">WHILE s&lt;=COUNT DO</span><br><span class="line">INSERT INTO test_load SELECT NULL, c;</span><br><span class="line">COMMIT;</span><br><span class="line">SET s=s+1;</span><br><span class="line">END WHILE;</span><br><span class="line">END //</span><br><span class="line">DELIMITER;</span><br></pre></td></tr></table></figure><p>存储过程代码中，每插入一条数据就进行一次显式的COMMIT操作。在默认的设置下，即参数innodb_flush_log_at_trx_commit为1的情况下，InnoDB存储引擎会将重做日志缓冲中的日志写入文件，并调用一次fsync操作。</p><p>执行命令CALL p_load (30000)，向表中插入3万行的记录，并执行3万次的fsync操作。在默认情况下所需的时间:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CALL p_load(30000);</span><br><span class="line">Query OK, 0 rows affected(1 min 23 sec)</span><br></pre></td></tr></table></figure><p><code>1 min 23 sec</code>的时间显然是不能接受的。而造成时间比较长的原因就在于fsync操作所需要的时间。</p><p>修改参数innodb_flush_log_at_trx_commit，设置为0：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; set global innodb_flush_log_at_trx_commit = 0;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CALL p_load(30000);</span><br><span class="line">Query OK, 0 rows affected(38 sec)</span><br></pre></td></tr></table></figure><p>修改参数innodb_flush_log_at_trx_commit，设置为2：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; set global innodb_flush_log_at_trx_commit = 2;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CALL p_load(30000);</span><br><span class="line">Query OK, 0 rows affected(46 sec)</span><br></pre></td></tr></table></figure><p>而形成这个现象的主要原因是:后者大大减少了fsync的次数，从而提高了数据库执行的性能。</p><p>下表显示了在innodb_flush_log_at_trx_commit的不同设置下，调用存储过程p_load插入3万行记录所需的时间:</p><div class="table-container"><table><thead><tr><th>innodb_flush_log_at_trx_commit</th><th>执行所用的时间</th></tr></thead><tbody><tr><td>0</td><td>38.709秒</td></tr><tr><td>1</td><td>1分23秒</td></tr><tr><td>2</td><td>46.016秒</td></tr></tbody></table></div><blockquote><p>虽然用户可以通过设置参数innodb_flush_log_at_trx_commit为0或2来提高事务提交的性能，但需清楚，这种设置方法丧失了事务的ACID特性。</p></blockquote><h3 id="1-7-写入redo-log-buffer-过程"><a href="#1-7-写入redo-log-buffer-过程" class="headerlink" title="1.7 写入redo log buffer 过程"></a>1.7 写入redo log buffer 过程</h3><h4 id="1-补充概念：Mini-Transaction"><a href="#1-补充概念：Mini-Transaction" class="headerlink" title="1. 补充概念：Mini-Transaction"></a>1. 补充概念：Mini-Transaction</h4><p>MySQL把对底层页面中的一次原子访问过程称之为一个<code>Mini-Transaction</code>，简称<code>mtr</code>，比如，向某个索引对应的B+树中插入一条记录的过程就是一个<code>Mini-Transaction</code>。一个所谓的<code>mtr</code>可以包含一组redo日志，在进行崩溃恢复时这一组<code>redo</code>日志可以作为一个不可分割的整体。</p><p>一个事务可以包含若干条语句，每一条语句其实是由若干个 <code>mtr</code> 组成，每一个 <code>mtr</code> 又可以包含若干条 redo日志，画个图表示它们的关系就是这样：</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220710220653131.png" alt="image-20220710220653131"></p><h4 id="2-redo-日志写入log-buffer"><a href="#2-redo-日志写入log-buffer" class="headerlink" title="2. redo 日志写入log buffer"></a>2. redo 日志写入log buffer</h4><p>向<code>log buffer</code>中写入redo日志的过程是顺序的，也就是先往前边的block中写，当该block的空闲空间用完之后再往下一个block中写。当我们想往<code>log buffer</code>中写入redo日志时，第一个遇到的问题就是应该写在哪个<code>block</code>的哪个偏移量处，所以工<code>InoDB</code>的设计者特意提供了一个称之为<code>buf_free</code>的全局变量，该变量指明后续写入的redo日志应该写入到<code>log buffer</code>中的哪个位置，如图所示:</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220710220919271.png" alt="image-20220710220919271"></p><p>一个mtr执行过程中可能产生若干条redo日志，<code>这些redo日志是一个不可分割的组</code>，所以其实并不是每生成一条redo日志，就将其插入到log buffer中，而是每个mtr运行过程中产生的日志先暂时存到一个地方，当该mtr结束的时候，将过程中产生的一组redo日志再全部复制到log buffer中。我们现在假设有两个名为<code>T1</code>、<code>T2</code>的事务，每个事务都包含2个mtr，我们给这几个mtr命名一下:</p><ul><li>事务<code>T1</code>的两个<code>mtr</code>分别称为<code>mtr_T1_1</code>和<code>mtr_T1_2</code>。</li><li>事务<code>T2</code>的两个<code>mtr</code>分别称为<code>mtr_T2_1</code>和<code>mtr_T2_2</code>。</li></ul><p>每个mtr都会产生一组redo日志，用示意图来描述一下这些mtr产生的日志情况:</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220710221318271.png" alt="image-20220710221318271"></p><p>不同的事务可能是 <code>并发</code> 执行的，所以 T1 、 T2 之间的 mtr 可能是 <code>交替执行</code> 的。没当一个mtr执行完成时，伴随该mtr生成的一组redo日志就需要被复制到log buffer中，也就是说不同事务的mtr可能是交替写入log buffer的，我们画个示意图（为了美观，我们把一个mtr中产生的所有redo日志当做一个整体来画）：</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220710221620291.png" alt="image-20220710221620291"></p><p>有的mtr产生的redo日志量非常大，比如<code>mtr_t1_2</code>产生的redo日志占用空间比较大，占用了3个block来存储。</p><h4 id="3-redo-log-block的结构图"><a href="#3-redo-log-block的结构图" class="headerlink" title="3. redo log block的结构图"></a>3. redo log block的结构图</h4><p>一个redo log block是由<code>日志头、日志体、日志尾</code>组成。日志头占用12字节，日志尾占用8字节，所以一个block真正能存储的数据是512-12-8=492字节。</p><blockquote><p><strong>为什么一个block设计成512字节?</strong><br>这个和磁盘的扇区有关，机械磁盘默认的扇区就是512字节，如果你要写入的数据大于512字节，那么要与人的扇区肯定不止一个，这时就要涉及到盘片的转动，找到下一个扇区，假设现在需要与人两个扇区A利5，刘果扇区A写入成功，而扇区B写入失败，那么就会出现<code>非原子性</code>的写入，而如果每次只写入和扇区的大小一样<br>的512字节，那么每次的写入都是原子性的。</p></blockquote><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220710223135374.png" alt="image-20220710223135374"></p><p>真正的redo日志都是存储到占用<code>496</code>字节大小的<code>log block body</code>中，图中的<code>log block header</code>和<code>log block trailer</code>存储的是一些管理信息。我们来看看这些所谓<code>管理信息</code>都有什么。</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220711144546439.png" alt="image-20220711144546439"></p><ul><li><code>log block header</code>的属分别如下:<ul><li><code>LOG_BLOCK_HDR_NO</code> : log buffer是由log block组成，在内部log buffer就好似一个数组，因此LOG_BLOCK_HDR_NO用来标记这个数组中的位置。其是递增并且循环使用的，占用4个字节，但是由于第一位用来判断是否是flush bit，所以最大的值为2G。</li><li><code>LOG_BLOCK_HDR_DATA_LEN</code>:表示block中已经使用了多少字节，初始值为<code>12</code>(因为<code>log block body</code>从第12个字节处开始)。随着往block中写入的redo日志越来也多，本属性值也跟着增长。如果<code>log block body</code>已经被全部写满，那么本属性的值被设置为<code>512</code>。</li><li><code>LOG_BLOCK_FIRST_REC_GROUP</code>:一条redo日志也可以称之为一条redo日志记录(redo log record)，一个mtr会生产多条redo日志记录，这些redo日志记录被称之为一个redo日志记录组（(redo log record group)。LOG_BLOCK_FIRST_REC_GROUP就代表该block中第一个mtr生成的redo日志记录组的偏移量(其实也就是这个block里第一个mtr生成的第一条redo日志的偏移量)。如果该值的大小和LOG_BLOCK_HDR_DATA_LEN相同，则表示当前log block不包含新的日志。</li><li><code>LOG_BLOCK_CHECKPOINT_NO</code>:占用4字节，表示该log block最后被写入时的<code>checkpoint</code>。</li></ul></li><li><code>log block trailer</code>中属性的意思如下:<ul><li><code>LOG_BLOCK_CHECKSUM</code>:表示block的校验值，用于正确性校验〈其值和LOG_BLOCK_HDR_NO相同)，我们暂时不关心它。</li></ul></li></ul><h3 id="1-8-redo-log-file"><a href="#1-8-redo-log-file" class="headerlink" title="1.8 redo log file"></a>1.8 redo log file</h3><h4 id="1-相关参数设置"><a href="#1-相关参数设置" class="headerlink" title="1. 相关参数设置"></a>1. 相关参数设置</h4><ul><li><p><code>innodb_log_group_home_dir</code> ：指定 redo log 文件组所在的路径，默认值为 <code>./</code> ，表示在数据库 的数据目录下。MySQL的默认数据目录（ <code>var/lib/mysql</code>）下默认有两个名为 <code>ib_logfile0</code> 和 <code>ib_logfile1</code> 的文件，log buffer中的日志默认情况下就是刷新到这两个磁盘文件中。此redo日志 文件位置还可以修改。</p></li><li><p><code>innodb_log_files_in_group</code>：指明redo log file的个数，命名方式如：ib_logfile0，iblogfile1… iblogfilen。默认2个，最大100个。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;innodb_log_files_in_group&#x27;;</span><br><span class="line">+---------------------------+-------+</span><br><span class="line">| Variable_name             | Value |</span><br><span class="line">+---------------------------+-------+</span><br><span class="line">| innodb_log_files_in_group | 2     |</span><br><span class="line">+---------------------------+-------+</span><br><span class="line">#ib_logfile0</span><br><span class="line">#ib_logfile1</span><br></pre></td></tr></table></figure></li><li><p><code>innodb_flush_log_at_trx_commit</code>：控制 redo log 刷新到磁盘的策略，默认为1。</p></li><li><p><code>innodb_log_file_size</code>：单个 redo log 文件设置大小，默认值为 <code>48M</code> 。最大值为512G，注意最大值 指的是整个 redo log 系列文件之和，即（innodb_log_files_in_group * innodb_log_file_size ）不能大 于最大值512G。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;innodb_log_file_size&#x27;;</span><br><span class="line">+----------------------+----------+</span><br><span class="line">| Variable_name        | Value    |</span><br><span class="line">+----------------------+----------+</span><br><span class="line">| innodb_log_file_size | 50331648 |</span><br><span class="line">+----------------------+----------+</span><br></pre></td></tr></table></figure></li></ul><p>根据业务修改其大小，以便容纳较大的事务。编辑my.cnf文件并重启数据库生效，如下所示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/my.cnf</span><br><span class="line">innodb_log_file_size=200M</span><br></pre></td></tr></table></figure><blockquote><p>在数据库实例更新比较频繁的情况下，可以适当加大 redo log 数组和大小。但也不推荐 redo log 设置过大，在MySQL崩溃时会重新执行REDO日志中的记录。</p></blockquote><h4 id="2-日志文件组"><a href="#2-日志文件组" class="headerlink" title="2. 日志文件组"></a>2. 日志文件组</h4><p>从上边的描述中可以看到，磁盘上的<code>redo</code>日志文件不只一个，而是以一个<code>日志文件组</code>的形式出现的。这些文件以<code>ib_logfile[数字]</code>（<code>数字</code>可以是<code>0</code>、<code>1</code>、<code>2.</code>..）的形式进行命名，每个的redo日志文件大小都是一样的。</p><p>在将redo日志写入日志文件组时，是从<code>ib_logfile0</code>开始写，如果<code>ib_logfile1</code>写满了，就接着<code>ib_logfile1</code>写。同理, <code>ib_logfile1</code>写满了就去写<code>ib_logfile2</code>，依此类推。如果写到最后一个文件该咋办?那就重新转到<code>ib_logfile0</code>继续写，所以整个过程如下图所示:</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220711152242300.png" alt="image-20220711152242300"></p><p>总共的redo日志文件大小其实就是： <code>innodb_log_file_size × innodb_log_files_in_group</code> 。</p><p>采用循环使用的方式向redo日志文件组里写数据的话，会导致后写入的redo日志覆盖掉前边写的redo日志？当然！所以InnoDB的设计者提出了checkpoint的概念。</p><h4 id="3-checkpoint"><a href="#3-checkpoint" class="headerlink" title="3. checkpoint"></a>3. checkpoint</h4><p>在整个日志文件组中还有两个重要的属性，分别是 write pos、checkpoint</p><ul><li><code>write pos</code>是当前记录的位置，一边写一边后移</li><li><code>checkpoint</code>是当前要擦除的位置，也是往后推移</li></ul><p>每次刷盘 redo log 记录到日志文件组中，write pos 位置就会后移更新。每次MySQL加载日志文件组恢复数据时，会清空加载过的 redo log 记录，并把check point后移更新。write pos 和 checkpoint 之间的还空着的部分可以用来写入新的 redo log 记录。</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220711152631108.png" alt="image-20220711152631108" style="zoom:80%;"></p><p>如果 write pos 追上 checkpoint ，表示<code>日志文件组</code>满了，这时候不能再写入新的 redo log记录，MySQL 得 停下来，清空一些记录，把 checkpoint 推进一下。</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220711152802294.png" alt="image-20220711152802294" style="zoom:80%;"></p><h3 id="1-9-redo-log-小结"><a href="#1-9-redo-log-小结" class="headerlink" title="1.9 redo log 小结"></a>1.9 redo log 小结</h3><p>相信大家都知道redo log的作用和它的刷盘时机、存储形式:</p><p><strong>InnoDB的更新操作采用的是Write Ahead Log (预先日志持久化)策略，即先写日志，再写入磁盘。</strong></p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220711152930911.png" alt="image-20220711152930911" style="float:left;"></p><h2 id="2-Undo日志"><a href="#2-Undo日志" class="headerlink" title="2. Undo日志"></a>2. Undo日志</h2><p>redo log是事务持久性的保证，undo log是事务原子性的保证。在事务中 <code>更新数据</code> 的 <code>前置操作</code> 其实是要先写入一个 <code>undo log</code> 。</p><h3 id="2-1-如何理解Undo日志"><a href="#2-1-如何理解Undo日志" class="headerlink" title="2.1 如何理解Undo日志"></a>2.1 如何理解Undo日志</h3><p>事务需要保证 <code>原子性</code>，也就是事务中的操作要么全部完成，要么什么也不做。但有时候事务执行到一半会出现一些情况，比如：</p><ul><li>情况一：事务执行过程中可能遇到各种错误，比如<code>服务器本身的错误</code> ， <code>操作系统错误</code> ，甚至是突然 <code>断电</code> 导致的错误。</li><li>情况二：程序员可以在事务执行过程中手动输入 <code>ROLLBACK</code> 语句结束当前事务的执行。</li></ul><p>以上情况出现，我们需要把数据改回原先的样子，这个过程称之为 <code>回滚</code> ，这样就可以造成一个假象：这 个事务看起来什么都没做，所以符合 <code>原子性</code> 要求。</p><p>每当我们要对一条记录做改动时(这里的<code>改动</code>可以指<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>)，都需要”留一手”—-把回滚时所需的东西记下来。比如:</p><ul><li>你<code>插入一条记录</code>时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的<code>记录删掉</code>就好了。(对于每个INSERT,InnoDB存储引擎会完成一个DELETE)</li><li>你<code>删除了一条记录</code>，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录<code>插入</code>到表中就好了。(对于每个DELETE,InnoDB存储引擎会执行一个INSERT)</li><li>你<code>修改了一条记录</code>，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录<code>更新为旧值</code>就好了。(对于每个UPDATE，InnoDB存储引擎会执行一个相反的UPDATE，将修改前的行放回去)</li></ul><p>MysQL把这些为了回滚而记录的这些内容称之为<code>撤销日志</code>或者<code>回滚日志</code>(即<code>undo log</code>)。注意，由于查询操作( <code>SELECT</code>）并不会修改任何用户记录，所以在查询操作执行时，并<code>不需要记录</code>相应的undo日志。</p><p>此外，undo log 会产生<code>redo log</code>，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护。</p><h3 id="2-2-Undo日志的作用"><a href="#2-2-Undo日志的作用" class="headerlink" title="2.2 Undo日志的作用"></a>2.2 Undo日志的作用</h3><ul><li><strong>作用1：回滚数据</strong></li></ul><p>用户对undo日志可能<code>有误解</code>:undo用于将数据库物理地恢复到执行语句或事务之前的样子。但事实并非如此。undo是<code>逻辑日志</code>，因此只是将数据库逻辑地恢复到原来的样子。所有修改都被逻辑地取消了，但是数据结构和页本身在回滚之后可能大不相同。</p><p>这是因为在多用户并发系统中，可能会有数十、数百甚至数千个并发事务。数据库的主要任务就是协调对数据记录的并发访问。比如，一个事务在修改当前一个页中某几条记录，同时还有别的事务在对同一个页中另几条记录进行修改。因此，不能将一个页回滚到事务开始的样子，因为这样会影响其他事务正在进行的工作。</p><ul><li><strong>作用2：MVCC</strong></li></ul><p>undo的另一个作用是MVCC，即在InnoDB存储引擎中MVCC的实现是通过undo来完成。当用户读取一行记录时，若该记录以及被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取。</p><h3 id="2-3-undo的存储结构"><a href="#2-3-undo的存储结构" class="headerlink" title="2.3 undo的存储结构"></a>2.3 undo的存储结构</h3><h4 id="1-回滚段与undo页"><a href="#1-回滚段与undo页" class="headerlink" title="1. 回滚段与undo页"></a>1. 回滚段与undo页</h4><p>InnoDB对undo log的管理采用段的方式，也就是 <code>回滚段（rollback segment）</code> 。每个回滚段记录了 <code>1024</code> 个 <code>undo log segment</code> ，而在每个undo log segment段中进行 <code>undo页</code> 的申请。</p><ul><li>在<code>InnoDB1.1版本之前</code> （不包括1.1版本），只有一个rollback segment，因此支持同时在线的事务限制为 <code>1024</code> 。虽然对绝大多数的应用来说都已经够用。 </li><li>从1.1版本开始InnoDB支持最大 <code>128个rollback segment</code> ，故其支持同时在线的事务限制提高到 了 <code>128*1024</code> 。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;innodb_undo_logs&#x27;;</span><br><span class="line">+------------------+-------+</span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+------------------+-------+</span><br><span class="line">| innodb_undo_logs | 128   |</span><br><span class="line">+------------------+-------+</span><br></pre></td></tr></table></figure><p>虽然InnoDB1.1版本支持了128个rollback segment，但是这些rollback segment都存储于共享表空间ibdata中。从InnoDB1.2版本开始，可通过参数对rollback segment做进一步的设置。这些参数包括:</p><ul><li><code>innodb_undo_directory:</code>设置rollback segment文件所在的路径。这意味着rollback segment可以存放在共享表空间以外的位置，即可以设置为独立表空间。该参数的默认值为“./”表示当前InnoDB存储引擎的目录。</li><li><code>innodb_undo_logs</code> :设置rollback segment的个数，默认值为128。在InnoDB1.2版本中，该参数用来替换之<br>前版本的参数innodb_rollback_segments。</li><li><code>innodb_undo_tablespaces</code>:设置构成rollback segment文件的数量，这样rollback segment可以较为平均地分布在多个文件中。设置该参数后，会在路径innodb_undo_directory看到undo为前缀的文件，该文件就代表rollback segment文件。</li></ul><p>undo log 相关参数一般很少改动。</p><p><strong>undo页的重用</strong></p><p>当我们开启一个事务需要写undo log的时候，就得先去undo log segment中去找到一个空闲的位置，当有空位的时候，就去申请undo页，在这个申请到的undo页中进行undo log的写入。我们知道mysql默认一页的大小是16k。</p><p>为每一个事务分配一个页，是非常浪费的(除非你的事务非常长)，假设你的应用的TPS(每秒处理的事务数目）为1000，那么1s就需要100o个页，大概需要16M的存储，1分钟大概需要1G的存储。如果照这样下去除非MySQL清理的非常勤快，否则随着时间的推移，磁盘空间会增长的非常快，而且很多空间都是浪费的。</p><p>于是undo页就被设计的可以<code>重用</code>了，当事务提交时，并不会立刻删除undo页。因为重用，所以这个undo页可能混杂着其他事务的undo log。undo log在commit后，会被放到一个<code>链表</code>中，然后判断undo页的使用空间是否<code>小于3/4</code>，如果小于3/4的话，则表示当前的undo页可以被重用，那么它就不会被回收，其他事务的undo log可以记录在当前undo页的后面。由于undo log是<code>离散的</code>，所以清理对应的磁盘空间时，效率不高。</p><h4 id="2-回滚段与事务"><a href="#2-回滚段与事务" class="headerlink" title="2. 回滚段与事务"></a>2. 回滚段与事务</h4><ol><li><p>每个事务只会使用一个回滚段，一个回滚段在同一时刻可能会服务于多个事务。</p></li><li><p>当一个事务开始的时候，会制定一个回滚段，在事务进行的过程中，当数据被修改时，原始的数据会被复制到回滚段。</p></li><li><p>在回滚段中，事务会不断填充盘区，直到事务结束或所有的空间被用完。如果当前的盘区不够用，事务会在段中请求扩展下一个盘区，如果所有已分配的盘区都被用完，事务会覆盖最初的盘区或者在回滚段允许的情况下扩展新的盘区来使用。</p></li><li><p>回滚段存在于undo表空间中，在数据库中可以存在多个undo表空间，但同一时刻只能使用一个 undo表空间。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;innodb_undo_tablespaces&#x27;;</span><br><span class="line">+-------------------------+-------+</span><br><span class="line">| Variable_name           | Value |</span><br><span class="line">+-------------------------+-------+</span><br><span class="line">| innodb_undo_tablespaces | 2     |</span><br><span class="line">+-------------------------+-------+</span><br><span class="line"># undo log的数量，最少为2. undo log的truncate操作有purge协调线程发起。在truncate某个undo log表空间的过程中，保证有一个可用的undo log可用。</span><br></pre></td></tr></table></figure></li><li><p>当事务提交时，InnoDB存储引擎会做以下两件事情：</p><ul><li>将undo log放入列表中，以供之后的purge操作 </li><li>判断undo log所在的页是否可以重用，若可以分配给下个事务使用</li></ul></li></ol><h4 id="3-回滚段中的数据分类"><a href="#3-回滚段中的数据分类" class="headerlink" title="3. 回滚段中的数据分类"></a>3. 回滚段中的数据分类</h4><ol><li><code>未提交的回滚数据(uncommitted undo information)</code>：该数据所关联的事务并未提交，用于实现读一致性，所以该数据不能被其他事务的数据覆盖。</li><li><code>已经提交但未过期的回滚数据(committed undo information)</code>：该数据关联的事务已经提交，但是仍受到undo retention参数的保持时间的影响。</li><li><code>事务已经提交并过期的数据(expired undo information)</code>：事务已经提交，而且数据保存时间已经超过 undo retention参数指定的时间，属于已经过期的数据。当回滚段满了之后，就优先覆盖“事务已经提交并过期的数据”。</li></ol><p>事务提交后不能马上删除undo log及undo log所在的页。这是因为可能还有其他事务需要通过undo log来得到行记录之前的版本。故事务提交时将undo log放入一个链表中，是否可以最终删除undo log以undo log所在页由purge线程来判断。</p><h3 id="2-4-undo的类型"><a href="#2-4-undo的类型" class="headerlink" title="2.4 undo的类型"></a>2.4 undo的类型</h3><p>在InnoDB存储引擎中，undo log分为：</p><ul><li><p>insert undo log</p><p>insert undo log是指insert操作中产生的undo log。因为insert操作的记录，只对事务本身可见，对其他事务不可见（这是事务隔离性的要求），故该undo log可以在事务提交后直接删除。不需要进行purge操作。</p></li><li><p>update undo log</p><p>update undo log记录的是对delete和update操作产生的undo log。该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</p></li></ul><h3 id="2-5-undo-log的生命周期"><a href="#2-5-undo-log的生命周期" class="headerlink" title="2.5 undo log的生命周期"></a>2.5 undo log的生命周期</h3><h4 id="1-简要生成过程"><a href="#1-简要生成过程" class="headerlink" title="1. 简要生成过程"></a>1. 简要生成过程</h4><p>以下是undo+redo事务的简化过程</p><p>假设有两个数值，分别为A=1和B=2，然后将A修改为3，B修改为4</p><blockquote><ol><li>start transaction;</li><li>记录A=1到undo log;</li><li>update A = 3;</li><li>记录A=3到redo log;</li><li>记录B=2到undo log;</li><li>update B = 4;</li><li>记录B =4到redo log;</li><li>将redo log刷新到磁盘</li><li><ol><li>commit</li></ol></li></ol></blockquote><ul><li>在1-8步骤的任意一步系统宕机，事务未提交，该事务就不会对磁盘上的数据做任何影响。</li><li>如果在8-9之间宕机，恢复之后可以选择回滚，也可以选择继续完成事务提交，因为此时redo log已经持久化。</li><li>若在9之后系统宕机，内存映射中变更的数据还来不及刷回磁盘，那么系统恢复之后，可以根据redo log把数据刷回磁盘。</li></ul><p><strong>只有Buffer Pool的流程：</strong></p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220711162505008.png" alt="image-20220711162505008"></p><p><strong>有了Redo Log和Undo Log之后：</strong></p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220711162642305.png" alt="image-20220711162642305"></p><p>在更新Buffer Pool中的数据之前，我们需要先将该数据事务开始之前的状态写入Undo Log中。假设更新到一半出错了，我们就可以通过Undo Log来回滚到事务开始前。</p><h4 id="2-详细生成过程"><a href="#2-详细生成过程" class="headerlink" title="2. 详细生成过程"></a>2. 详细生成过程</h4><p>对于InnoDB引擎来说，每个行记录除了记录本身的数据之外，还有几个隐藏的列:</p><ul><li><code>DB_ROW_ID</code>:如果没有为表显式的定义主键，并且表中也没有定义唯一索引，那么InnoDB会自动为表添加一个row_id的隐藏列作为主键。</li><li><code>DB_TRX_ID</code>:每个事务都会分配一个事务ID，当对某条记录发生变更时<br>就会将这个事务的事务ID写入trx_id中。</li><li><code>DB_ROLL_PTR</code>:回滚指针，本质上就是指向undo log的指针。</li></ul><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220711162919157.png" alt="image-20220711162919157" style="float:left;"></p><p><strong>当我们执行INSERT时：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">INSERT INTO user (name) VALUES (&quot;tom&quot;);</span><br></pre></td></tr></table></figure><p>插入的数据都会生成一条insert undo log，并且数据的回滚指针会指向它。undo log会记录undo log的序号、插入主键的列和值…，那么在进行rollback的时候，通过主键直接把对应的数据删除即可。</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220711163725129.png" alt="image-20220711163725129"></p><p><strong>当我们执行UPDATE时：</strong></p><p>对应更新的操作会产生update undo log，并且会分更新主键和不更新主键的，假设现在执行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE user SET name=&quot;Sun&quot; WHERE id=1;</span><br></pre></td></tr></table></figure><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220711164138414.png" alt="image-20220711164138414"></p><p>这时会把老的记录写入新的undo log，让回滚指针指向新的undo log，它的undo no是1，并且新的undo log会指向老的undo log（undo no=0）。</p><p>假设现在执行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE user SET id=2 WHERE id=1;</span><br></pre></td></tr></table></figure><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220711164421494.png" alt="image-20220711164421494"></p><p>对于更新主键的操作，会先把原来的数据deletemark标识打开，这时并没有真正的删除数据，真正的删除会交给清理线程去判断，然后在后面插入一条新的数据，新的数据也会产生undo log，并且undo log的序号会递增。</p><p>可以发现每次对数据的变更都会产生一个undo log，当一条记录被变更多次时，那么就会产生多条undo log，undo log记录的是变更前的日志，并且每个undo log的序号是递增的，那么当要回滚的时候，按照序号<code>依次向前推</code>，就可以找到我们的原始数据了。</p><h4 id="3-undo-log是如何回滚的"><a href="#3-undo-log是如何回滚的" class="headerlink" title="3. undo log是如何回滚的"></a>3. undo log是如何回滚的</h4><p>以上面的例子来说，假设执行rollback，那么对应的流程应该是这样：</p><ol><li>通过undo no=3的日志把id=2的数据删除 </li><li>通过undo no=2的日志把id=1的数据的deletemark还原成0 </li><li>通过undo no=1的日志把id=1的数据的name还原成Tom </li><li>通过undo no=0的日志把id=1的数据删除</li></ol><h4 id="4-undo-log的删除"><a href="#4-undo-log的删除" class="headerlink" title="4. undo log的删除"></a>4. undo log的删除</h4><ul><li><p>针对于insert undo log</p><p>因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删除，不需要进行purge操作。</p></li><li><p>针对于update undo log</p><p>该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</p></li></ul><blockquote><p>补充：</p><p>purge线程两个主要作用是：<code>清理undo页</code>和<code>清理page里面带有Delete_Bit标识的数据行</code>。在InnoDB中，事务中的Delete操作实际上并不是真正的删除掉数据行，而是一种Delete Mark操作，在记录上标识Delete_Bit，而不删除记录。是一种“假删除”，只是做了个标记，真正的删除工作需要后台purge线程去完成。</p></blockquote><h3 id="2-6-小结"><a href="#2-6-小结" class="headerlink" title="2.6 小结"></a>2.6 小结</h3><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220711165612956.png" alt="image-20220711165612956"></p><p>undo log是逻辑日志，对事务回滚时，只是将数据库逻辑地恢复到原来的样子。</p><p>redo log是物理日志，记录的是数据页的物理变化，undo log不是redo log的逆过程。</p><h1 id="第15章-锁"><a href="#第15章-锁" class="headerlink" title="第15章_锁"></a>第15章_锁</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><code>锁</code>是计算机协调多个进程或线程<code>并发访问某一资源</code>的机制。在程序开发中会存在多线程同步的问题，当多个线程并发访问某个数据的时候，尤其是针对一些敏感的数据（比如订单、金额等)，我们就需要保证这个数据在任何时刻<code>最多只有一个线程</code>在访问，保证数据的<code>完整性</code>和<code>一致性</code>。在开发过程中加锁是为了保证数据的一致性，这个思想在数据库领域中同样很重要。</p><p>在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的 资源。为保证数据的一致性，需要对 <code>并发操作进行控制</code> ，因此产生了 <code>锁</code> 。同时 <code>锁机制</code> 也为实现MySQL 的各个隔离级别提供了保证。 <code>锁冲突</code> 也是影响数据库 <code>并发访问性能</code> 的一个重要因素。所以锁对数据库而言显得尤其重要，也更加复杂。</p><h2 id="2-MySQL并发事务访问相同记录"><a href="#2-MySQL并发事务访问相同记录" class="headerlink" title="2. MySQL并发事务访问相同记录"></a>2. MySQL并发事务访问相同记录</h2><p>并发事务访问相同记录的情况大致可以划分为3种：</p><h3 id="2-1-读-读情况"><a href="#2-1-读-读情况" class="headerlink" title="2.1 读-读情况"></a>2.1 读-读情况</h3><p><code>读-读</code>情况，即并发事务相继<code>读取相同的记录</code>。读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生。</p><h3 id="2-2-写-写情况"><a href="#2-2-写-写情况" class="headerlink" title="2.2 写-写情况"></a>2.2 写-写情况</h3><p><code>写-写</code> 情况，即并发事务相继对相同的记录做出改动。</p><p>在这种情况下会发生 <code>脏写</code> 的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们 <code>排队执行</code> ，这个排队的过程其实是通过 <code>锁</code> 来实现的。这个所谓的锁其实是一个内存中的结构 ，在事务执行前本来是没有锁的，也就是说一开始是没有 锁结构 和记录进 行关联的，如图所示：</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220711181120639.png" alt="image-20220711181120639"></p><p>当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的 <code>锁结构</code> ，当没有的时候 就会在内存中生成一个 <code>锁结构</code> 与之关联。比如，事务<code>T1</code> 要对这条记录做改动，就需要生成一个 <code>锁结构</code> 与之关联：</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220711192633239.png" alt="image-20220711192633239"></p><p>在<code>锁结构</code>里有很多信息，为了简化理解，只把两个比较重要的属性拿了出来：</p><ul><li><code>trx信息</code>：代表这个锁结构是哪个事务生成的。</li><li><code>is_waiting</code>：代表当前事务是否在等待。</li></ul><p>在事务<code>T1</code>改动了这条记录后，就生成了一个<code>锁结构</code>与该记录关联，因为之前没有别的事务为这条记录加锁，所以<code>is_waiting</code>属性就是<code>false</code>，我们把这个场景就称值为<code>获取锁成功</code>，或者<code>加锁成功</code>，然后就可以继续执行操作了。</p><p>在事务<code>T1</code>提交之前，另一个事务<code>T2</code>也想对该记录做改动，那么先看看有没有<code>锁结构</code>与这条记录关联，发现有一个<code>锁结构</code>与之关联后，然后也生成了一个锁结构与这条记录关联，不过锁结构的<code>is_waiting</code>属性值为<code>true</code>，表示当前事务需要等待，我们把这个场景就称之为<code>获取锁失败</code>，或者<code>加锁失败</code>，图示：</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220711193732567.png" alt="image-20220711193732567"></p><p>在事务T1提交之后，就会把该事务生成的<code>锁结构释放</code>掉，然后看看还有没有别的事务在等待获取锁，发现了事务T2还在等待获取锁，所以把事务T2对应的锁结构的<code>is_waiting</code>属性设置为<code>false</code>，然后把该事务对应的线程唤醒，让它继续执行，此时事务T2就算获取到锁了。效果就是这样。</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220711194904328.png" alt="image-20220711194904328"></p><p>小结几种说法：</p><ul><li><p>不加锁</p><p>意思就是不需要在内存中生成对应的 <code>锁结构</code> ，可以直接执行操作。</p></li><li><p>获取锁成功，或者加锁成功</p><p>意思就是在内存中生成了对应的 <code>锁结构</code> ，而且锁结构的 <code>is_waiting</code> 属性为 <code>false</code> ，也就是事务 可以继续执行操作。</p></li><li><p>获取锁失败，或者加锁失败，或者没有获取到锁</p><p>意思就是在内存中生成了对应的 <code>锁结构</code> ，不过锁结构的 <code>is_waiting</code> 属性为 <code>true</code> ，也就是事务需要等待，不可以继续执行操作。</p></li></ul><h3 id="2-3-读-写或写-读情况"><a href="#2-3-读-写或写-读情况" class="headerlink" title="2.3 读-写或写-读情况"></a>2.3 读-写或写-读情况</h3><p><code>读-写</code> 或 <code>写-读</code>，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生 <code>脏读 、 不可重复读 、 幻读</code> 的问题。</p><p>各个数据库厂商对 <code>SQL标准</code> 的支持都可能不一样。比如MySQL在 <code>REPEATABLE READ</code> 隔离级别上就已经解决了 <code>幻读</code> 问题。</p><h3 id="2-4-并发问题的解决方案"><a href="#2-4-并发问题的解决方案" class="headerlink" title="2.4 并发问题的解决方案"></a>2.4 并发问题的解决方案</h3><p>怎么解决 <code>脏读 、 不可重复读 、 幻读</code> 这些问题呢？其实有两种可选的解决方案：</p><ul><li>方案一：读操作利用多版本并发控制（ <code>MVCC</code> ，下章讲解），写操作进行 <code>加锁</code> 。</li></ul><p>所谓的<code>MVCC</code>，就是生成一个<code>ReadView</code>，通过ReadView找到符合条件的记录版本（历史版本由<code>undo日志</code>构建)。查询语句只能<code>读</code>到在生成ReadView之前<code>已提交事务所做的更改</code>，在生成ReadView之前未提交的事务或者之后才开启的事务所做的更改是看不到的。而<code>写操作</code>肯定针对的是<code>最新版本的记录</code>，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC时，<code>读-写</code>操作并不冲突。</p><blockquote><p>普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。</p><ul><li>在 <code>READ COMMITTED</code> 隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一 个ReadView，ReadView的存在本身就保证了<code>事务不可以读取到未提交的事务所做的更改</code> ，也就是避免了脏读现象；</li><li>在 <code>REPEATABLE READ</code> 隔离级别下，一个事务在执行过程中只有 <code>第一次执行SELECT操作</code> 才会生成一个ReadView，之后的SELECT操作都 <code>复用</code> 这个ReadView，这样也就避免了不可重复读和幻读的问题。</li></ul></blockquote><ul><li>方案二：读、写操作都采用 <code>加锁</code> 的方式。</li></ul><p>如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去<code>读取记录的最新版本</code>。比如，在银行存款的事务中，你需要先把账户的余额读出米，然厂有基本次左款事务执行完成，其他事务才可以访问账户的余额。读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成这样在读取记录的时候就需要对其进行<code>加锁</code>操作，这样也就意味着<code>读</code>操作和<code>写</code>操作也像<code>写-写</code>操作那样<code>排队</code>执行。</p><p><code>脏读</code>的产生是因为当前事务读取了另一个未提交事务写的一条记录，如果另一个事务在写记录的时候就给这条记录加锁，那么当前事务就无法继续读取该记录了，所以也就不会有脏读问题的产生了。</p><p><code>不可重复读</code>的产生是因为当前事务先读取一条记录，另外一个事务对该记录做了改动之后并提交之后，当前事务再次读取时会获得不同的值，如果在当前事务读取记录时就给该记录加锁，那么另一个事务就无法修改该记录，自然也不会发生不可重复读了。</p><p><code>幻读</code>问题的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了新记录，当前事务再次读取该范围的记录的发现了新插入的新记录。采用加锁的方式解决幻读问题就有一些麻烦，因为当前事务在第一次读取记录时幻影记录并不存在，所以读取的时候加锁就有点尴尬（因为你并不知道给谁加锁)。</p><ul><li><p>小结对比发现：</p><ul><li>采用 <code>MVCC</code> 方式的话， 读-写 操作彼此并不冲突， 性能更高 。</li><li>采用 <code>加锁</code> 方式的话， 读-写 操作彼此需要 <code>排队执行</code> ，影响性能。</li></ul><p>一般情况下我们当然愿意采用 <code>MVCC</code> 来解决 <code>读-写</code> 操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用 <code>加锁</code>的方式执行。下面就讲解下MySQL中不同类别的锁。</p></li></ul><h2 id="3-锁的不同角度分类"><a href="#3-锁的不同角度分类" class="headerlink" title="3. 锁的不同角度分类"></a>3. 锁的不同角度分类</h2><p>锁的分类图，如下：</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220711203519162.png" alt="image-20220711203519162"></p><h3 id="3-1-从数据操作的类型划分：读锁、写锁"><a href="#3-1-从数据操作的类型划分：读锁、写锁" class="headerlink" title="3.1 从数据操作的类型划分：读锁、写锁"></a>3.1 从数据操作的类型划分：读锁、写锁</h3><p>对于数据库中并发事务的<code>读-读</code>情况并不会引起什么问题。对于<code>写-写</code>、<code>读-写</code>或<code>写-读</code>这些情况可能会引起一些问题，需要使用<code>MVCC</code> 或者<code>加锁</code>的方式来解决它们。在使用<code>加锁</code>的方式解决问题时，由于既要允许<code>读-读</code>情况不受影响，又要使<code>写-写</code>、<code>读-写</code>或<code>写-读</code>情况中的操作<code>相互阻塞</code>，所以MySQL实现一个由两种类型的锁组成的锁系统来解决。这两种类型的锁通常被称为<strong>共享锁(Shared Lock，S Lock)</strong>和<strong>排他锁(Exclusive Lock，X Lock)</strong>，也叫<strong>读锁(readlock)</strong>和<strong>写锁(write lock)</strong>。</p><ul><li><code>读锁</code> ：也称为 <code>共享锁</code> 、英文用 S 表示。针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞的。</li><li><code>写锁</code> ：也称为 <code>排他锁</code> 、英文用 X 表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。</li></ul><p><strong>需要注意的是对于 InnoDB 引擎来说，读锁和写锁可以加在表上，也可以加在行上。</strong></p><p><strong>举例（行级读写锁)</strong>︰如果一个事务T1已经获得了某个行r的读锁，那么此时另外的一个事务T2是可以去获得这个行r的读锁的，因为读取操作并没有改变行r的数据;但是，如果呆个事方132怨趺付1·的司以，对U0等待事务T1、T2释放掉行r上的读锁才行。</p><p>总结:这里的兼容是指对同一张表或记录的锁的兼容性情况。</p><div class="table-container"><table><thead><tr><th></th><th>X锁</th><th>S锁</th></tr></thead><tbody><tr><td>X锁</td><td>不兼容</td><td>不兼容</td></tr><tr><td>S锁</td><td>不兼容</td><td><strong>兼容</strong></td></tr></tbody></table></div><h4 id="1-锁定读"><a href="#1-锁定读" class="headerlink" title="1. 锁定读"></a>1. 锁定读</h4><p>在采用<code>加锁</code>方式解决<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>这些问题时，读取一条记录时需要获取该记录的<code>S锁</code>，其实是不严谨的，有时候需要在读取记录时就获取记录的<code>X锁</code>，来禁止别的事务读写该记录，为此MySQL提出了两种比较特殊的<code>SELECT</code>语句格式:</p><ul><li><p>对读取的记录加<code>S锁</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT ... LOCK IN SHARE MODE;</span><br><span class="line">#或</span><br><span class="line">SELECT ... FOR SHARE;#(8.0新增语法)</span><br></pre></td></tr></table></figure><p>在普通的SELECT语句后边加<code>LOCK IN SHARE MODE</code>，如果当前事务执行了该语句，那么它会为读取到的记录加<code>S锁</code>，这样允许别的事务继续获取这些记录的<code>S锁</code>(比方说别的事务也使用<code>SELECT ... LOCK IN SHARE MODE</code> 语句来读取这些记录)，但是不能获取这些记录的<code>X锁</code>(比如使用<code>SELECT ... FOR UPDATE</code> 语句来读取这些记录，或者直接修改这些记录)。如果别的事务想要获取这些记录的<code>X锁</code>，那么它们会阻塞，直到当前事务提交之后将这些记录上的<code>S锁</code>释放掉。</p></li><li><p>对读取的记录加<code>X锁</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT ... FOR UPDATE;</span><br></pre></td></tr></table></figure><p>在普通的SELECT语句后边加<code>FOR UPDATE</code>，如果当前事务执行了该语句，那么它会为读取到的记录加<code>X锁</code>，这样既不允许别的事务获取这些记录的<code>S锁</code>(比方说别的事务使用<code>SELECT... LOCK IN SHARE MODE</code>语句来读取这些记录)，也不允许获取这些记录的<code>X锁</code>(比如使用<code>SELECT ..FOR UPDATE</code>语句来读取这些记录，或者直接修改这些记录)。如果别的事务想要获取这些记录的<code>S锁</code>或者<code>X锁</code>，那么它们会阻塞，直到当前事务提交之后将这些记录上的<code>X锁</code>释放掉。</p></li></ul><p>MySQL8.0新特性:</p><p>在5.7及之前的版本，SELECT … FOR UPDATE，如果获取不到锁，会一直等待，直到<code>innodb_lock_wait_timeout</code>超时。在8.0版本中，SELECT …FOR UPDATE，SELECT ..FOR SHARE添加<code>NOWAIT</code> 、<code>SKIP LOCKED</code>语法，跳过锁等待，或者跳过锁定。</p><ul><li>通过添加NOWAIT、SKIP LOCKED语法，能够立即返回。如果查询的行已经加锁:<ul><li>那么NOWAIT会立即报错返回</li><li>而SKIP LOCKED也会立即返回，只是返回的结果中不包含被锁定的</li></ul></li></ul><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220711214013208.png" alt="image-20220711214013208" style="float:left;"></p><h4 id="2-写操作"><a href="#2-写操作" class="headerlink" title="2. 写操作"></a>2. 写操作</h4><p>平常所用到的写操作无非是<code>DELETE</code>、<code>UPDATE</code>、<code>INSERT</code>这三种:</p><ul><li><p><code>DELETE</code>:<br>对一条记录做DELETE操作的过程其实是先在B+树中定位到这条记录的位置，然后获取这条记录的<code>X锁</code>，再执行<code>delete mark</code>操作。我们也可以把这个定位待删除记录在B+树中位置的过程看成是一个获取<code>X锁</code>的<code>锁定读</code>。</p></li><li><p><code>UPDATE</code>∶在对一条记录做UPDATE操作时分为三种情况:</p><ul><li><p>情况1:未修改该记录的键值，并且被更新的列占用的存储空间在修改前后未发生变化。<br>则先在<code>B+</code>树中定位到这条记录的位置，然后再获取一下记录的<code>X锁</code>，最后在原记录的位置进行修改操作。我们也可以把这个定位待修改记录在<code>B+</code>树中位置的过程看成是一个获取<code>X锁</code>的<code>锁定读</code>。</p></li><li><p>情况2∶未修改该记录的键值，并且至少有一个被更新的列占用的存储空间在修改前后发生变化。</p><p>则先在<code>B+</code>树中定位到这条记录的位置，然后获取一下记录的<code>X锁</code>将该记录彻底删除掉(就是把记录彻底移入垃圾链表)，最后再插入一条新记录。这个定位待修改记录在<code>B+</code>树中位置的过程看成是一个获取<code>X锁</code>的锁定读，新插入的记录由<code>INSERT</code>操作提供的<code>隐式锁</code>进行保护。</p></li><li><p>情况3修改了该记录的键值，则相当于在原记录上做<code>DELETE</code>操作之后再来一次<code>INSERT</code>操作，加锁操作就需要按照<code>DELETE</code>和<code>INSERT</code>的规则进行了。</p></li></ul></li><li><p><code>INSERT</code> :<br>一般情况下，新插入一条记录的操作并不加锁，通过一种称之为<code>隐式锁</code>的结构来保护这条新插入的记录在本事务提交前不被别的事务访问。</p></li></ul><h3 id="3-2-从数据操作的粒度划分：表级锁、页级锁、行锁"><a href="#3-2-从数据操作的粒度划分：表级锁、页级锁、行锁" class="headerlink" title="3.2 从数据操作的粒度划分：表级锁、页级锁、行锁"></a>3.2 从数据操作的粒度划分：表级锁、页级锁、行锁</h3><p>为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好,理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但是管理锁是很<code>耗资源</code>的事情（涉及获取、检查、释放锁等动作)。因此数据库系统需要在<code>高并发响应</code>和<code>系统性能</code>两方面进行平衡，这样就产生了“<code>锁粒度(Lock granularity)</code>”的概念。</p><p>对一条记录加锁影响的也只是这条记录而已，我们就说这个锁的粒度比较细;其实一个事务也可以在<code>表级别</code>进行加锁，自然就被称之为<code>表级锁</code>或者<code>表锁</code>，对一个表加锁影响整个表中的记录，我们就说这个锁的粒度比较粗。锁的粒度主要分为表级锁、页级锁和行锁。</p><h4 id="1-表锁（Table-Lock）"><a href="#1-表锁（Table-Lock）" class="headerlink" title="1. 表锁（Table Lock）"></a>1. 表锁（Table Lock）</h4><p>该锁会锁定整张表，它是MySQL中最基本的锁策略，并<code>不依赖于存储引擎</code>（不管你是MySQL的什么存储引擎，对于表锁的策略都是一样的)，并且表锁是<code>开销最小</code>的策略（因为粒度比较大)。由于表级锁一次会将整个表锁定，所以可以很好的<code>避免死锁</code>问题。当然，锁的粒度大所带来最大的负面影响就是出现锁资源争用的概率也会最高，导致<code>并发率大打折扣</code>。</p><h5 id="①-表级别的S锁、X锁"><a href="#①-表级别的S锁、X锁" class="headerlink" title="① 表级别的S锁、X锁"></a>① 表级别的S锁、X锁</h5><p>在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级别的 <code>S锁</code> 或者 <code>X锁</code> 的。在对某个表执行一些诸如 <code>ALTER TABLE 、 DROP TABLE</code> 这类的 DDL 语句时，其 他事务对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞。同理，某个事务中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行 <code>DDL</code> 语句也会 发生阻塞。这个过程其实是通过在 server层使用一种称之为 <code>元数据锁</code> （英文名： Metadata Locks ， 简称 MDL ）结构来实现的。</p><p>一般情况下，不会使用InnoDB存储引擎提供的表级别的 <code>S锁</code> 和 <code>X锁</code> 。只会在一些特殊情况下，比方说 <code>崩溃恢复</code> 过程中用到。比如，在系统变量 <code>autocommit=0，innodb_table_locks = 1</code> 时， 手动 获取 InnoDB存储引擎提供的表t 的 <code>S锁</code> 或者 <code>X锁</code> 可以这么写：</p><ul><li><p><code>LOCK TABLES t READ</code> ：InnoDB存储引擎会对表 t 加表级别的 <code>S锁</code>。</p></li><li><p><code>LOCK TABLES t WRITE</code> ：InnoDB存储引擎会对表 t 加表级别的 <code>X锁</code> 。</p></li></ul><p>不过尽量避免在使用InnoDB存储引擎的表上使用 <code>LOCK TABLES</code> 这样的手动锁表语句，它们并不会提供 什么额外的保护，只是会降低并发能力而已。InnoDB的厉害之处还是实现了更细粒度的 <code>行锁</code> ，关于 InnoDB表级别的 <code>S锁</code> 和<code>X锁</code> 大家了解一下就可以了。</p><p><strong>举例：</strong>下面我们讲解MyISAM引擎下的表锁。</p><p>步骤1：创建表并添加数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE mylock(</span><br><span class="line">id INT NOT NULL PRIMARY KEY auto_increment,</span><br><span class="line">NAME VARCHAR(20)</span><br><span class="line">)ENGINE myisam;</span><br><span class="line"></span><br><span class="line"># 插入一条数据</span><br><span class="line">INSERT INTO mylock(NAME) VALUES(&#x27;a&#x27;);</span><br><span class="line"></span><br><span class="line"># 查询表中所有数据</span><br><span class="line">SELECT * FROM mylock;</span><br><span class="line">+----+------+</span><br><span class="line">| id | Name |</span><br><span class="line">+----+------+</span><br><span class="line">| 1  | a    |</span><br><span class="line">+----+------+</span><br></pre></td></tr></table></figure><p>步骤二：查看表上加过的锁</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW OPEN TABLES; # 主要关注In_use字段的值</span><br><span class="line">或者</span><br><span class="line">SHOW OPEN TABLES where In_use &gt; 0;</span><br></pre></td></tr></table></figure><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220711220342251.png" alt="image-20220711220342251" style="float:left;"></p><p>或者</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220711220418859.png" alt="image-20220711220418859" style="float:left;"></p><p>上面的结果表明，当前数据库中没有被锁定的表</p><p>步骤3：手动增加表锁命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOCK TABLES t READ; # 存储引擎会对表t加表级别的共享锁。共享锁也叫读锁或S锁（Share的缩写）</span><br><span class="line">LOCK TABLES t WRITE; # 存储引擎会对表t加表级别的排他锁。排他锁也叫独占锁、写锁或X锁（exclusive的缩写）</span><br></pre></td></tr></table></figure><p>比如：</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220711220442269.png" alt="image-20220711220442269" style="float:left;"></p><p>步骤4：释放表锁</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UNLOCK TABLES; # 使用此命令解锁当前加锁的表</span><br></pre></td></tr></table></figure><p>比如：</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220711220502141.png" alt="image-20220711220502141" style="float:left;"></p><p>步骤5：加读锁</p><p>我们为mylock表加read锁（读阻塞写），观察阻塞的情况，流程如下：</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220711220553225.png" alt="image-20220711220553225"></p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220711220616537.png" alt="image-20220711220616537"></p><p>步骤6：加写锁</p><p>为mylock表加write锁，观察阻塞的情况，流程如下：</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220711220711630.png" alt="image-20220711220711630"></p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220711220730112.png" alt="image-20220711220730112"></p><p>总结：</p><p>MyISAM在执行查询语句（SELECT）前，会给涉及的所有表加读锁，在执行增删改操作前，会给涉及的表加写锁。InnoDB存储引擎是不会为这个表添加表级别的读锁和写锁的。</p><p>MySQL的表级锁有两种模式：（以MyISAM表进行操作的演示）</p><ul><li><p>表共享读锁（Table Read Lock）</p></li><li><p>表独占写锁（Table Write Lock）</p><p>| 锁类型 | 自己可读 | 自己可写 | 自己课操作其他表 | 他人可读 | 他人可写 |<br>| ——— | ———— | ———— | ———————— | ———— | ———— |<br>| 读锁   | 是       | 否       | 否               | 是       | 否，等   |<br>| 写锁   | 是       | 是       | 否               | 否，等   | 否，等   |</p></li></ul><h5 id="②-意向锁-（intention-lock）"><a href="#②-意向锁-（intention-lock）" class="headerlink" title="② 意向锁 （intention lock）"></a>② 意向锁 （intention lock）</h5><p>InnoDB 支持 <code>多粒度锁（multiple granularity locking）</code> ，它允许 <code>行级锁</code> 与 <code>表级锁</code> 共存，而<code>意向锁</code>就是其中的一种 <code>表锁</code> 。</p><ol><li>意向锁的存在是为了协调行锁和表锁的关系，支持多粒度（表锁和行锁）的锁并存。</li><li>意向锁是一种<code>不与行级锁冲突表级锁</code>，这一点非常重要。</li><li>表明“某个事务正在某些行持有了锁或该事务准备去持有锁”</li></ol><p>意向锁分为两种：</p><ul><li><p><strong>意向共享锁</strong>（intention shared lock, IS）：事务有意向对表中的某些行加<strong>共享锁</strong>（S锁）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。</span><br><span class="line">SELECT column FROM table ... LOCK IN SHARE MODE;</span><br></pre></td></tr></table></figure></li><li><p><strong>意向排他锁</strong>（intention exclusive lock, IX）：事务有意向对表中的某些行加<strong>排他锁</strong>（X锁）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。</span><br><span class="line">SELECT column FROM table ... FOR UPDATE;</span><br></pre></td></tr></table></figure></li></ul><p>即：意向锁是由存储引擎 <code>自己维护的</code> ，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前， InooDB 会先获取该数据行 <code>所在数据表的对应意向锁</code> 。</p><p><strong>1. 意向锁要解决的问题</strong></p><p>现在有两个事务，分别是T1和T2，其中T2试图在该表级别上应用共享或排它锁，如果没有意向锁存在，那么T2就需要去检查各个页或行是否存在锁;如果存在意向锁，那么此时就会受到由T1控制的表级别意向锁的阻塞。T2在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁。简单来说就是给更大一级别的空间示意里面是否已经上过锁。</p><p>在数据表的场景中，<code>如果我们给某一行数据加上了排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排它锁了</code>，这样当其他人想要获取数据表排它锁的时候，只需要了解是否有人已经获取了这个数据表的意向排他锁即可。</p><ul><li>如果事务想要获得数据表中某些记录的共享锁，就需要在数据表上<code>添加意向共享锁</code>。</li><li>如果事务想要获得数据表中某些记录的排他锁，就需要在数据表上<code>添加意向排他锁</code>。</li></ul><p>这时，意向锁会告诉其他事务已经有人锁定了表中的某些记录。</p><p><strong>举例：</strong>创建表teacher,插入6条数据，事务的隔离级别默认为<code>Repeatable-Read</code>，如下所示。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `teacher` (</span><br><span class="line">`id` int NOT NULL,</span><br><span class="line">    `name` varchar(255) NOT NULL,</span><br><span class="line">    PRIMARY KEY (`id`)</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;</span><br><span class="line"></span><br><span class="line">INSERT INTO `teacher` VALUES</span><br><span class="line">(&#x27;1&#x27;, &#x27;zhangsan&#x27;),</span><br><span class="line">(&#x27;2&#x27;, &#x27;lisi&#x27;),</span><br><span class="line">(&#x27;3&#x27;, &#x27;wangwu&#x27;),</span><br><span class="line">(&#x27;4&#x27;, &#x27;zhaoliu&#x27;),</span><br><span class="line">(&#x27;5&#x27;, &#x27;songhongkang&#x27;),</span><br><span class="line">(&#x27;6&#x27;, &#x27;leifengyang&#x27;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT @@transaction_isolation;</span><br><span class="line">+-------------------------+</span><br><span class="line">| @@transaction_isolation |</span><br><span class="line">+-------------------------+</span><br><span class="line">| REPEATABLE-READ         |</span><br><span class="line">+-------------------------+</span><br></pre></td></tr></table></figure><p>假设事务A获取了某一行的排他锁，并未提交，语句如下所示:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">SELECT * FROM teacher WHERE id = 6 FOR UPDATE;</span><br></pre></td></tr></table></figure><p>事务B想要获取teacher表的表读锁，语句如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">LOCK TABLES teacher READ;</span><br></pre></td></tr></table></figure><p>因为共享锁与排他锁互斥，所以事务B在试图对teacher表加共享锁的时候必须保证两个条件。</p><ol><li>当前没有其他事务持有teacher表的排他锁</li><li>当前没有其他事务持有teacher表中任意一行的排他锁。</li></ol><p>为了检测是否满足第二个条件，事务B必须在确保teacher表不存在任何排他锁的前提下，去检测表中的每一行是否存在排他锁。很明显这是一个效率很差的做法，但是有了意向锁之后，情况就不一样了。<br>意向锁是怎么解决这个问题的呢?首先，我们需要知道意向锁之间的兼容互斥性，如下所示。</p><div class="table-container"><table><thead><tr><th></th><th>意向共享锁（IS）</th><th>意向排他锁（IX）</th></tr></thead><tbody><tr><td>意向共享锁（IS）</td><td>兼容</td><td>兼容</td></tr><tr><td>意向排他锁（IX）</td><td>不兼容</td><td>兼容</td></tr></tbody></table></div><p>即意向锁之间是互相兼容的，虽然意向锁和自家兄弟互相兼容，但是它会与普通的排他/共享锁互斥。</p><div class="table-container"><table><thead><tr><th></th><th>意向共享锁（IS）</th><th>意向排他锁（IX）</th></tr></thead><tbody><tr><td>共享锁（S）</td><td>兼容</td><td>互斥</td></tr><tr><td>排他锁（X）</td><td>互斥</td><td>互斥</td></tr></tbody></table></div><p>注意这里的排他/共享锁指的都是表锁，意向锁不会与行级的共享/排他锁互斥。回到刚才teacher 表的例子。</p><p>事务A获取了某一行的排他锁，并未提交:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">SELECT * FROM teacher WHERE id = 6 FOR UPDATE;</span><br></pre></td></tr></table></figure><p>此时teacher表存在两把锁：teacher表上的意向排他锁与id未6的数据行上的排他锁。事务B想要获取teacher表的共享锁。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">LOCK TABLES teacher READ;</span><br></pre></td></tr></table></figure><p>此时事务B检测事务A持有teacher表的意向排他锁，就可以得知事务A必须持有该表中某些数据行的排他锁，那么事务B对teacher表的加锁请求就会被排斥（阻塞），而无需去检测表中的每一行数据是否存在排他锁。</p><p><strong>意向锁的并发性</strong></p><p>意向锁不会与行级的共享 / 排他锁互斥！正因为如此，意向锁并不会影响到多个事务对不同数据行加排他锁时的并发性。（不然我们直接用普通的表锁就行了）</p><p>我们扩展一下上面 teacher表的例子来概括一下意向锁的作用（一条数据从被锁定到被释放的过程中，可 能存在多种不同锁，但是这里我们只着重表现意向锁）。</p><p>事务A先获得了某一行的排他锁，并未提交：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">SELECT * FROM teacher WHERE id = 6 FOR UPDATE;</span><br></pre></td></tr></table></figure><p>事务A获取了teacher表上的意向排他锁。事务A获取了id为6的数据行上的排他锁。之后事务B想要获取teacher表上的共享锁。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">LOCK TABLES teacher READ;</span><br></pre></td></tr></table></figure><p>事务B检测到事务A持有teacher表的意向排他锁。事务B对teacher表的加锁请求被阻塞（排斥）。最后事务C也想获取teacher表中某一行的排他锁。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">SELECT * FROM teacher WHERE id = 5 FOR UPDATE;</span><br></pre></td></tr></table></figure><p>事务C申请teacher表的意向排他锁。事务C检测到事务A持有teacher表的意向排他锁。因为意向锁之间并不互斥，所以事务C获取到了teacher表的意向排他锁。因为id为5的数据行上不存在任何排他锁，最终事务C成功获取到了该数据行上的排他锁。</p><p><strong>从上面的案例可以得到如下结论：</strong></p><ol><li>InnoDB 支持 <code>多粒度锁</code> ，特定场景下，行级锁可以与表级锁共存。 </li><li>意向锁之间互不排斥，但除了 IS 与 S 兼容外， <code>意向锁会与 共享锁 / 排他锁 互斥</code> 。 </li><li>IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。 </li><li>意向锁在保证并发性的前提下，实现了 <code>行锁和表锁共存</code> 且 <code>满足事务隔离性</code> 的要求。</li></ol><h5 id="③-自增锁（AUTO-INC锁）"><a href="#③-自增锁（AUTO-INC锁）" class="headerlink" title="③ 自增锁（AUTO-INC锁）"></a>③ 自增锁（AUTO-INC锁）</h5><p>在使用MySQL过程中，我们可以为表的某个列添加 <code>AUTO_INCREMENT</code> 属性。举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `teacher` (</span><br><span class="line">`id` int NOT NULL AUTO_INCREMENT,</span><br><span class="line">`name` varchar(255) NOT NULL,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;</span><br></pre></td></tr></table></figure><p>由于这个表的id字段声明了AUTO_INCREMENT，意味着在书写插入语句时不需要为其赋值，SQL语句修改 如下所示。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO `teacher` (name) VALUES (&#x27;zhangsan&#x27;), (&#x27;lisi&#x27;);</span><br></pre></td></tr></table></figure><p>上边的插入语句并没有为id列显式赋值，所以系统会自动为它赋上递增的值，结果如下所示。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from teacher;</span><br><span class="line">+----+----------+</span><br><span class="line">| id | name     |</span><br><span class="line">+----+----------+</span><br><span class="line">| 1  | zhangsan |</span><br><span class="line">| 2  | lisi     |</span><br><span class="line">+----+----------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>现在我们看到的上面插入数据只是一种简单的插入模式，所有插入数据的方式总共分为三类，分别是 “ <code>Simple inserts</code> ”，“ <code>Bulk inserts</code> ”和“ <code>Mixed-mode inserts</code>”。</p><p><strong>1. “Simple inserts” （简单插入）</strong></p><p>可以 <code>预先确定要插入的行数</code> （当语句被初始处理时）的语句。包括没有嵌套子查询的单行和多行<code>INSERT...VALUES()</code>和 <code>REPLACE</code> 语句。比如我们上面举的例子就属于该类插入，已经确定要插入的行 数。</p><p><strong>2. “Bulk inserts” （批量插入）</strong></p><p><code>事先不知道要插入的行数</code> （和所需自动递增值的数量）的语句。比如 <code>INSERT ... SELECT</code> ， <code>REPLACE ... SELECT</code> 和 <code>LOAD DATA</code> 语句，但不包括纯INSERT。 InnoDB在每处理一行，为AUTO_INCREMENT列</p><p><strong>3. “Mixed-mode inserts” （混合模式插入）</strong></p><p>这些是“Simple inserts”语句但是指定部分新行的自动递增值。例如 <code>INSERT INTO teacher (id,name) VALUES (1,&#39;a&#39;), (NULL,&#39;b&#39;), (5,&#39;c&#39;), (NULL,&#39;d&#39;);</code> 只是指定了部分id的值。另一种类型的“混合模式插入”是 <code>INSERT ... ON DUPLICATE KEY UPDATE</code> 。</p><p>对于上面数据插入的案例，MySQL中采用了<code>自增锁</code>的方式来实现，<strong>AUTO-INC锁是当向使用含有AUTO_INCREMENT列的表中插入数据时需要获取的一种特殊的表级锁</strong>，在执行插入语句时就在表级别加一个AUTO-INC锁，然后为每条待插入记录的AUTO_INCREMENT修饰的列分配递增的值，在该语句执行结束后，再把AUTO-INC锁释放掉。<strong>一个事务在持有AUTO-INC锁的过程中，其他事务的插入语句都要被阻塞</strong>，可以保证一个语句中分配的递增值是连续的。也正因为此，其并发性显然并不高，<strong>当我们向一个有AUTO_INCREMENT关键字的主键插入值的时候，每条语句都要对这个表锁进行竞争</strong>，这样的并发潜力其实是很低下的，所以innodb通过<code>innodb_autoinc_lock_mode</code>的不同取值来提供不同的锁定机制，来显著提高SQL语句的可伸缩性和性能。</p><p>innodb_autoinc_lock_mode有三种取值，分别对应与不同锁定模式：</p><p><code>（1）innodb_autoinc_lock_mode = 0(“传统”锁定模式)</code></p><p>在此锁定模式下，所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，用于插入具有 AUTO_INCREMENT列的表。这种模式其实就如我们上面的例子，即每当执行insert的时候，都会得到一个 表级锁(AUTO-INC锁)，使得语句中生成的auto_increment为顺序，且在binlog中重放的时候，可以保证 master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的 时候，对于AUTO-INC锁的争夺会 <code>限制并发</code> 能力。</p><p><code>（2）innodb_autoinc_lock_mode = 1(“连续”锁定模式)</code></p><p>在 MySQL 8.0 之前，连续锁定模式是 <code>默认</code> 的。</p><p>在这个模式下，“bulk inserts”仍然使用AUTO-INC表级锁，并保持到语句结束。这适用于所有INSERT … SELECT，REPLACE … SELECT和LOAD DATA语句。同一时刻只有一个语句可以持有AUTO-INC锁。</p><p>对于“Simple inserts”（要插入的行数事先已知），则通过在 <code>mutex（轻量锁）</code> 的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁， 它只在分配过程的持续时间内保持，而不是直到语句完成。不使用表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。如果另一个事务保持AUTO-INC锁，则“Simple inserts”等待AUTO-INC锁，如同它是一个“bulk inserts”。</p><p><code>（3）innodb_autoinc_lock_mode = 2(“交错”锁定模式)</code></p><p>从 MySQL 8.0 开始，交错锁模式是 <code>默认</code> 设置。</p><p>在此锁定模式下，自动递增值 <code>保证</code> 在所有并发执行的所有类型的insert语句中是 <code>唯一</code> 且 <code>单调递增</code> 的。但是，由于多个语句可以同时生成数字（即，跨语句交叉编号），<strong>为任何给定语句插入的行生成的值可能不是连续的。</strong></p><p>如果执行的语句是“simple inserts”，其中要插入的行数已提前知道，除了”Mixed-mode inserts”之外，为单个语句生成的数字不会有间隙。然后，当执行”bulk inserts”时，在由任何给定语句分配的自动递增值中可能存在间隙。</p><h5 id="④-元数据锁（MDL锁）"><a href="#④-元数据锁（MDL锁）" class="headerlink" title="④ 元数据锁（MDL锁）"></a>④ 元数据锁（MDL锁）</h5><p>MySQL5.5引入了meta data lock，简称MDL锁，属于表锁范畴。MDL 的作用是，保证读写的正确性。比 如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个 <code>表结构做变更</code> ，增加了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p><p>因此，<strong>当对一个表做增删改查操作的时候，加 MDL读锁；当要对表做结构变更操作的时候，加 MDL 写锁</strong>。</p><p>读锁之间不互斥，因此你可以有多个线程同时对一张表增删查改。读写锁之间、写锁之间都是互斥的，用来保证变更表结构操作的安全性，解决了DML和DDL操作之间的一致性问题。<code>不需要显式使用</code>，在访问一个表的时候会被自动加上。</p><p><strong>举例：元数据锁的使用场景模拟</strong></p><p><strong>会话A：</strong>从表中查询数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; SELECT COUNT(1) FROM teacher;</span><br><span class="line">+----------+</span><br><span class="line">| COUNT(1) |</span><br><span class="line">+----------+</span><br><span class="line">| 2        |</span><br><span class="line">+----------+</span><br><span class="line">1 row int set (7.46 sec)</span><br></pre></td></tr></table></figure><p><strong>会话B：</strong>修改表结构，增加新列</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; alter table teacher add age int not null;</span><br></pre></td></tr></table></figure><p><strong>会话C：</strong>查看当前MySQL的进程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show processlist;</span><br></pre></td></tr></table></figure><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220713142808924.png" alt="image-20220713142808924"></p><p>通过会话C可以看出会话B被阻塞，这是由于会话A拿到了teacher表的元数据读锁，会话B想申请teacher表的元数据写锁，由于读写锁互斥，会话B需要等待会话A释放元数据锁才能执行。</p><p><strong>元数据锁可能带来的问题</strong></p><div class="table-container"><table><thead><tr><th>SessionA</th><th>sessionB</th><th>SessionC</th></tr></thead><tbody><tr><td>begin;select * from teacher;</td><td></td><td></td></tr><tr><td></td><td>alter table teacher add age int;</td><td></td></tr><tr><td></td><td></td><td>select * from teacher;</td></tr></tbody></table></div><p>我们可以看到session A会对表teacher加一个MDL读锁，之后session B要加MDL写锁会被 blocked，因为session A的MDL读锁还没有释放，而session c要在表teacher上新申请MDL读锁的请求也会被session B阻塞。前面我们说了，所有对表的增删改查操作都需要先申请MDL读锁，就都被阻塞，等于这个表现在完全不可读写了。</p><h4 id="2-InnoDB中的行锁"><a href="#2-InnoDB中的行锁" class="headerlink" title="2. InnoDB中的行锁"></a>2. InnoDB中的行锁</h4><p>行锁（Row Lock）也称为记录锁，顾名思义，就是锁住某一行（某条记录 row）。需要注意的是，MySQL服务器层并没有实现行锁机制，<strong>行级锁只在存储引擎层实现</strong>。</p><p><strong>优点：</strong>锁定力度小，发生<code>锁冲突概率低</code>，可以实现的<code>并发度高</code>。</p><p><strong>缺点：</strong>对于<code>锁的开销比较大</code>，加锁会比较慢，容易出现<code>死锁</code>情况。</p><p>InnoDB与MyISAM的最大不同有两点：一是支持事物（TRANSACTION）；二是采用了行级锁。</p><p>首先我们创建表如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE student (</span><br><span class="line">id INT,</span><br><span class="line">    name VARCHAR(20),</span><br><span class="line">    class VARCHAR(10),</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">) Engine=InnoDB CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>向这个表里插入几条记录：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO student VALUES</span><br><span class="line">(1, &#x27;张三&#x27;, &#x27;一班&#x27;),</span><br><span class="line">(3, &#x27;李四&#x27;, &#x27;一班&#x27;),</span><br><span class="line">(8, &#x27;王五&#x27;, &#x27;二班&#x27;),</span><br><span class="line">(15, &#x27;赵六&#x27;, &#x27;二班&#x27;),</span><br><span class="line">(20, &#x27;钱七&#x27;, &#x27;三班&#x27;);</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM student;</span><br></pre></td></tr></table></figure><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220713161549241.png" alt="image-20220713161549241" style="float:left;"></p><p>student表中的聚簇索引的简图如下所示。</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220713163353648.png" alt="image-20220713163353648"></p><p>这里把B+树的索引结构做了超级简化，只把索引中的记录给拿了出来，下面看看都有哪些常用的行锁类型。</p><h5 id="①-记录锁（Record-Locks）"><a href="#①-记录锁（Record-Locks）" class="headerlink" title="① 记录锁（Record Locks）"></a>① 记录锁（Record Locks）</h5><p>记录锁也就是仅仅把一条记录锁，官方的类型名称为：<code>LOCK_REC_NOT_GAP</code>。比如我们把id值为8的那条记录加一个记录锁的示意图如果所示。仅仅是锁住了id值为8的记录，对周围的数据没有影响。</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220713164811567.png" alt="image-20220713164811567"></p><p>举例如下：</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220713164948405.png" alt="image-20220713164948405"></p><p>记录锁是有S锁和X锁之分的，称之为 <code>S型记录锁</code> 和 <code>X型记录锁</code> 。</p><ul><li>当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁；</li><li>当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁。</li></ul><h5 id="②-间隙锁（Gap-Locks）"><a href="#②-间隙锁（Gap-Locks）" class="headerlink" title="② 间隙锁（Gap Locks）"></a>② 间隙锁（Gap Locks）</h5><p><code>MySQL</code> 在 <code>REPEATABLE READ</code> 隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用 <code>MVCC</code> 方 案解决，也可以采用 <code>加锁</code>方案解决。但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些 <code>幻影记录</code> 加上 <code>记录锁</code> 。InnoDB提出了一种称之为 <code>Gap Locks</code> 的锁，官方的类型名称为：<code>LOCK_GAP</code> ，我们可以简称为 <code>gap锁</code> 。比如，把id值为8的那条 记录加一个gap锁的示意图如下。</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220713171650888.png" alt="image-20220713171650888"></p><p>图中id值为8的记录加了gap锁，意味着 <code>不允许别的事务在id值为8的记录前边的间隙插入新记录</code> ，其实就是 id列的值(3, 8)这个区间的新记录是不允许立即插入的。比如，有另外一个事务再想插入一条id值为4的新 记录，它定位到该条新记录的下一条记录的id值为8，而这条记录上又有一个gap锁，所以就会阻塞插入 操作，直到拥有这个gap锁的事务提交了之后，id列的值在区间(3, 8)中的新记录才可以被插入。</p><p><strong>gap锁的提出仅仅是为了防止插入幻影记录而提出的。</strong>虽然有<code>共享gap锁</code>和<code>独占gap锁</code>这样的说法，但是它们起到的作用是相同的。而且如果对一条记录加了gap锁（不论是共享gap锁还是独占gap锁），并不会限制其他事务对这条记录加记录锁或者继续加gap锁。</p><p><strong>举例：</strong></p><div class="table-container"><table><thead><tr><th>Session1</th><th>Session2</th></tr></thead><tbody><tr><td>select * from student where id=5 lock in share mode;</td><td></td></tr><tr><td></td><td>select * from student where id=5 for update;</td></tr></tbody></table></div><p>这里session2并不会被堵住。因为表里并没有id=5这条记录，因此session1嘉的是间隙锁(3,8)。而session2也是在这个间隙加的间隙锁。它们有共同的目标，即：保护这个间隙锁，不允许插入值。但，它们之间是不冲突的。</p><p>注意，给一条记录加了<code>gap锁</code>只是<code>不允许</code>其他事务往这条记录前边的间隙<code>插入新记录</code>，那对于最后一条记录之后的间隙，也就是student表中id值为<code>20</code>的记录之后的间隙该咋办呢?也就是说给哪条记录加<code>gap锁</code>才能阻止其他事务插入<code>id</code>值在<code>(20，+os)</code>这个区间的新记录呢?这时候我们在讲数据页时介绍的两条伪记录派上用场了:</p><ul><li><code>Infimum</code>记录，表示该页面中最小的记录。</li><li><code>Supremun</code>记录，表示该页面中最大的记录。</li></ul><p>为了实现阻止其他事务插入id值再(20,正无穷)这个区间的新纪录，我们可以给索引中的最后一条记录，也就是id值为20的那条记录所在页面的Supremun记录加上一个gap锁，如图所示。</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220713174108634.png" alt="image-20220713174108634"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student where id &gt; 20 lock in share mode;</span><br><span class="line">Empty set (0.01 sec)</span><br></pre></td></tr></table></figure><p>检测：</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220713174551814.png" alt="image-20220713174551814"></p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220713174602102.png" alt="image-20220713174602102"></p><p>这样就可以阻止其他事务插入id值在(20,+oo)这个区间的新记录。</p><p>间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的。下面的例子会产生<code>死锁</code></p><div class="table-container"><table><thead><tr><th>Session 1</th><th>Session 2</th></tr></thead><tbody><tr><td>begin;<br>select * from student where id = 5 for update;</td><td>begin;<br>select * from student where id = 5 for update;</td></tr><tr><td></td><td>INSERT INTO student VALUES(5,’宋红康;’二班);阻塞</td></tr><tr><td>INSERT INTO student VALUES(5,’宋红康;’二班’); <br>(ERROR 1213(40001): Deadlock found when trying to get lock; try restarting transaction)</td></tr></tbody></table></div><ol><li>session 1执行select … for update语句，由于id = 5这一行并不存在,因此会加上间隙锁（3，8) ;</li><li>session 2执行select … for update语句，同样会加上间隙锁（3，8),间隙锁之间不会冲突，因此这个语句可以执行成功;</li><li>session 2试图插入一行(5, ‘宋红康, ‘二班’)，被session 1的间隙锁挡住了，只好进入等待;</li><li>session 1试图插入一行(5, “宋红康, ‘二班’)，被session 2的间隙锁挡住了。至此，两个session进入互相等待状态，形成死锁。当然， InnoDB的死锁检测马上就发现了这对死锁关系，让session 1的insert 语句报错返回。</li></ol><h5 id="③-临键锁（Next-Key-Locks）"><a href="#③-临键锁（Next-Key-Locks）" class="headerlink" title="③ 临键锁（Next-Key Locks）"></a>③ 临键锁（Next-Key Locks）</h5><p>有时候我们既想 <code>锁住某条记录</code> ，又想 阻止 其他事务在该记录前边的 间隙插入新记录 ，所以InnoDB就提 出了一种称之为 Next-Key Locks 的锁，官方的类型名称为： LOCK_ORDINARY ，我们也可以简称为 next-key锁 。Next-Key Locks是在存储引擎 innodb 、事务级别在 可重复读 的情况下使用的数据库锁， innodb默认的锁就是Next-Key locks。比如，我们把id值为8的那条记录加一个next-key锁的示意图如下：</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220713192549340.png" alt="image-20220713192549340"></p><p><code>next-key锁</code>的本质就是一个<code>记录锁</code>和一个<code>gap锁</code>的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的<code>间隙</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from student where id &lt;=8 and id &gt; 3 for update;</span><br></pre></td></tr></table></figure><h5 id="④-插入意向锁（Insert-Intention-Locks）"><a href="#④-插入意向锁（Insert-Intention-Locks）" class="headerlink" title="④  插入意向锁（Insert Intention Locks）"></a>④  插入意向锁（Insert Intention Locks）</h5><p>我们说一个事务在<code>插入</code>一条记录时需要判断一下插入位置是不是被别的事务加了<code>gap锁</code>( <code>next-key锁</code>也包含<code>gap锁</code>），如果有的话，插入操作需要等待，直到拥有gap锁的那个事务提交。但是<strong>InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构</strong>，表明有事务想在某个<code>间隙</code>中<code>插入</code>新记录，但是现在在等待。InnoDB就把这种类型的锁命名为<code>Insert Inten本ion Locks</code>，官方的类型名称为:<code>LOCK_INSERT_INTENTION</code>，我们称为<code>插入意向锁</code>。插入意向锁是一种<code>Gap锁</code>，不是意向锁，在insert操作时产生。</p><p>插入意向锁是在插入一条记录行前，由<code>INSERT 操作产生的一种间隙锁</code>。该锁用以表示插入意向，当多个事务在同一区间(gap）插入位置不同的多条数据时，事务之间不需要互相等待。假设存在两条值分别为4和7的记录，两个不同的事务分别试图插入值为5和6的两条记录，每个事务在获取插入行上独占的(排他）锁前，都会获取（(4，7)之间的间隙锁，但是因为数据行之间并<code>不冲突</code>，所以两个事务之间并不会产生冲突（阻塞等待)。总结来说，插入意向锁的特性可以分成两部分:</p><ol><li>插入意向锁是一种<code>特殊的间隙锁</code>—―间隙锁可以锁定开区间内的部分记录。</li><li>插入意向锁之间<code>互不排斥</code>，所以即使多个事务在同一区间插入多条记录，只要记录本身(主键、唯一索引）不冲突，那么事务之间就不会出现冲突等待。</li></ol><p>注意，虽然插入意向锁中含有意向锁三个字，但是它并不属于意向锁而属于间隙锁，因为意向锁是表锁而插入意向锁是<code>行锁</code>。</p><p>比如，把id值为8的那条记录加一个插入意向锁的示意图如下:</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220713203532124.png" alt="image-20220713203532124" style="float:left;"></p><p>比如，现在T1为id值为s的记录加了一个gap锁，然后T2和T3分别想向student表中插入id值分别为4、5的两条记录，所以现在为id值为8的记录加的锁的示意图就如下所示:</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220713203619704.png" alt="image-20220713203619704" style="float:left;"></p><p>从图中可以看到，由于T1持有gap锁，所以T2和T3需要生成一个插入意向锁的锁结构并且处于等待状态。当T1提交后会把它获取到的锁都释放掉，这样T2和T3就能获取到对应的插入意向锁了(本质上就是把插入意向锁对应锁结构的is_waiting属性改为false)，T2和T3之间也并不会相互阻塞，它们可以同时获取到id值为8的插入意向锁，然后执行插入操作。<strong>事实上插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁。</strong></p><h4 id="3-页锁"><a href="#3-页锁" class="headerlink" title="3. 页锁"></a>3. 页锁</h4><p>页锁就是在 <code>页的粒度</code> 上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我 们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。<strong>页锁的开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。</strong></p><p>每个层级的锁数量是有限制的，因为锁会占用内存空间， <code>锁空间的大小是有限的</code> 。当某个层级的锁数量 超过了这个层级的阈值时，就会进行 <code>锁升级</code> 。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如 InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。</p><h3 id="3-3-从对待锁的态度划分-乐观锁、悲观锁"><a href="#3-3-从对待锁的态度划分-乐观锁、悲观锁" class="headerlink" title="3.3 从对待锁的态度划分:乐观锁、悲观锁"></a>3.3 从对待锁的态度划分:乐观锁、悲观锁</h3><p>从对待锁的态度来看锁的话，可以将锁分成乐观锁和悲观锁，从名字中也可以看出这两种锁是两种看待 <code>数据并发的思维方式</code> 。需要注意的是，乐观锁和悲观锁并不是锁，而是锁的 <code>设计思想</code> 。</p><h4 id="1-悲观锁（Pessimistic-Locking）"><a href="#1-悲观锁（Pessimistic-Locking）" class="headerlink" title="1. 悲观锁（Pessimistic Locking）"></a>1. 悲观锁（Pessimistic Locking）</h4><p>悲观锁是一种思想，顾名思义，就是很悲观，对数据被其他事务的修改持保守态度，会通过数据库自身的锁机制来实现，从而保证数据操作的排它性。</p><p>悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 <code>阻塞</code> 直到它拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞， 用完后再把资源转让给其它线程</strong>）。比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，当其他线程想要访问数据时，都需要阻塞挂起。Java中 <code>synchronized</code> 和 <code>ReentrantLock</code> 等独占锁就是悲观锁思想的实现。</p><p><strong>秒杀案例1：</strong></p><p>商品秒杀过程中，库存数量的减少，避免出现<code>超卖</code>的情况。比如，商品表中有一个字段为quantity表示当前该商品的库存量。假设商品为华为mate40，id为1001，quantity=100个。如果不使用锁的情况下，操作方法如下所示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#第1步:查出商品库存</span><br><span class="line">select quantity from items where id = 1001;</span><br><span class="line">#第2步:如果库存大于0，则根据商品信息生产订单</span><br><span class="line">insert into orders (item_id）values( 1001 );</span><br><span class="line">#第3步:修改商品的库存，num表示购买数量</span><br><span class="line">update items set quantity = quantity-num where id = 1081;</span><br></pre></td></tr></table></figure><p>这样写的话，在并发量小的公司没有大的问题，但是如果在<code>高并发环境</code>下可能出现以下问题</p><div class="table-container"><table><thead><tr><th>线程A</th><th>线程B</th></tr></thead><tbody><tr><td>step1(查询还有100部手机)</td><td>step1(查询还有100部手机)</td></tr><tr><td></td><td>step2 (生成订单)</td></tr><tr><td>step2(生成订单)</td><td></td></tr><tr><td></td><td>step3(减库存1)</td></tr><tr><td>step3(减库存2)</td></tr></tbody></table></div><p>其中线程B此时已经下单并且减完库存，这个时候线程A依然去执行step3，就造成了超卖。</p><p>我们使用悲观锁可以解决这个问题，商品信息从查询出来到修改，中间有一个生成订单的过程，使用悲观锁的原理就是，当我们在查询items信息后就把当前的数据锁定，直到我们修改完毕后再解锁。那么整个过程中，因为数据被锁定了，就不会出现有第三者来对其进行修改了。而这样做的前提是<strong>需要将要执行的SQL语句放在同一个事务中，否则达不到锁定数据行的目的。</strong></p><p>修改如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#第1步:查出商品库存</span><br><span class="line">select quantity from items where id = 1801 for update;</span><br><span class="line">#第2步:如果库存大于8，则根据商品信息生产订单</span><br><span class="line">insert into orders (item_id)values( 1001);</span><br><span class="line">#第3步:修改商品的库存，num表示购买数量</span><br><span class="line">update items set quantity = quantity-num where id = 1081;</span><br></pre></td></tr></table></figure><p><code>select .... for update</code>是MySQL中悲观锁。此时在items表中，id为1001的那条数据就被我们锁定了，其他的要执行select quantity from items where id = 1001 for update;语句的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。</p><p>注意，当执行select quantity from items where id = 1001 for update;语句之后，如果在其他事务中执行selectquantity from items where id = 1001;语句，并不会受第一个事务的影响，仍然可以正常查询出数据。</p><p>注意: <strong>select … for update语句执行过程中所有扫描的行都会被锁上，因此在MySQL中用悲观锁必须确定使用了索引，而不是全表扫描，否则将会把整个表锁住。</strong></p><p>悲观锁不适用的场景较多，它存在一些不足，因为悲观锁大多数情况下依靠数据库的锁机制来实现，以保证程序的并发访问性，同时这样对数据库性能开销影响也很大，特别是<code>长事务</code>而言，这样的<code>开销往往无法承受</code>，这时就需要乐观锁。</p><h4 id="2-乐观锁（Optimistic-Locking）"><a href="#2-乐观锁（Optimistic-Locking）" class="headerlink" title="2. 乐观锁（Optimistic Locking）"></a>2. 乐观锁（Optimistic Locking）</h4><p>乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，也就是<strong>不采用数据库自身的锁机制，而是通过程序来实现</strong>。在程序上，我们可以采用 <code>版本号机制</code> 或者 <code>CAS机制</code> 实现。<strong>乐观锁适用于多读的应用类型， 这样可以提高吞吐量</strong>。在Java中<code>java.util.concurrent.atomic</code> 包下的原子变量类就是使用了乐观锁的一种实现方式：CAS实现的。</p><p><strong>1. 乐观锁的版本号机制</strong></p><p>在表中设计一个 <code>版本字段 version</code> ，第一次读的时候，会获取 version 字段的取值。然后对数据进行更新或删除操作时，会执行 <code>UPDATE ... SET version=version+1 WHERE version=version</code> 。此时 如果已经有事务对这条数据进行了更改，修改就不会成功。</p><p>这种方式类似我们熟悉的SVN、CVS版本管理系统，当我们修改了代码进行提交时，首先会检查当前版本号与服务器上的版本号是否一致，如果一致就可以直接提交，如果不一致就需要更新服务器上的最新代码，然后再进行提交。</p><p><strong>2. 乐观锁的时间戳机制</strong></p><p>时间戳和版本号机制一样，也是在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行比较，如果两者一致则更新成功，否则就是版本冲突。</p><p>你能看到乐观锁就是程序员自己控制数据并发操作的权限，基本是通过给数据行增加一个戳（版本号或 者时间戳），从而证明当前拿到的数据是否最新。</p><p><strong>秒杀案例2</strong></p><p>依然使用上面秒杀的案例，执行流程如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#第1步:查出商品库存</span><br><span class="line">select quantity from items where id = 1001;</span><br><span class="line">#第2步:如果库存大于0，则根据商品信息生产订单</span><br><span class="line">insert into orders (item_id)values( 1001 ) ;</span><br><span class="line">#第3步:修改商品的库存，num表示购买数量</span><br><span class="line">update items set quantity = quantity-num , version = version+1 where id = 1001 and version = #&#123;version&#125; ;</span><br></pre></td></tr></table></figure><p>注意，如果数据表是<code>读写分离</code>的表，当matser表中写入的数据没有及时同步到slave表中时，会造成更新一直失败的问题。此时需要<code>强制读取master表</code>中的数据（即将select语句放到事务中即可，这时候查询的就是master主库了。)</p><p>如果我们对同一条数据进行<code>频繁的修改</code>的话，那么就会出现这么一种场景，每次修改都只有一个事务能更新成功，在业务感知上面就有大量的失败操作。我们把代码修改如下:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#第1步:查出商品库存</span><br><span class="line">select quantity from items where id = 1001;</span><br><span class="line">#第2步:如果库存大于8，则根据商品信息生产订单</span><br><span class="line">insert into orders (item_id&gt;values( 1001 ) ;</span><br><span class="line">#第3步:修改商品的库存，num表示购买数量</span><br><span class="line">update items set quantity = quantity-num where id = 1001 and</span><br><span class="line">quantity-num&gt;0 ;</span><br></pre></td></tr></table></figure><p>这样就会使每次修改都能成功，而且不会出现超卖的现象。</p><h4 id="3-两种锁的适用场景"><a href="#3-两种锁的适用场景" class="headerlink" title="3. 两种锁的适用场景"></a>3. 两种锁的适用场景</h4><p>从这两种锁的设计思想中，我们总结一下乐观锁和悲观锁的适用场景：</p><ol><li><code>乐观锁</code> 适合 <code>读操作多</code> 的场景，相对来说写的操作比较少。它的优点在于 <code>程序实现</code> ， <code>不存在死锁</code> 问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。</li><li><code>悲观锁</code> 适合 <code>写操作多</code> 的场景，因为写的操作具有 <code>排它性</code> 。采用悲观锁的方式，可以在数据库层 面阻止其他事务对该数据的操作权限，防止 <code>读 - 写</code> 和 <code>写 - 写</code> 的冲突。</li></ol><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220713211417909.png" alt="image-20220713211417909" style="float:left;"></p><h3 id="3-4-按加锁的方式划分：显式锁、隐式锁"><a href="#3-4-按加锁的方式划分：显式锁、隐式锁" class="headerlink" title="3.4 按加锁的方式划分：显式锁、隐式锁"></a>3.4 按加锁的方式划分：显式锁、隐式锁</h3><h4 id="1-隐式锁"><a href="#1-隐式锁" class="headerlink" title="1. 隐式锁"></a>1. 隐式锁</h4><p>一个事务在执行<code>INSERT</code>操作时，如果即将插入的<code>间隙</code>已经被其他事务加了<code>gap锁</code>，那么本次<code>INSERT</code>操作会阻塞，并且当前事务会在该间隙上加一个<code>插入意向锁</code>，否则一般情况下<code>INSERT</code>操作是不加锁的。那如果一个事务首先插入了一条记录（此时并没有在内存生产与该记录关联的锁结构)，然后另一个事务:</p><ul><li>立即使用<code>SELECT ... LOCK IN SHARE MODE</code>语句读取这条记录，也就是要获取这条记录的<code>S锁</code>，或者使用<code>SELECT ... FOR UPDATE</code>语句读取这条记录，也就是要获取这条记录的X锁，怎么办?<br>如果允许这种情况的发生，那么可能产生<code>脏读</code>问题。</li><li>立即修改这条记录，也就是要获取这条记录的<code>X锁</code>，怎么办?如果允许这种情况的发生，那么可能产生<code>脏写</code>问题。</li></ul><p>这时候我们前边提过的<code>事务id</code>又要起作用了。我们把聚簇索引和二级索引中的记录分开看一下:</p><ul><li><strong>情景一</strong>：对于聚簇索引记录来说，有一个 <code>trx_id</code> 隐藏列，该隐藏列记录着最后改动该记录的 <code>事务 id</code> 。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的 trx_id 隐藏列代表的的就是 当前事务的 事务id ，如果其他事务此时想对该记录添加 S锁 或者 X锁 时，首先会看一下该记录的 trx_id 隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个 X 锁 （也就是为当前事务创建一个锁结构， is_waiting 属性是 false ），然后自己进入等待状态 （也就是为自己也创建一个锁结构， is_waiting 属性是 true ）。</li><li><strong>情景二</strong>：对于二级索引记录来说，本身并没有 trx_id 隐藏列，但是在二级索引页面的 Page Header 部分有一个 <code>PAGE_MAX_TRX_ID</code> 属性，该属性代表对该页面做改动的最大的 <code>事务id</code> ，如 果 PAGE_MAX_TRX_ID 属性值小于当前最小的活跃 事务id ，那么说明对该页面做修改的事务都已 经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记 录，然后再重复 情景一 的做法。</li></ul><p>即:一个事务对新插入的记录可以不显式的加锁（生成一个锁结构），但是由于<code>事务id</code>的存在，相当于加了一个<code>隐式锁</code>。别的事务在对这条记录加<code>S锁</code>或者<code>X锁</code>时，由于<code>隐式锁</code>的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态。隐式锁是一种<code>延迟加锁</code>的机制，从而来减少加锁的数量。</p><p>隐式锁在实际内存对象中并不含有这个锁信息。只有当产生锁等待时,隐式锁转化为显式锁。</p><p>InnoDB的insert操作，对插入的记录不加锁，但是此时如果另一个线程进行当前读，类似以下的用例，session 2会锁等待session 1，那么这是如何实现的呢?</p><p><strong>session 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; insert INTO student VALUES(34,&quot;周八&quot;,&quot;二班&quot;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>session 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; select * from student lock in share mode; #执行完，当前事务被阻塞</span><br></pre></td></tr></table></figure><p>执行下述语句，输出结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM performance_schema.data_lock_waits\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">ENGINE: INNODB</span><br><span class="line">REQUESTING_ENGINE_LOCK_ID: 140562531358232:7:4:9:140562535668584</span><br><span class="line">REQUESTING_ENGINE_TRANSACTION_ID: 422037508068888</span><br><span class="line">REQUESTING_THREAD_ID: 64</span><br><span class="line">REQUESTING_EVENT_ID: 6</span><br><span class="line">REQUESTING_OBJECT_INSTANCE_BEGIN: 140562535668584</span><br><span class="line">BLOCKING_ENGINE_LOCK_ID: 140562531351768:7:4:9:140562535619104</span><br><span class="line">BLOCKING_ENGINE_TRANSACTION_ID: 15902</span><br><span class="line">BLOCKING_THREAD_ID: 64</span><br><span class="line">BLOCKING_EVENT_ID: 6</span><br><span class="line">BLOCKING_OBJECT_INSTANCE_BEGIN: 140562535619104</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>隐式锁的逻辑过程如下：</p><p>A. InnoDB的每条记录中都一个隐含的trx_id字段，这个字段存在于聚簇索引的B+Tree中。 </p><p>B. 在操作一条记录前，首先根据记录中的trx_id检查该事务是否是活动的事务(未提交或回滚)。如果是活动的事务，首先将 <code>隐式锁</code> 转换为 <code>显式锁</code> (就是为该事务添加一个锁)。 </p><p>C. 检查是否有锁冲突，如果有冲突，创建锁，并设置为waiting状态。如果没有冲突不加锁，跳到E。 </p><p>D. 等待加锁成功，被唤醒，或者超时。 </p><p>E. 写数据，并将自己的trx_id写入trx_id字段。</p><h4 id="2-显式锁"><a href="#2-显式锁" class="headerlink" title="2. 显式锁"></a>2. 显式锁</h4><p>通过特定的语句进行加锁，我们一般称之为显示加锁，例如：</p><p>显示加共享锁：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select .... lock in share mode</span><br></pre></td></tr></table></figure><p>显示加排它锁：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select .... for update</span><br></pre></td></tr></table></figure><h3 id="3-5-其它锁之：全局锁"><a href="#3-5-其它锁之：全局锁" class="headerlink" title="3.5 其它锁之：全局锁"></a>3.5 其它锁之：全局锁</h3><p>全局锁就是对 <code>整个数据库实例</code> 加锁。当你需要让整个库处于 <code>只读状态</code> 的时候，可以使用这个命令，之后 其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结 构等）和更新类事务的提交语句。全局锁的典型使用 <code>场景</code> 是：做 <code>全库逻辑备份</code> 。</p><p>全局锁的命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Flush tables with read lock</span><br></pre></td></tr></table></figure><h3 id="3-6-其它锁之：死锁"><a href="#3-6-其它锁之：死锁" class="headerlink" title="3.6 其它锁之：死锁"></a>3.6 其它锁之：死锁</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h4><p>两个事务都持有对方需要的锁，并且在等待对方释放，并且双方都不会释放自己的锁。</p><p><strong>举例1：</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th>事务1</th><th>事务2</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td>start transaction;<br>update account set money=10 where id=1;</td><td>start transaction;</td></tr><tr><td style="text-align:center">2</td><td></td><td>update account set money=10 where id=2;</td></tr><tr><td style="text-align:center">3</td><td>update account set money=20 where id=2;</td><td></td></tr><tr><td style="text-align:center">4</td><td></td><td>update account set money=20 where id=1;</td></tr></tbody></table></div><p><strong>举例2：</strong></p><p>用户A给用户B转账100，再次同时，用户B也给用户A转账100。这个过程，可能导致死锁。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#事务1</span><br><span class="line">update account set balance = balance - 100 where name = &#x27;A&#x27;;#操作1</span><br><span class="line">update account set balance = balance + 108 where name = &#x27;B&#x27;;#操作3</span><br><span class="line">#事务2</span><br><span class="line">update account set balance = balance - 100 where name = &#x27;B&#x27;;#操作2</span><br><span class="line">update account set balance = balance + 100 where name = &#x27;A&#x27;;#操作4</span><br></pre></td></tr></table></figure><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220713220936236.png" alt="image-20220713220936236" style="float:left;"></p><h4 id="2-产生死锁的必要条件"><a href="#2-产生死锁的必要条件" class="headerlink" title="2. 产生死锁的必要条件"></a>2. 产生死锁的必要条件</h4><ol><li>两个或者两个以上事务</li><li>每个事务都已经持有锁并且申请新的锁</li><li>锁资源同时只能被同一个事务持有或者不兼容</li><li>事务之间因为持有锁和申请锁导致彼此循环等待</li></ol><blockquote><p>死锁的关键在于：两个（或以上）的Session加锁的顺序不一致。</p></blockquote><h4 id="3-如何处理死锁"><a href="#3-如何处理死锁" class="headerlink" title="3. 如何处理死锁"></a>3. 如何处理死锁</h4><p><strong>方式1：</strong>等待，直到超时（innodb_lock_wait_timeout=50s)</p><p>即当两个事务互相等待时，当一个事务等待时间超过设置的阈值时，就将其<code>回滚</code>，另外事务继续进行。这种方法简单有效，在innodb中，参数<code>innodb_lock_wait_timeout</code>用来设置超时时间。</p><p>缺点:对于在线服务来说，这个等待时间往往是无法接受的。</p><p>那将此值修改短一些，比如1s，0.1s是否合适?不合适，容易误伤到普通的锁等待。</p><p><strong>方式2：</strong>使用死锁检测处理死锁程序</p><p>方式1检测死锁太过被动，innodb还提供了<code>wait-for graph算法</code>来主动进行死锁检测，每当加锁请求无法立即满足需要并进入等待时，wait-for graph算法都会被触发。</p><p>这是一种较为<code>主动的死锁检测机制</code>，要求数据库保存<code>锁的信息链表</code>和<code>事物等待链表</code>两部分信息。</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220713221758941.png" alt="image-20220713221758941"></p><p>基于这两个信息，可以绘制wait-for graph（等待图）</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220713221830455.png" alt="image-20220713221830455"></p><blockquote><p>死锁检测的原理是构建一个以事务为顶点，锁为边的有向图，判断有向图是否存在环，存在既有死锁。</p></blockquote><p>一旦检测到回路、有死锁，这时候InnoDB存储引擎会选择<code>回滚undo量最小的事务</code>，让其他事务继续执行（<code>innodb_deadlock_detect=on</code>表示开启这个逻辑）。</p><p>缺点：每个新的被阻塞的线程，都要判断是不是由于自己的加入导致了死锁，这个操作时间复杂度是O(n)。如果100个并发线程同时更新同一行，意味着要检测100*100=1万次，1万个线程就会有1千万次检测。</p><p><strong>如何解决？</strong></p><ul><li>方式1：关闭死锁检测，但意味着可能会出现大量的超时，会导致业务有损。</li><li>方式2：控制并发访问的数量。比如在中间件中实现对于相同行的更新，在进入引擎之前排队，这样在InnoDB内部就不会有大量的死锁检测工作。</li></ul><p><strong>进一步的思路：</strong></p><p>可以考虑通过将一行改成逻辑上的多行来减少<code>锁冲突</code>。比如，连锁超市账户总额的记录，可以考虑放到多条记录上。账户总额等于这多个记录的值的总和。</p><h4 id="4-如何避免死锁"><a href="#4-如何避免死锁" class="headerlink" title="4. 如何避免死锁"></a>4. 如何避免死锁</h4><ul><li>合理设计索引，使业务SQL尽可能通过索引定位更少的行，减少锁竞争。</li><li>调整业务逻辑sQL执行顺序，避免update/delete长时间持有锁的sQL在事务前面。</li><li>避免大事务，尽量将大事务拆成多个小事务来处理，小事务缩短锁定资源的时间，发生锁冲突的几率也更小。</li><li>在并发比较高的系统中，不要显式加锁，特别是是在事务里显式加锁。如select … for update语句，如果是在事务里运行了start transaction或设置auto commit等于0，那么就会锁定所查找到的记录。</li><li>降低隔离级别。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁。</li></ul><h2 id="4-锁的内部结构"><a href="#4-锁的内部结构" class="headerlink" title="4. 锁的内部结构"></a>4. 锁的内部结构</h2><p>我们前边说对一条记录加锁的本质就是在内存中创建一个<code>锁结构</code>与之关联，那么是不是一个事务对多条记录加锁，就要创建多个<code>锁结构</code>呢？比如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 事务T1</span><br><span class="line">SELECT * FROM user LOCK IN SHARE MODE;</span><br></pre></td></tr></table></figure><p>理论上创建多个<code>锁结构</code>没问题，但是如果一个事务要获取10000条记录的锁，生成10000个锁结构也太崩溃了！所以决定在对不同记录加锁时，如果符合下边这些条件的记录会放在一个<code>锁结构</code>中。</p><ul><li>在同一个事务中进行加锁操作</li><li>被加锁的记录在同一个页面中</li><li>加锁的类型是一样的</li><li>等待状态是一样的</li></ul><p><code>InnoDB</code> 存储引擎中的 <code>锁结构</code> 如下：</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220714132306208.png" alt="image-20220714132306208"></p><p>结构解析：</p><p><code>1. 锁所在的事务信息</code>：</p><p>不论是 <code>表锁</code> 还是 <code>行锁</code> ，都是在事务执行过程中生成的，哪个事务生成了这个<code>锁结构</code> ，这里就记录这个事务的信息。</p><p>此 <code>锁所在的事务信息</code> 在内存结构中只是一个指针，通过指针可以找到内存中关于该事务的更多信息，比方说事务id等。</p><p><code>2. 索引信息</code> ：</p><p>对于 <code>行锁</code> 来说，需要记录一下加锁的记录是属于哪个索引的。这里也是一个指针。</p><p><code>3. 表锁／行锁信息</code> ：</p><p><code>表锁结构</code> 和 <code>行锁结构</code> 在这个位置的内容是不同的：</p><ul><li><p>表锁：</p><p>记载着是对哪个表加的锁，还有其他的一些信息。</p></li><li><p>行锁：</p><p>记载了三个重要的信息：</p><ul><li><code>Space ID</code> ：记录所在表空间。</li><li><code>Page Number</code> ：记录所在页号。</li><li><code>n_bits</code>：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同 的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个<code>n_bis</code>属性代表使用了多少比特位。</li></ul><blockquote><p>n_bits的值一般都比页面中记录条数多一些。主要是为了之后在页面中插入了新记录后 也不至于重新分配锁结构</p></blockquote></li></ul><p><code>4. type_mode</code> ：</p><p>这是一个32位的数，被分成了 <code>lock_mode</code> 、 <code>lock_type</code> 和 <code>rec_lock_type</code> 三个部分，如图所示：</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220714133319666.png" alt="image-20220714133319666"></p><ul><li>锁的模式（ <code>lock_mode</code> ），占用低4位，可选的值如下：<ul><li><code>LOCK_IS</code> （十进制的 0 ）：表示共享意向锁，也就是 <code>IS锁</code> 。 </li><li><code>LOCK_IX</code> （十进制的 1 ）：表示独占意向锁，也就是 <code>IX锁</code> 。 </li><li><code>LOCK_S</code> （十进制的 2 ）：表示共享锁，也就是 <code>S锁</code> 。 </li><li><code>LOCK_X</code> （十进制的 3 ）：表示独占锁，也就是 <code>X锁</code> 。 </li><li><code>LOCK_AUTO_INC</code> （十进制的 4 ）：表示 <code>AUTO-INC锁</code> 。</li></ul></li></ul><p>在InnoDB存储引擎中，LOCK_IS，LOCK_IX，LOCK_AUTO_INC都算是表级锁的模式，LOCK_S和 LOCK_X既可以算是表级锁的模式，也可以是行级锁的模式。</p><ul><li>锁的类型（ <code>lock_type</code> ），占用第5～8位，不过现阶段只有第5位和第6位被使用：<ul><li><code>LOCK_TABLE</code> （十进制的 16 ），也就是当第5个比特位置为1时，表示表级锁。</li><li><code>LOCK_REC</code>（十进制的 32 ），也就是当第6个比特位置为1时，表示行级锁。</li></ul></li><li>行锁的具体类型（ <code>rec_lock_type</code> ），使用其余的位来表示。只有在 <code>lock_type</code> 的值为 <code>LOCK_REC</code> 时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：<ul><li><code>LOCK_ORDINARY</code> （十进制的 0 ）：表示 <code>next-key锁</code> 。</li><li><code>LOCK_GAP</code> （十进制的 512 ）：也就是当第10个比特位置为1时，表示 <code>gap锁</code> 。</li><li><code>LOCK_REC_NOT_GAP</code> （十进制的 1024 ）：也就是当第11个比特位置为1时，表示正经 <code>记录锁</code> 。</li><li><code>LOCK_INSERT_INTENTION</code> （十进制的 2048 ）：也就是当第12个比特位置为1时，表示插入意向锁。其他的类型：还有一些不常用的类型我们就不多说了。</li></ul></li><li><code>is_waiting</code> 属性呢？基于内存空间的节省，所以把 <code>is_waiting</code> 属性放到了 <code>type_mode</code> 这个32 位的数字中：<ul><li><code>LOCK_WAIT</code> （十进制的 256 ） ：当第9个比特位置为 1 时，表示 <code>is_waiting</code> 为 <code>true</code> ，也 就是当前事务尚未获取到锁，处在等待状态；当这个比特位为 0 时，表示 <code>is_waiting</code> 为 <code>false</code> ，也就是当前事务获取锁成功。</li></ul></li></ul><p><code>5. 其他信息</code> ：</p><p>为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表。</p><p><code>6. 一堆比特位</code> ：</p><p>如果是 <code>行锁结构</code> 的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的 <code>n_bits</code> 属性 表示的。InnoDB数据页中的每条记录在 <code>记录头信息</code> 中都包含一个 <code>heap_no</code> 属性，伪记录 <code>Infimum</code> 的 <code>heap_no</code> 值为 0 ， <code>Supremum</code> 的 <code>heap_no</code> 值为 1 ，之后每插入一条记录， <code>heap_no</code> 值就增1。 锁结构最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个 <code>heap_no</code> ，即一个比特位映射 到页内的一条记录。</p><h2 id="5-锁监控"><a href="#5-锁监控" class="headerlink" title="5. 锁监控"></a>5. 锁监控</h2><p>关于MySQL锁的监控，我们一般可以通过检查 InnoDB_row_lock 等状态变量来分析系统上的行锁的争夺情况</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show status like &#x27;innodb_row_lock%&#x27;;</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">| Variable_name                 | Value |</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">| Innodb_row_lock_current_waits | 0     |</span><br><span class="line">| Innodb_row_lock_time          | 0     |</span><br><span class="line">| Innodb_row_lock_time_avg      | 0     |</span><br><span class="line">| Innodb_row_lock_time_max      | 0     |</span><br><span class="line">| Innodb_row_lock_waits         | 0     |</span><br><span class="line">+-------------------------------+-------+</span><br><span class="line">5 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>对各个状态量的说明如下：</p><ul><li>Innodb_row_lock_current_waits：当前正在等待锁定的数量； </li><li><code>Innodb_row_lock_time</code> ：从系统启动到现在锁定总时间长度；（等待总时长） </li><li><code>Innodb_row_lock_time_avg</code> ：每次等待所花平均时间；（等待平均时长） </li><li>Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间； </li><li><code>Innodb_row_lock_waits</code> ：系统启动后到现在总共等待的次数；（等待总次数）</li></ul><p>对于这5个状态变量，比较重要的3个见上面（灰色）。</p><p>尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手指定优化计划。</p><p><strong>其他监控方法：</strong></p><p>MySQL把事务和锁的信息记录在了 <code>information_schema</code> 库中，涉及到的三张表分别是 <code>INNODB_TRX</code> 、 <code>INNODB_LOCKS</code> 和 <code>INNODB_LOCK_WAITS</code> 。</p><p><code>MySQL5.7及之前</code> ，可以通过information_schema.INNODB_LOCKS查看事务的锁情况，但只能看到阻塞事 务的锁；如果事务并未被阻塞，则在该表中看不到该事务的锁情况。</p><p>MySQL8.0删除了information_schema.INNODB_LOCKS，添加了 <code>performance_schema.data_locks</code> ，可以通过performance_schema.data_locks查看事务的锁情况，和MySQL5.7及之前不同， performance_schema.data_locks不但可以看到阻塞该事务的锁，还可以看到该事务所持有的锁。</p><p>同时，information_schema.INNODB_LOCK_WAITS也被 <code>performance_schema.data_lock_waits</code> 所代 替。</p><p>我们模拟一个锁等待的场景，以下是从这三张表收集的信息</p><p>锁等待场景，我们依然使用记录锁中的案例，当事务2进行等待时，查询情况如下：</p><p>（1）查询正在被锁阻塞的sql语句。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM information_schema.INNODB_TRX\G;</span><br></pre></td></tr></table></figure><p>重要属性代表含义已在上述中标注。</p><p>（2）查询锁等待情况</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM data_lock_waits\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">ENGINE: INNODB</span><br><span class="line">REQUESTING_ENGINE_LOCK_ID: 139750145405624:7:4:7:139747028690608</span><br><span class="line">REQUESTING_ENGINE_TRANSACTION_ID: 13845 #被阻塞的事务ID</span><br><span class="line">REQUESTING_THREAD_ID: 72</span><br><span class="line">REQUESTING_EVENT_ID: 26</span><br><span class="line">REQUESTING_OBJECT_INSTANCE_BEGIN: 139747028690608</span><br><span class="line">BLOCKING_ENGINE_LOCK_ID: 139750145406432:7:4:7:139747028813248</span><br><span class="line">BLOCKING_ENGINE_TRANSACTION_ID: 13844 #正在执行的事务ID，阻塞了13845</span><br><span class="line">BLOCKING_THREAD_ID: 71</span><br><span class="line">BLOCKING_EVENT_ID: 24</span><br><span class="line">BLOCKING_OBJECT_INSTANCE_BEGIN: 139747028813248</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>（3）查询锁的情况</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql &gt; SELECT * from performance_schema.data_locks\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">ENGINE: INNODB</span><br><span class="line">ENGINE_LOCK_ID: 139750145405624:1068:139747028693520</span><br><span class="line">ENGINE_TRANSACTION_ID: 13847</span><br><span class="line">THREAD_ID: 72</span><br><span class="line">EVENT_ID: 31</span><br><span class="line">OBJECT_SCHEMA: atguigu</span><br><span class="line">OBJECT_NAME: user</span><br><span class="line">PARTITION_NAME: NULL</span><br><span class="line">SUBPARTITION_NAME: NULL</span><br><span class="line">INDEX_NAME: NULL</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 139747028693520</span><br><span class="line">LOCK_TYPE: TABLE</span><br><span class="line">LOCK_MODE: IX</span><br><span class="line">LOCK_STATUS: GRANTED</span><br><span class="line">LOCK_DATA: NULL</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">ENGINE: INNODB</span><br><span class="line">ENGINE_LOCK_ID: 139750145405624:7:4:7:139747028690608</span><br><span class="line">ENGINE_TRANSACTION_ID: 13847</span><br><span class="line">THREAD_ID: 72</span><br><span class="line">EVENT_ID: 31</span><br><span class="line">OBJECT_SCHEMA: atguigu</span><br><span class="line">OBJECT_NAME: user</span><br><span class="line">PARTITION_NAME: NULL</span><br><span class="line">SUBPARTITION_NAME: NULL</span><br><span class="line">INDEX_NAME: PRIMARY</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 139747028690608</span><br><span class="line">LOCK_TYPE: RECORD</span><br><span class="line">LOCK_MODE: X,REC_NOT_GAP</span><br><span class="line">LOCK_STATUS: WAITING</span><br><span class="line">LOCK_DATA: 1</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">ENGINE: INNODB</span><br><span class="line">ENGINE_LOCK_ID: 139750145406432:1068:139747028816304</span><br><span class="line">ENGINE_TRANSACTION_ID: 13846</span><br><span class="line">THREAD_ID: 71</span><br><span class="line">EVENT_ID: 28</span><br><span class="line">OBJECT_SCHEMA: atguigu</span><br><span class="line">OBJECT_NAME: user</span><br><span class="line">PARTITION_NAME: NULL</span><br><span class="line">SUBPARTITION_NAME: NULL</span><br><span class="line">INDEX_NAME: NULL</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 139747028816304</span><br><span class="line">LOCK_TYPE: TABLE</span><br><span class="line">LOCK_MODE: IX</span><br><span class="line">LOCK_STATUS: GRANTED</span><br><span class="line">LOCK_DATA: NULL</span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line">ENGINE: INNODB</span><br><span class="line">ENGINE_LOCK_ID: 139750145406432:7:4:7:139747028813248</span><br><span class="line">ENGINE_TRANSACTION_ID: 13846</span><br><span class="line">THREAD_ID: 71</span><br><span class="line">EVENT_ID: 28</span><br><span class="line">OBJECT_SCHEMA: atguigu</span><br><span class="line">OBJECT_NAME: user</span><br><span class="line">PARTITION_NAME: NULL</span><br><span class="line">SUBPARTITION_NAME: NULL</span><br><span class="line">INDEX_NAME: PRIMARY</span><br><span class="line">OBJECT_INSTANCE_BEGIN: 139747028813248</span><br><span class="line">LOCK_TYPE: RECORD</span><br><span class="line">LOCK_MODE: X,REC_NOT_GAP</span><br><span class="line">LOCK_STATUS: GRANTED</span><br><span class="line">LOCK_DATA: 1</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR:</span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure><p>从锁的情况可以看出来，两个事务分别获取了IX锁，我们从意向锁章节可以知道，IX锁互相时兼容的。所 以这里不会等待，但是事务1同样持有X锁，此时事务2也要去同一行记录获取X锁，他们之间不兼容，导 致等待的情况发生。</p><h2 id="6-附录"><a href="#6-附录" class="headerlink" title="6. 附录"></a>6. 附录</h2><p><strong>间隙锁加锁规则（共11个案例）</strong></p><p>间隙锁是在可重复读隔离级别下才会生效的： next-key lock 实际上是由间隙锁加行锁实现的，如果切换 到读提交隔离级别 (read-committed) 的话，就好理解了，过程中去掉间隙锁的部分，也就是只剩下行锁 的部分。而在读提交隔离级别下间隙锁就没有了，为了解决可能出现的数据和日志不一致问题，需要把 binlog 格式设置为 row 。也就是说，许多公司的配置为：读提交隔离级别加 binlog_format=row。业务不 需要可重复读的保证，这样考虑到读提交下操作数据的锁范围更小（没有间隙锁），这个选择是合理的。</p><p>next-key lock的加锁规则</p><p>总结的加锁规则里面，包含了两个 “ “ 原则 ” ” 、两个 “ “ 优化 ” ” 和一个 “bug” 。</p><ol><li>原则 1 ：加锁的基本单位是 next-key lock 。 next-key lock 是前开后闭区间。 </li><li>原则 2 ：查找过程中访问到的对象才会加锁。任何辅助索引上的锁，或者非索引列上的锁，最终 都要回溯到主键上，在主键上也要加一把锁。 </li><li>优化 1 ：索引上的等值查询，给唯一索引加锁的时候， next-key lock 退化为行锁。也就是说如果 InnoDB扫描的是一个主键、或是一个唯一索引的话，那InnoDB只会采用行锁方式来加锁 </li><li>优化 2 ：索引上（不一定是唯一索引）的等值查询，向右遍历时且最后一个值不满足等值条件的 时候， next-keylock 退化为间隙锁。 </li><li>一个 bug ：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li></ol><p>我们以表test作为例子，建表语句和初始化语句如下：其中id为主键索引</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `test` (</span><br><span class="line">`id` int(11) NOT NULL,</span><br><span class="line">`col1` int(11) DEFAULT NULL,</span><br><span class="line">`col2` int(11) DEFAULT NULL,</span><br><span class="line">PRIMARY KEY (`id`),</span><br><span class="line">KEY `c` (`c`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line">insert into test values(0,0,0),(5,5,5),</span><br><span class="line">(10,10,10),(15,15,15),(20,20,20),(25,25,25);</span><br></pre></td></tr></table></figure><p><strong>案例一：唯一索引等值查询间隙锁</strong></p><div class="table-container"><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th></tr></thead><tbody><tr><td>begin;<br>update test set col2 = col2+1 where id=7;</td><td></td><td></td></tr><tr><td></td><td>insert into test values(8,8,8)(blocked)</td><td></td></tr><tr><td></td><td></td><td>update test set col2 = col2+1 where id=10;<br>(Query OK)</td></tr></tbody></table></div><p>由于表 test 中没有 id=7 的记录</p><p>根据原则 1 ，加锁单位是 next-key lock ， session A 加锁范围就是 (5,10] ； 同时根据优化 2 ，这是一个等 值查询 (id=7) ，而 id=10 不满足查询条件， next-key lock 退化成间隙锁，因此最终加锁的范围是 (5,10)</p><p><strong>案例二：非唯一索引等值查询锁</strong></p><div class="table-container"><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th></tr></thead><tbody><tr><td>begin;<br>select id from test where col1 = 5 lock in share mode;</td><td></td><td></td></tr><tr><td></td><td>update test col2 = col2+1where id=5;<br>(Query OK)</td><td></td></tr><tr><td></td><td></td><td>insert into test values(7,7,7)(blocked)</td></tr></tbody></table></div><p>这里 session A 要给索引 col1 上 col1=5 的这一行加上读锁。</p><ol><li>根据原则 1 ，加锁单位是 next-key lock ，左开右闭，5是闭上的，因此会给 (0,5] 加上 next-key lock 。 </li><li>要注意 c 是普通索引，因此仅访问 c=5 这一条记录是不能马上停下来的（可能有col1=5的其他记 录），需要向右遍历，查到c=10 才放弃。根据原则 2 ，访问到的都要加锁，因此要给 (5,10] 加 next-key lock 。 </li><li>但是同时这个符合优化 2 ：等值判断，向右遍历，最后一个值不满足 col1=5 这个等值条件，因此退化成间隙锁 (5,10) 。</li><li>根据原则 2 ， 只有访问到的对象才会加锁，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，这就是为什么 session B 的 update 语句可以执行完成。</li></ol><p>但 session C 要插入一个 (7,7,7) 的记录，就会被 session A 的间隙锁 (5,10) 锁住 这个例子说明，锁是加在索引上的。</p><p>执行 for update 时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁。</p><p>如果你要用 lock in share mode来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，因为覆盖索引不会访问主键索引，不会给主键索引上加锁</p><p><strong>案例三：主键索引范围查询锁</strong></p><p>上面两个例子是等值查询的，这个例子是关于范围查询的，也就是说下面的语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from test where id=10 for update</span><br><span class="line">select * from tets where id&gt;=10 and id&lt;11 for update;</span><br></pre></td></tr></table></figure><p>这两条查语句肯定是等价的，但是它们的加锁规则不太一样</p><div class="table-container"><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th></tr></thead><tbody><tr><td>begin;<br>sclect * from test where id&gt;= 10 and id&lt;11 for update;</td><td></td><td></td></tr><tr><td></td><td>insert into test values(8,8,8)(Query OK)<br>insert into testvalues(13,13,13);(blocked)</td><td></td></tr><tr><td></td><td></td><td>update test set col2 = col2+1 where id=10; (Query OK)</td></tr></tbody></table></div><ol><li>开始执行的时候，要找到第一个 id=10 的行，因此本该是 next-key lock(5,10] 。 根据优化 1 ，主键 id 上的等值条件，退化成行锁，只加了 id=10 这一行的行锁。 </li><li>它是范围查询， 范围查找就往后继续找，找到 id=15 这一行停下来，不满足条件，因此需要加 next-key lock(10,15] 。</li></ol><p>session A 这时候锁的范围就是主键索引上，行锁 id=10 和 next-key lock(10,15] 。<strong>首次 session A 定位查找 id=10 的行的时候，是当做等值查询来判断的，而向右扫描到 id=15 的时候，用的是范围查询判断。</strong></p><p><strong>案例四：非唯一索引范围查询锁</strong></p><p>与案例三不同的是，案例四中查询语句的 where 部分用的是字段 c ，它是普通索引</p><p>这两条查语句肯定是等价的，但是它们的加锁规则不太一样</p><div class="table-container"><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th></tr></thead><tbody><tr><td>begin;<br>select * from test where col1&gt;= 10 andcol1&lt;11 for update;</td><td></td><td></td></tr><tr><td></td><td>insert into test<br>values(8,8,8)(blocked)</td><td></td></tr><tr><td></td><td></td><td>update test set clo2=col2+1 where id=15;<br>(blocked)</td></tr></tbody></table></div><p>在第一次用 col1=10 定位记录的时候，索引 c 上加了 (5,10] 这个 next-key lock 后，由于索引 col1 是非唯 一索引，没有优化规则，也就是说不会蜕变为行锁，因此最终 sesion A 加的锁是，索引 c 上的 (5,10] 和 (10,15] 这两个 next-keylock 。</p><p>这里需要扫描到 col1=15 才停止扫描，是合理的，因为 InnoDB 要扫到 col1=15 ，才知道不需要继续往后找了。</p><p><strong>案例五：唯一索引范围查询锁 bug</strong></p><div class="table-container"><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th></tr></thead><tbody><tr><td>begin;<br>select * from test where id&gt; 10 and id&lt;=15 for update;</td><td></td><td></td></tr><tr><td></td><td>update test set clo2=col2+1 where id=20;<br>(blocked)</td><td></td></tr><tr><td></td><td></td><td>insert into test values(16,16,16);(blocked)</td></tr></tbody></table></div><p>session A 是一个范围查询，按照原则 1 的话，应该是索引 id 上只加 (10,15] 这个 next-key lock ，并且因 为 id 是唯一键，所以循环判断到 id=15 这一行就应该停止了。</p><p>但是实现上， InnoDB 会往前扫描到第一个不满足条件的行为止，也就是 id=20 。而且由于这是个范围扫描，因此索引 id 上的 (15,20] 这个 next-key lock 也会被锁上。照理说，这里锁住 id=20 这一行的行为，其实是没有必要的。因为扫描到 id=15 ，就可以确定不用往后再找了。</p><p><strong>案例六：非唯一索引上存在 “ “ 等值 “ “ 的例子</strong></p><p>这里，我给表 t 插入一条新记录：insert into t values(30,10,30);也就是说，现在表里面有两个c=10的行</p><p><strong>但是它们的主键值 id 是不同的（分别是 10 和 30 ），因此这两个c=10 的记录之间，也是有间隙的。</strong></p><div class="table-container"><table><thead><tr><th>sessionA</th><th>sessionB</th><th>sessionC</th></tr></thead><tbody><tr><td>begin;<br>delete from test where col1=10;</td><td></td><td></td></tr><tr><td></td><td>insert into test values(12,12,12);(blocked)</td><td></td></tr><tr><td></td><td></td><td>update test set col2=col2+1 where c=15;<br>(blocked)</td></tr></tbody></table></div><p>这次我们用 delete 语句来验证。注意， delete 语句加锁的逻辑，其实跟 select … for update 是类似的， 也就是我在文章开始总结的两个 “ 原则 ” 、两个 “ 优化 ” 和一个 “bug” 。</p><p>这时， session A 在遍历的时候，先访问第一个 col1=10 的记录。同样地，根据原则 1 ，这里加的是 (col1=5,id=5) 到 (col1=10,id=10) 这个 next-key lock 。</p><p>由于c是普通索引，所以继续向右查找，直到碰到 (col1=15,id=15) 这一行循环才结束。根据优化 2 ，这是 一个等值查询，向右查找到了不满足条件的行，所以会退化成 (col1=10,id=10) 到 (col1=15,id=15) 的间隙锁。</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220714134945012.png" alt="image-20220714134945012"></p><p>这个 delete 语句在索引 c 上的加锁范围，就是上面图中蓝色区域覆盖的部分。这个蓝色区域左右两边都 是虚线，表示开区间，即 (col1=5,id=5) 和 (col1=15,id=15) 这两行上都没有锁</p><p><strong>案例七： limit 语句加锁</strong></p><p>例子 6 也有一个对照案例，场景如下所示：</p><div class="table-container"><table><thead><tr><th>sessionA</th><th>sessionB</th></tr></thead><tbody><tr><td>begin;<br>delete from test where col1=10 limit 2;</td><td></td></tr><tr><td></td><td>insert into test values(12,12,12);(Query OK)</td></tr></tbody></table></div><p>session A 的 delete 语句加了 limit 2 。你知道表 t 里 c=10 的记录其实只有两条，因此加不加 limit 2 ，删除的效果都是一样的。但是加锁效果却不一样</p><p>这是因为，案例七里的 delete 语句明确加了 limit 2 的限制，因此在遍历到 (col1=10, id=30) 这一行之后， 满足条件的语句已经有两条，循环就结束了。因此，索引 col1 上的加锁范围就变成了从（ col1=5,id=5) 到（ col1=10,id=30) 这个前开后闭区间，如下图所示：</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220714135025045-16577778257713.png" alt="image-20220714135025045"></p><p>这个例子对我们实践的指导意义就是， 在删除数据的时候尽量加 limit 。</p><p>这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围。</p><p><strong>案例八：一个死锁的例子</strong></p><div class="table-container"><table><thead><tr><th>sessionA</th><th>sessionB</th></tr></thead><tbody><tr><td>begin;<br>select id from test where col1=10 lockin share mode;</td><td></td></tr><tr><td></td><td>update test set col2=col2+1 where c=10;(blocked)</td></tr><tr><td>insert into test values(8,8,8);</td><td></td></tr><tr><td></td><td>ERROR 1213(40001):Deadlock found when trying to getlock;try restarting transaction</td></tr></tbody></table></div><ol><li>session A 启动事务后执行查询语句加 lock in share mode ，在索引 col1 上加了 next-keylock(5,10] 和 间隙锁 (10,15) （索引向右遍历退化为间隙锁）； </li><li>session B 的 update 语句也要在索引 c 上加 next-key lock(5,10] ，进入锁等待； 实际上分成了两步， 先是加 (5,10) 的间隙锁，加锁成功；然后加 col1=10 的行锁，因为sessionA上已经给这行加上了读 锁，此时申请死锁时会被阻塞 </li><li>然后 session A 要再插入 (8,8,8) 这一行，被 session B 的间隙锁锁住。由于出现了死锁， InnoDB 让 session B 回滚</li></ol><p><strong>案例九：order by索引排序的间隙锁1</strong></p><p>如下面一条语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from test where id&gt;9 and id&lt;12 order by id desc for update;</span><br></pre></td></tr></table></figure><p>下图为这个表的索引id的示意图。</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220714135130668.png" alt="image-20220714135130668"></p><ol><li>首先这个查询语句的语义是 order by id desc ，要拿到满足条件的所有行，优化器必须先找到 “ 第 一个 id&lt;12 的值 ” 。 </li><li>这个过程是通过索引树的搜索过程得到的，在引擎内部，其实是要找到 id=12 的这个值，只是最终 没找到，但找到了 (10,15) 这个间隙。（ id=15 不满足条件，所以 next-key lock 退化为了间隙锁 (10, 15) 。）</li><li>然后向左遍历，在遍历过程中，就不是等值查询了，会扫描到 id=5 这一行，又因为区间是左开右 闭的，所以会加一个next-key lock (0,5] 。 也就是说，在执行过程中，通过树搜索的方式定位记录 的时候，用的是 “ 等值查询 ” 的方法。</li></ol><p><strong>案例十：order by索引排序的间隙锁2</strong></p><div class="table-container"><table><thead><tr><th>sessionA</th><th>sessionB</th></tr></thead><tbody><tr><td>begin<br>select *from test where col1&gt;=15 and c&lt;=20 order by col1 desc lock in share mode;</td><td></td></tr><tr><td></td><td>insert into test values(6,6,6);(blocked)</td></tr></tbody></table></div><ol><li><p>由于是 order by col1 desc ，第一个要定位的是索引 col1 上 “ 最右边的 ”col1=20 的行。这是一个非唯一索引的等值查询：</p><p>左开右闭区间，首先加上 next-key lock (15,20] 。 向右遍历，col1=25不满足条件，退化为间隙锁 所以会 加上间隙锁(20,25) 和 next-key lock (15,20] 。</p></li><li><p>在索引 col1 上向左遍历，要扫描到 col1=10 才停下来。同时又因为左开右闭区间，所以 next-key lock 会加到 (5,10] ，这正是阻塞session B 的 insert 语句的原因。</p></li><li><p>在扫描过程中， col1=20 、 col1=15 、 col1=10 这三行都存在值，由于是 select * ，所以会在主键 id 上加三个行锁。 因此， session A 的 select 语句锁的范围就是：</p><ol><li>索引 col1 上 (5, 25) ；</li><li>主键索引上 id=15 、 20 两个行锁。</li></ol></li></ol><p><strong>案例十一：update修改数据的例子-先插入后删除</strong></p><div class="table-container"><table><thead><tr><th>sessionA</th><th>sessionB</th></tr></thead><tbody><tr><td>begin;<br>select col1 from test where col1&gt;5 lock in share mode;</td><td></td></tr><tr><td></td><td>update test set col1=1 where col1=5(Query OK)<br>update test set col1=5 where col1=1;(blocked)</td></tr></tbody></table></div><p>注意：根据 col1&gt;5 查到的第一个记录是 col1=10 ，因此不会加 (0,5] 这个 next-key lock 。</p><p>session A 的加锁范围是索引 col1 上的 (5,10] 、 (10,15] 、 (15,20] 、 (20,25] 和(25,supremum] 。</p><p>之后 session B 的第一个 update 语句，要把 col1=5 改成 col1=1 ，你可以理解为两步：</p><ol><li>插入 (col1=1, id=5) 这个记录；</li><li>删除 (col1=5, id=5) 这个记录。</li></ol><p>通过这个操作， session A 的加锁范围变成了图 7 所示的样子:</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220714135333089.png" alt="image-20220714135333089"></p><p>好，接下来 session B 要执行 update t set col1 = 5 where col1 = 1 这个语句了，一样地可以拆成两步：</p><ol><li>插入 (col1=5, id=5) 这个记录；</li><li>删除 (col1=1, id=5) 这个记录。 第一步试图在已经加了间隙锁的 (1,10) 中插入数据，所以就被堵住了。</li></ol><h1 id="第16章-多版本并发控制"><a href="#第16章-多版本并发控制" class="headerlink" title="第16章_多版本并发控制"></a>第16章_多版本并发控制</h1><h2 id="1-什么是MVCC"><a href="#1-什么是MVCC" class="headerlink" title="1. 什么是MVCC"></a>1. 什么是MVCC</h2><p>MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版本管理来实现数据库的 <code>并发控制</code>。这项技术使得在InnoDB的事务隔离级别下执行 <code>一致性读</code> 操作有了保证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样 在做查询的时候就不用等待另一个事务释放锁。</p><p>MVCC没有正式的标准，在不同的DBMS中MVCC的实现方式可能是不同的，也不是普遍使用的（大家可以参考相关的DBMS文档）。这里讲解InnoDB中MVCC的实现机制（MySQL其他的存储引擎并不支持它）。</p><h2 id="2-快照读与当前读"><a href="#2-快照读与当前读" class="headerlink" title="2. 快照读与当前读"></a>2. 快照读与当前读</h2><p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理 <code>读-写冲突</code> ，做到即使有读写冲突时，也能做到 <code>不加锁</code> ， <code>非阻塞并发读</code> ，而这个读指的就是 <code>快照读</code> , 而非 <code>当前读</code> 。当前 读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式。</p><h3 id="2-1-快照读"><a href="#2-1-快照读" class="headerlink" title="2.1 快照读"></a>2.1 快照读</h3><p>快照读又叫一致性读，读取的是快照数据。<strong>不加锁的简单的 SELECT 都属于快照读</strong>，即不加锁的非阻塞 读；比如这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM player WHERE ...</span><br></pre></td></tr></table></figure><p>之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于MVCC，它在很多情况下， 避免了加锁操作，降低了开销。</p><p>既然是基于多版本，那么快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。 </p><p>快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读。</p><h3 id="2-2-当前读"><a href="#2-2-当前读" class="headerlink" title="2.2 当前读"></a>2.2 当前读</h3><p>当前读读取的是记录的最新版本（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务 不能修改当前记录，会对读取的记录进行加锁。加锁的 SELECT，或者对数据进行增删改都会进行当前 读。比如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM student LOCK IN SHARE MODE; # 共享锁</span><br><span class="line">SELECT * FROM student FOR UPDATE; # 排他锁</span><br><span class="line">INSERT INTO student values ... # 排他锁</span><br><span class="line">DELETE FROM student WHERE ... # 排他锁</span><br><span class="line">UPDATE student SET ... # 排他锁</span><br></pre></td></tr></table></figure><h2 id="3-复习"><a href="#3-复习" class="headerlink" title="3. 复习"></a>3. 复习</h2><h3 id="3-1-再谈隔离级别"><a href="#3-1-再谈隔离级别" class="headerlink" title="3.1 再谈隔离级别"></a>3.1 再谈隔离级别</h3><p>我们知道事务有 4 个隔离级别，可能存在三种并发问题：</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220714140441064.png" alt="image-20220714140441064"></p><p>在MysQL中，默认的隔离级别是可重复读，可以解决脏读和不可重复读的问题，如果仅从定义的角度来看，它并不能解决幻读问题。如果我们想要解决幻读问题，就需要采用串行化的方式，也就是将隔离级别提升到最高，但这样一来就会大幅降低数据库的事务并发能力。</p><p>MVCC可以不采用锁机制，而是通过乐观锁的方式来解决不可重复读和幻读问题!它可以在大多数情况下替代行级锁，降低系统的开销。</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220714140541555.png" alt="image-20220714140541555"></p><h3 id="3-2-隐藏字段、Undo-Log版本链"><a href="#3-2-隐藏字段、Undo-Log版本链" class="headerlink" title="3.2 隐藏字段、Undo Log版本链"></a>3.2 隐藏字段、Undo Log版本链</h3><p>回顾一下undo日志的版本链，对于使用 InnoDB 存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列。</p><ul><li><code>trx_id</code> ：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的 <code>事务id</code> 赋值给 <code>trx_id</code> 隐藏列。 </li><li><code>roll_pointer</code> ：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 <code>undo日志</code> 中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li></ul><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220714140716427.png" alt="image-20220714140716427" style="float:left;"></p><p>假设插入该记录的<code>事务id</code>为<code>8</code>，那么此刻该条记录的示意图如下所示：</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220714140801595.png" alt="image-20220714140801595"></p><blockquote><p>insert undo只在事务回滚时起作用，当事务提交后，该类型的undo日志就没用了，它占用的Undo Log Segment也会被系统回收（也就是该undo日志占用的Undo页面链表要么被重用，要么被释放）。</p></blockquote><p>假设之后两个事务id分别为 <code>10</code> 、 <code>20</code> 的事务对这条记录进行<code>UPDATE</code> 操作，操作流程如下：</p><div class="table-container"><table><thead><tr><th>发生时间顺序</th><th>事务10</th><th>事务20</th></tr></thead><tbody><tr><td>1</td><td>BEGIN;</td><td></td></tr><tr><td>2</td><td></td><td>BEGIN;</td></tr><tr><td>3</td><td>UPDATE student SET name=”李四” WHERE id=1;</td><td></td></tr><tr><td>4</td><td>UPDATE student SET name=”王五” WHERE id=1;</td><td></td></tr><tr><td>5</td><td>COMMIT;</td><td></td></tr><tr><td>6</td><td></td><td>UPDATE student SET name=”钱七” WHERE id=1;</td></tr><tr><td>7</td><td></td><td>UPDATE student SET name=”宋八” WHERE id=1;</td></tr><tr><td>8</td><td></td><td>COMMIT;</td></tr></tbody></table></div><blockquote><p>能不能在两个事务中交叉更新同一条记录呢?不能!这不就是一个事务修改了另一个未提交事务修改过的数据，脏写。</p><p>InnoDB使用锁来保证不会有脏写情况的发生，也就是在第一个事务更新了某条记录后，就会给这条记录加锁，另一个事务再次更新时就需要等待第一个事务提交了，把锁释放之后才可以继续更新。</p></blockquote><p>每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个 <code>roll_pointer</code> 属性 （ <code>INSERT</code> 操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些 <code>undo日志</code> 都连起来，串成一个链表：</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220714141012874.png" alt="image-20220714141012874"></p><p>对该记录每次更新后，都会将旧值放到一条 <code>undo日志</code> 中，就算是该记录的一个旧版本，随着更新次数 的增多，所有的版本都会被 <code>roll_pointer</code> 属性连接成一个链表，我们把这个链表称之为 <code>版本链</code> ，版本链的头节点就是当前记录最新的值。</p><p>每个版本中还包含生成该版本时对应的<code>事务id</code>。</p><h2 id="4-MVCC实现原理之ReadView"><a href="#4-MVCC实现原理之ReadView" class="headerlink" title="4. MVCC实现原理之ReadView"></a>4. MVCC实现原理之ReadView</h2><p>MVCC 的实现依赖于：<code>隐藏字段</code>、<code>Undo Log</code>、<code>Read View</code>。</p><h3 id="4-1-什么是ReadView"><a href="#4-1-什么是ReadView" class="headerlink" title="4.1 什么是ReadView"></a>4.1 什么是ReadView</h3><p>在MVCC机制中，多个事务对同一一个行记录进行更新会产生多个历史快照，这些历史快照保存在UndoLog里。如果一个事务想要查询这个行记录，需要读取哪个版本的行记录呢?这时就需要用到ReadView了，它帮我们解决了行的可见性问题。</p><p>ReadView就是事务在使用MVCC机制进行快照读操作时产生的读视图。当事务启动时，会生成数据库系统当前的一个快照， InnoDB为每个事务构造了-个数组，用来记录并维护系统当前<code>活跃事务</code>的ID (“活跃’指的就是，启动了但还没提交)</p><h3 id="4-2-设计思路"><a href="#4-2-设计思路" class="headerlink" title="4.2 设计思路"></a>4.2 设计思路</h3><p>使用 <code>READ UNCOMMITTED</code> 隔离级别的事务，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了。</p><p>使用 <code>SERIALIZABLE</code> 隔离级别的事务，InnoDB规定使用加锁的方式来访问记录。</p><p>使用 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 隔离级别的事务，都必须保证读到 <code>已经提交了的</code> 事务修改过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是需要判断一下版本链中的哪个版本是当前事务可见的，这是ReadView要解决的主要问题。</p><p>这个ReadView中主要包含4个比较重要的内容，分别如下：</p><ol><li><p><code>creator_trx_id</code> ，创建这个 Read View 的事务 ID。</p><blockquote><p>说明：只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。</p></blockquote></li><li><p><code>trx_ids</code> ，表示在生成ReadView时当前系统中活跃的读写事务的 <code>事务id列表</code> 。</p></li><li><p><code>up_limit_id</code> ，活跃的事务中最小的事务 ID。</p></li><li><p><code>low_limit_id</code> ，表示生成ReadView时系统中应该分配给下一个事务的<code>id</code>值。low_limit_id 是系统最大的事务id值，这里要注意是系统中的事务id，需要区别于正在活跃的事务ID。  </p></li></ol><blockquote><p>注意：low_limit_id并不是trx_ids中的最大值，事务id是递增分配的。比如，现在有id为1， 2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时， trx_ids就包括1和2，up_limit_id的值就是1，low_limit_id的值就是4。</p></blockquote><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220714142254768.png" alt="image-20220714142254768" style="float:left;"></p><h3 id="4-3-ReadView的规则"><a href="#4-3-ReadView的规则" class="headerlink" title="4.3 ReadView的规则"></a>4.3 ReadView的规则</h3><p>有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见。</p><ul><li>如果被访问版本的trx_id属性值与ReadView中的 creator_trx_id 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。 </li><li>如果被访问版本的trx_id属性值小于ReadView中的 up_limit_id 值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。 </li><li>如果被访问版本的trx_id属性值大于或等于ReadView中的 low_limit_id 值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。 </li><li>如果被访问版本的trx_id属性值在ReadView的 up_limit_id 和 low_limit_id 之间，那就需要判断一下trx_id属性值是不是在 trx_ids 列表中。<ul><li>如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。 </li><li>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li></ul></li></ul><h3 id="4-4-MVCC整体操作流程"><a href="#4-4-MVCC整体操作流程" class="headerlink" title="4.4 MVCC整体操作流程"></a>4.4 MVCC整体操作流程</h3><p>了解了这些概念之后，我们来看下当查询一条记录的时候，系统如何通过MVCC找到它：</p><ol><li>首先获取事务自己的版本号，也就是事务 ID； </li><li>获取 ReadView； </li><li>查询得到的数据，然后与 ReadView 中的事务版本号进行比较；</li><li>如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照； </li><li>最后返回符合规则的数据。</li></ol><p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。</p><blockquote><p>InnoDB中，MVCC是通过Undo Log + Read View进行数据读取，Undo Log保存了历史快照，而Read View规则帮我们判断当前版本的数据是否可见。</p></blockquote><p>在隔离级别为读已提交（Read Committed）时，一个事务中的每一次 SELECT 查询都会重新获取一次 Read View。</p><p>如表所示：</p><div class="table-container"><table><thead><tr><th style="text-align:center">事务</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">begin;</td><td></td></tr><tr><td style="text-align:center">select * from student where id &gt;2;</td><td>获取一次Read View</td></tr><tr><td style="text-align:center">……..</td><td></td></tr><tr><td style="text-align:center">select *from student where id &gt;2;</td><td>获取一次Read View</td></tr><tr><td style="text-align:center">commit;</td></tr></tbody></table></div><blockquote><p>注意，此时同样的查询语句都会重新获取一次 Read View，这时如果 Read View 不同，就可能产生不可重复读或者幻读的情况。</p></blockquote><p>当隔离级别为可重复读的时候，就避免了不可重复读，这是因为一个事务只在第一次 SELECT 的时候会获取一次 Read View，而后面所有的 SELECT 都会复用这个 Read View，如下表所示：</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220715130916437.png" alt="image-20220715130916437"></p><h2 id="5-举例说明"><a href="#5-举例说明" class="headerlink" title="5. 举例说明"></a>5. 举例说明</h2><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220715131200077.png" alt="image-20220715131200077" style="float:center;"></p><h3 id="5-1-READ-COMMITTED隔离级别下"><a href="#5-1-READ-COMMITTED隔离级别下" class="headerlink" title="5.1 READ COMMITTED隔离级别下"></a>5.1 READ COMMITTED隔离级别下</h3><p><strong>READ COMMITTED ：每次读取数据前都生成一个ReadView。</strong></p><p>现在有两个 <code>事务id</code> 分别为 <code>10</code> 、 <code>20</code> 的事务在执行:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Transaction 10</span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE student SET name=&quot;李四&quot; WHERE id=1;</span><br><span class="line">UPDATE student SET name=&quot;王五&quot; WHERE id=1;</span><br><span class="line"># Transaction 20</span><br><span class="line">BEGIN;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>说明：事务执行过程中，只有在第一次真正修改记录时（比如使用INSERT、DELETE、UPDATE语句），才会被分配一个单独的事务id，这个事务id是递增的。所以我们才在事务2中更新一些别的表的记录，目的是让它分配事务id。</p></blockquote><p>此刻，表student 中 id 为 1 的记录得到的版本链表如下所示：</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220715133640655.png" alt="image-20220715133640655"></p><p>假设现在有一个使用 <code>READ COMMITTED</code> 隔离级别的事务开始执行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction 10、20未提交</span><br><span class="line">SELECT * FROM student WHERE id = 1; # 得到的列name的值为&#x27;张三&#x27;</span><br></pre></td></tr></table></figure><p>这个<code>SELECT1</code>的执行过程如下:</p><p>步骤1∶在执行<code>SELECT</code>语句时会先生成一个<code>ReadView</code>，ReadView的<code>trx_ids</code>列表的内容就是<code>[10，20]</code>，<code>up_limit_id</code>为<code>10</code>，<code>low_limit_id</code>为<code>21</code>，<code>creator_trx_id</code>为<code>0</code>。</p><p>步骤2:从版本链中挑选可见的记录，从图中看出，最新版本的列<code>name</code>的内容是<code>&#39;王五&#39;</code>，该版本的<code>trx_id</code>值为<code>10</code>，在<code>trx_ids</code>列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本。</p><p>步骤3:下一个版本的列<code>name</code>的内容是<code>&#39;李四&#39;</code>，该版本的<code>trx_id</code>值也为<code>10</code>，也在<code>trx_ids</code>列表内，所以也不符合要求，继续跳到下一个版本。</p><p>步骤4∶下一个版本的列<code>name</code>的内容是<code>&#39;张三&#39;</code>，该版本的<code>trx_id</code>值为<code>8</code>，小于<code>ReadView</code>中的<code>up_limit_id</code>值<code>10</code>，所以这个版本是符合要求的，最后返回给用户的版本就是这条列<code>name</code>为<code>&#39;张三&#39;</code>的记录。</p><p>之后，我们把 <code>事务id</code> 为 <code>10</code> 的事务提交一下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Transaction 10</span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE student SET name=&quot;李四&quot; WHERE id=1;</span><br><span class="line">UPDATE student SET name=&quot;王五&quot; WHERE id=1;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure><p>然后再到 <code>事务id</code> 为 <code>20</code> 的事务中更新一下表 <code>student</code> 中 <code>id</code> 为 <code>1</code> 的记录：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Transaction 20</span><br><span class="line">BEGIN;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line">UPDATE student SET name=&quot;钱七&quot; WHERE id=1;</span><br><span class="line">UPDATE student SET name=&quot;宋八&quot; WHERE id=1;</span><br></pre></td></tr></table></figure><p>此刻，表student中 <code>id</code> 为 <code>1</code> 的记录的版本链就长这样：</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220715134839081.png" alt="image-20220715134839081"></p><p>然后再到刚才使用 <code>READ COMMITTED</code> 隔离级别的事务中继续查找这个 id 为 1 的记录，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction 10、20均未提交</span><br><span class="line">SELECT * FROM student WHERE id = 1; # 得到的列name的值为&#x27;张三&#x27;</span><br><span class="line"></span><br><span class="line"># SELECT2：Transaction 10提交，Transaction 20未提交</span><br><span class="line">SELECT * FROM student WHERE id = 1; # 得到的列name的值为&#x27;王五&#x27;</span><br></pre></td></tr></table></figure><p>这个<code>SELECT2</code>的执行过程如下:</p><p>步骤1∶在执行<code>SELECT</code>语句时会先生成一个<code>ReadView</code>，ReadView的<code>trx_ids</code>列表的内容就是<code>[20]</code>，<code>up_limit_id</code>为<code>20</code>，<code>low_limit_id</code>为<code>21</code>，<code>creator_trx_id</code>为<code>0</code>。</p><p>步骤2:从版本链中挑选可见的记录，从图中看出，最新版本的列<code>name</code>的内容是<code>&#39;宋八&#39;</code>，该版本的<code>trx_id</code>值为<code>20</code>，在<code>trx_ids</code>列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本。</p><p>步骤3:下一个版本的列<code>name</code>的内容是<code>&#39;钱七&#39;</code>，该版本的<code>trx_id</code>值也为<code>20</code>，也在<code>trx_ids</code>列表内，所以也不符合要求，继续跳到下一个版本。</p><p>步骤4∶下一个版本的列<code>name</code>的内容是<code>&#39;王五&#39;</code>，该版本的<code>trx_id</code>值为<code>10</code>，小于<code>ReadView</code>中的<code>up_limit_id</code>值<code>20</code>，所以这个版本是符合要求的，最后返回给用户的版本就是这条列<code>name</code>为<code>&#39;王五&#39;</code>的记录。</p><p>以此类推，如果之后<code>事务id</code>为<code>20</code>的记录也提交了，再次在使用<code>READ COMMITTED</code>隔离级别的事务中查询表<code>student</code>中<code>id</code>值为<code>1</code>的记录时，得到的结果就是<code>&#39;宋八&#39;</code>了，具体流程我们就不分析了。</p><blockquote><p>强调:使用READ COMMITTED隔离级别的事务在每次查询开始时都会生成一个独立的ReadView。</p></blockquote><h3 id="5-2-REPEATABLE-READ隔离级别下"><a href="#5-2-REPEATABLE-READ隔离级别下" class="headerlink" title="5.2 REPEATABLE READ隔离级别下"></a>5.2 REPEATABLE READ隔离级别下</h3><p>使用 <code>REPEATABLE READ</code> 隔离级别的事务来说，只会在第一次执行查询语句时生成一个 <code>ReadView</code> ，之后的查询就不会重复生成了。</p><p>比如，系统里有两个 <code>事务id</code> 分别为 <code>10</code> 、 <code>20</code> 的事务在执行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Transaction 10</span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE student SET name=&quot;李四&quot; WHERE id=1;</span><br><span class="line">UPDATE student SET name=&quot;王五&quot; WHERE id=1;</span><br><span class="line"># Transaction 20</span><br><span class="line">BEGIN;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>此刻，表student 中 id 为 1 的记录得到的版本链表如下所示：</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220715140006061.png" alt="image-20220715140006061"></p><p>假设现在有一个使用 <code>REPEATABLE READ</code> 隔离级别的事务开始执行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction 10、20未提交</span><br><span class="line">SELECT * FROM student WHERE id = 1; # 得到的列name的值为&#x27;张三&#x27;</span><br></pre></td></tr></table></figure><p>这个<code>SELECT1</code>的执行过程如下:</p><p>步骤1∶在执行<code>SELECT</code>语句时会先生成一个<code>ReadView</code>，ReadView的<code>trx_ids</code>列表的内容就是<code>[10，20]</code>，<code>up_limit_id</code>为<code>10</code>，<code>low_limit_id</code>为<code>21</code>，<code>creator_trx_id</code>为<code>0</code>。</p><p>步骤2:从版本链中挑选可见的记录，从图中看出，最新版本的列<code>name</code>的内容是<code>&#39;王五&#39;</code>，该版本的<code>trx_id</code>值为<code>10</code>，在<code>trx_ids</code>列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本。</p><p>步骤3:下一个版本的列<code>name</code>的内容是<code>&#39;李四&#39;</code>，该版本的<code>trx_id</code>值也为<code>10</code>，也在<code>trx_ids</code>列表内，所以也不符合要求，继续跳到下一个版本。</p><p>步骤4∶下一个版本的列<code>name</code>的内容是<code>&#39;张三&#39;</code>，该版本的<code>trx_id</code>值为<code>8</code>，小于<code>ReadView</code>中的<code>up_limit_id</code>值<code>10</code>，所以这个版本是符合要求的，最后返回给用户的版本就是这条列<code>name</code>为<code>&#39;张三&#39;</code>的记录。</p><p>之后，我们把 <code>事务id</code> 为 <code>10</code> 的事务提交一下，就像这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Transaction 10</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">UPDATE student SET name=&quot;李四&quot; WHERE id=1;</span><br><span class="line">UPDATE student SET name=&quot;王五&quot; WHERE id=1;</span><br><span class="line"></span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure><p>然后再到 <code>事务id</code> 为 <code>20</code> 的事务中更新一下表 <code>student</code> 中 <code>id</code> 为 <code>1</code> 的记录：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Transaction 20</span><br><span class="line">BEGIN;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line">UPDATE student SET name=&quot;钱七&quot; WHERE id=1;</span><br><span class="line">UPDATE student SET name=&quot;宋八&quot; WHERE id=1;</span><br></pre></td></tr></table></figure><p>此刻，表student 中 <code>id</code> 为 <code>1</code> 的记录的版本链长这样：</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220715140354217.png" alt="image-20220715140354217"></p><p>然后再到刚才使用 <code>REPEATABLE READ</code> 隔离级别的事务中继续查找这个 <code>id</code> 为 <code>1</code> 的记录，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line">BEGIN;</span><br><span class="line"># SELECT1：Transaction 10、20均未提交</span><br><span class="line">SELECT * FROM student WHERE id = 1; # 得到的列name的值为&#x27;张三&#x27;</span><br><span class="line"># SELECT2：Transaction 10提交，Transaction 20未提交</span><br><span class="line">SELECT * FROM student WHERE id = 1; # 得到的列name的值仍为&#x27;张三&#x27;</span><br></pre></td></tr></table></figure><p>这个<code>SELECT2</code>的执行过程如下:</p><p>步骤1∶因为当前事务的隔离级别为REPEATED_READ，而之前在执行<code>SELECT</code>语句时已经生成过<code>ReadView</code>，ReadView的<code>trx_ids</code>列表的内容就是<code>[10，20]</code>，<code>up_limit_id</code>为<code>10，</code>low_limit_id<code>为</code>21<code>，</code>creator_trx_id<code>为</code>0`。</p><p>步骤2: 从版本链中挑选可见的记录，从图中看出，最新版本的列<code>name</code>的内容是<code>&#39;宋八&#39;</code>，该版本的<code>trx_id</code>值为<code>20</code>，在<code>trx_ids</code>列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本。</p><p>步骤3: 下一个版本的列<code>name</code>的内容是<code>&#39;钱七&#39;</code>，该版本的<code>trx_id</code>值也为<code>20</code>，也在<code>trx_ids</code>列表内，所以也不符合要求，继续跳到下一个版本。</p><p>步骤4:下一个版本的列<code>name</code>的内容是‘王五’，该版本的<code>trx_id</code>值为<code>10</code>而<code>trx_ids</code>列表中是包含值为<code>10</code>的<code>事务id</code>的，所以该版本也不符合要求，同理下一个列<code>name</code>的内容是<code>&#39;李四&#39;</code>的版本也不符合要求。继续跳到下一个版本。</p><p>步骤5:下一个版本的列<code>name</code>的内容是<code>&#39;张三&#39;</code>，该版本的<code>trx_id</code>值为<code>80</code>,小于<code>ReadView</code>中的<code>up_limit_id</code>值<code>10</code>，所以这个版本是符合要求的，最后返回给用户的版本就是这条列<code>c</code>为<code>‘张三&#39;</code>的记录。</p><p>这次<code>SELECT</code>查询得到的结果是重复的，记录的列<code>c</code>值都是<code>张三</code>，这就是<code>可重复读</code>的含义。如果我们之后再把<code>事务id</code>为<code>20</code>的记录提交了，然后再到刚才使用<code>REPEATABLE READ</code>隔离级别的事务中继续查找这个<code>id</code>为<code>1</code>的记录，得到的结果还是<code>张三</code>，具体执行过程大家可以自己分析一下。</p><h3 id="5-3-如何解决幻读"><a href="#5-3-如何解决幻读" class="headerlink" title="5.3 如何解决幻读"></a>5.3 如何解决幻读</h3><p>接下来说明InnoDB 是如何解决幻读的。</p><p>假设现在表 student 中只有一条数据，数据内容中，主键 id=1，隐藏的 trx_id=10，它的 undo log 如下图所示。</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220715141002035.png" alt="image-20220715141002035" style="zoom:80%;"></p><p>假设现在有事务 A 和事务 B 并发执行，<code>事务 A</code> 的事务 id 为 <code>20</code> ， <code>事务 B</code> 的事务 id 为 <code>30</code> 。</p><p>步骤1：事务 A 开始第一次查询数据，查询的 SQL 语句如下。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from student where id &gt;= 1;</span><br></pre></td></tr></table></figure><p>在开始查询之前，MySQL 会为事务 A 产生一个 ReadView，此时 ReadView 的内容如下： <code>trx_ids= [20,30] ， up_limit_id=20 ， low_limit_id=31 ， creator_trx_id=20</code> 。</p><p>由于此时表 student 中只有一条数据，且符合 where id&gt;=1 条件，因此会查询出来。然后根据 ReadView 机制，发现该行数据的trx_id=10，小于事务 A 的 ReadView 里 up_limit_id，这表示这条数据是事务 A 开启之前，其他事务就已经提交了的数据，因此事务 A 可以读取到。</p><p>结论：事务 A 的第一次查询，能读取到一条数据，id=1。</p><p>步骤2：接着事务 B(trx_id=30)，往表 student 中新插入两条数据，并提交事务。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into student(id,name) values(2,&#x27;李四&#x27;);</span><br><span class="line">insert into student(id,name) values(3,&#x27;王五&#x27;);</span><br></pre></td></tr></table></figure><p>此时表student 中就有三条数据了，对应的 undo 如下图所示：</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220715141208667.png" alt="image-20220715141208667"></p><p>步骤3：接着事务 A 开启第二次查询，根据可重复读隔离级别的规则，此时事务 A 并不会再重新生成 ReadView。此时表 student 中的 3 条数据都满足 where id&gt;=1 的条件，因此会先查出来。然后根据 ReadView 机制，判断每条数据是不是都可以被事务 A 看到。</p><p>1）首先 id=1 的这条数据，前面已经说过了，可以被事务 A 看到。 </p><p>2）然后是 id=2 的数据，它的 trx_id=30，此时事务 A 发现，这个值处于 up_limit_id 和 low_limit_id 之 间，因此还需要再判断 30 是否处于 trx_ids 数组内。由于事务 A 的 trx_ids=[20,30]，因此在数组内，这表 示 id=2 的这条数据是与事务 A 在同一时刻启动的其他事务提交的，所以这条数据不能让事务 A 看到。</p><p>3）同理，id=3 的这条数据，trx_id 也为 30，因此也不能被事务 A 看见。</p><p><img src="/2022/10/28/MySQL/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20220715141243993.png" alt="image-20220715141243993"></p><p>结论：最终事务 A 的第二次查询，只能查询出 id=1 的这条数据。这和事务 A 的第一次查询的结果是一样 的，因此没有出现幻读现象，所以说在 MySQL 的可重复读隔离级别下，不存在幻读问题。</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>这里介绍了 MVCC 在 <code>READ COMMITTD</code> 、 <code>REPEATABLE READ</code> 这两种隔离级别的事务在执行快照读操作时 访问记录的版本链的过程。这样使不同事务的 <code>读-写</code> 、 <code>写-读</code> 操作并发执行，从而提升系统性能。</p><p>核心点在于 ReadView 的原理， <code>READ COMMITTD</code> 、 <code>REPEATABLE READ</code> 这两个隔离级别的一个很大不同 就是生成ReadView的时机不同：</p><ul><li><code>READ COMMITTD</code> 在每一次进行普通SELECT操作前都会生成一个ReadView </li><li><code>REPEATABLE READ</code> 只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复 使用这个ReadView就好了。</li></ul><blockquote><p>说明:我们之前说执行DELETE语句或者更新主键的UPDATE语句并不会立即把对应的记录完全从页面中删除，而是执行一个所谓的delete mark操作，相当于只是对记录打上了一个删除标志位，这主要就是为MVCC服务的。</p></blockquote><p>通过MVCC我们可以解决：</p><ol><li>读写之间阻塞的问题。通过MVCC可以让读写互相不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力。</li><li>降低了死锁的概率。这是因为MVCC采用了乐观锁的方式，读取数据时并不需要加锁，对于写操作，也只锁定必要的行。</li><li>解决快照读的问题。当我们查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第13章-事务基础知识&quot;&gt;&lt;a href=&quot;#第13章-事务基础知识&quot; class=&quot;headerlink&quot; title=&quot;第13章_事务基础知识&quot;&gt;&lt;/a&gt;第13章_事务基础知识&lt;/h1&gt;&lt;h2 id=&quot;1-数据库事务概述&quot;&gt;&lt;a href=&quot;#1-数据库事务概</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>代码演示</title>
    <link href="http://example.com/2022/10/28/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/"/>
    <id>http://example.com/2022/10/28/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/</id>
    <published>2022-10-28T07:58:51.887Z</published>
    <updated>2022-05-10T05:33:07.668Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">代码块的演示</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/10/28/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC00%E7%AB%A0_%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E/"/>
    <id>http://example.com/2022/10/28/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC00%E7%AB%A0_%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E/</id>
    <published>2022-10-28T07:57:40.894Z</published>
    <updated>2021-11-12T04:06:05.771Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第19章-写在最后"><a href="#第19章-写在最后" class="headerlink" title="第19章_写在最后"></a>第19章_写在最后</h1><h3 id="分享1"><a href="#分享1" class="headerlink" title="分享1"></a>分享1</h3><p><img src="images/自律ing.jpg" alt="自律ing"></p><h3 id="分享2"><a href="#分享2" class="headerlink" title="分享2"></a>分享2</h3><p>如何看待生活上、工作上的冗余、反冗余？</p><p>又如何看待社会的脆弱性？反脆弱性？</p><p>个人如何应对？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第19章-写在最后&quot;&gt;&lt;a href=&quot;#第19章-写在最后&quot; class=&quot;headerlink&quot; title=&quot;第19章_写在最后&quot;&gt;&lt;/a&gt;第19章_写在最后&lt;/h1&gt;&lt;h3 id=&quot;分享1&quot;&gt;&lt;a href=&quot;#分享1&quot; class=&quot;headerlink</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/10/28/hello-world/"/>
    <id>http://example.com/2022/10/28/hello-world/</id>
    <published>2022-10-28T07:57:40.403Z</published>
    <updated>2022-09-03T02:12:55.395Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p>常用命令</p><pre><code>清除缓存：hexo clean生成静态文件：hexo generate可简写为 hexo g启动服务器：hexo server或者 hexo s 常用参数：-p（--port）重设端口部署：hexo deploy可简写为hexo d，用于将网站部署到服务器上。（暂时用不到，目前都是在本地，后面我们将博客托管到GitHub Pages或Gitee Pages时才会用到此命令） 常用参数：-g（--generate），hexo d -g部署前预先生成静态文件，等同于 hexo g -d</code></pre><p>一般发布文章或者修改博客后需要这些操作：清除缓存&gt;生成静态文件&gt;启动服务器，测试没问题后再部署。</p><p>// 我们可以写成一条命令<br>$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</p><p>$ hexo d</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    <category term="关于Hexo" scheme="http://example.com/categories/%E5%85%B3%E4%BA%8EHexo/"/>
    
    
  </entry>
  
  <entry>
    <title>page</title>
    <link href="http://example.com/2022/09/28/Mybatis/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%981/"/>
    <id>http://example.com/2022/09/28/Mybatis/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%981/</id>
    <published>2022-09-28T01:03:30.000Z</published>
    <updated>2022-09-28T01:04:21.848Z</updated>
    
    <content type="html"><![CDATA[<p>在查询条件中，如果查询字段为integer，并且值为0，在xml查询语句＜if test=“参数 != null and 参数 != ‘‘“＞这时候是不会进去的。</p><p><strong>原因：</strong><br>mapper接口传入的参数类型为Integer值为0时，会默认将这个值转换为空字符串！</p><p><strong>解决办法：</strong><br>1、去掉【参数 != ‘‘“】的非空判断，因为Integer类型的值除了0也不可能为空字符串<br>2、不用integer类型，直接换成string类型</p><p>本文转自 <a href="https://blog.csdn.net/qq_43270074/article/details/119571760">https://blog.csdn.net/qq_43270074/article/details/119571760</a>，如有侵权，请联系删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在查询条件中，如果查询字段为integer，并且值为0，在xml查询语句＜if test=“参数 != null and 参数 != ‘‘“＞这时候是不会进去的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原因：&lt;/strong&gt;&lt;br&gt;mapper接口传入的参数类型为Integer值</summary>
      
    
    
    
    <category term="Mybatis" scheme="http://example.com/categories/Mybatis/"/>
    
    
    <category term="Mybatis" scheme="http://example.com/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>一道面试题搞懂JVM类加载机制（类被初始化的几种情况，类文件加载的过程）</title>
    <link href="http://example.com/2022/09/18/Java%E5%9F%BA%E7%A1%80/%E4%B8%80%E9%81%93JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2022/09/18/Java%E5%9F%BA%E7%A1%80/%E4%B8%80%E9%81%93JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-09-18T13:23:49.000Z</published>
    <updated>2022-09-18T13:47:30.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="有这样一道面试题："><a href="#有这样一道面试题：" class="headerlink" title="有这样一道面试题："></a>有这样一道面试题：</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> value1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        value1++;</span><br><span class="line">        value2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> value1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton2</span> <span class="variable">singleton2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton2</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton2</span><span class="params">()</span> &#123;</span><br><span class="line">        value1++;</span><br><span class="line">        value2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title function_">getInstance2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> singleton2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">staticTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;Singleton1 value1:&quot;</span> + singleton.value1);</span><br><span class="line">        System.out.println(<span class="string">&quot;Singleton1 value2:&quot;</span> + singleton.value2);</span><br><span class="line"></span><br><span class="line">        <span class="type">Singleton2</span> <span class="variable">singleton2</span> <span class="operator">=</span> Singleton2.getInstance2();</span><br><span class="line">        System.out.println(<span class="string">&quot;Singleton2 value1:&quot;</span> + singleton2.value1);</span><br><span class="line">        System.out.println(<span class="string">&quot;Singleton2 value2:&quot;</span> + singleton2.value2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><p><img src="/2022/09/18/Java%E5%9F%BA%E7%A1%80/%E4%B8%80%E9%81%93JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E9%9D%A2%E8%AF%95%E9%A2%98/运行结果.png" alt></p><p>稍后会带来分析。</p><h1 id="一-类加载机制"><a href="#一-类加载机制" class="headerlink" title="一 类加载机制"></a>一 类加载机制</h1><hr><p>JVM类加载分为5个过程：加载，验证，准备，解析，初始化，使用，卸载，如下图所示：<br><img src="/2022/09/18/Java%E5%9F%BA%E7%A1%80/%E4%B8%80%E9%81%93JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E9%9D%A2%E8%AF%95%E9%A2%98/图片1.png" alt="JVM类加载5个过程"></p><p>下面来看看加载，验证，准备，解析，初始化这5个过程的具体动作。</p><h2 id="1-1-加载"><a href="#1-1-加载" class="headerlink" title="1.1 加载"></a>1.1 加载</h2><hr><p>加载主要是将.class文件（并不一定是.class。可以是ZIP包，网络中获取）中的二进制字节流读入到JVM中。 在加载阶段，JVM需要完成3件事： 1）通过类的全限定名获取该类的二进制字节流；<br>2）将字节流所代表的静态存储结构转化为方法区的运行时数据结构；<br>3）在内存中生成一个该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</p><h2 id="1-2-连接"><a href="#1-2-连接" class="headerlink" title="1.2 连接"></a>1.2 连接</h2><hr><p>1.2.1 验证</p><p>验证是连接阶段的第一步，主要确保加载进来的字节流符合JVM规范。<br>验证阶段会完成以下4个阶段的检验动作：<br>1）文件格式验证<br>2）元数据验证(是否符合Java语言规范)<br>3）字节码验证（确定程序语义合法，符合逻辑）<br>4）符号引用验证（确保下一步的解析能正常执行）</p><p>1.2.2 准备</p><p>准备是连接阶段的第二步，主要为静态变量在方法区分配内存，并设置默认初始值。</p><p>1.2.3 解析</p><p>解析是连接阶段的第三步，是虚拟机将常量池内的符号引用替换为直接引用的过程。</p><h2 id="1-3-初始化"><a href="#1-3-初始化" class="headerlink" title="1.3 初始化"></a>1.3 初始化</h2><hr><p>初始化阶段是类加载过程的最后一步，主要是根据程序中的赋值语句主动为类变量赋值。<br>注：<br>1）当有父类且父类为初始化的时候，先去初始化父类；<br>2）再进行子类初始化语句。</p><p>（假如构造方法是public的，被new之后，也是在静态变量初始化完成之后才会执行构造方法）</p><p>什么时候需要对类进行初始化？</p><p>1）使用new该类实例化对象的时候；<br>2）读取或设置类静态字段的时候（但被final修饰的字段，在编译器时就被放入常量池的静态字段除外static final）；<br>3）调用类静态方法的时候；<br>4）使用反射Class.forName(“xxxx”)对类进行反射调用的时候，该类需要初始化；<br>5） 初始化一个类的时候，有父类，先初始化父类（注：1. 接口除外，父接口在调用的时候才会被初始化；2.子类引用父类静态字段，只会引发父类初始化）；<br>6） 被标明为启动类的类（即包含main()方法的类）要初始化；<br>7）当使用JDK1.7的动态语言支持时，如果一个java.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</p><p>以上情况称为对一个类进行主动引用，且有且只要以上几种情况需要对类进行初始化。</p><p>再回过头来分析一开始的面试题：</p><p>Singleton输出结果：1 0</p><p>原因：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 首先执行main中的Singleton singleton = Singleton.getInstance(); </span><br><span class="line">2 类的加载：加载类Singleton </span><br><span class="line">3 类的验证 </span><br><span class="line">4 类的准备：为静态变量分配内存，设置默认值。这里为singleton(引用类型)设置为null,value1,value2（基本数据类型）设置默认值0 </span><br><span class="line">5 类的初始化（按照赋值语句进行修改）： </span><br><span class="line">  执行private static Singleton singleton = new Singleton(); </span><br><span class="line">  执行Singleton的构造器：value1++;value2++; 此时value1，value2均等于1 </span><br><span class="line">  执行 </span><br><span class="line">  　　public static int value1;  　　public static int value2 = 0; </span><br><span class="line">  此时value1\=1，value2=0</span><br></pre></td></tr></table></figure><p>Singleton2输出结果：1 1</p><p>原因：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 首先执行main中的Singleton2 singleton2 = Singleton2.getInstance2(); </span><br><span class="line">2 类的加载：加载类Singleton2 </span><br><span class="line">3 类的验证 </span><br><span class="line">4 类的准备：为静态变量分配内存，设置默认值。这里为value1,value2（基本数据类型）设置默认值0,singleton2(引用类型)设置为null, </span><br><span class="line">5 类的初始化（按照赋值语句进行修改）： </span><br><span class="line">  执行 </span><br><span class="line">　　public static int value2 = 0; </span><br><span class="line">  此时value2\=0(value1不变，依然是0); </span><br><span class="line">  执行 </span><br><span class="line">　　private static Singleton singleton = new Singleton(); </span><br><span class="line">  执行Singleton2的构造器：value1++;value2++; </span><br><span class="line">  此时value1，value2均等于1,即为最后结果</span><br></pre></td></tr></table></figure><h1 id="二-类加载器"><a href="#二-类加载器" class="headerlink" title="二 类加载器"></a>二 类加载器</h1><hr><h2 id="类加载器实现的功能是即为加载阶段获取二进制字节流的时候。"><a href="#类加载器实现的功能是即为加载阶段获取二进制字节流的时候。" class="headerlink" title="类加载器实现的功能是即为加载阶段获取二进制字节流的时候。"></a>类加载器实现的功能是即为加载阶段获取二进制字节流的时候。</h2><p>JVM提供了以下3种系统的类加载器：</p><ul><li>启动类加载器（Bootstrap ClassLoader）：最顶层的类加载器，负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类。</li><li>扩展类加载器(Extension ClassLoader)：负责加载 JAVA_HOME\lib\ext 目录中的，或通过java.ext.dirs系统变量指定路径中的类库。</li><li>应用程序类加载器(Application ClassLoader)：也叫做系统类加载器，可以通过getSystemClassLoader()获取，负责加载用户路径（classpath）上的类库。如果没有自定义类加载器，一般这个就是默认的类加载器。</li></ul><p>类加载器之间的层次关系如下：</p><p>照片来源：<a href="http://www.importnew.com/25295.html">http://www.importnew.com/25295.html</a></p><p>类加载器之间的这种层次关系叫做双亲委派模型。<br>双亲委派模型要求除了顶层的启动类加载器（Bootstrap ClassLoader）外，其余的类加载器都应当有自己的父类加载器。这里的类加载器之间的父子关系一般不是以继承关系实现的，而是用组合实现的。</p><h2 id="双亲委派模型的工作过程"><a href="#双亲委派模型的工作过程" class="headerlink" title="双亲委派模型的工作过程"></a>双亲委派模型的工作过程</h2><p>如果一个类接受到类加载请求，他自己不会去加载这个请求，而是将这个类加载请求委派给父类加载器，这样一层一层传送，直到到达启动类加载器（Bootstrap ClassLoader）。<br>只有当父类加载器无法加载这个请求时，子加载器才会尝试自己去加载。</p><h2 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h2><p>双亲委派模型很好的解决了各个类加载器加载基础类的统一性问题。即越基础的类由越上层的加载器进行加载。<br>若加载的基础类中需要回调用户代码，而这时顶层的类加载器无法识别这些用户代码，怎么办呢？这时就需要破坏双亲委派模型了。<br>下面介绍两个例子来讲解破坏双亲委派模型的过程。</p><h2 id="JNDI破坏双亲委派模型"><a href="#JNDI破坏双亲委派模型" class="headerlink" title="JNDI破坏双亲委派模型"></a>JNDI破坏双亲委派模型</h2><p>JNDI是Java标准服务，它的代码由启动类加载器去加载。但是JNDI需要回调独立厂商实现的代码，而类加载器无法识别这些回调代码（SPI）。<br>为了解决这个问题，引入了一个线程上下文类加载器。 可通过Thread.setContextClassLoader()设置。<br>利用线程上下文类加载器去加载所需要的SPI代码，即父类加载器请求子类加载器去完成类加载的过程，而破坏了双亲委派模型。</p><h2 id="Spring破坏双亲委派模型"><a href="#Spring破坏双亲委派模型" class="headerlink" title="Spring破坏双亲委派模型"></a>Spring破坏双亲委派模型</h2><p>Spring要对用户程序进行组织和管理，而用户程序一般放在WEB-INF目录下，由WebAppClassLoader类加载器加载，而Spring由Common类加载器或Shared类加载器加载。<br>那么Spring是如何访问WEB-INF下的用户程序呢？<br>使用线程上下文类加载器。 Spring加载类所用的classLoader都是通过Thread.currentThread().getContextClassLoader()获取的。当线程创建时会默认创建一个AppClassLoader类加载器（对应Tomcat中的WebAppclassLoader类加载器）： setContextClassLoader(AppClassLoader)。<br>利用这个来加载用户程序。即任何一个线程都可通过getContextClassLoader()获取到WebAppclassLoader。</p><h1 id="三-附上Tomcat类加载架构："><a href="#三-附上Tomcat类加载架构：" class="headerlink" title="三 附上Tomcat类加载架构："></a>三 附上Tomcat类加载架构：</h1><hr><p><img src="/2022/09/18/Java%E5%9F%BA%E7%A1%80/%E4%B8%80%E9%81%93JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E9%9D%A2%E8%AF%95%E9%A2%98/图片2.png" alt="Tomcat类加载架构"></p><h1 id="Tomcat目录下有4组目录："><a href="#Tomcat目录下有4组目录：" class="headerlink" title="Tomcat目录下有4组目录："></a>Tomcat目录下有4组目录：</h1><p>/common目录下：类库可以被Tomcat和Web应用程序共同使用；由 Common ClassLoader类加载器加载目录下的类库；<br>/server目录：类库只能被Tomcat可见；由 Catalina ClassLoader类加载器加载目录下的类库；<br>/shared目录：类库对所有Web应用程序可见，但对Tomcat不可见；由 Shared ClassLoader类加载器加载目录下的类库；<br>/WebApp/WEB-INF目录：仅仅对当前web应用程序可见。由 WebApp ClassLoader类加载器加载目录下的类库；<br>每一个JSP文件对应一个JSP类加载器。</p><p>本文转自 <a href="https://www.cnblogs.com/UncleWang001/articles/10429801.html">https://www.cnblogs.com/UncleWang001/articles/10429801.html</a>，如有侵权，请联系删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;有这样一道面试题：&quot;&gt;&lt;a href=&quot;#有这样一道面试题：&quot; class=&quot;headerlink&quot; title=&quot;有这样一道面试题：&quot;&gt;&lt;/a&gt;有这样一道面试题：&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td</summary>
      
    
    
    
    <category term="Java基础" scheme="http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>类加载顺序</title>
    <link href="http://example.com/2022/09/18/Java%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/"/>
    <id>http://example.com/2022/09/18/Java%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/</id>
    <published>2022-09-18T12:26:25.000Z</published>
    <updated>2022-09-18T13:31:45.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、先来了解几个概念"><a href="#一、先来了解几个概念" class="headerlink" title="一、先来了解几个概念"></a>一、先来了解几个概念</h1><hr><h2 id="1、静态代码块"><a href="#1、静态代码块" class="headerlink" title="1、静态代码块"></a>1、静态代码块</h2><p>（1）格式</p><ul><li>在java类中，使用static关键字和{}声明的代码块</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeBlock</span> &#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（2）执行时机</p><ul><li>静态代码块在类被加载的时候就运行了，而且只运行一次，并且优先于各种代码块以及构造函数。</li><li>如果一个类中有多个静态代码块，会按照书写顺序依次执行。后面在比较的时候会通过具体实例来证明。</li></ul><p>（3）静态代码块的作用</p><ul><li>一般情况下，如果有些代码需要在项目启动的时候就执行，这时候就需要静态代码块。</li><li>比如一个项目启动需要加载的很多<strong>配置文件</strong>等资源，我们就可以都放入静态代码块中。</li></ul><p>（4）静态代码块不能存在任何方法体中</p><blockquote><p>首先我们要明确静态代码块是在类加载的时候就要运行了。我们分情况讨论：</p></blockquote><ul><li>对于普通方法：由于普通方法是通过加载类，然后new出实例化对象，通过对象才能运行这个方法，而静态代码块只需要加载类之后就能运行了。</li><li>对于静态方法：在类加载的时候，静态方法也已经加载了，但是我们必须要通过类名或者对象名才能访问，也就是说相比于静态代码块，静态代码块是主动运行的，而静态方法是被动运行的。</li></ul><p>（5）静态代码块不能访问普通变量</p><ul><li>普通变量只能通过对象来调用，是不能放在静态代码块中的。</li></ul><h2 id="2、构造代码块"><a href="#2、构造代码块" class="headerlink" title="2、构造代码块"></a>2、构造代码块</h2><p>（1）格式</p><ul><li>在java类中使用<code>&#123;&#125;</code>声明的代码块（和静态代码块的区别是少了static关键字）:</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeBlock</span> &#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（2）执行时机</p><ul><li>构造代码块在创建对象时被调用，每次创建对象都会调用一次，但是优先于构造函数执行。</li><li>但是要知道：构造代码块依托于构造函数，也就是说，如果你不实例化对象，构造代码块是不会执行的</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constructor</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Constructor</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Constructor</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Constructor</span>();</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Constructor</span>(<span class="string">&quot;构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行截图：</p><p><img src="/2022/09/18/Java%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/类加载顺序1.png" alt></p><p>（3）构造代码块的作用</p><ul><li>和构造函数的作用类似，都能对对象进行初始化，并且只要创建一个对象，构造代码块都会执行一次。</li><li>反过来，构造函数则不一定每个对象建立时都执行（多个构造函数情况下，建立对象时，传入的参数不同则初始化使用对应的构造函数）。</li></ul><h2 id="3、构造函数"><a href="#3、构造函数" class="headerlink" title="3、构造函数"></a>3、构造函数</h2><p>（1）构造函数的命名必须和类名完全相同。在java中普通函数可以和构造函数同名，但是必须带有返回值<br>（2）构造函数的功能主要用于在类的对象创建时定义初始化的状态。它没有返回值，也不能用void来修饰。这就保证了它不仅什么也不用自动返回，而且根本不能有任何选择。而其他方法都有返回值，即使是void返回值<br>（3）构造函数不能被直接调用，<strong>必须通过new运算符在创建对象时才会自动调用</strong>；<br>而一般的方法是在程序执行到它的时候被调用的<br>（4）<strong>默认先调用父类的无参构造函数</strong></p><h2 id="4、普通代码块"><a href="#4、普通代码块" class="headerlink" title="4、普通代码块"></a>4、普通代码块</h2><p><code>普通代码块和构造代码块的区别是</code></p><ul><li>构造代码块是在类中定义的，</li><li>普通代码块是在方法体中定义的。且普通代码块的执行顺序和书写顺序一致。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5、各种类型变量的默认初始值"><a href="#5、各种类型变量的默认初始值" class="headerlink" title="5、各种类型变量的默认初始值"></a>5、各种类型变量的默认初始值</h2><p>JVM 类加载机制中提到，**类连接 （验证， 准备， 解析）**中准备工作：</p><ul><li>负责为类的类变量（非对象变量）分配内存，并设置默认初始值，准备类中每个字段、方法和实现接口所需的数据结构</li><li>这里说的初始值都是默认的值， 并不是程序中指定的值 ：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Text</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> print(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> print(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Text</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Text</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> print(<span class="string">&quot;i&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> print(<span class="string">&quot;j&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 经过准备工作后，类中变量的初始值为如下：</span></span><br><span class="line"><span class="comment">//k =0;     b=0;     t1=null;     t2=null;    i=0;    n=0;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="二、正题：Java的实例化顺序"><a href="#二、正题：Java的实例化顺序" class="headerlink" title="二、正题：Java的实例化顺序"></a>二、正题：Java的实例化顺序</h1><hr><h2 id="1、牢记：静态和非静态分开处理"><a href="#1、牢记：静态和非静态分开处理" class="headerlink" title="1、牢记：静态和非静态分开处理"></a>1、牢记：静态和非静态分开处理</h2><p>（1）使用到静态加载时，静态又分为： 静态变量， 静态代码块，其中加载顺序是按照类中书写的先后顺序加载的<br>（2）非静态加载顺序： 按照非静态书写顺序加载 /（）执行<br>（3）<strong>静态方法，实例方法只有在调用的时候才会去执行</strong><br>（4）<strong>当静态加载中遇到需要加载非静态的情况：</strong><br>先加载非静态再加载静态（因为非静态可以访问静态，而静态不能访问非静态）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 当加载静态变量是需要先加载构造器， 那就转为先加载所有非静态属性</span><br><span class="line">public static Text t1 = new Text(&quot;t1&quot;);  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2、静态变量声明-一定-放在使用前面"><a href="#2、静态变量声明-一定-放在使用前面" class="headerlink" title="2、静态变量声明 一定 放在使用前面"></a>2、静态变量声明 一定 放在使用前面</h2><h2 id="3、main是否第一句先执行"><a href="#3、main是否第一句先执行" class="headerlink" title="3、main是否第一句先执行?"></a>3、main是否第一句先执行?</h2><ul><li>Java程序运行时，第一件事情就是试图访问main方法，因为main相等于程序的入口，如果没有main方法，程序将无法启动，main方法更是占一个独立的线程.</li><li><strong>找到main方法后，是不是就会执行mian方法块里的第一句话呢？</strong><br>答：不是</li></ul><hr><p><strong>因为main方法虽然是一个特殊的静态方法，但是还是静态方法，此时JVM会加载main方法所在的类，试图找到类中其他静态部分，即首先会找main方法所在的类。</strong></p><hr><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JVMTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Main 方法所在静态代码块 static1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main start&quot;</span>);</span><br><span class="line">        <span class="type">A1</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A1</span>();</span><br><span class="line">        System.out.println(A1.width);</span><br><span class="line">        System.out.println(a.width);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Main 方法所在静态代码块 static2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态初始化类A&quot;</span>);</span><br><span class="line">        width = <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建A类的对象&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行截图：</p><p><img src="/2022/09/18/Java%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/类加载顺序2.png" alt></p><h2 id="4、父类、子类加载顺序"><a href="#4、父类、子类加载顺序" class="headerlink" title="4、父类、子类加载顺序"></a>4、父类、子类加载顺序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JVMParent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;parent no static code block :&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;parent static&#x27;s count:&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    JVMParent(<span class="type">int</span> a) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;parent init one parameter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    JVMParent() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;parent init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 子类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JVMSons</span> <span class="keyword">extends</span> <span class="title class_">JVMParent</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;son no static code block :&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;son static 1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> count1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    JVMSons() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;son init:&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;son static 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;son main start&quot;</span>);</span><br><span class="line">        <span class="type">JVMSons</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JVMSons</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行截图：</p><p><img src="/2022/09/18/Java%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/类加载顺序3.png" alt></p><hr><h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h2><ol><li>父类的静态变量和静态块赋值（按照声明顺序）</li><li>自身的静态变量和静态块赋值（按照声明顺序）</li><li>main方法</li><li>父类的成员变量和块赋值（按照声明顺序）</li><li>父类构造器赋值</li><li>自身成员变量和块赋值（按照声明顺序）</li><li>自身构造器赋值</li><li>静态方法，实例方法只有在调用的时候才会去执行</li></ol><h1 id="三、参考"><a href="#三、参考" class="headerlink" title="三、参考"></a>三、参考</h1><hr><blockquote><p><a href="https://www.cnblogs.com/zhongHW/p/11047007.html">https://www.cnblogs.com/zhongHW/p/11047007.html</a><br><a href="https://www.cnblogs.com/UncleWang001/articles/10429801.html">https://www.cnblogs.com/UncleWang001/articles/10429801.html</a></p></blockquote><p>本文转自 <a href="https://blog.csdn.net/sinat_34863938/article/details/113246484">https://blog.csdn.net/sinat_34863938/article/details/113246484</a>，如有侵权，请联系删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、先来了解几个概念&quot;&gt;&lt;a href=&quot;#一、先来了解几个概念&quot; class=&quot;headerlink&quot; title=&quot;一、先来了解几个概念&quot;&gt;&lt;/a&gt;一、先来了解几个概念&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;1、静态代码块&quot;&gt;&lt;a href=&quot;#1、静态代码块&quot; </summary>
      
    
    
    
    <category term="Java基础" scheme="http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>内部类</title>
    <link href="http://example.com/2022/09/15/Java%E5%9F%BA%E7%A1%80/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>http://example.com/2022/09/15/Java%E5%9F%BA%E7%A1%80/%E5%86%85%E9%83%A8%E7%B1%BB/</id>
    <published>2022-09-15T13:54:48.000Z</published>
    <updated>2022-09-18T12:49:35.386Z</updated>
    
    <content type="html"><![CDATA[<hr><p>首先看看什么是内部类：在类的内部定义另一个类。没错，定义就这么简单。如果在类Outer的内部再定义一个类Inner，此时Inner就称为内部类，而Outer则称为外部类。内部类的定义格式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 外部类的名称&#123;</span><br><span class="line">    <span class="comment">//外部类的成员</span></span><br><span class="line">    <span class="keyword">public</span> class 内部类的名称&#123;</span><br><span class="line">             <span class="comment">//内部类的成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用内部类有什么好处；</p><p>1）实现多重继承;</p><p>2）内部类可以很好的实现隐藏：一般的非内部类，是不允许有 private 与protected权限的，但内部类可以</p><p>3）减少了类文件编译后的产生的字节码文件的大小</p><p>使用内部类的缺点：使程序结构不清楚。</p><p>内部类在编译完成后也会产生.class文件，但文件名称是：外部类名称$内部类名称.class</p><p>内部类的种类：成员内部类、静态内部类、局部内部类、匿名内部类。下面分别详细学习一下这四种内部类的具体使用。</p></blockquote><h3 id="一、成员内部类"><a href="#一、成员内部类" class="headerlink" title="一、成员内部类"></a><strong>一、成员内部类</strong></h3><blockquote><p>1、成员内部类也叫实例内部类。应用场合：每一个外部类对象都需要一个内部类的实例，内部类离不开外部类存在（相当于心脏对人体）</p><p>2、成员内部类的特征：</p><p>作为外部类的一个成员存在，与外部类的属性、方法并列</p><p>成员内部类持有外部类的引用</p><p>成员内部类中不能定义static变量和方法</p><p>3、使用格式：</p><p>Outer outer = new Outer();<br>       Outer.Inner inner = outer.new Inner();</p><p>代码演示一：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 成员内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Body</span> &#123;</span><br><span class="line">    String arm;</span><br><span class="line">    String leg;</span><br><span class="line">    String blood;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Body</span><span class="params">(String arm, String leg, String blood)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.arm = arm;</span><br><span class="line">        <span class="built_in">this</span>.leg = leg;</span><br><span class="line">        <span class="built_in">this</span>.blood = blood;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//内部类Heart</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Heart</span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">         <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;心脏正在给&quot;</span>+arm+leg+<span class="string">&quot;输&quot;</span>+blood);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;       </span><br><span class="line">        Body body=<span class="keyword">new</span> <span class="title class_">Body</span>(<span class="string">&quot;两个胳膊&quot;</span>,<span class="string">&quot;两条腿&quot;</span>,<span class="string">&quot;血&quot;</span>);</span><br><span class="line">        Body.Heart heart=body.<span class="keyword">new</span> <span class="title class_">Heart</span>();</span><br><span class="line">        heart.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行截图：</p><p> <a href="http://www.cnblogs.com/shen-hua/"><img src="/2022/09/15/Java%E5%9F%BA%E7%A1%80/%E5%86%85%E9%83%A8%E7%B1%BB/内部类1.png" alt></a></p><p>代码演示二：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 成员内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name=<span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;<span class="comment">//定义外部类方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Inner</span>().print();<span class="comment">//通过内部类的实例化对象调用方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Outer outer=<span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        outer.print();<span class="comment">//调用外部类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行截图：</p><p><img src="/2022/09/15/Java%E5%9F%BA%E7%A1%80/%E5%86%85%E9%83%A8%E7%B1%BB/内部类2.png" alt><br>解释一下，上述代码中，new Inner().print();<br>代码相当于 Inner inner=new Inner(); Inner.print();</p></blockquote><h3 id="二、静态内部类"><a href="#二、静态内部类" class="headerlink" title="二、静态内部类"></a><strong>二、静态内部类</strong></h3><blockquote><p>1、内部类如果使用static声明，则此内部类就称为静态内部类。（其实也相当于外部类）可以通过外部类 . 内部类来访问。</p><p>2、静态内部类使用场合：内部类不需要外部类的实例（注意区分成员内部类），静态内部类存在仅仅为外部类提供服务或者逻辑上属于外部类，且逻辑上可以单独存在。</p><p>3、静态内部类的特征：</p><pre><code> 静态内部类不会持有外部类的引用 静态内部类可以访问外部的静态变量，如果访问外部类的成员变量必须通过外部类的实例访问</code></pre><p>4、Java中只有内部类才可以是静态的</p><p>使用格式：Outer.Inner inner = new Outer.Inner();</p><p>代码演示一：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 静态内部</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Company</span> &#123;</span><br><span class="line">    String companyNam;</span><br><span class="line">    <span class="keyword">static</span> String country;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Clear</span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Clear</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Clear</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">(String name)</span>&#123;</span><br><span class="line">            String na=<span class="keyword">new</span> <span class="title class_">Company</span>().companyNam=<span class="string">&quot;联想&quot;</span>;</span><br><span class="line">            country=<span class="string">&quot;中国&quot;</span>;</span><br><span class="line">            System.out.println(name+<span class="string">&quot;为&quot;</span>+na+<span class="string">&quot;打扫卫生，该公司属于&quot;</span>+country);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Company.Clear zcl=<span class="keyword">new</span> <span class="title class_">Company</span>.Clear();</span><br><span class="line">        zcl.work(<span class="string">&quot;shen_hua&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行截图：</p><p><img src="/2022/09/15/Java%E5%9F%BA%E7%A1%80/%E5%86%85%E9%83%A8%E7%B1%BB/内部类3.png" alt></p><p> 代码演示二：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 静态内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String info=<span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> i=<span class="number">8</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="type">int</span> num=<span class="keyword">new</span> <span class="title class_">Outer</span>().i;<span class="comment">//获取外部类的非静态成员变量，景天成员变量可以直接使用</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(info+<span class="string">&quot;---&quot;</span>+num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Outer.Inner inner=<span class="keyword">new</span> <span class="title class_">Outer</span>.Inner();</span><br><span class="line">        inner.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行截图：</p><p><img src="/2022/09/15/Java%E5%9F%BA%E7%A1%80/%E5%86%85%E9%83%A8%E7%B1%BB/内部类4.png" alt></p></blockquote><h3 id="三、局部内部类"><a href="#三、局部内部类" class="headerlink" title="三、局部内部类"></a><strong>三、局部内部类</strong></h3><blockquote><p>1、局部内部类也叫区域内嵌类，局部内部类与成员内部类类似，不过，区域内嵌类是定义在一个方法中的内嵌类。</p><p>2、使用场合：如果内部类对象仅仅为外部类的某个方法使用，使用局部内部类</p><p>3、特征：</p><pre><code> 用在方法内部，作用范围仅限于该方法中 根据情况决定持有外部类对象引用 不能使用private，protected，public修饰符 不能包含静态成员</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 局部内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">School</span> &#123;</span><br><span class="line"></span><br><span class="line">    String schoolName;</span><br><span class="line">    String buss=<span class="string">&quot;培养人才&quot;</span>;</span><br><span class="line">    <span class="type">int</span> studentNum;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">School</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">School</span><span class="params">(String schoolName, String buss, <span class="type">int</span> studentNum)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.schoolName = schoolName;</span><br><span class="line">        <span class="built_in">this</span>.buss = buss;</span><br><span class="line">        <span class="built_in">this</span>.studentNum = studentNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//宣传</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">double</span> tvMoney=<span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">double</span> netMoney=<span class="number">20000</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">AdverTeam</span>&#123;</span><br><span class="line">            String teamName=<span class="string">&quot;shen_hua&quot;</span>;</span><br><span class="line">            <span class="comment">//电视宣传</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tvShow</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;宣传队是：&quot;</span>+teamName);</span><br><span class="line">                System.out.println(<span class="string">&quot;这是电视宣传，学校名称&quot;</span>+schoolName+<span class="string">&quot;,业务内容：&quot;</span>+buss+<span class="string">&quot;，学校人数：&quot;</span>+studentNum+<span class="string">&quot;,宣传所需费用&quot;</span>+tvMoney);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//网络宣传</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">netShow</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;宣传队是：&quot;</span>+teamName);</span><br><span class="line">                System.out.println(<span class="string">&quot;这是网络宣传，学校名称&quot;</span>+schoolName+<span class="string">&quot;,业务内容：&quot;</span>+buss+<span class="string">&quot;，学校人数：&quot;</span>+studentNum+<span class="string">&quot;,宣传所需费用&quot;</span>+netMoney);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AdverTeam</span>().tvShow();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AdverTeam</span>().netShow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        School qinghua=<span class="keyword">new</span> <span class="title class_">School</span>(<span class="string">&quot;清华&quot;</span>,<span class="string">&quot;互联网培训&quot;</span>,<span class="number">1000</span>);</span><br><span class="line">        qinghua.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行截图：</p><p><img src="/2022/09/15/Java%E5%9F%BA%E7%A1%80/%E5%86%85%E9%83%A8%E7%B1%BB/内部类5.png" alt></p><h3 id="四、匿名内部类"><a href="#四、匿名内部类" class="headerlink" title="四、匿名内部类"></a><strong>四、匿名内部类</strong></h3><p>1、如果一个内部类在整个操作中只使用一次的话，就可以定义为匿名内部类。匿名内部类也就是没有名字的内部类，这是java为了方便我们编写程序而设计的一个机制，因为有时候有的内部类只需要创建一个它的对象就可以了，以后再不会用到这个类，这时候使用匿名内部类就比较合适。</p><p>2、使用场合：简化内部类的使用</p><p>3、特征：</p><pre><code>  使用new创建 ，没有具体位置  创建的匿名类，默认继承或实现new后面的类型  根据使用情况决定是否持有外部类对象引用  内嵌匿名类编译后生成的.class文件的命名方式是”外部类名称$编号.class”，编号为1，2，3…n，编号为x的文件对应的就是第x个匿名类</code></pre><p>代码演示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 匿名内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Person p=<span class="keyword">new</span> <span class="title class_">Person</span>() &#123;        </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类实现的&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行截图：</p><p><img src="/2022/09/15/Java%E5%9F%BA%E7%A1%80/%E5%86%85%E9%83%A8%E7%B1%BB/内部类6.png" alt></p></blockquote><p>参考：<a href="https://blog.csdn.net/vcliy/article/details/85235363">https://blog.csdn.net/vcliy/article/details/85235363</a></p><p>本文转自 <a href="https://blog.csdn.net/jhdhcbjka/article/details/113523937">https://blog.csdn.net/jhdhcbjka/article/details/113523937</a>，如有侵权，请联系删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;首先看看什么是内部类：在类的内部定义另一个类。没错，定义就这么简单。如果在类Outer的内部再定义一个类Inner，此时Inner就称为内部类，而Outer则称为外部类。内部类的定义格式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;</summary>
      
    
    
    
    <category term="Java基础" scheme="http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>50道练习题掌握查询操作</title>
    <link href="http://example.com/2022/09/04/MySQL/50%E9%81%93%E7%BB%83%E4%B9%A0%E9%A2%98%E6%8E%8C%E6%8F%A1%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2022/09/04/MySQL/50%E9%81%93%E7%BB%83%E4%B9%A0%E9%A2%98%E6%8E%8C%E6%8F%A1%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C/</id>
    <published>2022-09-04T08:13:27.000Z</published>
    <updated>2022-09-13T10:10:01.938Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库准备工作"><a href="#数据库准备工作" class="headerlink" title="数据库准备工作"></a>数据库准备工作</h1><h2 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1.学生表</span><br><span class="line">Student(s<span class="emphasis">_id,s_</span>name,s<span class="emphasis">_birth,s_</span>sex) –学生编号,学生姓名, 出生年月,学生性别</span><br><span class="line"></span><br><span class="line">2.课程表</span><br><span class="line">Course(c<span class="emphasis">_id,c_</span>name,t<span class="emphasis">_id) – –课程编号, 课程名称, 教师编号</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">3.教师表</span></span><br><span class="line"><span class="emphasis">Teacher(t_</span>id,t<span class="emphasis">_name) –教师编号,教师姓名</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">4.成绩表</span></span><br><span class="line"><span class="emphasis">Score(s_</span>id,c<span class="emphasis">_id,s_</span>score) –学生编号,课程编号,分数</span><br></pre></td></tr></table></figure><h2 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--建表</span></span><br><span class="line"><span class="comment">--学生表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `Student`(</span><br><span class="line">`s_id` <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">`s_name` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">`s_birth` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">`s_sex` <span class="type">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(`s_id`)</span><br><span class="line">);</span><br><span class="line"><span class="comment">--课程表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `Course`(</span><br><span class="line">`c_id` <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">`c_name` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">`t_id` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(`c_id`)</span><br><span class="line">);</span><br><span class="line"><span class="comment">--教师表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `Teacher`(</span><br><span class="line">`t_id` <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">`t_name` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(`t_id`)</span><br><span class="line">);</span><br><span class="line"><span class="comment">--成绩表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `Score`(</span><br><span class="line">`s_id` <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">`c_id` <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">`s_score` <span class="type">INT</span>(<span class="number">3</span>),</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(`s_id`,`c_id`)</span><br><span class="line">);</span><br><span class="line"><span class="comment">--插入学生表测试数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">&#x27;01&#x27;</span> , <span class="string">&#x27;赵雷&#x27;</span> , <span class="string">&#x27;1990-01-01&#x27;</span> , <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">&#x27;02&#x27;</span> , <span class="string">&#x27;钱电&#x27;</span> , <span class="string">&#x27;1990-12-21&#x27;</span> , <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">&#x27;03&#x27;</span> , <span class="string">&#x27;孙风&#x27;</span> , <span class="string">&#x27;1990-05-20&#x27;</span> , <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">&#x27;04&#x27;</span> , <span class="string">&#x27;李云&#x27;</span> , <span class="string">&#x27;1990-08-06&#x27;</span> , <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">&#x27;05&#x27;</span> , <span class="string">&#x27;周梅&#x27;</span> , <span class="string">&#x27;1991-12-01&#x27;</span> , <span class="string">&#x27;女&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">&#x27;06&#x27;</span> , <span class="string">&#x27;吴兰&#x27;</span> , <span class="string">&#x27;1992-03-01&#x27;</span> , <span class="string">&#x27;女&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">&#x27;07&#x27;</span> , <span class="string">&#x27;郑竹&#x27;</span> , <span class="string">&#x27;1989-07-01&#x27;</span> , <span class="string">&#x27;女&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span>(<span class="string">&#x27;08&#x27;</span> , <span class="string">&#x27;王菊&#x27;</span> , <span class="string">&#x27;1990-01-20&#x27;</span> , <span class="string">&#x27;女&#x27;</span>);</span><br><span class="line"><span class="comment">--课程表测试数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Course <span class="keyword">values</span>(<span class="string">&#x27;01&#x27;</span> , <span class="string">&#x27;语文&#x27;</span> , <span class="string">&#x27;02&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Course <span class="keyword">values</span>(<span class="string">&#x27;02&#x27;</span> , <span class="string">&#x27;数学&#x27;</span> , <span class="string">&#x27;01&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Course <span class="keyword">values</span>(<span class="string">&#x27;03&#x27;</span> , <span class="string">&#x27;英语&#x27;</span> , <span class="string">&#x27;03&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--教师表测试数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Teacher <span class="keyword">values</span>(<span class="string">&#x27;01&#x27;</span> , <span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Teacher <span class="keyword">values</span>(<span class="string">&#x27;02&#x27;</span> , <span class="string">&#x27;李四&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Teacher <span class="keyword">values</span>(<span class="string">&#x27;03&#x27;</span> , <span class="string">&#x27;王五&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--成绩表测试数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">&#x27;01&#x27;</span> , <span class="string">&#x27;01&#x27;</span> , <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">&#x27;01&#x27;</span> , <span class="string">&#x27;02&#x27;</span> , <span class="number">90</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">&#x27;01&#x27;</span> , <span class="string">&#x27;03&#x27;</span> , <span class="number">99</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">&#x27;02&#x27;</span> , <span class="string">&#x27;01&#x27;</span> , <span class="number">70</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">&#x27;02&#x27;</span> , <span class="string">&#x27;02&#x27;</span> , <span class="number">60</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">&#x27;02&#x27;</span> , <span class="string">&#x27;03&#x27;</span> , <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">&#x27;03&#x27;</span> , <span class="string">&#x27;01&#x27;</span> , <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">&#x27;03&#x27;</span> , <span class="string">&#x27;02&#x27;</span> , <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">&#x27;03&#x27;</span> , <span class="string">&#x27;03&#x27;</span> , <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">&#x27;04&#x27;</span> , <span class="string">&#x27;01&#x27;</span> , <span class="number">50</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">&#x27;04&#x27;</span> , <span class="string">&#x27;02&#x27;</span> , <span class="number">30</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">&#x27;04&#x27;</span> , <span class="string">&#x27;03&#x27;</span> , <span class="number">20</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">&#x27;05&#x27;</span> , <span class="string">&#x27;01&#x27;</span> , <span class="number">76</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">&#x27;05&#x27;</span> , <span class="string">&#x27;02&#x27;</span> , <span class="number">87</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">&#x27;06&#x27;</span> , <span class="string">&#x27;01&#x27;</span> , <span class="number">31</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">&#x27;06&#x27;</span> , <span class="string">&#x27;03&#x27;</span> , <span class="number">34</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">&#x27;07&#x27;</span> , <span class="string">&#x27;02&#x27;</span> , <span class="number">89</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Score <span class="keyword">values</span>(<span class="string">&#x27;07&#x27;</span> , <span class="string">&#x27;03&#x27;</span> , <span class="number">98</span>);</span><br></pre></td></tr></table></figure><h1 id="正片开始"><a href="#正片开始" class="headerlink" title="正片开始"></a>正片开始</h1><h2 id="查询”01”课程比”02”课程成绩高的学生的信息及课程分数"><a href="#查询”01”课程比”02”课程成绩高的学生的信息及课程分数" class="headerlink" title="查询”01”课程比”02”课程成绩高的学生的信息及课程分数"></a>查询”01”课程比”02”课程成绩高的学生的信息及课程分数</h2><h3 id="1-自连接"><a href="#1-自连接" class="headerlink" title="1.自连接"></a>1.自连接</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.<span class="operator">*</span>,</span><br><span class="line">sc1.s_score <span class="keyword">AS</span> s01,</span><br><span class="line">sc2.s_score <span class="keyword">AS</span> s02 </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student st,</span><br><span class="line">score sc1,</span><br><span class="line">score sc2 </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">st.s_id <span class="operator">=</span> sc1.s_id </span><br><span class="line"><span class="keyword">AND</span> sc1.c_id <span class="operator">=</span> <span class="string">&#x27;01&#x27;</span> </span><br><span class="line"><span class="keyword">AND</span> st.s_id <span class="operator">=</span> sc2.s_id </span><br><span class="line"><span class="keyword">AND</span> sc2.c_id <span class="operator">=</span> <span class="string">&#x27;02&#x27;</span> </span><br><span class="line"><span class="keyword">AND</span> sc1.s_score <span class="operator">&gt;</span> sc2.s_score</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.<span class="operator">*</span>,</span><br><span class="line">sc.s_score <span class="keyword">AS</span> s01,</span><br><span class="line">sc2.s_score <span class="keyword">AS</span> s02 </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student st</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score sc <span class="keyword">ON</span> sc.s_id <span class="operator">=</span> st.s_id </span><br><span class="line"><span class="keyword">AND</span> sc.c_id <span class="operator">=</span> <span class="string">&#x27;01&#x27;</span></span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score sc2 <span class="keyword">ON</span> sc2.s_id <span class="operator">=</span> st.s_id </span><br><span class="line"><span class="keyword">AND</span> sc2.c_id <span class="operator">=</span> <span class="string">&#x27;02&#x27;</span> </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sc.s_score <span class="operator">&gt;</span> sc2.s_score</span><br></pre></td></tr></table></figure><h3 id="2-长型数据变宽型数据"><a href="#2-长型数据变宽型数据" class="headerlink" title="2.长型数据变宽型数据"></a>2.长型数据变宽型数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.<span class="operator">*</span>,</span><br><span class="line">t.s01,</span><br><span class="line">t.s02 </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sc.s_id,</span><br><span class="line"><span class="built_in">MAX</span>( <span class="keyword">CASE</span> <span class="keyword">WHEN</span> sc.c_id <span class="operator">=</span> <span class="string">&#x27;01&#x27;</span> <span class="keyword">THEN</span> sc.s_score <span class="keyword">END</span> ) s01,</span><br><span class="line"><span class="built_in">MAX</span>( <span class="keyword">CASE</span> <span class="keyword">WHEN</span> sc.c_id <span class="operator">=</span> <span class="string">&#x27;02&#x27;</span> <span class="keyword">THEN</span> sc.s_score <span class="keyword">END</span> ) s02 </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">score sc </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">sc.s_id </span><br><span class="line">) t,</span><br><span class="line">student st </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">t.s01 <span class="operator">&gt;</span> t.s02 </span><br><span class="line"><span class="keyword">AND</span> t.s_id <span class="operator">=</span> st.s_id</span><br></pre></td></tr></table></figure><h2 id="查询”01”课程比”02”课程成绩低的学生的信息及课程分数"><a href="#查询”01”课程比”02”课程成绩低的学生的信息及课程分数" class="headerlink" title="查询”01”课程比”02”课程成绩低的学生的信息及课程分数"></a>查询”01”课程比”02”课程成绩低的学生的信息及课程分数</h2><p>大于变小于</p><h2 id="查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩"><a href="#查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩" class="headerlink" title="查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩"></a>查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩</h2><h3 id="俩个表连接"><a href="#俩个表连接" class="headerlink" title="俩个表连接"></a>俩个表连接</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.s_id,</span><br><span class="line">st.s_name,</span><br><span class="line"><span class="built_in">AVG</span>( sc.s_score ) <span class="keyword">AS</span> average </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student st,</span><br><span class="line">score sc </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">st.s_id <span class="operator">=</span> sc.s_id </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">st.s_id </span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line"><span class="built_in">AVG</span>( sc.s_score )<span class="operator">&gt;</span> <span class="number">60</span></span><br></pre></td></tr></table></figure><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sc.s_id,</span><br><span class="line">( <span class="keyword">SELECT</span> st.s_name <span class="keyword">FROM</span> student st <span class="keyword">WHERE</span> st.s_id <span class="operator">=</span> sc.s_id ) <span class="keyword">AS</span> s_name,</span><br><span class="line"><span class="built_in">AVG</span>( sc.s_score ) <span class="keyword">AS</span> average </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">score sc </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">sc.s_id </span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line"><span class="built_in">AVG</span>( sc.s_score )<span class="operator">&gt;</span> <span class="number">60</span></span><br></pre></td></tr></table></figure><h2 id="查询平均成绩小于60分的同学的学生编号和学生姓名和平均成绩-包括有成绩的和无成绩的"><a href="#查询平均成绩小于60分的同学的学生编号和学生姓名和平均成绩-包括有成绩的和无成绩的" class="headerlink" title="查询平均成绩小于60分的同学的学生编号和学生姓名和平均成绩(包括有成绩的和无成绩的)"></a>查询平均成绩小于60分的同学的学生编号和学生姓名和平均成绩(包括有成绩的和无成绩的)</h2><p><code>注意</code>：编号为08学生没有选课</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.s_id,</span><br><span class="line">st.s_name,</span><br><span class="line">IFNULL( <span class="built_in">AVG</span>( sc.s_score ), <span class="number">0</span> ) <span class="keyword">AS</span> average </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student st</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score sc <span class="keyword">ON</span> st.s_id <span class="operator">=</span> sc.s_id </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">sc.s_id </span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">IFNULL( <span class="built_in">AVG</span>( sc.s_score ), <span class="number">0</span> )<span class="operator">&lt;</span> <span class="number">60</span></span><br></pre></td></tr></table></figure><h2 id="查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩"><a href="#查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩" class="headerlink" title="查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩"></a>查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩</h2><p><code>注意</code>：编号为08学生没有选课</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.s_id,</span><br><span class="line">st.s_name,</span><br><span class="line"><span class="built_in">count</span>( sc.c_id ) <span class="keyword">AS</span> count,</span><br><span class="line">IFNULL( <span class="built_in">SUM</span>( sc.s_score ), <span class="number">0</span> ) <span class="keyword">AS</span> sum </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student st</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score sc <span class="keyword">ON</span> st.s_id <span class="operator">=</span> sc.s_id </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">st.s_id</span><br></pre></td></tr></table></figure><h2 id="查询”李”姓老师的数量"><a href="#查询”李”姓老师的数量" class="headerlink" title="查询”李”姓老师的数量"></a>查询”李”姓老师的数量</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="built_in">count</span>( t.t_name ) count </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">teacher t </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">t.t_name <span class="keyword">LIKE</span> <span class="string">&#x27;李%&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="查询学过”张三”老师授课的同学的信息"><a href="#查询学过”张三”老师授课的同学的信息" class="headerlink" title="查询学过”张三”老师授课的同学的信息"></a>查询学过”张三”老师授课的同学的信息</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student st </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">st.s_id <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sc.s_id </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">score sc,</span><br><span class="line">course co,</span><br><span class="line">teacher te </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sc.c_id <span class="operator">=</span> co.c_id </span><br><span class="line"><span class="keyword">AND</span> co.t_id <span class="operator">=</span> te.t_id </span><br><span class="line"><span class="keyword">AND</span> te.t_name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="查询没学过”张三”老师授课的同学的信息"><a href="#查询没学过”张三”老师授课的同学的信息" class="headerlink" title="查询没学过”张三”老师授课的同学的信息"></a>查询没学过”张三”老师授课的同学的信息</h2><p>not in</p><h2 id="查询学过编号为”01”并且也学过编号为”02”的课程的同学的信息"><a href="#查询学过编号为”01”并且也学过编号为”02”的课程的同学的信息" class="headerlink" title="查询学过编号为”01”并且也学过编号为”02”的课程的同学的信息"></a>查询学过编号为”01”并且也学过编号为”02”的课程的同学的信息</h2><h3 id="1-自连接-1"><a href="#1-自连接-1" class="headerlink" title="1.自连接"></a>1.自连接</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">score sc1,</span><br><span class="line">score sc2,</span><br><span class="line">student st </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sc1.c_id <span class="operator">=</span> <span class="string">&#x27;01&#x27;</span> </span><br><span class="line"><span class="keyword">AND</span> sc2.c_id <span class="operator">=</span> <span class="string">&#x27;02&#x27;</span> </span><br><span class="line"><span class="keyword">AND</span> st.s_id <span class="operator">=</span> sc1.s_id </span><br><span class="line"><span class="keyword">AND</span> sc1.s_id <span class="operator">=</span> sc2.s_id</span><br></pre></td></tr></table></figure><h3 id="2-长型数据变宽型数据-1"><a href="#2-长型数据变宽型数据-1" class="headerlink" title="2.长型数据变宽型数据"></a>2.长型数据变宽型数据</h3><h3 id="3-关键字IN"><a href="#3-关键字IN" class="headerlink" title="3.关键字IN"></a>3.关键字IN</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">score sc,</span><br><span class="line">student st </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sc.c_id <span class="operator">=</span> <span class="string">&#x27;01&#x27;</span> </span><br><span class="line"><span class="keyword">AND</span> sc.s_id <span class="operator">=</span> st.s_id </span><br><span class="line"><span class="keyword">AND</span> sc.s_id <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sc.s_id </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">score sc </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sc.c_id <span class="operator">=</span> <span class="string">&#x27;02&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="查询学过编号为”01”但是没有学过编号为”02”的课程的同学的信息"><a href="#查询学过编号为”01”但是没有学过编号为”02”的课程的同学的信息" class="headerlink" title="查询学过编号为”01”但是没有学过编号为”02”的课程的同学的信息"></a>查询学过编号为”01”但是没有学过编号为”02”的课程的同学的信息</h2><h3 id="1-关键字NOT-IN"><a href="#1-关键字NOT-IN" class="headerlink" title="1.关键字NOT IN"></a>1.关键字NOT IN</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">score sc,</span><br><span class="line">student st </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sc.c_id <span class="operator">=</span> <span class="string">&#x27;01&#x27;</span> </span><br><span class="line"><span class="keyword">AND</span> sc.s_id <span class="operator">=</span> st.s_id </span><br><span class="line"><span class="keyword">AND</span> sc.s_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sc.s_id </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">score sc </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sc.c_id <span class="operator">=</span> <span class="string">&#x27;02&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-长型数据变宽型数据-2"><a href="#2-长型数据变宽型数据-2" class="headerlink" title="2.长型数据变宽型数据"></a>2.长型数据变宽型数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sc.s_id,</span><br><span class="line"><span class="built_in">MAX</span>( <span class="keyword">CASE</span> <span class="keyword">WHEN</span> sc.c_id <span class="operator">=</span> <span class="string">&#x27;01&#x27;</span> <span class="keyword">THEN</span> sc.s_score <span class="keyword">END</span> ) s01,</span><br><span class="line"><span class="built_in">MAX</span>( <span class="keyword">CASE</span> <span class="keyword">WHEN</span> sc.c_id <span class="operator">=</span> <span class="string">&#x27;02&#x27;</span> <span class="keyword">THEN</span> sc.s_score <span class="keyword">END</span> ) s02 </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">score sc </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">sc.s_id </span><br><span class="line">) t,</span><br><span class="line">student st </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">t.s_id <span class="operator">=</span> st.s_id </span><br><span class="line"><span class="keyword">AND</span> t.s01 <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> </span><br><span class="line"><span class="keyword">AND</span> t.s02 <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure><h2 id="查询没有学全所有课程的同学的信息"><a href="#查询没有学全所有课程的同学的信息" class="headerlink" title="查询没有学全所有课程的同学的信息"></a>查询没有学全所有课程的同学的信息</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student st</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score sc <span class="keyword">ON</span> st.s_id <span class="operator">=</span> sc.s_id </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">st.s_id </span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line"><span class="built_in">COUNT</span>( sc.c_id )<span class="operator">&lt;</span>(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="built_in">COUNT</span>( co.c_id ) </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">course co </span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="查询至少有一门课与学号为”01”的同学所学相同的同学的信息"><a href="#查询至少有一门课与学号为”01”的同学所学相同的同学的信息" class="headerlink" title="查询至少有一门课与学号为”01”的同学所学相同的同学的信息"></a>查询至少有一门课与学号为”01”的同学所学相同的同学的信息</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">score sc,</span><br><span class="line">student st </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sc.c_id <span class="keyword">IN</span> ( <span class="keyword">SELECT</span> sc.c_id <span class="keyword">FROM</span> score sc <span class="keyword">WHERE</span> sc.s_id <span class="operator">=</span> <span class="string">&#x27;01&#x27;</span> ) </span><br><span class="line"><span class="keyword">AND</span> sc.s_id <span class="operator">=</span> st.s_id </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">st.s_id</span><br></pre></td></tr></table></figure><p><code>注意</code>：GROUP BY 可以换成 distinct st.*</p><h2 id="查询和”01”号的同学学习的课程完全相同的其他同学的信息"><a href="#查询和”01”号的同学学习的课程完全相同的其他同学的信息" class="headerlink" title="查询和”01”号的同学学习的课程完全相同的其他同学的信息"></a>查询和”01”号的同学学习的课程完全相同的其他同学的信息</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student st </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">st.s_id <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sc.s_id </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">score sc </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">sc.s_id </span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">group_concat( sc.c_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> sc.c_id ) <span class="operator">=</span> ( <span class="keyword">SELECT</span> group_concat( sc.c_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> sc.c_id ) <span class="keyword">AS</span> str1 <span class="keyword">FROM</span> score sc <span class="keyword">WHERE</span> sc.s_id <span class="operator">=</span> <span class="string">&#x27;01&#x27;</span> ) </span><br><span class="line"><span class="keyword">AND</span> sc.s_id <span class="operator">!=</span> <span class="string">&#x27;01&#x27;</span> </span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="查询没学过”张三”老师讲授的任一门课程的学生姓名"><a href="#查询没学过”张三”老师讲授的任一门课程的学生姓名" class="headerlink" title="查询没学过”张三”老师讲授的任一门课程的学生姓名"></a>查询没学过”张三”老师讲授的任一门课程的学生姓名</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.s_name </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student st </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">st.s_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sc.s_id </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">teacher te,</span><br><span class="line">course co,</span><br><span class="line">score sc </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">te.t_name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span> </span><br><span class="line"><span class="keyword">AND</span> co.t_id <span class="operator">=</span> te.t_id </span><br><span class="line"><span class="keyword">AND</span> co.c_id <span class="operator">=</span> sc.c_id)</span><br></pre></td></tr></table></figure><h2 id="查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩"><a href="#查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩" class="headerlink" title="查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩"></a>查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.s_id,</span><br><span class="line">st.s_name,</span><br><span class="line"><span class="built_in">AVG</span>( sc.s_score ) </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student st</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score sc <span class="keyword">ON</span> st.s_id <span class="operator">=</span> sc.s_id </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sc.s_id <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sc.s_id </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">score sc </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sc.s_score <span class="operator">&lt;</span> <span class="number">60</span> </span><br><span class="line"><span class="keyword">OR</span> sc.s_score <span class="keyword">IS</span> <span class="keyword">NULL</span> </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">sc.s_id </span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line"><span class="built_in">COUNT</span>( <span class="number">1</span> )<span class="operator">&gt;=</span> <span class="number">2</span> </span><br><span class="line">) </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">st.s_id</span><br></pre></td></tr></table></figure><h2 id="检索”01”课程分数小于60，按分数降序排列的学生信息"><a href="#检索”01”课程分数小于60，按分数降序排列的学生信息" class="headerlink" title="检索”01”课程分数小于60，按分数降序排列的学生信息"></a>检索”01”课程分数小于60，按分数降序排列的学生信息</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.<span class="operator">*</span>,</span><br><span class="line">sc.s_score </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student st,</span><br><span class="line">score sc </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">st.s_id <span class="operator">=</span> sc.s_id </span><br><span class="line"><span class="keyword">AND</span> sc.c_id <span class="operator">=</span> <span class="string">&#x27;01&#x27;</span> </span><br><span class="line"><span class="keyword">AND</span> sc.s_score <span class="operator">&lt;</span> <span class="number">60</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">sc.s_score <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><h2 id="按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩"><a href="#按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩" class="headerlink" title="按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩"></a>按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">a.<span class="operator">*</span>,</span><br><span class="line">t.s01,</span><br><span class="line">t.s02,</span><br><span class="line">t.s03 </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.s_id,</span><br><span class="line"><span class="built_in">AVG</span>( sc.s_score ) <span class="keyword">AS</span> average </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student st</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score sc <span class="keyword">ON</span> st.s_id <span class="operator">=</span> sc.s_id </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">st.s_id </span><br><span class="line">) a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.s_id,</span><br><span class="line"><span class="built_in">MAX</span>( <span class="keyword">CASE</span> <span class="keyword">WHEN</span> sc.c_id <span class="operator">=</span> <span class="string">&#x27;01&#x27;</span> <span class="keyword">THEN</span> sc.s_score <span class="keyword">END</span> ) s01,</span><br><span class="line"><span class="built_in">MAX</span>( <span class="keyword">CASE</span> <span class="keyword">WHEN</span> sc.c_id <span class="operator">=</span> <span class="string">&#x27;02&#x27;</span> <span class="keyword">THEN</span> sc.s_score <span class="keyword">END</span> ) s02,</span><br><span class="line"><span class="built_in">MAX</span>( <span class="keyword">CASE</span> <span class="keyword">WHEN</span> sc.c_id <span class="operator">=</span> <span class="string">&#x27;03&#x27;</span> <span class="keyword">THEN</span> sc.s_score <span class="keyword">END</span> ) s03 </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student st</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score sc <span class="keyword">ON</span> st.s_id <span class="operator">=</span> sc.s_id </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">st.s_id </span><br><span class="line">) t <span class="keyword">ON</span> a.s_id <span class="operator">=</span> t.s_id </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">a.average <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><p><code>注意</code>:mysql8.0以上版本使用开窗函数<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sc.<span class="operator">*</span>,</span><br><span class="line"><span class="built_in">AVG</span>( sc.s_score ) <span class="keyword">over</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> sc.s_id ) avg_s </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">score sc </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">avg_s <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure></p><h2 id="查询各科成绩最高分、最低分和平均分：以如下形式显示：课程ID，课程name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率"><a href="#查询各科成绩最高分、最低分和平均分：以如下形式显示：课程ID，课程name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率" class="headerlink" title="查询各科成绩最高分、最低分和平均分：以如下形式显示：课程ID，课程name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率"></a>查询各科成绩最高分、最低分和平均分：以如下形式显示：课程ID，课程name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率</h2><p><code>及格为&gt;=60，中等为：70-80，优良为：80-90，优秀为：&gt;=90</code><br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">c.c_id <span class="keyword">AS</span> <span class="string">&#x27;课程ID&#x27;</span>,</span><br><span class="line">c.c_name <span class="keyword">AS</span> <span class="string">&#x27;课程name&#x27;</span>,</span><br><span class="line">ROUND( <span class="built_in">MAX</span>( s_score ), <span class="number">2</span> ) <span class="keyword">AS</span> <span class="string">&#x27;最高分&#x27;</span>,</span><br><span class="line">ROUND( <span class="built_in">MIN</span>( s_score ), <span class="number">2</span> ) <span class="keyword">AS</span> <span class="string">&#x27;最低分&#x27;</span>,</span><br><span class="line">ROUND( <span class="built_in">AVG</span>( s_score ), <span class="number">2</span> ) <span class="keyword">AS</span> <span class="string">&#x27;平均分&#x27;</span>,</span><br><span class="line">ROUND( <span class="built_in">SUM</span>( <span class="keyword">CASE</span> <span class="keyword">WHEN</span> s_score <span class="operator">&gt;=</span> <span class="number">60</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span> )<span class="operator">/</span> <span class="built_in">COUNT</span>( <span class="number">1</span> ), <span class="number">2</span> ) <span class="keyword">AS</span> <span class="string">&#x27;及格率&#x27;</span>,</span><br><span class="line">ROUND( <span class="built_in">SUM</span>( <span class="keyword">CASE</span> <span class="keyword">WHEN</span> s_score <span class="operator">&gt;=</span> <span class="number">70</span> <span class="keyword">AND</span> s_score <span class="operator">&lt;</span> <span class="number">80</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span> )<span class="operator">/</span> <span class="built_in">COUNT</span>( <span class="number">1</span> ), <span class="number">2</span> ) <span class="keyword">AS</span> <span class="string">&#x27;中等率&#x27;</span>,</span><br><span class="line">ROUND( <span class="built_in">SUM</span>( <span class="keyword">CASE</span> <span class="keyword">WHEN</span> s_score <span class="operator">&gt;=</span> <span class="number">80</span> <span class="keyword">AND</span> s_score <span class="operator">&lt;</span> <span class="number">90</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span> )<span class="operator">/</span> <span class="built_in">COUNT</span>( <span class="number">1</span> ), <span class="number">2</span> ) <span class="keyword">AS</span> <span class="string">&#x27;优良率&#x27;</span>,</span><br><span class="line">ROUND( <span class="built_in">SUM</span>( <span class="keyword">CASE</span> <span class="keyword">WHEN</span> s_score <span class="operator">&gt;=</span> <span class="number">90</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span> )<span class="operator">/</span> <span class="built_in">COUNT</span>( <span class="number">1</span> ), <span class="number">2</span> ) <span class="keyword">AS</span> <span class="string">&#x27;优秀率&#x27;</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">course c</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score sc <span class="keyword">ON</span> c.c_id <span class="operator">=</span> sc.c_id </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">c.c_id</span><br></pre></td></tr></table></figure></p><h2 id="按各科成绩进行排序，并显示排名-实现不完全"><a href="#按各科成绩进行排序，并显示排名-实现不完全" class="headerlink" title="按各科成绩进行排序，并显示排名(实现不完全)"></a>按各科成绩进行排序，并显示排名(实现不完全)</h2><h3 id="mysql8-0之后加入开窗函数"><a href="#mysql8-0之后加入开窗函数" class="headerlink" title="mysql8.0之后加入开窗函数"></a>mysql8.0之后加入开窗函数</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sc.<span class="operator">*</span>,</span><br><span class="line"><span class="built_in">RANK</span>() <span class="keyword">over</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> c_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> s_score <span class="keyword">DESC</span> ) <span class="keyword">AS</span> <span class="string">&#x27;rank&#x27;</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">score sc</span><br></pre></td></tr></table></figure><h3 id="mysql8-0之前"><a href="#mysql8-0之前" class="headerlink" title="mysql8.0之前"></a>mysql8.0之前</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sc.<span class="operator">*</span>,(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="built_in">COUNT</span>( s_score ) </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">score a </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">a.c_id <span class="operator">=</span> sc.c_id </span><br><span class="line"><span class="keyword">AND</span> sc.s_score <span class="operator">&lt;</span> a.s_score </span><br><span class="line">)<span class="operator">+</span> <span class="number">1</span> <span class="keyword">AS</span> <span class="string">&#x27;rank&#x27;</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">score sc </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">c_id,</span><br><span class="line">sc.s_score <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><h2 id="查询学生的总成绩并进行排名"><a href="#查询学生的总成绩并进行排名" class="headerlink" title="查询学生的总成绩并进行排名"></a>查询学生的总成绩并进行排名</h2><h3 id="mysql8-0之后加入开窗函数-1"><a href="#mysql8-0之后加入开窗函数-1" class="headerlink" title="mysql8.0之后加入开窗函数"></a>mysql8.0之后加入开窗函数</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">t.<span class="operator">*</span>,</span><br><span class="line"><span class="built_in">RANK</span>() <span class="keyword">over</span> ( <span class="keyword">ORDER</span> <span class="keyword">BY</span> sum_s <span class="keyword">DESC</span> ) rk </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">( <span class="keyword">SELECT</span> s_id, <span class="built_in">SUM</span>( s_score ) sum_s <span class="keyword">FROM</span> score sc <span class="keyword">GROUP</span> <span class="keyword">BY</span> sc.s_id ) t</span><br></pre></td></tr></table></figure><h3 id="mysql8-0之前-1"><a href="#mysql8-0之前-1" class="headerlink" title="mysql8.0之前"></a>mysql8.0之前</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sum_s_temp <span class="keyword">AS</span> <span class="keyword">SELECT</span></span><br><span class="line">s_id,</span><br><span class="line"><span class="built_in">SUM</span>( s_score ) sum_s </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">score sc </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">sc.s_id</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">t.<span class="operator">*</span>,</span><br><span class="line">(<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(sum_s) <span class="keyword">FROM</span> sum_s_temp a <span class="keyword">WHERE</span> a.sum_s<span class="operator">&gt;</span>t.sum_s)<span class="operator">+</span><span class="number">1</span> <span class="keyword">AS</span> <span class="string">&#x27;rank&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">sum_s_temp t</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> sum_s <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><h2 id="查询不同老师所教不同课程平均分从高到低显示"><a href="#查询不同老师所教不同课程平均分从高到低显示" class="headerlink" title="查询不同老师所教不同课程平均分从高到低显示"></a>查询不同老师所教不同课程平均分从高到低显示</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">t.t_id,</span><br><span class="line">t.t_name,</span><br><span class="line"><span class="built_in">AVG</span>( sc.s_score ) </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">teacher t</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> course c <span class="keyword">ON</span> t.t_id <span class="operator">=</span> c.t_id</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score sc <span class="keyword">ON</span> c.c_id <span class="operator">=</span> sc.c_id </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">t.t_id </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line"><span class="built_in">AVG</span>( sc.s_score ) <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><h2 id="查询所有课程的成绩第2名到第3名的学生信息及该课程成绩"><a href="#查询所有课程的成绩第2名到第3名的学生信息及该课程成绩" class="headerlink" title="查询所有课程的成绩第2名到第3名的学生信息及该课程成绩"></a>查询所有课程的成绩第2名到第3名的学生信息及该课程成绩</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.<span class="operator">*</span>,</span><br><span class="line">t.c_id,</span><br><span class="line">t.s_score </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student st</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> ( <span class="keyword">SELECT</span> sc.<span class="operator">*</span>, <span class="built_in">RANK</span>() <span class="keyword">over</span> ( <span class="keyword">ORDER</span> <span class="keyword">BY</span> s_score <span class="keyword">DESC</span> ) rk <span class="keyword">FROM</span> score sc ) t <span class="keyword">ON</span> st.s_id <span class="operator">=</span> t.s_id </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">rk <span class="keyword">IN</span> (<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h2 id="统计各科成绩各分数段人数：课程编号-课程名称-100-85-85-70-70-60-0-60-及所占百分比"><a href="#统计各科成绩各分数段人数：课程编号-课程名称-100-85-85-70-70-60-0-60-及所占百分比" class="headerlink" title="统计各科成绩各分数段人数：课程编号,课程名称,[100-85],[85-70],[70-60],[0-60]及所占百分比"></a>统计各科成绩各分数段人数：课程编号,课程名称,[100-85],[85-70],[70-60],[0-60]及所占百分比</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sc.c_id,</span><br><span class="line">c.c_name,</span><br><span class="line"><span class="built_in">SUM</span>( <span class="keyword">CASE</span> <span class="keyword">WHEN</span> sc.s_score <span class="operator">&gt;=</span> <span class="number">85</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span> )<span class="operator">/</span> <span class="built_in">COUNT</span>( s_score ) <span class="keyword">AS</span> <span class="string">&#x27;[100-85]&#x27;</span>,</span><br><span class="line"><span class="built_in">SUM</span>( <span class="keyword">CASE</span> <span class="keyword">WHEN</span> sc.s_score <span class="operator">&gt;=</span> <span class="number">70</span> <span class="keyword">AND</span> sc.s_score <span class="operator">&lt;</span> <span class="number">85</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span> )<span class="operator">/</span> <span class="built_in">COUNT</span>( s_score ) <span class="keyword">AS</span> <span class="string">&#x27;[85-70]&#x27;</span>,</span><br><span class="line"><span class="built_in">SUM</span>( <span class="keyword">CASE</span> <span class="keyword">WHEN</span> sc.s_score <span class="operator">&gt;=</span> <span class="number">60</span> <span class="keyword">AND</span> sc.s_score <span class="operator">&lt;</span> <span class="number">70</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span> )<span class="operator">/</span> <span class="built_in">COUNT</span>( s_score ) <span class="keyword">AS</span> <span class="string">&#x27;[70-60]&#x27;</span>,</span><br><span class="line"><span class="built_in">SUM</span>( <span class="keyword">CASE</span> <span class="keyword">WHEN</span> sc.s_score <span class="operator">&gt;=</span> <span class="number">0</span> <span class="keyword">AND</span> sc.s_score <span class="operator">&lt;</span> <span class="number">60</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span> )<span class="operator">/</span> <span class="built_in">COUNT</span>( s_score ) <span class="keyword">AS</span> <span class="string">&#x27;[0-60]&#x27;</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">score sc</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> course c <span class="keyword">ON</span> sc.c_id <span class="operator">=</span> c.c_id </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">sc.c_id</span><br></pre></td></tr></table></figure><h2 id="查询学生平均成绩及其名次"><a href="#查询学生平均成绩及其名次" class="headerlink" title="查询学生平均成绩及其名次"></a>查询学生平均成绩及其名次</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.s_id,</span><br><span class="line">t.average,</span><br><span class="line"><span class="built_in">RANK</span>() <span class="keyword">over</span> ( <span class="keyword">ORDER</span> <span class="keyword">BY</span> average <span class="keyword">DESC</span> ) rk </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student st</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> ( <span class="keyword">SELECT</span> sc.s_id, <span class="built_in">AVG</span>( sc.s_score ) average <span class="keyword">FROM</span> score sc <span class="keyword">GROUP</span> <span class="keyword">BY</span> sc.s_id ) t <span class="keyword">ON</span> st.s_id <span class="operator">=</span> t.s_id</span><br></pre></td></tr></table></figure><h2 id="查询各科成绩前三名的记录"><a href="#查询各科成绩前三名的记录" class="headerlink" title="查询各科成绩前三名的记录"></a>查询各科成绩前三名的记录</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">t.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">c.c_id,</span><br><span class="line">c.c_name,</span><br><span class="line">sc.s_score,</span><br><span class="line"><span class="built_in">RANK</span>() <span class="keyword">over</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> c.c_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> sc.s_score <span class="keyword">DESC</span> ) <span class="keyword">AS</span> rk </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">course c</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score sc <span class="keyword">ON</span> c.c_id <span class="operator">=</span> sc.c_id </span><br><span class="line">) t </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">t.rk <span class="keyword">IN</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h2 id="查询每门课程被选修的学生数"><a href="#查询每门课程被选修的学生数" class="headerlink" title="查询每门课程被选修的学生数"></a>查询每门课程被选修的学生数</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">c.c_id,</span><br><span class="line">c.c_name,</span><br><span class="line"><span class="built_in">COUNT</span>( sc.s_score ) <span class="keyword">AS</span> cnt</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">course c</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score sc <span class="keyword">ON</span> c.c_id <span class="operator">=</span> sc.c_id </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">c.c_id</span><br></pre></td></tr></table></figure><h2 id="查询出只有两门课程的全部学生的学号和姓名"><a href="#查询出只有两门课程的全部学生的学号和姓名" class="headerlink" title="查询出只有两门课程的全部学生的学号和姓名"></a>查询出只有两门课程的全部学生的学号和姓名</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.s_id,</span><br><span class="line">st.s_name </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student st</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> score sc <span class="keyword">ON</span> st.s_id <span class="operator">=</span> sc.s_id </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">st.s_id </span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line"><span class="built_in">COUNT</span>( sc.s_score )<span class="operator">=</span><span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="查询男生、女生人数"><a href="#查询男生、女生人数" class="headerlink" title="查询男生、女生人数"></a>查询男生、女生人数</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.s_sex,</span><br><span class="line"><span class="built_in">COUNT</span>( <span class="number">1</span> ) </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student st </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">st.s_sex</span><br></pre></td></tr></table></figure><h2 id="查询名字中含有”风”字的学生信息"><a href="#查询名字中含有”风”字的学生信息" class="headerlink" title="查询名字中含有”风”字的学生信息"></a>查询名字中含有”风”字的学生信息</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student st </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">st.s_name <span class="keyword">LIKE</span> <span class="string">&#x27;%风%&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="查询同名同性学生名单，并统计同名人数"><a href="#查询同名同性学生名单，并统计同名人数" class="headerlink" title="查询同名同性学生名单，并统计同名人数"></a>查询同名同性学生名单，并统计同名人数</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.s_name,</span><br><span class="line">st.s_sex,</span><br><span class="line"><span class="built_in">COUNT</span>( <span class="number">1</span> ) <span class="keyword">AS</span> cnt </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student st </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">st.s_name,</span><br><span class="line">st.s_sex </span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line"><span class="built_in">COUNT</span>( <span class="number">1</span> )<span class="operator">&gt;</span><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="查询1990年出生的学生名单"><a href="#查询1990年出生的学生名单" class="headerlink" title="查询1990年出生的学生名单"></a>查询1990年出生的学生名单</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student st </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">st.s_birth <span class="keyword">LIKE</span> <span class="string">&#x27;1990%&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列"><a href="#查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列" class="headerlink" title="查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列"></a>查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">c.c_id,</span><br><span class="line">c.c_name,</span><br><span class="line"><span class="built_in">AVG</span>( sc.s_score ) <span class="keyword">AS</span> average </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">course c</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score sc <span class="keyword">ON</span> c.c_id <span class="operator">=</span> sc.c_id </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">c.c_id </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">average <span class="keyword">DESC</span>,</span><br><span class="line">c_id</span><br></pre></td></tr></table></figure><h2 id="查询平均成绩大于等于85的所有学生的学号、姓名和平均成绩"><a href="#查询平均成绩大于等于85的所有学生的学号、姓名和平均成绩" class="headerlink" title="查询平均成绩大于等于85的所有学生的学号、姓名和平均成绩"></a>查询平均成绩大于等于85的所有学生的学号、姓名和平均成绩</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.s_id,</span><br><span class="line">st.s_name,</span><br><span class="line"><span class="built_in">AVG</span>( sc.s_score ) average </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student st</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score sc <span class="keyword">ON</span> st.s_id <span class="operator">=</span> sc.s_id </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">st.s_id </span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">average <span class="operator">&gt;=</span> <span class="number">85</span></span><br></pre></td></tr></table></figure><h2 id="查询课程名称为”数学”，且分数低于60的学生姓名和分数"><a href="#查询课程名称为”数学”，且分数低于60的学生姓名和分数" class="headerlink" title="查询课程名称为”数学”，且分数低于60的学生姓名和分数"></a>查询课程名称为”数学”，且分数低于60的学生姓名和分数</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.s_name,</span><br><span class="line">sc.s_score </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student st</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score sc <span class="keyword">ON</span> st.s_id <span class="operator">=</span> sc.s_id</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> course c <span class="keyword">ON</span> sc.c_id <span class="operator">=</span> c.c_id </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">c.c_name <span class="operator">=</span> <span class="string">&#x27;数学&#x27;</span> </span><br><span class="line"><span class="keyword">AND</span> sc.s_score <span class="operator">&lt;</span> <span class="number">60</span></span><br></pre></td></tr></table></figure><h2 id="查询所有学生的课程及分数情况"><a href="#查询所有学生的课程及分数情况" class="headerlink" title="查询所有学生的课程及分数情况"></a>查询所有学生的课程及分数情况</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.s_id,</span><br><span class="line">st.s_name,</span><br><span class="line">c.c_name,</span><br><span class="line">sc.s_score </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student st</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score sc <span class="keyword">ON</span> st.s_id <span class="operator">=</span> sc.s_id</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> course c <span class="keyword">ON</span> sc.c_id <span class="operator">=</span> c.c_id </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">st.s_id</span><br></pre></td></tr></table></figure><h2 id="查询任何一门课程成绩在70分以上的姓名、课程名称和分数"><a href="#查询任何一门课程成绩在70分以上的姓名、课程名称和分数" class="headerlink" title="查询任何一门课程成绩在70分以上的姓名、课程名称和分数"></a>查询任何一门课程成绩在70分以上的姓名、课程名称和分数</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.s_name,</span><br><span class="line">c.c_name,</span><br><span class="line">sc.s_score </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student st</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score sc <span class="keyword">ON</span> st.s_id <span class="operator">=</span> sc.s_id</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> course c <span class="keyword">ON</span> sc.c_id <span class="operator">=</span> c.c_id </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">st.s_id <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">s_id </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">score </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">s_id </span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line"><span class="built_in">MIN</span>( s_score ) <span class="operator">&gt;</span> <span class="number">70</span> </span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="查询不及格的课程"><a href="#查询不及格的课程" class="headerlink" title="查询不及格的课程"></a>查询不及格的课程</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">st.s_id,</span><br><span class="line">st.s_name,</span><br><span class="line">c.c_name,</span><br><span class="line">sc.s_score </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">score sc</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> student st <span class="keyword">ON</span> sc.s_id <span class="operator">=</span> st.s_id</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> course c <span class="keyword">ON</span> sc.c_id <span class="operator">=</span> c.c_id </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sc.s_score <span class="operator">&lt;</span> <span class="number">60</span>;</span><br></pre></td></tr></table></figure><h2 id="查询课程编号为01且课程成绩在80分以上的学生的学号和姓名"><a href="#查询课程编号为01且课程成绩在80分以上的学生的学号和姓名" class="headerlink" title="查询课程编号为01且课程成绩在80分以上的学生的学号和姓名"></a>查询课程编号为01且课程成绩在80分以上的学生的学号和姓名</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.s_id,</span><br><span class="line">st.s_name,</span><br><span class="line">sc.s_score </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student st</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> score sc <span class="keyword">ON</span> st.s_id <span class="operator">=</span> sc.s_id </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sc.c_id <span class="operator">=</span> <span class="string">&#x27;01&#x27;</span> </span><br><span class="line"><span class="keyword">AND</span> sc.s_score <span class="operator">&gt;=</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><h2 id="求每门课程的学生人数"><a href="#求每门课程的学生人数" class="headerlink" title="求每门课程的学生人数"></a>求每门课程的学生人数</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">c.c_id,</span><br><span class="line">c.c_name,</span><br><span class="line"><span class="built_in">count</span>( <span class="number">1</span> ) </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">course c</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> score sc <span class="keyword">ON</span> sc.c_id <span class="operator">=</span> c.c_id </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">c.c_id</span><br></pre></td></tr></table></figure><h2 id="查询选修”张三”老师所授课程的学生中，成绩最高的学生信息及其成绩"><a href="#查询选修”张三”老师所授课程的学生中，成绩最高的学生信息及其成绩" class="headerlink" title="查询选修”张三”老师所授课程的学生中，成绩最高的学生信息及其成绩"></a>查询选修”张三”老师所授课程的学生中，成绩最高的学生信息及其成绩</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.<span class="operator">*</span>,</span><br><span class="line">c.c_name,</span><br><span class="line">sc.s_score </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">score sc</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> student st <span class="keyword">ON</span> sc.s_id <span class="operator">=</span> st.s_id</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> course c <span class="keyword">ON</span> sc.c_id <span class="operator">=</span> c.c_id</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> teacher t <span class="keyword">ON</span> c.t_id <span class="operator">=</span> t.t_id </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">t.t_name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">sc.s_score <span class="keyword">DESC</span> </span><br><span class="line">LIMIT <span class="number">0</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩"><a href="#查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩" class="headerlink" title="查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩"></a>查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sc1.s_id,</span><br><span class="line">sc1.c_id,</span><br><span class="line">sc1.s_score </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">score sc1 </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sc1.s_score <span class="keyword">IN</span> ( <span class="keyword">SELECT</span> sc.s_score <span class="keyword">FROM</span> score sc <span class="keyword">GROUP</span> <span class="keyword">BY</span> sc.s_score <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>( <span class="number">1</span> )<span class="operator">&gt;</span> <span class="number">1</span> )</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span></span><br><span class="line">sc1.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">score sc1,</span><br><span class="line">score sc2 </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sc1.c_id <span class="operator">!=</span> sc2.c_id </span><br><span class="line"><span class="keyword">AND</span> sc1.s_score <span class="operator">=</span> sc2.s_score</span><br></pre></td></tr></table></figure><h2 id="查询每门功成绩最好的前两名"><a href="#查询每门功成绩最好的前两名" class="headerlink" title="查询每门功成绩最好的前两名"></a>查询每门功成绩最好的前两名</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">t.s_id,</span><br><span class="line">t.c_id,</span><br><span class="line">t.s_score </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">( <span class="keyword">SELECT</span> sc.<span class="operator">*</span>, <span class="built_in">RANK</span>() <span class="keyword">over</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> sc.c_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> sc.s_score <span class="keyword">DESC</span> ) <span class="keyword">AS</span> rk <span class="keyword">FROM</span> score sc ) t </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">t.rk <span class="keyword">IN</span> (<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="统计每门课程的学生选修人数（超过5人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列"><a href="#统计每门课程的学生选修人数（超过5人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列" class="headerlink" title="统计每门课程的学生选修人数（超过5人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列"></a>统计每门课程的学生选修人数（超过5人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列</h2><p><code>若人数相同，按课程号升序排列</code><br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">c.c_id,</span><br><span class="line">c.c_name,</span><br><span class="line"><span class="built_in">count</span>( <span class="number">1</span> ) <span class="keyword">AS</span> cnt </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">course c</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> score sc <span class="keyword">ON</span> sc.c_id <span class="operator">=</span> c.c_id </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">c.c_id </span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line"><span class="built_in">COUNT</span>( <span class="number">1</span> )<span class="operator">&gt;</span> <span class="number">5</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">cnt <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure></p><h2 id="检索至少选修两门课程的学生学号"><a href="#检索至少选修两门课程的学生学号" class="headerlink" title="检索至少选修两门课程的学生学号"></a>检索至少选修两门课程的学生学号</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sc.s_id </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">score sc </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">sc.s_id </span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line"><span class="built_in">COUNT</span>( <span class="number">1</span> )<span class="operator">&gt;=</span><span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="查询选修了全部课程的学生信息"><a href="#查询选修了全部课程的学生信息" class="headerlink" title="查询选修了全部课程的学生信息"></a>查询选修了全部课程的学生信息</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">score sc</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> student st <span class="keyword">ON</span> sc.s_id <span class="operator">=</span> st.s_id </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">sc.s_id </span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line"><span class="built_in">COUNT</span>( <span class="number">1</span> )<span class="operator">=</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="built_in">COUNT</span>( <span class="number">1</span> ) </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">course c)</span><br></pre></td></tr></table></figure><h2 id="查询各学生的年龄"><a href="#查询各学生的年龄" class="headerlink" title="查询各学生的年龄"></a>查询各学生的年龄</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.s_id,</span><br><span class="line">TIMESTAMPDIFF(</span><br><span class="line"><span class="keyword">YEAR</span>,</span><br><span class="line">st.s_birth,</span><br><span class="line">DATE_FORMAT( NOW(), <span class="string">&#x27;%Y-%m-%d&#x27;</span> )) </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student st</span><br></pre></td></tr></table></figure><h2 id="查询本周过生日的学生"><a href="#查询本周过生日的学生" class="headerlink" title="查询本周过生日的学生"></a>查询本周过生日的学生</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student st </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">WEEKOFYEAR(</span><br><span class="line">STR_TO_DATE( CONCAT( <span class="keyword">YEAR</span> ( NOW()), DATE_FORMAT( s_birth, <span class="string">&#x27;%m%d&#x27;</span> )), <span class="string">&#x27;&amp;y%m%d&#x27;</span> ))</span><br></pre></td></tr></table></figure><h2 id="查询下周过生日的学生"><a href="#查询下周过生日的学生" class="headerlink" title="查询下周过生日的学生"></a>查询下周过生日的学生</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student st </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">WEEKOFYEAR(</span><br><span class="line">STR_TO_DATE( CONCAT( <span class="keyword">YEAR</span> ( NOW()), DATE_FORMAT( s_birth, <span class="string">&#x27;%m%d&#x27;</span> )), <span class="string">&#x27;&amp;y%m%d&#x27;</span> ))<span class="operator">=</span>WEEKOFYEAR(NOW()<span class="operator">+</span><span class="type">INTERVAL</span> <span class="string">&#x27;7&#x27;</span> <span class="keyword">DAY</span>)</span><br></pre></td></tr></table></figure><h2 id="查询本月过生日的学生"><a href="#查询本月过生日的学生" class="headerlink" title="查询本月过生日的学生"></a>查询本月过生日的学生</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student st </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">MONTH</span>(NOW())<span class="operator">=</span><span class="keyword">MONTH</span>(s_birth)</span><br></pre></td></tr></table></figure><h2 id="查询下月过生日的学生"><a href="#查询下月过生日的学生" class="headerlink" title="查询下月过生日的学生"></a>查询下月过生日的学生</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student st </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">MONTH</span>(NOW()<span class="operator">+</span><span class="type">INTERVAL</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">MONTH</span>)<span class="operator">=</span><span class="keyword">MONTH</span>(s_birth)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据库准备工作&quot;&gt;&lt;a href=&quot;#数据库准备工作&quot; class=&quot;headerlink&quot; title=&quot;数据库准备工作&quot;&gt;&lt;/a&gt;数据库准备工作&lt;/h1&gt;&lt;h2 id=&quot;数据表&quot;&gt;&lt;a href=&quot;#数据表&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>事务管理详解</title>
    <link href="http://example.com/2022/09/03/Spring%E7%9B%B8%E5%85%B3/%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2022/09/03/Spring%E7%9B%B8%E5%85%B3/%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-09-03T07:06:49.000Z</published>
    <updated>2022-09-03T10:16:09.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事务的基本概念"><a href="#事务的基本概念" class="headerlink" title="事务的基本概念"></a>事务的基本概念</h1><p>事务（ Transaction ）是访问并可能 数据库 数据项 程序执行单元（ unit ）。</p><p>特点： 事务是恢复和并发控制基本单位。事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。</p><ul><li>原子性（ Atomicity ）：一个事务是一个不可分割的工作单位，事务中包括的诸多操作， 要么都做，要么都不做</li><li>一致性（ Consistency ）： 事务必须使数据库从一致性状态变到另一个致性状态。一致性与原子性是密切相关的</li><li>隔离性（ Isolation ）： 一个事务的执行不能被其它事务干扰，即一个事务内部的操作及使用的数据对井发其他的事务是隔离的，并发执行的各个事务之间不能互相干扰</li><li>持久性（ Durability ）： 持久性也称永久性（ Permanence ），指一旦提交它对数据库中数据的改变就应该是永久性的，接下来的其他操作或故障不应该对其有任何影响</li></ul><h1 id="事务的基本原理"><a href="#事务的基本原理" class="headerlink" title="事务的基本原理"></a>事务的基本原理</h1><p>Spring 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持， Spring是无法提<br>供事务功能的。对于纯 JDBC 操作数据库，想要用到事务，可以按照以下步骤进行：</p><ol><li>获取连接 <code>Connection con = DriverManager.getConnection（）</code></li><li>开启事务 <code>con.setAutoCommit(true/false)</code></li><li>执行 CRUD 操作</li><li>提交事务／回滚事务 <code>con.commit()/con.rollback()</code></li><li>关闭连接 <code>con.close()</code></li></ol><p>&emsp;&emsp;使用Spring的事务管理功能后，我们可以不再写步骤 2 和 4 的代码，而是由Spring自动完成。那么Spring是如何在我们书写的CRUD操作之前和之后开启事务和关闭事务的呢？解决了这个问题，也就可以从整体上理解Spring的事务管理实现原理了。下面简单地介绍一下，以注解方式为例。</p><p>&emsp;&emsp;在配置文件中开启注解驱动，在相关的类和方法上通过注解＠Transactional标识。</p><p>&emsp;&emsp;Spring 在启动的时候会解析生成相关的Bean，这时候会查看拥有相关注解的类和方法，并且为这些类和方法生成代理，根据＠Transactional的相关参数进行相关配置注入，这样就在代理中为我们把相关的事务处理掉了（开启正常提交事务、异常回滚事务）。</p><p>&emsp;&emsp;真正的数据库层的事务提交和回滚是通过binlog或者 redo log实现的。</p><h1 id="声明式事务管理参数配置"><a href="#声明式事务管理参数配置" class="headerlink" title="声明式事务管理参数配置"></a>声明式事务管理参数配置</h1><p>在 service 类上面添加注解@Transactional，在这个注解里面可以配置事务相关参数</p><div class="table-container"><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>propagation</td><td>事务传播行为</td></tr><tr><td>ioslation</td><td>事务隔离级别</td></tr><tr><td>timeout</td><td>超时时间</td></tr><tr><td>readOnly</td><td>是否只读</td></tr><tr><td>rollbackFor</td><td>回滚</td></tr><tr><td>noRollbackFor</td><td>不回滚</td></tr></tbody></table></div><p><strong>(1) propagation : 事务传播行为</strong></p><p>事务传播行为:多事务方法直接进行调用,这个过程中事务是如何进行管理的(理解:在多事务方法调用的时候,指定事务的管理方式)</p><div class="table-container"><table><thead><tr><th>传播属性</th><th>描述</th></tr></thead><tbody><tr><td>Propagation.REQUIRED</td><td>支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择，也是 Spring 默认的事务的传播属性</td></tr><tr><td>Propagation.REQUIRES_NEW</td><td>新建事务，如果当前存在事务，把当前事务挂起。新建的事务将和被挂起的事务没有任何关系，是两个独立的事务。外部事务失败回滚之后，不能回滚内部事务执行的结果，内部事务失败抛出异常，被外部事务捕获，也可以不处理回滚操作</td></tr><tr><td>Propagation.SUPPORTS</td><td>支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</td></tr><tr><td>Propagation.NOT_SUPPORTED</td><td>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</td></tr><tr><td>Propagation.MANDATORY</td><td>支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</td></tr><tr><td>Propagation.NEVER</td><td>以非事务方式执行，如果当前存在事务，则抛出异常440</td></tr><tr><td>Propagation.NESTED</td><td>如果有活动事务，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager 事务管理器有效</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Transactional(propagation = Propagation.REQUIRED)</span><br><span class="line">public class UserService &#123;...&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>(2) ioslation : 事务隔离级别</strong></p><p>数据库事务隔离级别如下表所示。</p><div class="table-container"><table><thead><tr><th>隔离级别</th><th>值</th><th>脏读</th><th>不可重读读</th><th>幻读</th></tr></thead><tbody><tr><td>READ_UNCOMMITTED(读为提交)</td><td>0</td><td>✔</td><td>✔</td><td>✔</td></tr><tr><td>READ_COMMITTED(读已提交)</td><td>1</td><td>❌</td><td>✔</td><td>✔</td></tr><tr><td>REPEATABLE_READ(可重复读)</td><td>2</td><td>❌</td><td>❌</td><td>✔</td></tr><tr><td>SERIALIZABLE(串行化)</td><td>3</td><td>❌</td><td>❌</td><td>❌</td></tr></tbody></table></div><ul><li><p>事务隔离性:多事务操作之间不会产生影响.</p></li><li><p>不考虑隔离性会出现:脏读,不可重复读,虚(幻)读</p><ul><li>脏读: 一个事务对数据进行了增、删、改，但未提交，另一个事务可以读取到未提交的数据。如果第一个事务这时候回滚了，那么第二个事务就读到了脏数据。</li><li>不可重复读：一个事务中发生了两次读操作，在第一次读操作和第二次读操作之间，另外一个事务对数据进行了修改，这时候两次读取的数据是不一致的。</li><li>虚读: 第一个事务对一定范围的数据进行了批量修改，第二个事务在这个范围内增加了一条数据，这时候第一个事务就会丢失对新增数据的修改。</li></ul></li><li>通过设置事务隔离级别，解决读问题</li></ul><p>Spring 中的事务隔离级别如下表所示。</p><div class="table-container"><table><thead><tr><th>常量</th><th>解释</th></tr></thead><tbody><tr><td>ISOLATION_DEFAULT</td><td>这是PlatformTransactionManager默认的事务隔离级别，使用数据库默认的事务隔离级别。另外4个与JDBC的事务隔离级别相对应</td></tr><tr><td>ISOLATION_READ_UNCOMMITTED</td><td>这是最低的事务隔离级别，它允许另外一个事务看到这个事务未提交的数据。这种隔离级别会产生脏读、不可重复读和幻读</td></tr><tr><td>ISOLATION_READ_COMMITTED</td><td>保证一个事务修改的数据提交后才能被另一个事务读取。另一个事务不能读取该事务未提交的数据</td></tr><tr><td>ISOLATION REPEATABLE READ</td><td>这种事务隔离级别可以防止脏读、不可重复读，但是可能出现幻读</td></tr><tr><td>ISOLATION SERIALIZABLE</td><td>这是花费最高代价但是最可靠的事务隔离级别，事务被处理为顺序执行</td></tr></tbody></table></div><p>&emsp;&emsp;数据库事务隔离级别越 ，越能保证数据的完整性和一致性，但是对井发性能的影响也越大。大多数数据库（ 比如SQLServer和Oracle ）事务默认隔离级别 Read_Commited ，少数数据库（比如 MySQL InnoDB ）事务默认隔离级别为 Repeatable_Read</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Transactional(propagation = Propagation.REQUIRED,isolation = Isolation.REPEATABLE_READ)</span><br><span class="line">public class UserService &#123;...&#125;</span><br></pre></td></tr></table></figure><p><strong>(3) timeout : 超时时间</strong></p><ul><li>事务需要在一定时间内进行提交,如果不提交进行回滚</li><li>默认值为-1,设置时间以秒单位进行计算</li></ul><p><strong>(4) readOnly : 是否只读</strong></p><ul><li>读 : 查询操作 , 写 : 添加修改删除操作</li><li>readOnly 默认值 false，表示可以查询，可以添加修改删除操作</li><li>设置 readOnly 值是 true，设置成 true 之后，只能查询</li></ul><p><strong>(5) rollbackFor : 回滚</strong></p><ul><li>设置出现哪些异常进行事务回滚</li></ul><p><strong>(6) noRollbackFor : 不回滚</strong></p><ul><li>设置出现哪些异常不进行事务回滚</li></ul><h1 id="Spring事务的嵌套"><a href="#Spring事务的嵌套" class="headerlink" title="Spring事务的嵌套"></a>Spring事务的嵌套</h1><p>通过前面的理论知识的铺垫，我们大致知道了数据库事务和Spring 事务的一些属性和特点， 接下来通过分析一些嵌套事务场景来深入理解Spring事务传播机制。</p><p>假设外部事务 ServiceA的MethodA()调用内部事务 ServiceB的MethodB()。 </p><p><strong>1．PROPAGATION_REQUIRED（Spring默认事务属性）</strong></p><p>&emsp;&emsp;如果 ServiceB.MethodB()的事务属性定义为 PROPAGATION_REQUIRED，那么执行 ServiceA.MethodA()的时候Spring已经发起了事务，这时调用ServiceB.MethodB()，ServiceB.MethodB()看到自己已经运行在ServiceA.MethodA()的事务内部，就不再发起新的事务。</p><p>&emsp;&emsp;假如 ServiceB.MethodB()运行的时候发现自己没有在事务中，它就会为自己分配一个事务。这样，在ServiceA.MethodA()或者 ServiceB.MethodB()内的任何地方出现异常，事务都会被回滚。</p><p><strong>2.PROPAGATION_REQUIRES_NEW</strong></p><p>&emsp;&emsp;如果设计 ServiceA.MethodA()的事务属性为PROPAGATION＿REQUIRED，ServiceB.MethodB()的事务属性为 PROPAGATION＿REQUIRES＿NEW，那么当执行到 ServiceB.MethodB()的时候， ServiceA.MethodA()所在的事务就会挂起，ServiceB.MethodBO会发起一个新的事务，等待 ServiceB.MethodB()的事务完成以后，挂起的事务才会继续执行。</p><p>&emsp;&emsp;它与PROPAGATION＿REQUIRED的区别在于事务的回滚程度。因为ServiceB.MethodB()新发起一个事务，存在两个不同的事务。如果 ServiceB.MethodB()已经提交，那么 ServiceA.MethodA() 回滚失败时 ServiceB.MethodB()是不会回滚的。如果 ServiceB.MethodB()回滚失败，它抛出的异常被 ServiceA.Method()捕获，ServiceA.MethodA的事务仍然可能提交(主要看 ServiceB MethodB() 抛出的异常是不是ServiceA.MethodA。会回滚的异常)。</p><p><strong>3.PROPAGATION_SUPPORTS</strong></p><p>&emsp;&emsp;假设ServiceB.MethodBQ的事务属性为PROPAGATION_SUPPORTS ,那么当执行到 ServiceB.MethodB()时，如果发现ServiceA.MethodA()。已经开启了一个事务，则加入当前的事务。 如果发现ServiceA.MethodA()没有开启事务，则自己也不开启事务。对于这种事务属性，内部方法 的事务完全依赖于最外部的事务。</p><p><strong>4.PROPAGATION_NESTED</strong></p><p>&emsp;&emsp;这种情况比较复杂，ServiceB.MethodB()的事务属性被配置为PROPAGATION_NESTED,此时两者之间将如何协作呢？ ServiceB.MethodB()如果回滚，那么内部事务(即ServiceB.MethodB()) 将回滚到它执行前的SavePoint,而外部事务(即ServiceA.MethodA())可以有以下两种处理方式。<br>(1) 捕获异常，执行异常分支逻辑</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void MethodA() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">ServiceB.MethodB();</span><br><span class="line">&#125; catch (SomeException) &#123;</span><br><span class="line">// 执行其他事务,如 ServiceC.MethodC();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种方式也是嵌套事务最有价值的地方，它起到了分支执行的效果，如果ServiceB.MethodB() 失败，那么执行ServiceC.MethodC(),而ServiceB.MethodB。已经回滚到它执行之前的SavePoint, 所以不会产生脏数据(相当于此方法从未执行过)，这种特性可以用在某些特殊的业务中，而 PROPAGATION_REQUIRED 和 PROPAGATION_REQUIRES_NEW 都没有办法做到这一点。</p><p>(2) 外部事务回滚/提交</p><p>&emsp;&emsp;代码不做任何修改，如果内部事务(ServiceB.MethodB())回滚，首先ServiceB.MethodB()回滚到它执行之前的SavePoint (在任何情况下都会如此)，外部事务(即ServiceA.MethodA())将 根据具体的配置决定自己是提交还是回滚。</p><p>&emsp;&emsp;另外三种事务传播属性基本用不到，在此不做分析。</p><h1 id="自己出现的问题"><a href="#自己出现的问题" class="headerlink" title="自己出现的问题"></a>自己出现的问题</h1><p>报错信息：</p><p><code>MYSQL——CAUSED BY: JAVA.SQL.SQLEXCEPTION: UNKNOWN SYSTEM VARIABLE ‘TRANSACTION_ISOLATION‘</code></p><p>报错排查</p><ol><li>查询数据库版本号<br><code>select version()</code> 8.0.15</li><li>查看数据库隔离级别变量<br><code>show variables like &#39;t%_isolation&#39;</code> REPEATABLE-READ</li><li>查看jdbc驱动版本号<br><code>为mysql-connector-java 5.1.7</code></li></ol><p>原因是版本不匹配，提升了JDBC版本号OK</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;事务的基本概念&quot;&gt;&lt;a href=&quot;#事务的基本概念&quot; class=&quot;headerlink&quot; title=&quot;事务的基本概念&quot;&gt;&lt;/a&gt;事务的基本概念&lt;/h1&gt;&lt;p&gt;事务（ Transaction ）是访问并可能 数据库 数据项 程序执行单元（ unit ）。&lt;/p</summary>
      
    
    
    
    <category term="Spring相关" scheme="http://example.com/categories/Spring%E7%9B%B8%E5%85%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>动态代理</title>
    <link href="http://example.com/2022/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://example.com/2022/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</id>
    <published>2022-09-02T14:46:29.000Z</published>
    <updated>2022-09-02T15:25:11.635Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、提出问题"><a href="#一、提出问题" class="headerlink" title="一、提出问题"></a>一、提出问题</h1><p>情境：算数计算器</p><h3 id="1）功能要求"><a href="#1）功能要求" class="headerlink" title="1）功能要求"></a>1）功能要求</h3><p>① 执行加减乘除操作<br>② 日志：在程序执行期间追踪正在发生的活动<br>③ 验证：希望计算器只能处理正数的运算</p><p><img src="https://oscimg.oschina.net/oscnet/up-b20c44e70a49bfe22a05639dfaed512bf3e.png" alt></p><h3 id="2）常规实现"><a href="#2）常规实现" class="headerlink" title="2）常规实现"></a>2）常规实现</h3><p><img src="https://oscimg.oschina.net/oscnet/up-bf41d9ba991f72216b24505bf51efb78226.png" alt></p><h3 id="3）存在问题"><a href="#3）存在问题" class="headerlink" title="3）存在问题"></a>3）存在问题</h3><p>① 代码分散：同样的代码在多个模块反复书写了很多遍，就应该考虑进行提炼；<br>② 难以维护：如果日志内容要更改，需要把每个方法中的日志信息都重写一遍；<br>③ 代码混乱：日志功能对于加减乘除方法来说，并非核心业务需求，混在其中，导致原本的核心业务代码变得膨胀不堪；</p><hr><hr><h1 id="二、动态代理"><a href="#二、动态代理" class="headerlink" title="二、动态代理"></a>二、动态代理</h1><h3 id="2-1-动态代理的原理"><a href="#2-1-动态代理的原理" class="headerlink" title="2.1 动态代理的原理"></a>2.1 动态代理的原理</h3><p>代理设计模式的原理：<strong>使用一个代理将对象包装起来</strong>，然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理来完成。代理对象决定是否以及何时将方法的调用转到原始对象上。</p><p>【<em><strong>可以结合“微商”的例子来理解</strong></em>，我们买东西的时候，真正发货的并不是微商，而是最顶层的“厂商”；而“微商”作为代理商，可以在“卖东西”（核心业务）的同时，搞一些自己的宣传、营销手段、做一些自己的优惠活动等等。但是无论如何，一定要确保最终发货给客户的都是“厂商”，代理只是做了一个推广作用。<em><strong>这里”厂商”就相当于目标对象，“微商”就相当于代理对象，代理对象并不能取代目标对象的核心业务，但是没有代理对象的话，用户也找不到目标对象</strong></em>】</p><p><img src="https://oscimg.oschina.net/oscnet/up-be6403b38b6fc31823e9716273ab99ac700.png" alt></p><p>以上图为例：本身我们是一个计算器，负责计算加减乘除的功能；但是如果想记录日志，计算器是不擅长的、干不了的，那我们就可以去找一个代理，通过日志代理，对我原本的对象来做一个代理，那么他就可以在我原本的加减乘除功能的基础之上，帮我完成记录日志这个功能（但是最终我们还是要完成加减乘除的，还是得找到目标对象来完成这些功能）；同理，如果我们还有验证的需求，就可以再加一个验证代理</p><p><em><strong>【注意：代理只能是在我原本功能的基础上做增强、可以扩展一些功能，但是我原本的功能，代理是不可能取代的，这是原则】</strong></em></p><h3 id="2-2-动态代理的实现方式"><a href="#2-2-动态代理的实现方式" class="headerlink" title="2.2 动态代理的实现方式"></a>2.2 动态代理的实现方式</h3><hr><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 基于接口的动态代理：JDK动态代理</span><br><span class="line">2. 基于继承的动态代理：Cglib、Javassist动态代理</span><br><span class="line">（之所以会有两种方式的代理实现方式，我们后面会说）</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><hr><h1 id="三、基于动态代理来实现日志代理"><a href="#三、基于动态代理来实现日志代理" class="headerlink" title="三、基于动态代理来实现日志代理"></a>三、基于动态代理来实现日志代理</h1><h2 id="3-1-日志处理器"><a href="#3-1-日志处理器" class="headerlink" title="3.1 日志处理器"></a>3.1 日志处理器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">此处采用JDK动态代理（即基于接口的代理，这也是最常用的动态代理方式）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://oscimg.oschina.net/oscnet/up-fe1117e619a4b6d35a392bbc04fe44b0f03.png" alt></p><ol><li><strong>JDK的动态代理中需要关注的接口和类</strong>：</li></ol><ul><li><p><strong>① Proxy类</strong><code>(java.lang.reflect.Proxy)</code>：是所有动态代理类的父类，专门用来生成代理类或者代理对象；</p><ul><li><p><code>public static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interface)</code>：用于生成代理类的Class对象（从而获取构造器对象，进而创建代理类对象）</p></li><li><p><code>public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;... interfaces, InvocationHandler h)</code>：用于生成代理对象（直接就给返回一个代理对象了，不必再用代理类的Class对象来调用构造器对象进行手动生成了）</p></li></ul></li><li><p><strong>② InvocationHandler接口</strong><code>(java.lang.reflect.InvocationHandler)</code>：用于完成动态代理的整个过程（即：动态代理要做什么）（这是一个接口，我们要做的就是自己写一个类，来实现这个接口）</p><ul><li><code>public Object invoke(Object proxy, Method method, Object[] args) throws Throwable</code>：<em><strong>这个方法才是整个动态代理的核心，动态代理要做什么，都编写在这个方法里</strong></em>（注意，这不是反射里的那个invoke()方法，只是同名而已）</li></ul></li></ul><hr><ol><li><strong>动态代理要关心的三个问题</strong></li></ol><ul><li><p><strong>① 目标对象是谁</strong>：此处就是ArithmeticCalculator</p></li><li><p><strong>② 如何获取代理对象</strong>：提供一个<code>getProxy()</code>方法，其中通过<code>Proxy.newProxyInstance()</code>方法来构造一个代理对象、并返回<br><code>public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code>的三个参数：</p><ul><li><p><strong><code>ClassLoader loader</code></strong>：是一个类加载器，因为动态代理意味着要“动态生成一个类是一个类”，既然是一个类，就要进行类加载，就要传进去一个类加载器对象、帮我们加载动态生成的代理类（那这个loader我们用谁比较好呢，我就用目标对象的类加载器<code>target.getClass().getClassLoader()</code>即可，因为类加载器不仅仅能加载一个类、不同的类他都是可以加载的）；</p></li><li><p><strong><code>Class&lt;?&gt;[] interfaces</code></strong>：要求我们提供目标对象实现的所有接口 <code>target.getClass().getInterfaces()</code>，目的是“看一下你目标对象里的方法都是从哪些接口实现出来的”，<em><strong>让代理对象与目标对象都有接口中相同的方法</strong></em>，（这就是“JDK基于接口的动态代理”），【因为代理类是要制造一种假象的，比如微商给我们的感觉就是“我们从微商手里买到的东西”，但实际上是从厂商那里买的。所以我们必须要让代理对象也有目标对象的功能，但这个功能是个假的，只是让我们“感觉上”有这些功能，那我们就来思考：代理对象也想有这些方法的话怎么办呢，他就只要去看一下你目标对象实现了哪些接口，我也去实现这些接口，这样我们就有了相同的方法了（当然，这只是一个假象，最终你的加减乘除还是找执行到目标对象的，否则原理上就错误了）】；</p></li><li><p><strong><code>InvocationHandler h</code></strong>：是InvocationHandler类型的对象，我们<strong>通常使用匿名内部类的方式</strong>，创建一个InvocationHandler接口类型的对象，<strong>实现其invoke()方法</strong>，真正的动态代理就是从这里开始的【<em><strong>代理对象调用代理方法的时候，会回来调用<code>invoke()</code>方法</strong></em>】</p></li></ul></li></ul><blockquote><p>到目前为止，我们完全可以获取一个代理对象了，但是这个代理对象要替我们做什么事呢？那么接下来就要在invoke()方法中编写代码，来完成代理对象的功能。</p></blockquote><ul><li><p><strong>③ 代理对象要做什么</strong>：此处就是记录日志的功能，代理要做的事，都写在invoke()方法中（我们希望计算器，也就是目标对象只能处理加减乘除，而其他操作都由代理来替我们完成）<br><code>public Object invoke(Object proxy, Method method, Object[] args) throws Throwable</code>的三个参数：</p><ul><li><p><strong><code>Object proxy</code></strong>：就是之前获取的代理对象，我们通常在<code>invoke()</code>方法中很少使用，而且要慎用【所以可以发现这里比较绕：在创建代理对象proxy的时候、要传入一个InvocationHandler对象并实现invoke()方法，然而后续代理对象proxy调用代理方法的时候、又会回来调用invoke()方法、并且要传入一个代理对象proxy；不过实际上这种实现在java里很常见，暂时不深究】；</p></li><li><p><strong><code>Method method</code></strong>：就是“正在被调用的”方法对象，<strong>即代理对象中“虚假的”加减乘除方法</strong>；</p></li><li><p><strong><code>Object[] args</code></strong>：就是“正在被调用的”方法的参数列表；</p></li></ul></li></ul><blockquote><p>【切记，<em><strong>代理是“在原本对象的基础上”做增强操作的</strong></em>，因此：<strong>①首先就要先把目标对象的功能完成</strong>，（有了方法对象method，有了参数列表args，那么使用<code>Object result = method.invoke(target, args)</code>，“通过目标对象调用目标方法”即可，返回值是Object类型）；<strong>②然后在此基础上，就可以在调用前后进行增强操作</strong>】</p></blockquote><hr><h2 id="3-2-测试"><a href="#3-2-测试" class="headerlink" title="3.2 测试"></a>3.2 测试</h2><p>【最终使用的时候，就可以参照如下代码：<br>① 先创建目标对象<br>② 然后获取代理对象、并绑定上目标对象（此时是一个Object类型，要强转回目标对象类型，此处即ArithmeticCalculator接口类型）<br>③ 最后通过代理对象来调用加减乘除方法，就能实现“日志+原本业务”功能】</p><p><img src="https://oscimg.oschina.net/oscnet/up-ae5c4b001bb85b1a8e9488fe064853033d9.png" alt></p><hr><hr><h2 id="四、动态代理的底层原理分析★"><a href="#四、动态代理的底层原理分析★" class="headerlink" title="四、动态代理的底层原理分析★"></a>四、动态代理的底层原理分析★</h2><p>要想研究“JDK基于接口的动态代理”的底层原理，我们需要能观察到代理类的底层源码<br>但是动态代理类是在运行过程中动态生成的，是在内存中的，并不会保存到硬盘里，这样我们想要看到代理类就很麻烦（因此使用如下代码，可以将动态代理类保存到本地，不过得到的是一个class文件，我们再通过反编译工具将其转化为java代码）\</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//在测试方法中加入如下两行代码，即可将动态代理类保存到本地</span><br><span class="line">Properties properties = System.getProperties();</span><br><span class="line">properties.put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>动态代理类如下： <img src="https://oscimg.oschina.net/oscnet/up-36fd3534ef71f7e5c2fe9bc68a0e4863df0.png" alt></p><p>有了动态代理类后，我们带着两个问题来研究：<br>① 代理对象能否转换成目标对象的类型？（不能，兄弟关系当然不能互相转，只能都向上转型成接口类型）<br>② 代理对象调用代理方法，为什么会执行InvocationHandler中的invoke()方法？（去看$proxy00类，就是因为在通过代理对象调用方法的时候，调用了）</p><hr><h2 id="tips："><a href="#tips：" class="headerlink" title="tips："></a>tips：</h2><ol><li><p>【目前的动态代理，目标对象使用的是ArithmeticCalculator类型，这样只能为这个类进行代理，不够动态。<strong>真正的动态代理，不指定具体类型，而是使用Object，这样这个代理类可以为任何对象进行代理</strong>】 <img src="https://oscimg.oschina.net/oscnet/up-7b2d3e88bab82f6a167d7d10875bca5ab3a.png" alt></p></li><li><p>【<strong>之前提到动态代理分为两种方式</strong>：基于接口的代理方式 和 基于继承的代理方式。<strong>为什么会有两种方式的区分</strong>？我们来考虑这样一个问题：如果我的目标类，在接口规定的方法之外，又有一些自己的方法，那么此时基于接口的代理方式，是无法为这些方法进行代理的（因为基于接口的代理方式，只能看到接口中有的方法，跟目标类本身是毫无关系的）；这种时候，如果我们想为目标类自己的方法提供代理的话，就需要使用基于继承的代理方式，这种方式是把代理类当做目标类的子类，这样目标类中有的方法（确切的说是能被继承的方法，final的也不行），代理类都能为其提供代理】</p></li></ol><p>本文转自 <a href="https://my.oschina.net/u/4152309/blog/3178065">https://my.oschina.net/u/4152309/blog/3178065</a>，如有侵权，请联系删除。</p>]]></content>
    
    
    <summary type="html">这里以一个实际的例子（算数计算器）为依托，集中讨论使用代理模式的原因、如何使用代理模式、以及部分底层原理</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>第18章_MySQL8其它新特性</title>
    <link href="http://example.com/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC18%E7%AB%A0_MySQL8%E5%85%B6%E5%AE%83%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://example.com/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC18%E7%AB%A0_MySQL8%E5%85%B6%E5%AE%83%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2022-05-17T12:37:18.000Z</published>
    <updated>2022-05-17T13:02:21.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第18章-MySQL8其它新特性"><a href="#第18章-MySQL8其它新特性" class="headerlink" title="第18章_MySQL8其它新特性"></a>第18章_MySQL8其它新特性</h1><p>讲师：尚硅谷-宋红康（江湖人称：康师傅）</p><p>官网：<a href="http://www.atguigu.com/">http://www.atguigu.com</a></p><hr><h2 id="MySQL8新特性概述"><a href="#MySQL8新特性概述" class="headerlink" title="MySQL8新特性概述"></a>MySQL8新特性概述</h2><p><code>MySQL从5.7版本直接跳跃发布了8.0版本</code>，可见这是一个令人兴奋的里程碑版本。MySQL 8版本在功能上做了显著的改进与增强，开发者对MySQL的源代码进行了重构，最突出的一点是多MySQL Optimizer优化器进行了改进。不仅在速度上得到了改善，还为用户带来了更好的性能和更棒的体验。</p><h3 id="MySQL8-0-新增特性"><a href="#MySQL8-0-新增特性" class="headerlink" title="MySQL8.0 新增特性"></a>MySQL8.0 新增特性</h3><p><strong>1. 更简便的NoSQL支持</strong><br>NoSQL泛指非关系型数据库和数据存储。随着互联网平台的规模飞速发展，传统的关系型数据库已经越来越不能满足需求。从5.6版本开始，MySQL就开始支持简单的NoSQL存储功能。MySQL 8对这一功能做了优化，以更灵活的方式实现NoSQL功能，不再依赖模式（schema）。</p><p><strong>2. 更好的索引</strong><br>在查询中，正确地使用索引可以提高查询的效率。MySQL 8中新增了<code>隐藏索引</code>和<code>降序索引</code>。隐藏索引可以用来测试去掉索引对查询性能的影响。在查询中混合存在多列索引时，使用降序索引可以提高查询的性能。</p><p><strong>3.更完善的JSON支持</strong><br>MySQL从5.7开始支持原生JSON数据的存储，MySQL 8对这一功能做了优化，增加了聚合函数<code>JSON_ARRAYAGG()</code>和<code>JSON_OBJECTAGG()</code>，将参数聚合为JSON数组或对象，新增了行内操作符 -&gt;&gt;，是列路径运算符 -&gt;的增强，对JSON排序做了提升，并优化了JSON的更新操作。</p><p><strong>4.安全和账户管理</strong><br>MySQL 8中新增了<code>caching_sha2_password</code> 授权插件、角色、密码历史记录和FIPS模式支持，这些特性提高了数据库的安全性和性能，使数据库管理员能够更灵活地进行账户管理工作。</p><p><strong>5.InnoDB的变化</strong><br><code>InnoDB是MySQL默认的存储引擎</code>，是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。在MySQL 8 版本中，InnoDB在自增、索引、加密、死锁、共享锁等方面做了大量的<code>改进和优化</code>，并且支持原子数据定义语言（DDL），提高了数据安全性，对事务提供更好的支持。</p><p><strong>6.数据字典</strong><br>在之前的MySQL版本中，字典数据都存储在元数据文件和非事务表中。从MySQL 8开始新增了事务数据字典，在这个字典里存储着数据库对象信息，这些数据字典存储在内部事务表中。</p><p><strong>7. 原子数据定义语句</strong><br>MySQL 8开始支持原子数据定义语句（Automic DDL），即<code>原子DDL</code>。目前，只有InnoDB存储引擎支持原子DDL。原子数据定义语句（DDL）将与DDL操作相关的数据字典更新、存储引擎操作、二进制日志写入结合到一个单独的原子事务中，这使得即使服务器崩溃，事务也会提交或回滚。<br>使用支持原子操作的存储引擎所创建的表，在执行DROP TABLE、CREATE TABLE、ALTER TABLE、 RENAME TABLE、TRUNCATE TABLE、CREATE TABLESPACE、DROP TABLESPACE等操作时，都支持原子操作，即事务要么完全操作成功，要么失败后回滚，不再进行部分提交。<br>对于从MySQL 5.7复制到MySQL 8 版本中的语句，可以添加<code>IF EXISTS</code>或<code>IF NOT EXISTS</code>语句来避免发生错误。</p><p><strong>8.资源管理</strong><br>MySQL 8开始支持创建和管理资源组，允许将服务器内运行的线程分配给特定的分组，以便线程根据组内可用资源执行。组属性能够控制组内资源，启用或限制组内资源消耗。数据库管理员能够根据不同的工作负载适当地更改这些属性。<br>目前，CPU时间是可控资源，由“虚拟CPU”这个概念来表示，此术语包含CPU的核心数，超线程，硬件线程等等。服务器在启动时确定可用的虚拟CPU数量。拥有对应权限的数据库管理员可以将这些CPU与资源组关联，并为资源组分配线程。<br>资源组组件为MySQL中的资源组管理提供了SQL接口。资源组的属性用于定义资源组。MySQL中存在两个默认组，系统组和用户组，默认的组不能被删除，其属性也不能被更改。对于用户自定义的组，资源组创建时可初始化所有的属性，除去名字和类型，其他属性都可在创建之后进行更改。<br>在一些平台下，或进行了某些MySQL的配置时，资源管理的功能将受到限制，甚至不可用。例如，如果安装了线程池插件，或者使用的是macOS系统，资源管理将处于不可用状态。在FreeBSD和Solaris系统中，资源线程优先级将失效。在Linux系统中，只有配置了CAP_SYS_NICE属性，资源管理优先级才能发挥作用。</p><p><strong>9.字符集支持</strong><br>MySQL 8中默认的字符集由<code>latin1</code>更改为<code>utf8mb4</code>，并首次增加了日语所特定使用的集合，utf8mb4_ja_0900_as_cs。</p><p><strong>10.优化器增强</strong><br>MySQL优化器开始支持隐藏索引和降序索引。隐藏索引不会被优化器使用，验证索引的必要性时不需要删除索引，先将索引隐藏，如果优化器性能无影响就可以真正地删除索引。降序索引允许优化器对多个列进行排序，并且允许排序顺序不一致。</p><p><strong>11.公用表表达式</strong><br>公用表表达式（Common Table Expressions）简称为CTE，MySQL现在支持递归和非递归两种形式的CTE。CTE通过在SELECT语句或其他特定语句前<code>使用WITH语句对临时结果集</code>进行命名。</p><p>基础语法如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WITH cte_name (col_name1,col_name2 ...) AS (Subquery)</span><br><span class="line">SELECT * FROM cte_name;</span><br></pre></td></tr></table></figure><p>Subquery代表子查询，子查询前使用WITH语句将结果集命名为cte_name，在后续的查询中即可使用cte_name进行查询。</p><p><strong>12.窗口函数</strong><br>MySQL 8开始支持窗口函数。在之前的版本中已存在的大部分<code>聚合函数</code>在MySQL 8中也可以作为窗口函数来使用。</p><p><img src="/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC18%E7%AB%A0_MySQL8%E5%85%B6%E5%AE%83%E6%96%B0%E7%89%B9%E6%80%A7/image-20210730165317542.png" alt="image-20210730165317542"></p><p><strong>13.正则表达式支持</strong><br>MySQL在8.0.4以后的版本中采用支持Unicode的国际化组件库实现正则表达式操作，这种方式不仅能提供完全的Unicode支持，而且是多字节安全编码。MySQL增加了REGEXP_LIKE()、EGEXP_INSTR()、REGEXP_REPLACE()和 REGEXP_SUBSTR()等函数来提升性能。另外，regexp_stack_limit和regexp_time_limit 系统变量能够通过匹配引擎来控制资源消耗。</p><p><strong>14.内部临时表</strong><br><code>TempTable存储引擎取代MEMORY存储引擎成为内部临时表的默认存储引擎</code>。TempTable存储引擎为VARCHAR和VARBINARY列提供高效存储。internal_tmp_mem_storage_engine会话变量定义了内部临时表的存储引擎，可选的值有两个，TempTable和MEMORY，其中TempTable为默认的存储引擎。temptable_max_ram系统配置项定义了TempTable存储引擎可使用的最大内存数量。</p><p><strong>15.日志记录</strong><br>在MySQL 8中错误日志子系统由一系列MySQL组件构成。这些组件的构成由系统变量log_error_services来配置，能够实现日志事件的过滤和写入。</p><p><strong>16.备份锁</strong><br>新的备份锁允许在线备份期间执行数据操作语句，同时阻止可能造成快照不一致的操作。新备份锁由 LOCK INSTANCE FOR BACKUP 和 UNLOCK INSTANCE 语法提供支持，执行这些操作需要备份管理员特权。</p><p><strong>17.增强的MySQL复制</strong><br>MySQL 8复制支持对<code>JSON文档</code>进行部分更新的<code>二进制日志记录</code>，该记录<code>使用紧凑的二进制格式</code>，从而节省记录完整JSON文档的空间。当使用基于语句的日志记录时，这种紧凑的日志记录会自动完成，并且可以通过将新的binlog_row_value_options系统变量值设置为PARTIAL_JSON来启用。</p><h3 id="MySQL8-0移除的旧特性"><a href="#MySQL8-0移除的旧特性" class="headerlink" title="MySQL8.0移除的旧特性"></a>MySQL8.0移除的旧特性</h3><p>在MySQL 5.7版本上开发的应用程序如果使用了MySQL8.0 移除的特性，语句可能会失败，或者产生不同的执行结果。为了避免这些问题，对于使用了移除特性的应用，应当尽力修正避免使用这些特性，并尽可能使用替代方法。</p><p><strong>1. 查询缓存</strong><br><code>查询缓存已被移除</code>，删除的项有：<br><strong>（1）语句：</strong>FLUSH QUERY CACHE和RESET QUERY CACHE。<br><strong>（2）系统变量：</strong>query_cache_limit、query_cache_min_res_unit、query_cache_size、query_cache_type、query_cache_wlock_invalidate。<br><strong>（3）状态变量：</strong>Qcache_free_blocks、Qcache_free_memory、Qcache_hits、Qcache_inserts、Qcache_lowmem_prunes、Qcache_not_cached、Qcache_queries_in_cache、Qcache_total_blocks。<br><strong>（4）线程状态：</strong>checking privileges on cached query、checking query cache for query、invalidating query cache entries、sending cached result to client、storing result in query cache、waiting for query cache lock。</p><p><strong>2.加密相关</strong><br>删除的加密相关的内容有：ENCODE()、DECODE()、ENCRYPT()、DES_ENCRYPT()和DES_DECRYPT()函数，配置项des-key-file，系统变量have_crypt，FLUSH语句的DES_KEY_FILE选项，HAVE_CRYPT CMake选项。<br>对于移除的ENCRYPT()函数，考虑使用SHA2()替代，对于其他移除的函数，使用AES_ENCRYPT()和AES_DECRYPT()替代。</p><p><strong>3.空间函数相关</strong><br>在MySQL 5.7版本中，多个空间函数已被标记为过时。这些过时函数在MySQL 8中都已被移除，只保留了对应的ST_和MBR函数。</p><p><strong>4.\N和NULL</strong><br>在SQL语句中，解析器不再将\N视为NULL，所以在SQL语句中应使用NULL代替\N。这项变化不会影响使用LOAD DATA INFILE或者SELECT…INTO OUTFILE操作文件的导入和导出。在这类操作中，NULL仍等同于\N。</p><p><strong>5. mysql_install_db</strong><br>在MySQL分布中，已移除了mysql_install_db程序，数据字典初始化需要调用带着—initialize或者—initialize-insecure选项的mysqld来代替实现。另外，—bootstrap和INSTALL_SCRIPTDIR CMake也已被删除。</p><p><strong>6.通用分区处理程序</strong><br>通用分区处理程序已从MySQL服务中被移除。为了实现给定表分区，表所使用的存储引擎需要自有的分区处理程序。<br>提供本地分区支持的MySQL存储引擎有两个，即InnoDB和NDB，而在MySQL 8中只支持InnoDB。</p><p><strong>7.系统和状态变量信息</strong><br>在INFORMATION_SCHEMA数据库中，对系统和状态变量信息不再进行维护。GLOBAL_VARIABLES、SESSION_VARIABLES、GLOBAL_STATUS、SESSION_STATUS表都已被删除。另外，系统变量show_compatibility_56也已被删除。被删除的状态变量有Slave_heartbeat_period、Slave_last_heartbeat,Slave_received_heartbeats、Slave_retried_transactions、Slave_running。以上被删除的内容都可使用性能模式中对应的内容进行替代。</p><p><strong>8.mysql_plugin工具</strong><br>mysql_plugin工具用来配置MySQL服务器插件，现已被删除，可使用—plugin-load或—plugin-load-add选项在服务器启动时加载插件或者在运行时使用INSTALL PLUGIN语句加载插件来替代该工具。</p><h2 id="新特性1：窗口函数"><a href="#新特性1：窗口函数" class="headerlink" title="新特性1：窗口函数"></a>新特性1：窗口函数</h2><h3 id="使用窗口函数前后对比"><a href="#使用窗口函数前后对比" class="headerlink" title="使用窗口函数前后对比"></a>使用窗口函数前后对比</h3><p>假设我现在有这样一个数据表，它显示了某购物网站在每个城市每个区的销售额：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE sales(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">city VARCHAR(15),</span><br><span class="line">county VARCHAR(15),</span><br><span class="line">sales_value DECIMAL</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO sales(city,county,sales_value)</span><br><span class="line">VALUES</span><br><span class="line">(&#x27;北京&#x27;,&#x27;海淀&#x27;,10.00),</span><br><span class="line">(&#x27;北京&#x27;,&#x27;朝阳&#x27;,20.00),</span><br><span class="line">(&#x27;上海&#x27;,&#x27;黄埔&#x27;,30.00),</span><br><span class="line">(&#x27;上海&#x27;,&#x27;长宁&#x27;,10.00);</span><br></pre></td></tr></table></figure><p>查询：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM sales;</span><br><span class="line">+----+------+--------+-------------+</span><br><span class="line">| id | city | county | sales_value |</span><br><span class="line">+----+------+--------+-------------+</span><br><span class="line">|  1 | 北京 | 海淀    |          10 |</span><br><span class="line">|  2 | 北京 | 朝阳    |          20 |</span><br><span class="line">|  3 | 上海 | 黄埔    |          30 |</span><br><span class="line">|  4 | 上海 | 长宁    |          10 |</span><br><span class="line">+----+------+--------+-------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>需求：</strong>现在计算这个网站在每个城市的销售总额、在全国的销售总额、每个区的销售额占所在城市销售额中的比率，以及占总销售额中的比率。</p><p>如果用分组和聚合函数，就需要分好几步来计算。</p><p>第一步，计算总销售金额，并存入临时表 a：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TEMPORARY TABLE a       -- 创建临时表</span><br><span class="line">SELECT SUM(sales_value) AS sales_value -- 计算总计金额</span><br><span class="line">FROM sales;</span><br></pre></td></tr></table></figure><p>查看一下临时表 a ：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM a;</span><br><span class="line">+-------------+</span><br><span class="line">| sales_value |</span><br><span class="line">+-------------+</span><br><span class="line">|          70 |</span><br><span class="line">+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>第二步，计算每个城市的销售总额并存入临时表 b：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TEMPORARY TABLE b    -- 创建临时表</span><br><span class="line">SELECT city,SUM(sales_value) AS sales_value  -- 计算城市销售合计</span><br><span class="line">FROM sales</span><br><span class="line">GROUP BY city;</span><br></pre></td></tr></table></figure><p>查看临时表 b ：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM b;</span><br><span class="line">+------+-------------+</span><br><span class="line">| city | sales_value |</span><br><span class="line">+------+-------------+</span><br><span class="line">| 北京 |          30 |</span><br><span class="line">| 上海 |          40 |</span><br><span class="line">+------+-------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>第三步，计算各区的销售占所在城市的总计金额的比例，和占全部销售总计金额的比例。我们可以通过下面的连接查询获得需要的结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT s.city AS 城市,s.county AS 区,s.sales_value AS 区销售额,</span><br><span class="line">    -&gt; b.sales_value AS 市销售额,s.sales_value/b.sales_value AS 市比率,</span><br><span class="line">    -&gt; a.sales_value AS 总销售额,s.sales_value/a.sales_value AS 总比率</span><br><span class="line">    -&gt; FROM sales s</span><br><span class="line">    -&gt; JOIN b ON (s.city=b.city) -- 连接市统计结果临时表</span><br><span class="line">    -&gt; JOIN a                   -- 连接总计金额临时表</span><br><span class="line">    -&gt; ORDER BY s.city,s.county;</span><br><span class="line">+------+------+----------+----------+--------+----------+--------+</span><br><span class="line">| 城市  | 区   | 区销售额  | 市销售额   | 市比率  | 总销售额  | 总比率  |</span><br><span class="line">+------+------+----------+----------+--------+----------+--------+</span><br><span class="line">| 上海  | 长宁 |       10 |       40 | 0.2500 |       70 | 0.1429 |</span><br><span class="line">| 上海  | 黄埔 |       30 |       40 | 0.7500 |       70 | 0.4286 |</span><br><span class="line">| 北京  | 朝阳 |       20 |       30 | 0.6667 |       70 | 0.2857 |</span><br><span class="line">| 北京  | 海淀 |       10 |       30 | 0.3333 |       70 | 0.1429 |</span><br><span class="line">+------+------+----------+----------+--------+----------+--------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>结果显示：市销售金额、市销售占比、总销售金额、总销售占比都计算出来了。</p><p>同样的查询，如果用窗口函数，就简单多了。我们可以用下面的代码来实现：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT city AS 城市,county AS 区,sales_value AS 区销售额,</span><br><span class="line">    -&gt; SUM(sales_value) OVER(PARTITION BY city) AS 市销售额,  -- 计算市销售额</span><br><span class="line">    -&gt; sales_value/SUM(sales_value) OVER(PARTITION BY city) AS 市比率,</span><br><span class="line">    -&gt; SUM(sales_value) OVER() AS 总销售额,   -- 计算总销售额</span><br><span class="line">    -&gt; sales_value/SUM(sales_value) OVER() AS 总比率</span><br><span class="line">    -&gt; FROM sales</span><br><span class="line">    -&gt; ORDER BY city,county;</span><br><span class="line">+------+------+----------+----------+--------+----------+--------+</span><br><span class="line">| 城市  | 区   | 区销售额  | 市销售额   | 市比率  | 总销售额  | 总比率  |</span><br><span class="line">+------+------+----------+----------+--------+----------+--------+</span><br><span class="line">| 上海  | 长宁 |       10 |       40  | 0.2500 |       70 | 0.1429 |</span><br><span class="line">| 上海  | 黄埔 |       30 |       40  | 0.7500 |       70 | 0.4286 |</span><br><span class="line">| 北京  | 朝阳 |       20 |       30  | 0.6667 |       70 | 0.2857 |</span><br><span class="line">| 北京  | 海淀 |       10 |       30  | 0.3333 |       70 | 0.1429 |</span><br><span class="line">+------+------+----------+-----------+--------+----------+--------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>结果显示，我们得到了与上面那种查询同样的结果。</p><p>使用窗口函数，只用了一步就完成了查询。而且，由于没有用到临时表，执行的效率也更高了。很显然，<strong>在这种需要用到分组统计的结果对每一条记录进行计算的场景下，使用窗口函数更好</strong>。</p><h3 id="窗口函数分类"><a href="#窗口函数分类" class="headerlink" title="窗口函数分类"></a>窗口函数分类</h3><p>MySQL从8.0版本开始支持窗口函数。窗口函数的作用类似于在查询中对数据进行分组，不同的是，分组操作会把分组的结果聚合成一条记录，而窗口函数是将结果置于每一条数据记录中。</p><p>窗口函数可以分为<code>静态窗口函数</code>和<code>动态窗口函数</code>。</p><ul><li>静态窗口函数的窗口大小是固定的，不会因为记录的不同而不同；</li><li>动态窗口函数的窗口大小会随着记录的不同而变化。</li></ul><p>MySQL官方网站窗口函数的网址为<a href="https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_row-number。">https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_row-number。</a></p><p>窗口函数总体上可以分为序号函数、分布函数、前后函数、首尾函数和其他函数，如下表：</p><p><img src="/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC18%E7%AB%A0_MySQL8%E5%85%B6%E5%AE%83%E6%96%B0%E7%89%B9%E6%80%A7/image-20211012162944536.png" alt="image-20211012162944536"></p><h3 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h3><p>窗口函数的语法结构是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数 OVER（[PARTITION BY 字段名 ORDER BY 字段名 ASC|DESC]）</span><br></pre></td></tr></table></figure><p>或者是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数 OVER 窗口名 … WINDOW 窗口名 AS （[PARTITION BY 字段名 ORDER BY 字段名 ASC|DESC]）</span><br></pre></td></tr></table></figure><ul><li>OVER 关键字指定函数窗口的范围。<ul><li>如果省略后面括号中的内容，则窗口会包含满足WHERE条件的所有记录，窗口函数会基于所有满足WHERE条件的记录进行计算。</li><li>如果OVER关键字后面的括号不为空，则可以使用如下语法设置窗口。</li></ul></li><li>窗口名：为窗口设置一个别名，用来标识窗口。</li><li>PARTITION BY子句：指定窗口函数按照哪些字段进行分组。分组后，窗口函数可以在每个分组中分别执行。</li><li>ORDER BY子句：指定窗口函数按照哪些字段进行排序。执行排序操作使窗口函数按照排序后的数据记录的顺序进行编号。</li><li>FRAME子句：为分区中的某个子集定义规则，可以用来作为滑动窗口使用。</li></ul><h3 id="分类讲解"><a href="#分类讲解" class="headerlink" title="分类讲解"></a>分类讲解</h3><p>创建表：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE goods(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">category_id INT,</span><br><span class="line">category VARCHAR(15),</span><br><span class="line">NAME VARCHAR(30),</span><br><span class="line">price DECIMAL(10,2),</span><br><span class="line">stock INT,</span><br><span class="line">upper_time DATETIME</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>添加数据：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO goods(category_id,category,NAME,price,stock,upper_time)</span><br><span class="line">VALUES</span><br><span class="line">(1, &#x27;女装/女士精品&#x27;, &#x27;T恤&#x27;, 39.90, 1000, &#x27;2020-11-10 00:00:00&#x27;),</span><br><span class="line">(1, &#x27;女装/女士精品&#x27;, &#x27;连衣裙&#x27;, 79.90, 2500, &#x27;2020-11-10 00:00:00&#x27;),</span><br><span class="line">(1, &#x27;女装/女士精品&#x27;, &#x27;卫衣&#x27;, 89.90, 1500, &#x27;2020-11-10 00:00:00&#x27;),</span><br><span class="line">(1, &#x27;女装/女士精品&#x27;, &#x27;牛仔裤&#x27;, 89.90, 3500, &#x27;2020-11-10 00:00:00&#x27;),</span><br><span class="line">(1, &#x27;女装/女士精品&#x27;, &#x27;百褶裙&#x27;, 29.90, 500, &#x27;2020-11-10 00:00:00&#x27;),</span><br><span class="line">(1, &#x27;女装/女士精品&#x27;, &#x27;呢绒外套&#x27;, 399.90, 1200, &#x27;2020-11-10 00:00:00&#x27;),</span><br><span class="line">(2, &#x27;户外运动&#x27;, &#x27;自行车&#x27;, 399.90, 1000, &#x27;2020-11-10 00:00:00&#x27;),</span><br><span class="line">(2, &#x27;户外运动&#x27;, &#x27;山地自行车&#x27;, 1399.90, 2500, &#x27;2020-11-10 00:00:00&#x27;),</span><br><span class="line">(2, &#x27;户外运动&#x27;, &#x27;登山杖&#x27;, 59.90, 1500, &#x27;2020-11-10 00:00:00&#x27;),</span><br><span class="line">(2, &#x27;户外运动&#x27;, &#x27;骑行装备&#x27;, 399.90, 3500, &#x27;2020-11-10 00:00:00&#x27;),</span><br><span class="line">(2, &#x27;户外运动&#x27;, &#x27;运动外套&#x27;, 799.90, 500, &#x27;2020-11-10 00:00:00&#x27;),</span><br><span class="line">(2, &#x27;户外运动&#x27;, &#x27;滑板&#x27;, 499.90, 1200, &#x27;2020-11-10 00:00:00&#x27;);</span><br></pre></td></tr></table></figure><p>下面针对goods表中的数据来验证每个窗口函数的功能。</p><h4 id="序号函数"><a href="#序号函数" class="headerlink" title="序号函数"></a>序号函数</h4><p><strong>1．ROW_NUMBER()函数</strong></p><p>ROW_NUMBER()函数能够对数据中的序号进行顺序显示。</p><p>举例：查询 goods 数据表中每个商品分类下价格降序排列的各个商品信息。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT ROW_NUMBER() OVER(PARTITION BY category_id ORDER BY price DESC) AS row_num,</span><br><span class="line">    -&gt; id, category_id, category, NAME, price, stock</span><br><span class="line">    -&gt; FROM goods;</span><br><span class="line">+---------+----+-------------+---------------+------------+---------+-------+</span><br><span class="line">| row_num | id | category_id | category      | NAME       | price   | stock |</span><br><span class="line">+---------+----+-------------+---------------+------------+---------+-------+</span><br><span class="line">|       1 |  6 |           1 | 女装/女士精品   | 呢绒外套    |  399.90 |  1200 |</span><br><span class="line">|       2 |  3 |           1 | 女装/女士精品   | 卫衣        |   89.90 |  1500 |</span><br><span class="line">|       3 |  4 |           1 | 女装/女士精品   | 牛仔裤      |   89.90 |  3500 |</span><br><span class="line">|       4 |  2 |           1 | 女装/女士精品   | 连衣裙      |   79.90 |  2500 |</span><br><span class="line">|       5 |  1 |           1 | 女装/女士精品   | T恤        |   39.90 |  1000 |</span><br><span class="line">|       6 |  5 |           1 | 女装/女士精品   | 百褶裙      |   29.90 |   500 |</span><br><span class="line">|       1 |  8 |           2 | 户外运动       | 山地自行车   | 1399.90 |  2500 |</span><br><span class="line">|       2 | 11 |           2 | 户外运动       | 运动外套     |  799.90 |   500 |</span><br><span class="line">|       3 | 12 |           2 | 户外运动       | 滑板        |  499.90 |  1200 |</span><br><span class="line">|       4 |  7 |           2 | 户外运动       | 自行车      |  399.90 |  1000 |</span><br><span class="line">|       5 | 10 |           2 | 户外运动       | 骑行装备    |  399.90 |  3500 |</span><br><span class="line">|       6 |  9 |           2 | 户外运动       | 登山杖      |   59.90 |  1500 |</span><br><span class="line">+---------+----+-------------+---------------+------------+---------+-------+</span><br><span class="line">12 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>举例：查询 goods 数据表中每个商品分类下价格最高的3种商品信息。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT *</span><br><span class="line">    -&gt; FROM (</span><br><span class="line">    -&gt;  SELECT ROW_NUMBER() OVER(PARTITION BY category_id ORDER BY price DESC) AS row_num,</span><br><span class="line">    -&gt;  id, category_id, category, NAME, price, stock</span><br><span class="line">    -&gt;  FROM goods) t</span><br><span class="line">    -&gt; WHERE row_num &lt;= 3;</span><br><span class="line">+---------+----+-------------+---------------+------------+---------+-------+</span><br><span class="line">| row_num | id | category_id | category      | NAME       | price   | stock |</span><br><span class="line">+---------+----+-------------+---------------+------------+---------+-------+</span><br><span class="line">|       1 |  6 |           1 | 女装/女士精品   | 呢绒外套    |  399.90  |  1200 |</span><br><span class="line">|       2 |  3 |           1 | 女装/女士精品   | 卫衣        |   89.90 |  1500 |</span><br><span class="line">|       3 |  4 |           1 | 女装/女士精品   | 牛仔裤      |   89.90  |  3500 |</span><br><span class="line">|       1 |  8 |           2 | 户外运动       | 山地自行车   | 1399.90  |  2500 |</span><br><span class="line">|       2 | 11 |           2 | 户外运动       | 运动外套     |  799.90  |   500 |</span><br><span class="line">|       3 | 12 |           2 | 户外运动       | 滑板        |  499.90  |  1200 |</span><br><span class="line">+---------+----+-------------+---------------+------------+----------+-------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>在名称为“女装/女士精品”的商品类别中，有两款商品的价格为89.90元，分别是卫衣和牛仔裤。两款商品的序号都应该为2，而不是一个为2，另一个为3。此时，可以使用RANK()函数和DENSE_RANK()函数解决。</p><p><strong>2．RANK()函数</strong></p><p>使用RANK()函数能够对序号进行并列排序，并且会跳过重复的序号，比如序号为1、1、3。</p><p>举例：使用RANK()函数获取 goods 数据表中各类别的价格从高到低排序的各商品信息。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT RANK() OVER(PARTITION BY category_id ORDER BY price DESC) AS row_num,</span><br><span class="line">    -&gt; id, category_id, category, NAME, price, stock</span><br><span class="line">    -&gt; FROM goods;</span><br><span class="line">+---------+----+-------------+---------------+------------+---------+-------+</span><br><span class="line">| row_num | id | category_id | category      | NAME       | price   | stock |</span><br><span class="line">+---------+----+-------------+---------------+------------+---------+-------+</span><br><span class="line">|       1 |  6 |           1 | 女装/女士精品   | 呢绒外套    |  399.90 |  1200 |</span><br><span class="line">|       2 |  3 |           1 | 女装/女士精品   | 卫衣        |   89.90 |  1500 |</span><br><span class="line">|       2 |  4 |           1 | 女装/女士精品   | 牛仔裤      |   89.90 |  3500 |</span><br><span class="line">|       4 |  2 |           1 | 女装/女士精品   | 连衣裙      |   79.90 |  2500 |</span><br><span class="line">|       5 |  1 |           1 | 女装/女士精品   | T恤         |   39.90 |  1000 |</span><br><span class="line">|       6 |  5 |           1 | 女装/女士精品   | 百褶裙      |   29.90 |   500 |</span><br><span class="line">|       1 |  8 |           2 | 户外运动       | 山地自行车   | 1399.90 |  2500 |</span><br><span class="line">|       2 | 11 |           2 | 户外运动       | 运动外套     |  799.90 |   500 |</span><br><span class="line">|       3 | 12 |           2 | 户外运动       | 滑板        |  499.90 |  1200 |</span><br><span class="line">|       4 |  7 |           2 | 户外运动       | 自行车      |  399.90 |  1000 |</span><br><span class="line">|       4 | 10 |           2 | 户外运动       | 骑行装备    |  399.90 |  3500 |</span><br><span class="line">|       6 |  9 |           2 | 户外运动       | 登山杖      |   59.90 |  1500 |</span><br><span class="line">+---------+----+-------------+---------------+------------+---------+-------+</span><br><span class="line">12 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>举例：使用RANK()函数获取 goods 数据表中类别为“女装/女士精品”的价格最高的4款商品信息。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT *</span><br><span class="line">    -&gt; FROM(</span><br><span class="line">    -&gt;  SELECT RANK() OVER(PARTITION BY category_id ORDER BY price DESC) AS row_num,</span><br><span class="line">    -&gt;  id, category_id, category, NAME, price, stock</span><br><span class="line">    -&gt;  FROM goods) t</span><br><span class="line">    -&gt; WHERE category_id = 1 AND row_num &lt;= 4;</span><br><span class="line">+---------+----+-------------+---------------+----------+--------+-------+</span><br><span class="line">| row_num | id | category_id | category      | NAME     | price  | stock |</span><br><span class="line">+---------+----+-------------+---------------+----------+--------+-------+</span><br><span class="line">|       1 |  6 |           1 | 女装/女士精品   | 呢绒外套  | 399.90 |  1200 |</span><br><span class="line">|       2 |  3 |           1 | 女装/女士精品   | 卫衣      |  89.90 |  1500 |</span><br><span class="line">|       2 |  4 |           1 | 女装/女士精品   | 牛仔裤    |  89.90 |  3500 |</span><br><span class="line">|       4 |  2 |           1 | 女装/女士精品   | 连衣裙    |  79.90 |  2500 |</span><br><span class="line">+---------+----+-------------+---------------+----------+--------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>可以看到，使用RANK()函数得出的序号为1、2、2、4，相同价格的商品序号相同，后面的商品序号是不连续的，跳过了重复的序号。</p><p><strong>3．DENSE_RANK()函数</strong></p><p>DENSE_RANK()函数对序号进行并列排序，并且不会跳过重复的序号，比如序号为1、1、2。</p><p>举例：使用DENSE_RANK()函数获取 goods 数据表中各类别的价格从高到低排序的各商品信息。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT DENSE_RANK() OVER(PARTITION BY category_id ORDER BY price DESC) AS row_num,</span><br><span class="line">    -&gt; id, category_id, category, NAME, price, stock</span><br><span class="line">    -&gt; FROM goods;</span><br><span class="line">+---------+----+-------------+---------------+------------+---------+-------+</span><br><span class="line">| row_num | id | category_id | category      | NAME       | price   | stock |</span><br><span class="line">+---------+----+-------------+---------------+------------+---------+-------+</span><br><span class="line">|       1 |  6 |           1 | 女装/女士精品   | 呢绒外套    |  399.90 |  1200 |</span><br><span class="line">|       2 |  3 |           1 | 女装/女士精品   | 卫衣        |   89.90 |  1500 |</span><br><span class="line">|       2 |  4 |           1 | 女装/女士精品   | 牛仔裤      |   89.90 |  3500 |</span><br><span class="line">|       3 |  2 |           1 | 女装/女士精品   | 连衣裙      |   79.90 |  2500 |</span><br><span class="line">|       4 |  1 |           1 | 女装/女士精品   | T恤        |   39.90 |  1000 |</span><br><span class="line">|       5 |  5 |           1 | 女装/女士精品   | 百褶裙      |   29.90 |   500 |</span><br><span class="line">|       1 |  8 |           2 | 户外运动       | 山地自行车   | 1399.90 |  2500 |</span><br><span class="line">|       2 | 11 |           2 | 户外运动       | 运动外套     |  799.90 |   500 |</span><br><span class="line">|       3 | 12 |           2 | 户外运动       | 滑板        |  499.90 |  1200 |</span><br><span class="line">|       4 |  7 |           2 | 户外运动       | 自行车       |  399.90 |  1000 |</span><br><span class="line">|       4 | 10 |           2 | 户外运动       | 骑行装备     |  399.90 |  3500 |</span><br><span class="line">|       5 |  9 |           2 | 户外运动       | 登山杖       |   59.90 |  1500 |</span><br><span class="line">+---------+----+-------------+---------------+------------+---------+-------+</span><br><span class="line">12 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>举例：使用DENSE_RANK()函数获取 goods 数据表中类别为“女装/女士精品”的价格最高的4款商品信息。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT *</span><br><span class="line">    -&gt; FROM(</span><br><span class="line">    -&gt;  SELECT DENSE_RANK() OVER(PARTITION BY category_id ORDER BY price DESC) AS row_num,</span><br><span class="line">    -&gt;  id, category_id, category, NAME, price, stock</span><br><span class="line">    -&gt;  FROM goods) t</span><br><span class="line">    -&gt; WHERE category_id = 1 AND row_num &lt;= 3;</span><br><span class="line">+---------+----+-------------+---------------+----------+--------+-------+</span><br><span class="line">| row_num | id | category_id | category      | NAME     | price  | stock |</span><br><span class="line">+---------+----+-------------+---------------+----------+--------+-------+</span><br><span class="line">|       1 |  6 |           1 | 女装/女士精品   | 呢绒外套  | 399.90 |  1200 |</span><br><span class="line">|       2 |  3 |           1 | 女装/女士精品   | 卫衣     |  89.90  |  1500 |</span><br><span class="line">|       2 |  4 |           1 | 女装/女士精品   | 牛仔裤    |  89.90 |  3500 |</span><br><span class="line">|       3 |  2 |           1 | 女装/女士精品   | 连衣裙    |  79.90 |  2500 |</span><br><span class="line">+---------+----+-------------+---------------+----------+--------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>可以看到，使用DENSE_RANK()函数得出的行号为1、2、2、3，相同价格的商品序号相同，后面的商品序号是连续的，并且没有跳过重复的序号。</p><h4 id="分布函数"><a href="#分布函数" class="headerlink" title="分布函数"></a>分布函数</h4><p><strong>1．PERCENT_RANK()函数</strong></p><p>PERCENT_RANK()函数是等级值百分比函数。按照如下方式进行计算。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(rank - 1) / (rows - 1)</span><br></pre></td></tr></table></figure><p>其中，rank的值为使用RANK()函数产生的序号，rows的值为当前窗口的总记录数。</p><p>举例：计算 goods 数据表中名称为“女装/女士精品”的类别下的商品的PERCENT_RANK值。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#写法一：</span><br><span class="line">SELECT RANK() OVER (PARTITION BY category_id ORDER BY price DESC) AS r,</span><br><span class="line">PERCENT_RANK() OVER (PARTITION BY category_id ORDER BY price DESC) AS pr,</span><br><span class="line">id, category_id, category, NAME, price, stock</span><br><span class="line">FROM goods</span><br><span class="line">WHERE category_id = 1;</span><br><span class="line"></span><br><span class="line">#写法二：</span><br><span class="line">mysql&gt; SELECT RANK() OVER w AS r,</span><br><span class="line">    -&gt; PERCENT_RANK() OVER w AS pr,</span><br><span class="line">    -&gt; id, category_id, category, NAME, price, stock</span><br><span class="line">    -&gt; FROM goods</span><br><span class="line">    -&gt; WHERE category_id = 1 WINDOW w AS (PARTITION BY category_id ORDER BY price DESC);</span><br><span class="line">+---+-----+----+-------------+---------------+----------+--------+-------+</span><br><span class="line">| r | pr  | id | category_id | category      | NAME     | price  | stock |</span><br><span class="line">+---+-----+----+-------------+---------------+----------+--------+-------+</span><br><span class="line">| 1 |   0 |  6 |           1 | 女装/女士精品   | 呢绒外套  | 399.90 |  1200 |</span><br><span class="line">| 2 | 0.2 |  3 |           1 | 女装/女士精品   | 卫衣     |  89.90 |  1500 |</span><br><span class="line">| 2 | 0.2 |  4 |           1 | 女装/女士精品   | 牛仔裤   |  89.90 |  3500  |</span><br><span class="line">| 4 | 0.6 |  2 |           1 | 女装/女士精品   | 连衣裙   |  79.90 |  2500  |</span><br><span class="line">| 5 | 0.8 |  1 |           1 | 女装/女士精品   | T恤      |  39.90 |  1000 |</span><br><span class="line">| 6 |   1 |  5 |           1 | 女装/女士精品   | 百褶裙   |  29.90  |   500 |</span><br><span class="line">+---+-----+----+-------------+---------------+----------+--------+-------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>2．CUME_DIST()函数</strong></p><p>CUME_DIST()函数主要用于查询小于或等于某个值的比例。</p><p>举例：查询goods数据表中小于或等于当前价格的比例。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT CUME_DIST() OVER(PARTITION BY category_id ORDER BY price ASC) AS cd,</span><br><span class="line">    -&gt; id, category, NAME, price</span><br><span class="line">    -&gt; FROM goods;</span><br><span class="line">+---------------------+----+---------------+------------+---------+</span><br><span class="line">| cd                  | id | category      | NAME       | price   |</span><br><span class="line">+---------------------+----+---------------+------------+---------+</span><br><span class="line">| 0.16666666666666666 |  5 | 女装/女士精品   | 百褶裙      |   29.90 |</span><br><span class="line">|  0.3333333333333333 |  1 | 女装/女士精品   | T恤        |   39.90 |</span><br><span class="line">|                 0.5 |  2 | 女装/女士精品   | 连衣裙      |   79.90 |</span><br><span class="line">|  0.8333333333333334 |  3 | 女装/女士精品   | 卫衣        |   89.90 |</span><br><span class="line">|  0.8333333333333334 |  4 | 女装/女士精品   | 牛仔裤      |   89.90 |</span><br><span class="line">|                   1 |  6 | 女装/女士精品   | 呢绒外套    |  399.90 |</span><br><span class="line">| 0.16666666666666666 |  9 | 户外运动       | 登山杖      |   59.90 |</span><br><span class="line">|                 0.5 |  7 | 户外运动       | 自行车      |  399.90 |</span><br><span class="line">|                 0.5 | 10 | 户外运动       | 骑行装备     |  399.90 |</span><br><span class="line">|  0.6666666666666666 | 12 | 户外运动       | 滑板        |  499.90 |</span><br><span class="line">|  0.8333333333333334 | 11 | 户外运动       | 运动外套    |  799.90 |</span><br><span class="line">|                   1 |  8 | 户外运动       | 山地自行车   | 1399.90 |</span><br><span class="line">+---------------------+----+---------------+------------+---------+</span><br><span class="line">12 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="前后函数"><a href="#前后函数" class="headerlink" title="前后函数"></a>前后函数</h4><p><strong>1．LAG(expr,n)函数</strong></p><p>LAG(expr,n)函数返回当前行的前n行的expr的值。</p><p>举例：查询goods数据表中前一个商品价格与当前商品价格的差值。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT id, category, NAME, price, pre_price, price - pre_price AS diff_price</span><br><span class="line">    -&gt; FROM (</span><br><span class="line">    -&gt;  SELECT  id, category, NAME, price,LAG(price,1) OVER w AS pre_price</span><br><span class="line">    -&gt;  FROM goods</span><br><span class="line">    -&gt;  WINDOW w AS (PARTITION BY category_id ORDER BY price)) t;</span><br><span class="line">+----+---------------+------------+---------+-----------+------------+</span><br><span class="line">| id | category      | NAME       | price   | pre_price | diff_price |</span><br><span class="line">+----+---------------+------------+---------+-----------+------------+</span><br><span class="line">|  5 | 女装/女士精品   | 百褶裙      |   29.90 |      NULL |       NULL |</span><br><span class="line">|  1 | 女装/女士精品   | T恤        |   39.90 |     29.90 |      10.00 |</span><br><span class="line">|  2 | 女装/女士精品   | 连衣裙      |   79.90 |     39.90 |      40.00 |</span><br><span class="line">|  3 | 女装/女士精品   | 卫衣       |   89.90 |     79.90 |      10.00 |</span><br><span class="line">|  4 | 女装/女士精品   | 牛仔裤      |   89.90 |     89.90 |       0.00 |</span><br><span class="line">|  6 | 女装/女士精品   | 呢绒外套    |  399.90 |     89.90 |     310.00 |</span><br><span class="line">|  9 | 户外运动       | 登山杖      |   59.90 |      NULL |       NULL |</span><br><span class="line">|  7 | 户外运动       | 自行车      |  399.90 |     59.90 |     340.00 |</span><br><span class="line">| 10 | 户外运动       | 骑行装备    |  399.90 |    399.90 |       0.00 |</span><br><span class="line">| 12 | 户外运动       | 滑板       |  499.90 |    399.90 |     100.00 |</span><br><span class="line">| 11 | 户外运动       | 运动外套    |  799.90 |    499.90 |     300.00 |</span><br><span class="line">|  8 | 户外运动       | 山地自行车  | 1399.90 |    799.90 |     600.00 |</span><br><span class="line">+----+---------------+------------+---------+-----------+------------+</span><br><span class="line">12 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>2．LEAD(expr,n)函数</strong></p><p>LEAD(expr,n)函数返回当前行的后n行的expr的值。</p><p>举例：查询goods数据表中后一个商品价格与当前商品价格的差值。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT id, category, NAME, behind_price, price,behind_price - price AS diff_price</span><br><span class="line">    -&gt; FROM(</span><br><span class="line">    -&gt;  SELECT id, category, NAME, price,LEAD(price, 1) OVER w AS behind_price</span><br><span class="line">    -&gt;  FROM goods WINDOW w AS (PARTITION BY category_id ORDER BY price)) t;</span><br><span class="line">+----+---------------+------------+--------------+---------+------------+</span><br><span class="line">| id | category      | NAME       | behind_price | price   | diff_price |</span><br><span class="line">+----+---------------+------------+--------------+---------+------------+</span><br><span class="line">|  5 | 女装/女士精品   | 百褶裙      |        39.90 |   29.90 |      10.00 |</span><br><span class="line">|  1 | 女装/女士精品   | T恤        |        79.90 |   39.90 |      40.00 |</span><br><span class="line">|  2 | 女装/女士精品   | 连衣裙      |        89.90 |   79.90 |      10.00 |</span><br><span class="line">|  3 | 女装/女士精品   | 卫衣        |        89.90 |   89.90 |       0.00 |</span><br><span class="line">|  4 | 女装/女士精品   | 牛仔裤      |       399.90 |   89.90 |     310.00 |</span><br><span class="line">|  6 | 女装/女士精品   | 呢绒外套     |         NULL |  399.90 |       NULL |</span><br><span class="line">|  9 | 户外运动       | 登山杖       |       399.90 |   59.90 |     340.00 |</span><br><span class="line">|  7 | 户外运动       | 自行车       |       399.90 |  399.90 |       0.00 |</span><br><span class="line">| 10 | 户外运动       | 骑行装备     |       499.90 |  399.90 |     100.00 |</span><br><span class="line">| 12 | 户外运动       | 滑板        |       799.90 |  499.90 |     300.00 |</span><br><span class="line">| 11 | 户外运动       | 运动外套     |      1399.90 |  799.90 |     600.00 |</span><br><span class="line">|  8 | 户外运动       | 山地自行车   |         NULL | 1399.90 |       NULL |</span><br><span class="line">+----+---------------+------------+--------------+---------+------------+</span><br><span class="line">12 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="首尾函数"><a href="#首尾函数" class="headerlink" title="首尾函数"></a>首尾函数</h4><p><strong>1．FIRST_VALUE(expr)函数</strong></p><p>FIRST_VALUE(expr)函数返回第一个expr的值。</p><p>举例：按照价格排序，查询第1个商品的价格信息。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT id, category, NAME, price, stock,FIRST_VALUE(price) OVER w AS first_price</span><br><span class="line">    -&gt; FROM goods WINDOW w AS (PARTITION BY category_id ORDER BY price);</span><br><span class="line">+----+---------------+------------+---------+-------+-------------+</span><br><span class="line">| id | category      | NAME       | price   | stock | first_price |</span><br><span class="line">+----+---------------+------------+---------+-------+-------------+</span><br><span class="line">|  5 | 女装/女士精品   | 百褶裙      |   29.90 |   500 |       29.90 |</span><br><span class="line">|  1 | 女装/女士精品   | T恤        |   39.90 |  1000 |       29.90 |</span><br><span class="line">|  2 | 女装/女士精品   | 连衣裙      |   79.90 |  2500 |       29.90 |</span><br><span class="line">|  3 | 女装/女士精品   | 卫衣       |   89.90 |  1500 |       29.90 |</span><br><span class="line">|  4 | 女装/女士精品   | 牛仔裤      |   89.90 |  3500 |       29.90 |</span><br><span class="line">|  6 | 女装/女士精品   | 呢绒外套    |  399.90 |  1200 |       29.90 |</span><br><span class="line">|  9 | 户外运动       | 登山杖      |   59.90 |  1500 |       59.90 |</span><br><span class="line">|  7 | 户外运动       | 自行车      |  399.90 |  1000 |       59.90 |</span><br><span class="line">| 10 | 户外运动       | 骑行装备    |  399.90 |  3500 |       59.90 |</span><br><span class="line">| 12 | 户外运动       | 滑板       |  499.90 |  1200 |       59.90 |</span><br><span class="line">| 11 | 户外运动       | 运动外套    |  799.90 |   500 |       59.90 |</span><br><span class="line">|  8 | 户外运动       | 山地自行车  | 1399.90 |  2500 |       59.90 |</span><br><span class="line">+----+---------------+------------+---------+-------+-------------+</span><br><span class="line">12 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>2．LAST_VALUE(expr)函数</strong></p><p>LAST_VALUE(expr)函数返回最后一个expr的值。</p><p>举例：按照价格排序，查询最后一个商品的价格信息。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT id, category, NAME, price, stock,LAST_VALUE(price) OVER w AS last_price</span><br><span class="line">    -&gt; FROM goods WINDOW w AS (PARTITION BY category_id ORDER BY price);</span><br><span class="line">+----+---------------+------------+---------+-------+------------+</span><br><span class="line">| id | category      | NAME       | price   | stock | last_price |</span><br><span class="line">+----+---------------+------------+---------+-------+------------+</span><br><span class="line">|  5 | 女装/女士精品   | 百褶裙     |   29.90 |   500 |      29.90 |</span><br><span class="line">|  1 | 女装/女士精品   | T恤        |   39.90 |  1000 |      39.90 |</span><br><span class="line">|  2 | 女装/女士精品   | 连衣裙     |   79.90 |  2500 |      79.90 |</span><br><span class="line">|  3 | 女装/女士精品   | 卫衣       |   89.90 |  1500 |      89.90 |</span><br><span class="line">|  4 | 女装/女士精品   | 牛仔裤     |   89.90 |  3500 |      89.90 |</span><br><span class="line">|  6 | 女装/女士精品   | 呢绒外套   |  399.90 |  1200 |     399.90 |</span><br><span class="line">|  9 | 户外运动       | 登山杖     |   59.90 |  1500 |      59.90 |</span><br><span class="line">|  7 | 户外运动       | 自行车     |  399.90 |  1000 |     399.90 |</span><br><span class="line">| 10 | 户外运动       | 骑行装备   |  399.90 |  3500 |     399.90 |</span><br><span class="line">| 12 | 户外运动       | 滑板       |  499.90 |  1200 |     499.90 |</span><br><span class="line">| 11 | 户外运动       | 运动外套   |  799.90 |   500 |     799.90 |</span><br><span class="line">|  8 | 户外运动       | 山地自行车 | 1399.90 |  2500 |    1399.90 |</span><br><span class="line">+----+---------------+------------+---------+-------+------------+</span><br><span class="line">12 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h4><p><strong>1．NTH_VALUE(expr,n)函数</strong></p><p>NTH_VALUE(expr,n)函数返回第n个expr的值。</p><p>举例：查询goods数据表中排名第2和第3的价格信息。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT id, category, NAME, price,NTH_VALUE(price,2) OVER w AS second_price,</span><br><span class="line">    -&gt; NTH_VALUE(price,3) OVER w AS third_price</span><br><span class="line">    -&gt; FROM goods WINDOW w AS (PARTITION BY category_id ORDER BY price);</span><br><span class="line">+----+---------------+------------+---------+--------------+-------------+</span><br><span class="line">| id | category      | NAME       | price   | second_price | third_price |</span><br><span class="line">+----+---------------+------------+---------+--------------+-------------+</span><br><span class="line">|  5 | 女装/女士精品   | 百褶裙     |   29.90 |         NULL |        NULL |</span><br><span class="line">|  1 | 女装/女士精品   | T恤        |   39.90 |        39.90 |        NULL |</span><br><span class="line">|  2 | 女装/女士精品   | 连衣裙     |   79.90 |        39.90 |       79.90 |</span><br><span class="line">|  3 | 女装/女士精品   | 卫衣       |   89.90 |        39.90 |       79.90 |</span><br><span class="line">|  4 | 女装/女士精品   | 牛仔裤     |   89.90 |        39.90 |       79.90 |</span><br><span class="line">|  6 | 女装/女士精品   | 呢绒外套   |  399.90 |        39.90 |       79.90 |</span><br><span class="line">|  9 | 户外运动       | 登山杖     |   59.90 |         NULL |        NULL |</span><br><span class="line">|  7 | 户外运动       | 自行车     |  399.90 |       399.90 |      399.90 |</span><br><span class="line">| 10 | 户外运动       | 骑行装备   |  399.90 |       399.90 |      399.90 |</span><br><span class="line">| 12 | 户外运动       | 滑板       |  499.90 |       399.90 |      399.90 |</span><br><span class="line">| 11 | 户外运动       | 运动外套   |  799.90 |       399.90 |      399.90 |</span><br><span class="line">|  8 | 户外运动       | 山地自行车 | 1399.90 |       399.90 |      399.90 |</span><br><span class="line">+----+---------------+------------+---------+--------------+-------------+</span><br><span class="line">12 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>2．NTILE(n)函数</strong></p><p>NTILE(n)函数将分区中的有序数据分为n个桶，记录桶编号。</p><p>举例：将goods表中的商品按照价格分为3组。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT NTILE(3) OVER w AS nt,id, category, NAME, price</span><br><span class="line">    -&gt; FROM goods WINDOW w AS (PARTITION BY category_id ORDER BY price);</span><br><span class="line">+----+----+---------------+------------+---------+</span><br><span class="line">| nt | id | category      | NAME       | price   |</span><br><span class="line">+----+----+---------------+------------+---------+</span><br><span class="line">|  1 |  5 | 女装/女士精品 | 百褶裙     |   29.90 |</span><br><span class="line">|  1 |  1 | 女装/女士精品 | T恤        |   39.90 |</span><br><span class="line">|  2 |  2 | 女装/女士精品 | 连衣裙     |   79.90 |</span><br><span class="line">|  2 |  3 | 女装/女士精品 | 卫衣       |   89.90 |</span><br><span class="line">|  3 |  4 | 女装/女士精品 | 牛仔裤     |   89.90 |</span><br><span class="line">|  3 |  6 | 女装/女士精品 | 呢绒外套   |  399.90 |</span><br><span class="line">|  1 |  9 | 户外运动      | 登山杖     |   59.90 |</span><br><span class="line">|  1 |  7 | 户外运动      | 自行车     |  399.90 |</span><br><span class="line">|  2 | 10 | 户外运动      | 骑行装备   |  399.90 |</span><br><span class="line">|  2 | 12 | 户外运动      | 滑板       |  499.90 |</span><br><span class="line">|  3 | 11 | 户外运动      | 运动外套   |  799.90 |</span><br><span class="line">|  3 |  8 | 户外运动      | 山地自行车 | 1399.90 |</span><br><span class="line">+----+----+---------------+------------+---------+</span><br><span class="line">12 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="小-结"><a href="#小-结" class="headerlink" title="小 结"></a>小 结</h3><p>窗口函数的特点是可以分组，而且可以在分组内排序。另外，窗口函数不会因为分组而减少原表中的行数，这对我们在原表数据的基础上进行统计和排序非常有用。</p><h2 id="新特性2：公用表表达式"><a href="#新特性2：公用表表达式" class="headerlink" title="新特性2：公用表表达式"></a>新特性2：公用表表达式</h2><p>公用表表达式（或通用表表达式）简称为CTE（Common Table Expressions）。CTE是一个命名的临时结果集，作用范围是当前语句。CTE可以理解成一个可以复用的子查询，当然跟子查询还是有点区别的，CTE可以引用其他CTE，但子查询不能引用其他子查询。所以，可以考虑代替子查询。</p><p>依据语法结构和执行方式的不同，公用表表达式分为<code>普通公用表表达式</code>和<code>递归公用表表达式</code> 2 种。</p><h3 id="3-1-普通公用表表达式"><a href="#3-1-普通公用表表达式" class="headerlink" title="3.1 普通公用表表达式"></a>3.1 普通公用表表达式</h3><p>普通公用表表达式的语法结构是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WITH CTE名称 </span><br><span class="line">AS （子查询）</span><br><span class="line">SELECT|DELETE|UPDATE 语句;</span><br></pre></td></tr></table></figure><p>普通公用表表达式类似于子查询，不过，跟子查询不同的是，它可以被多次引用，而且可以被其他的普通公用表表达式所引用。</p><p>举例：查询员工所在的部门的详细信息。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM departments</span><br><span class="line">    -&gt; WHERE department_id IN (</span><br><span class="line">    -&gt;                  SELECT DISTINCT department_id</span><br><span class="line">    -&gt;                  FROM employees</span><br><span class="line">    -&gt;                  );</span><br><span class="line">+---------------+------------------+------------+-------------+</span><br><span class="line">| department_id | department_name  | manager_id | location_id |</span><br><span class="line">+---------------+------------------+------------+-------------+</span><br><span class="line">|            10 | Administration   |        200 |        1700 |</span><br><span class="line">|            20 | Marketing        |        201 |        1800 |</span><br><span class="line">|            30 | Purchasing       |        114 |        1700 |</span><br><span class="line">|            40 | Human Resources  |        203 |        2400 |</span><br><span class="line">|            50 | Shipping         |        121 |        1500 |</span><br><span class="line">|            60 | IT               |        103 |        1400 |</span><br><span class="line">|            70 | Public Relations |        204 |        2700 |</span><br><span class="line">|            80 | Sales            |        145 |        2500 |</span><br><span class="line">|            90 | Executive        |        100 |        1700 |</span><br><span class="line">|           100 | Finance          |        108 |        1700 |</span><br><span class="line">|           110 | Accounting       |        205 |        1700 |</span><br><span class="line">+---------------+------------------+------------+-------------+</span><br><span class="line">11 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>这个查询也可以用普通公用表表达式的方式完成：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; WITH emp_dept_id</span><br><span class="line">    -&gt; AS (SELECT DISTINCT department_id FROM employees)</span><br><span class="line">    -&gt; SELECT *</span><br><span class="line">    -&gt; FROM departments d JOIN emp_dept_id e</span><br><span class="line">    -&gt; ON d.department_id = e.department_id;</span><br><span class="line">+---------------+------------------+------------+-------------+---------------+</span><br><span class="line">| department_id | department_name  | manager_id | location_id | department_id |</span><br><span class="line">+---------------+------------------+------------+-------------+---------------+</span><br><span class="line">|            90 | Executive        |        100 |        1700 |            90 |</span><br><span class="line">|            60 | IT               |        103 |        1400 |            60 |</span><br><span class="line">|           100 | Finance          |        108 |        1700 |           100 |</span><br><span class="line">|            30 | Purchasing       |        114 |        1700 |            30 |</span><br><span class="line">|            50 | Shipping         |        121 |        1500 |            50 |</span><br><span class="line">|            80 | Sales            |        145 |        2500 |            80 |</span><br><span class="line">|            10 | Administration   |        200 |        1700 |            10 |</span><br><span class="line">|            20 | Marketing        |        201 |        1800 |            20 |</span><br><span class="line">|            40 | Human Resources  |        203 |        2400 |            40 |</span><br><span class="line">|            70 | Public Relations |        204 |        2700 |            70 |</span><br><span class="line">|           110 | Accounting       |        205 |        1700 |           110 |</span><br><span class="line">+---------------+------------------+------------+-------------+---------------+</span><br><span class="line">11 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>例子说明，公用表表达式可以起到子查询的作用。以后如果遇到需要使用子查询的场景，你可以在查询之前，先定义公用表表达式，然后在查询中用它来代替子查询。而且，跟子查询相比，公用表表达式有一个优点，就是定义过公用表表达式之后的查询，可以像一个表一样多次引用公用表表达式，而子查询则不能。</p><h3 id="递归公用表表达式"><a href="#递归公用表表达式" class="headerlink" title="递归公用表表达式"></a>递归公用表表达式</h3><p>递归公用表表达式也是一种公用表表达式，只不过，除了普通公用表表达式的特点以外，它还有自己的特点，就是<strong>可以调用自己</strong>。它的语法结构是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WITH RECURSIVE</span><br><span class="line">CTE名称 AS （子查询）</span><br><span class="line">SELECT|DELETE|UPDATE 语句;</span><br></pre></td></tr></table></figure><p>递归公用表表达式由 2 部分组成，分别是种子查询和递归查询，中间通过关键字 UNION  [ALL]进行连接。这里的<strong>种子查询，意思就是获得递归的初始值</strong>。这个查询只会运行一次，以创建初始数据集，之后递归查询会一直执行，直到没有任何新的查询数据产生，递归返回。</p><p><strong>案例：</strong>针对于我们常用的employees表，包含employee_id，last_name和manager_id三个字段。如果a是b的管理者，那么，我们可以把b叫做a的下属，如果同时b又是c的管理者，那么c就是b的下属，是a的下下属。</p><p>下面我们尝试用查询语句列出所有具有下下属身份的人员信息。</p><p>如果用我们之前学过的知识来解决，会比较复杂，至少要进行 4 次查询才能搞定：</p><ul><li><p>第一步，先找出初代管理者，就是不以任何别人为管理者的人，把结果存入临时表；</p></li><li><p>第二步，找出所有以初代管理者为管理者的人，得到一个下属集，把结果存入临时表；</p></li><li><p>第三步，找出所有以下属为管理者的人，得到一个下下属集，把结果存入临时表。</p></li><li><p>第四步，找出所有以下下属为管理者的人，得到一个结果集。</p></li></ul><p>如果第四步的结果集为空，则计算结束，第三步的结果集就是我们需要的下下属集了，否则就必须继续进行第四步，一直到结果集为空为止。比如上面的这个数据表，就需要到第五步，才能得到空结果集。而且，最后还要进行第六步：把第三步和第四步的结果集合并，这样才能最终获得我们需要的结果集。</p><p>如果用递归公用表表达式，就非常简单了。我介绍下具体的思路。</p><ul><li><p>用递归公用表表达式中的种子查询，找出初代管理者。字段 n 表示代次，初始值为 1，表示是第一代管理者。</p></li><li><p>用递归公用表表达式中的递归查询，查出以这个递归公用表表达式中的人为管理者的人，并且代次的值加 1。直到没有人以这个递归公用表表达式中的人为管理者了，递归返回。</p></li><li><p>在最后的查询中，选出所有代次大于等于 3 的人，他们肯定是第三代及以上代次的下属了，也就是下下属了。这样就得到了我们需要的结果集。</p></li></ul><p>这里看似也是 3 步，实际上是一个查询的 3 个部分，只需要执行一次就可以了。而且也不需要用临时表保存中间结果，比刚刚的方法简单多了。</p><p><strong>代码实现：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WITH RECURSIVE cte </span><br><span class="line">AS </span><br><span class="line">(</span><br><span class="line">SELECT employee_id,last_name,manager_id,1 AS n FROM employees WHERE employee_id = 100 -- 种子查询，找到第一代领导</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT a.employee_id,a.last_name,a.manager_id,n+1 FROM employees AS a JOIN cte</span><br><span class="line">ON (a.manager_id = cte.employee_id) -- 递归查询，找出以递归公用表表达式的人为领导的人</span><br><span class="line">)</span><br><span class="line">SELECT employee_id,last_name FROM cte WHERE n &gt;= 3; </span><br></pre></td></tr></table></figure><p>总之，递归公用表表达式对于查询一个有共同的根节点的树形结构数据，非常有用。它可以不受层级的限制，轻松查出所有节点的数据。如果用其他的查询方式，就比较复杂了。</p><h3 id="3-3-小-结"><a href="#3-3-小-结" class="headerlink" title="3.3 小 结"></a>3.3 小 结</h3><p>公用表表达式的作用是可以替代子查询，而且可以被多次引用。递归公用表表达式对查询有一个共同根节点的树形结构数据非常高效，可以轻松搞定其他查询方式难以处理的查询。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第18章-MySQL8其它新特性&quot;&gt;&lt;a href=&quot;#第18章-MySQL8其它新特性&quot; class=&quot;headerlink&quot; title=&quot;第18章_MySQL8其它新特性&quot;&gt;&lt;/a&gt;第18章_MySQL8其它新特性&lt;/h1&gt;&lt;p&gt;讲师：尚硅谷-宋红康（江湖人</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    <category term="基础版" scheme="http://example.com/categories/MySQL/%E5%9F%BA%E7%A1%80%E7%89%88/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>第17章_触发器</title>
    <link href="http://example.com/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC17%E7%AB%A0_%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <id>http://example.com/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC17%E7%AB%A0_%E8%A7%A6%E5%8F%91%E5%99%A8/</id>
    <published>2022-05-17T12:37:17.000Z</published>
    <updated>2022-05-17T13:02:21.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第17章-触发器"><a href="#第17章-触发器" class="headerlink" title="第17章_触发器"></a>第17章_触发器</h1><p>讲师：尚硅谷-宋红康（江湖人称：康师傅）</p><p>官网：<a href="http://www.atguigu.com/">http://www.atguigu.com</a></p><hr><p>在实际开发中，我们经常会遇到这样的情况：有 2 个或者多个相互关联的表，如<code>商品信息</code>和<code>库存信息</code>分别存放在 2 个不同的数据表中，我们在添加一条新商品记录的时候，为了保证数据的完整性，必须同时在库存表中添加一条库存记录。</p><p>这样一来，我们就必须把这两个关联的操作步骤写到程序里面，而且要用<code>事务</code>包裹起来，确保这两个操作成为一个<code>原子操作</code>，要么全部执行，要么全部不执行。要是遇到特殊情况，可能还需要对数据进行手动维护，这样就很<code>容易忘记其中的一步</code>，导致数据缺失。</p><p>这个时候，咱们可以使用触发器。<strong>你可以创建一个触发器，让商品信息数据的插入操作自动触发库存数据的插入操作。</strong>这样一来，就不用担心因为忘记添加库存数据而导致的数据缺失了。</p><h2 id="触发器概述"><a href="#触发器概述" class="headerlink" title="触发器概述"></a>触发器概述</h2><p>MySQL从<code>5.0.2</code>版本开始支持触发器。MySQL的触发器和存储过程一样，都是嵌入到MySQL服务器的一段程序。</p><p>触发器是由<code>事件来触发</code>某个操作，这些事件包括<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>事件。所谓事件就是指用户的动作或者触发某项行为。如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生了，就会<code>自动</code>激发触发器执行相应的操作。</p><p>当对数据表中的数据执行插入、更新和删除操作，需要自动执行一些数据库逻辑时，可以使用触发器来实现。</p><h2 id="触发器的创建"><a href="#触发器的创建" class="headerlink" title="触发器的创建"></a>触发器的创建</h2><h3 id="创建触发器语法"><a href="#创建触发器语法" class="headerlink" title="创建触发器语法"></a>创建触发器语法</h3><p>创建触发器的语法结构是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER 触发器名称 </span><br><span class="line">&#123;BEFORE|AFTER&#125; &#123;INSERT|UPDATE|DELETE&#125; ON 表名 </span><br><span class="line">FOR EACH ROW </span><br><span class="line">触发器执行的语句块;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>表名</code>：表示触发器监控的对象。</li><li><code>BEFORE|AFTER</code>：表示触发的时间。BEFORE 表示在事件之前触发；AFTER 表示在事件之后触发。</li><li><code>INSERT|UPDATE|DELETE</code>：表示触发的事件。<ul><li>INSERT 表示插入记录时触发；</li><li>UPDATE 表示更新记录时触发；</li><li>DELETE 表示删除记录时触发。</li></ul></li></ul><ul><li><code>触发器执行的语句块</code>：可以是单条SQL语句，也可以是由BEGIN…END结构组成的复合语句块。</li></ul><h3 id="代码举例"><a href="#代码举例" class="headerlink" title="代码举例"></a>代码举例</h3><p><strong>举例1：</strong></p><p>1、创建数据表：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_trigger (</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">t_note VARCHAR(30)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE test_trigger_log (</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">t_log VARCHAR(30)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>2、创建触发器：创建名称为before_insert的触发器，向test_trigger数据表插入数据之前，向test_trigger_log数据表中插入before_insert的日志信息。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE TRIGGER before_insert</span><br><span class="line">BEFORE INSERT ON test_trigger </span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">INSERT INTO test_trigger_log (t_log)</span><br><span class="line">VALUES(&#x27;before_insert&#x27;);</span><br><span class="line"></span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>3、向test_trigger数据表中插入数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test_trigger (t_note) VALUES (&#x27;测试 BEFORE INSERT 触发器&#x27;);</span><br></pre></td></tr></table></figure><p>4、查看test_trigger_log数据表中的数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM test_trigger_log;</span><br><span class="line">+----+---------------+</span><br><span class="line">| id | t_log         |</span><br><span class="line">+----+---------------+</span><br><span class="line">|  1 | before_insert |</span><br><span class="line">+----+---------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>举例2：</strong></p><p>1、创建名称为after_insert的触发器，向test_trigger数据表插入数据之后，向test_trigger_log数据表中插入after_insert的日志信息。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE TRIGGER after_insert</span><br><span class="line">AFTER INSERT ON test_trigger</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">INSERT INTO test_trigger_log (t_log)</span><br><span class="line">VALUES(&#x27;after_insert&#x27;);</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>2、向test_trigger数据表中插入数据。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test_trigger (t_note) VALUES (&#x27;测试 AFTER INSERT 触发器&#x27;);</span><br></pre></td></tr></table></figure><p>3、查看test_trigger_log数据表中的数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM test_trigger_log;</span><br><span class="line">+----+---------------+</span><br><span class="line">| id | t_log         |</span><br><span class="line">+----+---------------+</span><br><span class="line">|  1 | before_insert |</span><br><span class="line">|  2 | before_insert |</span><br><span class="line">|  3 | after_insert  |</span><br><span class="line">+----+---------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>举例3：</strong>定义触发器“salary_check_trigger”，基于员工表“employees”的INSERT事件，在INSERT之前检查将要添加的新员工薪资是否大于他领导的薪资，如果大于领导薪资，则报sqlstate_value为’HY000’的错误，从而使得添加失败。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE TRIGGER salary_check_trigger</span><br><span class="line">BEFORE INSERT ON employees FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE mgrsalary DOUBLE;</span><br><span class="line">SELECT salary INTO mgrsalary FROM employees WHERE employee_id = NEW.manager_id;</span><br><span class="line"></span><br><span class="line">IF NEW.salary &gt; mgrsalary THEN</span><br><span class="line">SIGNAL SQLSTATE &#x27;HY000&#x27; SET MESSAGE_TEXT = &#x27;薪资高于领导薪资错误&#x27;;</span><br><span class="line">END IF;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>上面触发器声明过程中的NEW关键字代表INSERT添加语句的新记录。</p><h2 id="查看、删除触发器"><a href="#查看、删除触发器" class="headerlink" title="查看、删除触发器"></a>查看、删除触发器</h2><h3 id="查看触发器"><a href="#查看触发器" class="headerlink" title="查看触发器"></a>查看触发器</h3><p>查看触发器是查看数据库中已经存在的触发器的定义、状态和语法信息等。</p><p>方式1：查看当前数据库的所有触发器的定义</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TRIGGERS\G</span><br></pre></td></tr></table></figure><p>方式2：查看当前数据库中某个触发器的定义</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE TRIGGER 触发器名</span><br></pre></td></tr></table></figure><p>方式3：从系统库information_schema的TRIGGERS表中查询“salary_check_trigger”触发器的信息。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM information_schema.TRIGGERS;</span><br></pre></td></tr></table></figure><h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><p>触发器也是数据库对象，删除触发器也用DROP语句，语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TRIGGER  IF EXISTS 触发器名称;</span><br></pre></td></tr></table></figure><h2 id="触发器的优缺点"><a href="#触发器的优缺点" class="headerlink" title="触发器的优缺点"></a>触发器的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p><strong>1、触发器可以确保数据的完整性</strong>。</p><p>假设我们用<code>进货单头表</code>（demo.importhead）来保存进货单的总体信息，包括进货单编号、供货商编号、仓库编号、总计进货数量、总计进货金额和验收日期。</p><p> <img src="/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC17%E7%AB%A0_%E8%A7%A6%E5%8F%91%E5%99%A8/image-20211010233336012.png" alt="image-20211010233336012"></p><p>用<code>进货单明细表</code>（demo.importdetails）来保存进货商品的明细，包括进货单编号、商品编号、进货数量、进货价格和进货金额。</p><p> <img src="/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC17%E7%AB%A0_%E8%A7%A6%E5%8F%91%E5%99%A8/image-20211010233344125.png" alt="image-20211010233344125"></p><p>每当我们录入、删除和修改一条进货单明细数据的时候，进货单明细表里的数据就会发生变动。这个时候，在进货单头表中的总计数量和总计金额就必须重新计算，否则，进货单头表中的总计数量和总计金额就不等于进货单明细表中数量合计和金额合计了，这就是数据不一致。</p><p>为了解决这个问题，我们就可以使用触发器，<strong>规定每当进货单明细表有数据插入、修改和删除的操作时，自动触发 2 步操作：</strong></p><p>1）重新计算进货单明细表中的数量合计和金额合计；</p><p>2）用第一步中计算出来的值更新进货单头表中的合计数量与合计金额。</p><p>这样一来，进货单头表中的合计数量与合计金额的值，就始终与进货单明细表中计算出来的合计数量与合计金额的值相同，数据就是一致的，不会互相矛盾。</p><p><strong>2、触发器可以帮助我们记录操作日志。</strong></p><p>利用触发器，可以具体记录什么时间发生了什么。比如，记录修改会员储值金额的触发器，就是一个很好的例子。这对我们还原操作执行时的具体场景，更好地定位问题原因很有帮助。</p><p><strong>3、触发器还可以用在操作数据前，对数据进行合法性检查。</strong></p><p>比如，超市进货的时候，需要库管录入进货价格。但是，人为操作很容易犯错误，比如说在录入数量的时候，把条形码扫进去了；录入金额的时候，看串了行，录入的价格远超售价，导致账面上的巨亏……这些都可以通过触发器，在实际插入或者更新操作之前，对相应的数据进行检查，及时提示错误，防止错误数据进入系统。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p><strong>1、触发器最大的一个问题就是可读性差。</strong></p><p>因为触发器存储在数据库中，并且由事件驱动，这就意味着触发器有可能<code>不受应用层的控制</code>。这对系统维护是非常有挑战的。</p><p>比如，创建触发器用于修改会员储值操作。如果触发器中的操作出了问题，会导致会员储值金额更新失败。我用下面的代码演示一下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; update demo.membermaster set memberdeposit=20 where memberid = 2;</span><br><span class="line">ERROR 1054 (42S22): Unknown column &#x27;aa&#x27; in &#x27;field list&#x27;</span><br></pre></td></tr></table></figure><p>结果显示，系统提示错误，字段“aa”不存在。</p><p>这是因为，触发器中的数据插入操作多了一个字段，系统提示错误。可是，如果你不了解这个触发器，很可能会认为是更新语句本身的问题，或者是会员信息表的结构出了问题。说不定你还会给会员信息表添加一个叫“aa”的字段，试图解决这个问题，结果只能是白费力。</p><p><strong>2、相关数据的变更，可能会导致触发器出错。</strong></p><p>特别是数据表结构的变更，都可能会导致触发器出错，进而影响数据操作的正常运行。这些都会由于触发器本身的隐蔽性，影响到应用中错误原因排查的效率。</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>注意，如果在子表中定义了外键约束，并且外键指定了ON UPDATE/DELETE CASCADE/SET NULL子句，此时修改父表被引用的键值或删除父表被引用的记录行时，也会引起子表的修改和删除操作，此时基于子表的UPDATE和DELETE语句定义的触发器并不会被激活。</p><p>例如：基于子表员工表（t_employee）的DELETE语句定义了触发器t1，而子表的部门编号（did）字段定义了外键约束引用了父表部门表（t_department）的主键列部门编号（did），并且该外键加了“ON DELETE SET NULL”子句，那么如果此时删除父表部门表（t_department）在子表员工表（t_employee）有匹配记录的部门记录时，会引起子表员工表（t_employee）匹配记录的部门编号（did）修改为NULL，但是此时不会激活触发器t1。只有直接对子表员工表（t_employee）执行DELETE语句时才会激活触发器t1。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第17章-触发器&quot;&gt;&lt;a href=&quot;#第17章-触发器&quot; class=&quot;headerlink&quot; title=&quot;第17章_触发器&quot;&gt;&lt;/a&gt;第17章_触发器&lt;/h1&gt;&lt;p&gt;讲师：尚硅谷-宋红康（江湖人称：康师傅）&lt;/p&gt;
&lt;p&gt;官网：&lt;a href=&quot;http:/</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    <category term="基础版" scheme="http://example.com/categories/MySQL/%E5%9F%BA%E7%A1%80%E7%89%88/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>第16章_变量、流程控制与游标</title>
    <link href="http://example.com/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC16%E7%AB%A0_%E5%8F%98%E9%87%8F%E3%80%81%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%B8%B8%E6%A0%87/"/>
    <id>http://example.com/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC16%E7%AB%A0_%E5%8F%98%E9%87%8F%E3%80%81%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%B8%B8%E6%A0%87/</id>
    <published>2022-05-17T12:37:16.000Z</published>
    <updated>2022-05-17T13:02:20.920Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第16章-变量、流程控制与游标"><a href="#第16章-变量、流程控制与游标" class="headerlink" title="第16章_变量、流程控制与游标"></a>第16章_变量、流程控制与游标</h1><p>讲师：尚硅谷-宋红康（江湖人称：康师傅）</p><p>官网：<a href="http://www.atguigu.com/">http://www.atguigu.com</a></p><hr><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>在MySQL数据库的存储过程和函数中，可以使用变量来存储查询或计算的中间结果数据，或者输出最终的结果数据。</p><p>在 MySQL 数据库中，变量分为<code>系统变量</code>以及<code>用户自定义变量</code>。</p><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><h4 id="系统变量分类"><a href="#系统变量分类" class="headerlink" title="系统变量分类"></a>系统变量分类</h4><p>变量由系统定义，不是用户定义，属于<code>服务器</code>层面。启动MySQL服务，生成MySQL服务实例期间，MySQL将为MySQL服务器内存中的系统变量赋值，这些系统变量定义了当前MySQL服务实例的属性、特征。这些系统变量的值要么是<code>编译MySQL时参数</code>的默认值，要么是<code>配置文件</code>（例如my.ini等）中的参数值。大家可以通过网址 <code>https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html</code> 查看MySQL文档的系统变量。</p><p>系统变量分为全局系统变量（需要添加<code>global</code> 关键字）以及会话系统变量（需要添加 <code>session</code> 关键字），有时也把全局系统变量简称为全局变量，有时也把会话系统变量称为local变量。<strong>如果不写，默认会话级别。</strong>静态变量（在 MySQL 服务实例运行期间它们的值不能使用 set 动态修改）属于特殊的全局系统变量。</p><p>每一个MySQL客户机成功连接MySQL服务器后，都会产生与之对应的会话。会话期间，MySQL服务实例会在MySQL服务器内存中生成与该会话对应的会话系统变量，这些会话系统变量的初始值是全局系统变量值的复制。如下图：</p><p><img src="/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC16%E7%AB%A0_%E5%8F%98%E9%87%8F%E3%80%81%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%B8%B8%E6%A0%87/image-20211108114846634.png" alt="image-20211108114846634"></p><ul><li>全局系统变量针对于所有会话（连接）有效，但<code>不能跨重启</code></li><li>会话系统变量仅针对于当前会话（连接）有效。会话期间，当前会话对某个会话系统变量值的修改，不会影响其他会话同一个会话系统变量的值。</li><li>会话1对某个全局系统变量值的修改会导致会话2中同一个全局系统变量值的修改。</li></ul><p>在MySQL中有些系统变量只能是全局的，例如 max_connections 用于限制服务器的最大连接数；有些系统变量作用域既可以是全局又可以是会话，例如 character_set_client 用于设置客户端的字符集；有些系统变量的作用域只能是当前会话，例如 pseudo_thread_id 用于标记当前会话的 MySQL 连接 ID。</p><h4 id="查看系统变量"><a href="#查看系统变量" class="headerlink" title="查看系统变量"></a>查看系统变量</h4><ul><li><strong>查看所有或部分系统变量</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看所有全局变量</span><br><span class="line">SHOW GLOBAL VARIABLES;</span><br><span class="line"></span><br><span class="line">#查看所有会话变量</span><br><span class="line">SHOW SESSION VARIABLES;</span><br><span class="line">或</span><br><span class="line">SHOW VARIABLES;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看满足条件的部分系统变量。</span><br><span class="line">SHOW GLOBAL VARIABLES LIKE &#x27;%标识符%&#x27;;</span><br><span class="line"></span><br><span class="line">#查看满足条件的部分会话变量</span><br><span class="line">SHOW SESSION VARIABLES LIKE &#x27;%标识符%&#x27;;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW GLOBAL VARIABLES LIKE &#x27;admin_%&#x27;;</span><br></pre></td></tr></table></figure><ul><li><strong>查看指定系统变量</strong></li></ul><p>作为 MySQL 编码规范，MySQL 中的系统变量以<code>两个“@”</code>开头，其中“@@global”仅用于标记全局系统变量，“@@session”仅用于标记会话系统变量。“@@”首先标记会话系统变量，如果会话系统变量不存在，则标记全局系统变量。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看指定的系统变量的值</span><br><span class="line">SELECT @@global.变量名;</span><br><span class="line"></span><br><span class="line">#查看指定的会话变量的值</span><br><span class="line">SELECT @@session.变量名;</span><br><span class="line">#或者</span><br><span class="line">SELECT @@变量名;</span><br></pre></td></tr></table></figure><ul><li><strong>修改系统变量的值</strong></li></ul><p>有些时候，数据库管理员需要修改系统变量的默认值，以便修改当前会话或者MySQL服务实例的属性、特征。具体方法：</p><p>方式1：修改MySQL<code>配置文件</code>，继而修改MySQL系统变量的值（该方法需要重启MySQL服务）</p><p>方式2：在MySQL服务运行期间，使用“set”命令重新设置系统变量的值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#为某个系统变量赋值</span><br><span class="line">#方式1：</span><br><span class="line">SET @@global.变量名=变量值;</span><br><span class="line">#方式2：</span><br><span class="line">SET GLOBAL 变量名=变量值;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#为某个会话变量赋值</span><br><span class="line">#方式1：</span><br><span class="line">SET @@session.变量名=变量值;</span><br><span class="line">#方式2：</span><br><span class="line">SET SESSION 变量名=变量值;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT @@global.autocommit;</span><br><span class="line">SET GLOBAL autocommit=0;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT @@session.tx_isolation;</span><br><span class="line">SET @@session.tx_isolation=&#x27;read-uncommitted&#x27;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET GLOBAL max_connections = 1000;</span><br><span class="line">SELECT @@global.max_connections;</span><br></pre></td></tr></table></figure><h3 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h3><h4 id="用户变量分类"><a href="#用户变量分类" class="headerlink" title="用户变量分类"></a>用户变量分类</h4><p>用户变量是用户自己定义的，作为 MySQL 编码规范，MySQL 中的用户变量以<code>一个“@”</code>开头。根据作用范围不同，又分为<code>会话用户变量</code>和<code>局部变量</code>。</p><ul><li><p>会话用户变量：作用域和会话变量一样，只对<code>当前连接</code>会话有效。</p></li><li><p>局部变量：只在 BEGIN 和 END 语句块中有效。局部变量只能在<code>存储过程和函数</code>中使用。</p></li></ul><h4 id="会话用户变量"><a href="#会话用户变量" class="headerlink" title="会话用户变量"></a>会话用户变量</h4><ul><li>变量的定义</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#方式1：“=”或“:=”</span><br><span class="line">SET @用户变量 = 值;</span><br><span class="line">SET @用户变量 := 值;</span><br><span class="line"></span><br><span class="line">#方式2：“:=” 或 INTO关键字</span><br><span class="line">SELECT @用户变量 := 表达式 [FROM 等子句];</span><br><span class="line">SELECT 表达式 INTO @用户变量  [FROM 等子句];</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>查看用户变量的值 （查看、比较、运算等）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT @用户变量</span><br></pre></td></tr></table></figure><ul><li>举例</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET @a = 1;</span><br><span class="line"></span><br><span class="line">SELECT @a;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT @num := COUNT(*) FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT @num;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT AVG(salary) INTO @avgsalary FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT @avgsalary;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT @big;  #查看某个未声明的变量时，将得到NULL值</span><br></pre></td></tr></table></figure><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>定义：可以使用<code>DECLARE</code>语句定义一个局部变量</p><p>作用域：仅仅在定义它的 BEGIN … END 中有效</p><p>位置：只能放在 BEGIN … END 中，而且只能放在第一句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">#声明局部变量</span><br><span class="line">DECLARE 变量名1 变量数据类型 [DEFAULT 变量默认值];</span><br><span class="line">DECLARE 变量名2,变量名3,... 变量数据类型 [DEFAULT 变量默认值];</span><br><span class="line"></span><br><span class="line">#为局部变量赋值</span><br><span class="line">SET 变量名1 = 值;</span><br><span class="line">SELECT 值 INTO 变量名2 [FROM 子句];</span><br><span class="line"></span><br><span class="line">#查看局部变量的值</span><br><span class="line">SELECT 变量1,变量2,变量3;</span><br><span class="line">END</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>1.定义变量</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE 变量名 类型 [default 值];  # 如果没有DEFAULT子句，初始值为NULL</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE　myparam　INT　DEFAULT 100;</span><br></pre></td></tr></table></figure><p><strong>2.变量赋值</strong></p><p>方式1：一般用于赋简单的值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET 变量名=值;</span><br><span class="line">SET 变量名:=值;</span><br></pre></td></tr></table></figure><p>方式2：一般用于赋表中的字段值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段名或表达式 INTO 变量名 FROM 表;</span><br></pre></td></tr></table></figure><p><strong>3.使用变量</strong>（查看、比较、运算等）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 局部变量名;</span><br></pre></td></tr></table></figure><p>举例1：声明局部变量，并分别赋值为employees表中employee_id为102的last_name和salary</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE set_value()</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE emp_name VARCHAR(25);</span><br><span class="line">DECLARE sal DOUBLE(10,2);</span><br><span class="line"></span><br><span class="line">SELECT last_name,salary INTO emp_name,sal</span><br><span class="line">FROM employees </span><br><span class="line">WHERE employee_id = 102;</span><br><span class="line"></span><br><span class="line">SELECT emp_name,sal;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>举例2：声明两个变量，求和并打印 （分别使用会话用户变量、局部变量的方式实现）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#方式1：使用用户变量</span><br><span class="line">SET @m=1;</span><br><span class="line">SET @n=1;</span><br><span class="line">SET @sum=@m+@n;</span><br><span class="line"></span><br><span class="line">SELECT @sum;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#方式2：使用局部变量</span><br><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE add_value()</span><br><span class="line">BEGIN</span><br><span class="line">#局部变量</span><br><span class="line">DECLARE m INT DEFAULT 1;</span><br><span class="line">DECLARE n INT DEFAULT 3;</span><br><span class="line">DECLARE SUM INT;</span><br><span class="line"></span><br><span class="line">SET SUM = m+n;</span><br><span class="line">SELECT SUM;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>举例3：创建存储过程“different_salary”查询某员工和他领导的薪资差距，并用IN参数emp_id接收员工id，用OUT参数dif_salary输出薪资差距结果。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#声明</span><br><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE different_salary(IN emp_id INT,OUT dif_salary DOUBLE)</span><br><span class="line">BEGIN</span><br><span class="line">#声明局部变量</span><br><span class="line">DECLARE emp_sal,mgr_sal DOUBLE DEFAULT 0.0;</span><br><span class="line">DECLARE mgr_id INT;</span><br><span class="line"></span><br><span class="line">SELECT salary INTO emp_sal FROM employees WHERE employee_id = emp_id;</span><br><span class="line">SELECT manager_id INTO mgr_id FROM employees WHERE employee_id = emp_id;</span><br><span class="line">SELECT salary INTO mgr_sal FROM employees WHERE employee_id = mgr_id;</span><br><span class="line">SET dif_salary = mgr_sal - emp_sal;</span><br><span class="line"></span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">#调用</span><br><span class="line">SET @emp_id = 102;</span><br><span class="line">CALL different_salary(@emp_id,@diff_sal);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line">SELECT @diff_sal;</span><br></pre></td></tr></table></figure><h4 id="对比会话用户变量与局部变量"><a href="#对比会话用户变量与局部变量" class="headerlink" title="对比会话用户变量与局部变量"></a>对比会话用户变量与局部变量</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  作用域定义位置  语法</span><br><span class="line">会话用户变量  当前会话   会话的任何地方加@符号，不用指定类型</span><br><span class="line">局部变量   定义它的BEGIN END中 BEGIN END的第一句话  一般不用加@,需要指定类型</span><br></pre></td></tr></table></figure><h2 id="定义条件与处理程序"><a href="#定义条件与处理程序" class="headerlink" title="定义条件与处理程序"></a>定义条件与处理程序</h2><p><code>定义条件</code>是事先定义程序执行过程中可能遇到的问题，<code>处理程序</code>定义了在遇到问题时应当采取的处理方式，并且保证存储过程或函数在遇到警告或错误时能继续执行。这样可以增强存储程序处理问题的能力，避免程序异常停止运行。</p><p>说明：定义条件和处理程序在存储过程、存储函数中都是支持的。</p><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><p><strong>案例分析：</strong>创建一个名称为“UpdateDataNoCondition”的存储过程。代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE UpdateDataNoCondition()</span><br><span class="line">BEGIN</span><br><span class="line">SET @x = 1;</span><br><span class="line">UPDATE employees SET email = NULL WHERE last_name = &#x27;Abel&#x27;;</span><br><span class="line">SET @x = 2;</span><br><span class="line">UPDATE employees SET email = &#x27;aabbel&#x27; WHERE last_name = &#x27;Abel&#x27;;</span><br><span class="line">SET @x = 3;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>调用存储过程：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CALL UpdateDataNoCondition();</span><br><span class="line">ERROR 1048 (23000): Column &#x27;email&#x27; cannot be null</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT @x;</span><br><span class="line">+------+</span><br><span class="line">| @x   |</span><br><span class="line">+------+</span><br><span class="line">|   1  |</span><br><span class="line">+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，此时@x变量的值为1。结合创建存储过程的SQL语句代码可以得出：在存储过程中未定义条件和处理程序，且当存储过程中执行的SQL语句报错时，MySQL数据库会抛出错误，并退出当前SQL逻辑，不再向下继续执行。</p><h3 id="定义条件"><a href="#定义条件" class="headerlink" title="定义条件"></a>定义条件</h3><p>定义条件就是给MySQL中的错误码命名，这有助于存储的程序代码更清晰。它将一个<code>错误名字</code>和<code>指定的错误条件</code>关联起来。这个名字可以随后被用在定义处理程序的<code>DECLARE HANDLER</code>语句中。</p><p>定义条件使用DECLARE语句，语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE 错误名称 CONDITION FOR 错误码（或错误条件）</span><br></pre></td></tr></table></figure><p>错误码的说明：</p><ul><li><code>MySQL_error_code</code>和<code>sqlstate_value</code>都可以表示MySQL的错误。<ul><li>MySQL_error_code是数值类型错误代码。</li><li>sqlstate_value是长度为5的字符串类型错误代码。</li></ul></li><li>例如，在ERROR 1418 (HY000)中，1418是MySQL_error_code，’HY000’是sqlstate_value。</li><li>例如，在ERROR 1142（42000）中，1142是MySQL_error_code，’42000’是sqlstate_value。</li></ul><p><strong>举例1：</strong>定义“Field_Not_Be_NULL”错误名与MySQL中违反非空约束的错误类型是“ERROR 1048 (23000)”对应。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#使用MySQL_error_code</span><br><span class="line">DECLARE Field_Not_Be_NULL CONDITION FOR 1048;</span><br><span class="line"></span><br><span class="line">#使用sqlstate_value</span><br><span class="line">DECLARE Field_Not_Be_NULL CONDITION FOR SQLSTATE &#x27;23000&#x27;;</span><br></pre></td></tr></table></figure><p><strong>举例2：</strong>定义”ERROR 1148(42000)”错误，名称为command_not_allowed。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#使用MySQL_error_code</span><br><span class="line">DECLARE command_not_allowed CONDITION FOR 1148;</span><br><span class="line"></span><br><span class="line">#使用sqlstate_value</span><br><span class="line">DECLARE command_not_allowed CONDITION FOR SQLSTATE &#x27;42000&#x27;;</span><br></pre></td></tr></table></figure><h3 id="定义处理程序"><a href="#定义处理程序" class="headerlink" title="定义处理程序"></a>定义处理程序</h3><p>可以为SQL执行过程中发生的某种类型的错误定义特殊的处理程序。定义处理程序时，使用DECLARE语句的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE 处理方式 HANDLER FOR 错误类型 处理语句</span><br></pre></td></tr></table></figure><ul><li><strong>处理方式</strong>：处理方式有3个取值：CONTINUE、EXIT、UNDO。<ul><li><code>CONTINUE</code>：表示遇到错误不处理，继续执行。</li><li><code>EXIT</code>：表示遇到错误马上退出。</li><li><code>UNDO</code>：表示遇到错误后撤回之前的操作。MySQL中暂时不支持这样的操作。</li></ul></li><li><strong>错误类型</strong>（即条件）可以有如下取值：<ul><li><code>SQLSTATE &#39;字符串错误码&#39;</code>：表示长度为5的sqlstate_value类型的错误代码；</li><li><code>MySQL_error_code</code>：匹配数值类型错误代码；</li><li><code>错误名称</code>：表示DECLARE … CONDITION定义的错误条件名称。</li><li><code>SQLWARNING</code>：匹配所有以01开头的SQLSTATE错误代码；</li><li><code>NOT FOUND</code>：匹配所有以02开头的SQLSTATE错误代码；</li><li><code>SQLEXCEPTION</code>：匹配所有没有被SQLWARNING或NOT FOUND捕获的SQLSTATE错误代码；</li></ul></li><li><strong>处理语句</strong>：如果出现上述条件之一，则采用对应的处理方式，并执行指定的处理语句。语句可以是像“<code>SET 变量 = 值</code>”这样的简单语句，也可以是使用<code>BEGIN ... END</code>编写的复合语句。</li></ul><p>定义处理程序的几种方式，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#方法1：捕获sqlstate_value</span><br><span class="line">DECLARE CONTINUE HANDLER FOR SQLSTATE &#x27;42S02&#x27; SET @info = &#x27;NO_SUCH_TABLE&#x27;;</span><br><span class="line"></span><br><span class="line">#方法2：捕获mysql_error_value</span><br><span class="line">DECLARE CONTINUE HANDLER FOR 1146 SET @info = &#x27;NO_SUCH_TABLE&#x27;;</span><br><span class="line"></span><br><span class="line">#方法3：先定义条件，再调用</span><br><span class="line">DECLARE no_such_table CONDITION FOR 1146;</span><br><span class="line">DECLARE CONTINUE HANDLER FOR NO_SUCH_TABLE SET @info = &#x27;NO_SUCH_TABLE&#x27;;</span><br><span class="line"></span><br><span class="line">#方法4：使用SQLWARNING</span><br><span class="line">DECLARE EXIT HANDLER FOR SQLWARNING SET @info = &#x27;ERROR&#x27;;</span><br><span class="line"></span><br><span class="line">#方法5：使用NOT FOUND</span><br><span class="line">DECLARE EXIT HANDLER FOR NOT FOUND SET @info = &#x27;NO_SUCH_TABLE&#x27;;</span><br><span class="line"></span><br><span class="line">#方法6：使用SQLEXCEPTION</span><br><span class="line">DECLARE EXIT HANDLER FOR SQLEXCEPTION SET @info = &#x27;ERROR&#x27;;</span><br></pre></td></tr></table></figure><h3 id="案例解决"><a href="#案例解决" class="headerlink" title="案例解决"></a>案例解决</h3><p>在存储过程中，定义处理程序，捕获sqlstate_value值，当遇到MySQL_error_code值为1048时，执行CONTINUE操作，并且将@proc_value的值设置为-1。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE UpdateDataNoCondition()</span><br><span class="line">BEGIN</span><br><span class="line">#定义处理程序</span><br><span class="line">DECLARE CONTINUE HANDLER FOR 1048 SET @proc_value = -1;</span><br><span class="line"></span><br><span class="line">SET @x = 1;</span><br><span class="line">UPDATE employees SET email = NULL WHERE last_name = &#x27;Abel&#x27;;</span><br><span class="line">SET @x = 2;</span><br><span class="line">UPDATE employees SET email = &#x27;aabbel&#x27; WHERE last_name = &#x27;Abel&#x27;;</span><br><span class="line">SET @x = 3;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>调用过程：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CALL UpdateDataWithCondition();</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT @x,@proc_value;</span><br><span class="line">+------+-------------+</span><br><span class="line">| @x   | @proc_value |</span><br><span class="line">+------+-------------+</span><br><span class="line">|    3 |        -1  |</span><br><span class="line">+------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>举例：</strong></p><p>创建一个名称为“InsertDataWithCondition”的存储过程，代码如下。</p><p>在存储过程中，定义处理程序，捕获sqlstate_value值，当遇到sqlstate_value值为23000时，执行EXIT操作，并且将@proc_value的值设置为-1。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#准备工作</span><br><span class="line">CREATE TABLE departments</span><br><span class="line">AS</span><br><span class="line">SELECT * FROM atguigudb.`departments`;</span><br><span class="line"></span><br><span class="line">ALTER TABLE departments</span><br><span class="line">ADD CONSTRAINT uk_dept_name UNIQUE(department_id);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE InsertDataWithCondition()</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE duplicate_entry CONDITION FOR SQLSTATE &#x27;23000&#x27; ;</span><br><span class="line">DECLARE EXIT HANDLER FOR duplicate_entry SET @proc_value = -1;</span><br><span class="line"></span><br><span class="line">SET @x = 1;</span><br><span class="line">INSERT INTO departments(department_name) VALUES(&#x27;测试&#x27;);</span><br><span class="line">SET @x = 2;</span><br><span class="line">INSERT INTO departments(department_name) VALUES(&#x27;测试&#x27;);</span><br><span class="line">SET @x = 3;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>调用存储过程：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CALL InsertDataWithCondition();</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT @x,@proc_value;</span><br><span class="line">+------+-------------+</span><br><span class="line">| @x   | @proc_value |</span><br><span class="line">+------+-------------+</span><br><span class="line">|    2 |        -1  |</span><br><span class="line">+------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>解决复杂问题不可能通过一个 SQL 语句完成，我们需要执行多个 SQL 操作。流程控制语句的作用就是控制存储过程中 SQL 语句的执行顺序，是我们完成复杂操作必不可少的一部分。只要是执行的程序，流程就分为三大类：</p><ul><li><code>顺序结构</code>：程序从上往下依次执行</li><li><code>分支结构</code>：程序按条件进行选择执行，从两条或多条路径中选择一条执行</li><li><code>循环结构</code>：程序满足一定条件下，重复执行一组语句</li></ul><p>针对于MySQL 的流程控制语句主要有 3 类。注意：只能用于存储程序。</p><ul><li><code>条件判断语句</code>：IF 语句和 CASE 语句</li><li><code>循环语句</code>：LOOP、WHILE 和 REPEAT 语句</li><li><code>跳转语句</code>：ITERATE 和 LEAVE 语句</li></ul><h3 id="分支结构之-IF"><a href="#分支结构之-IF" class="headerlink" title="分支结构之 IF"></a>分支结构之 IF</h3><ul><li>IF 语句的语法结构是：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IF 表达式1 THEN 操作1</span><br><span class="line">[ELSEIF 表达式2 THEN 操作2]……</span><br><span class="line">[ELSE 操作N]</span><br><span class="line">END IF</span><br></pre></td></tr></table></figure><p>根据表达式的结果为TRUE或FALSE执行相应的语句。这里“[]”中的内容是可选的。</p><ul><li><p>特点：① 不同的表达式对应不同的操作 ② 使用在begin end中</p></li><li><p><strong>举例1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IF val IS NULL </span><br><span class="line">THEN SELECT &#x27;val is null&#x27;;</span><br><span class="line">ELSE SELECT &#x27;val is not null&#x27;;</span><br><span class="line"></span><br><span class="line">END IF;</span><br></pre></td></tr></table></figure></li><li><p><strong>举例2：</strong>声明存储过程“update_salary_by_eid1”，定义IN参数emp_id，输入员工编号。判断该员工薪资如果低于8000元并且入职时间超过5年，就涨薪500元；否则就不变。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE update_salary_by_eid1(IN emp_id INT)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE emp_salary DOUBLE;</span><br><span class="line">DECLARE hire_year DOUBLE;</span><br><span class="line"></span><br><span class="line">SELECT salary INTO emp_salary FROM employees WHERE employee_id = emp_id;</span><br><span class="line"></span><br><span class="line">SELECT DATEDIFF(CURDATE(),hire_date)/365 INTO hire_year</span><br><span class="line">FROM employees WHERE employee_id = emp_id;</span><br><span class="line"></span><br><span class="line">IF emp_salary &lt; 8000 AND hire_year &gt; 5</span><br><span class="line">THEN UPDATE employees SET salary = salary + 500 WHERE employee_id = emp_id;</span><br><span class="line">END IF;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure></li><li><p><strong>举例3：</strong>声明存储过程“update_salary_by_eid2”，定义IN参数emp_id，输入员工编号。判断该员工薪资如果低于9000元并且入职时间超过5年，就涨薪500元；否则就涨薪100元。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE update_salary_by_eid2(IN emp_id INT)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE emp_salary DOUBLE;</span><br><span class="line">DECLARE hire_year DOUBLE;</span><br><span class="line"></span><br><span class="line">SELECT salary INTO emp_salary FROM employees WHERE employee_id = emp_id;</span><br><span class="line"></span><br><span class="line">SELECT DATEDIFF(CURDATE(),hire_date)/365 INTO hire_year</span><br><span class="line">FROM employees WHERE employee_id = emp_id;</span><br><span class="line"></span><br><span class="line">IF emp_salary &lt; 8000 AND hire_year &gt; 5</span><br><span class="line">THEN UPDATE employees SET salary = salary + 500 WHERE employee_id = emp_id;</span><br><span class="line">ELSE </span><br><span class="line">UPDATE employees SET salary = salary + 100 WHERE employee_id = emp_id;</span><br><span class="line">END IF;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure></li><li><p><strong>举例4：</strong>声明存储过程“update_salary_by_eid3”，定义IN参数emp_id，输入员工编号。判断该员工薪资如果低于9000元，就更新薪资为9000元；薪资如果大于等于9000元且低于10000的，但是奖金比例为NULL的，就更新奖金比例为0.01；其他的涨薪100元。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE update_salary_by_eid3(IN emp_id INT)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE emp_salary DOUBLE;</span><br><span class="line">DECLARE bonus DECIMAL(3,2);</span><br><span class="line"></span><br><span class="line">SELECT salary INTO emp_salary FROM employees WHERE employee_id = emp_id;</span><br><span class="line">SELECT commission_pct INTO bonus FROM employees WHERE employee_id = emp_id;</span><br><span class="line"></span><br><span class="line">IF emp_salary &lt; 9000</span><br><span class="line">THEN UPDATE employees SET salary = 9000 WHERE employee_id = emp_id;</span><br><span class="line">ELSEIF emp_salary &lt; 10000 AND bonus IS NULL</span><br><span class="line">THEN UPDATE employees SET commission_pct = 0.01 WHERE employee_id = emp_id;</span><br><span class="line">ELSE</span><br><span class="line">UPDATE employees SET salary = salary + 100 WHERE employee_id = emp_id;</span><br><span class="line">END IF;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-分支结构之-CASE"><a href="#3-2-分支结构之-CASE" class="headerlink" title="3.2 分支结构之 CASE"></a>3.2 分支结构之 CASE</h3><p>CASE 语句的语法结构1：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#情况一：类似于switch</span><br><span class="line">CASE 表达式</span><br><span class="line">WHEN 值1 THEN 结果1或语句1(如果是语句，需要加分号) </span><br><span class="line">WHEN 值2 THEN 结果2或语句2(如果是语句，需要加分号)</span><br><span class="line">...</span><br><span class="line">ELSE 结果n或语句n(如果是语句，需要加分号)</span><br><span class="line">END [case]（如果是放在begin end中需要加上case，如果放在select后面不需要）</span><br></pre></td></tr></table></figure><p>CASE 语句的语法结构2：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#情况二：类似于多重if</span><br><span class="line">CASE </span><br><span class="line">WHEN 条件1 THEN 结果1或语句1(如果是语句，需要加分号) </span><br><span class="line">WHEN 条件2 THEN 结果2或语句2(如果是语句，需要加分号)</span><br><span class="line">...</span><br><span class="line">ELSE 结果n或语句n(如果是语句，需要加分号)</span><br><span class="line">END [case]（如果是放在begin end中需要加上case，如果放在select后面不需要）</span><br></pre></td></tr></table></figure><ul><li><strong>举例1：</strong></li></ul><p>使用CASE流程控制语句的第1种格式，判断val值等于1、等于2，或者两者都不等。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CASE val</span><br><span class="line">　　　WHEN 1 THEN SELECT &#x27;val is 1&#x27;;</span><br><span class="line">　　　WHEN 2 THEN SELECT &#x27;val is 2&#x27;;</span><br><span class="line">　　　ELSE SELECT &#x27;val is not 1 or 2&#x27;;</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure><ul><li><strong>举例2：</strong></li></ul><p>使用CASE流程控制语句的第2种格式，判断val是否为空、小于0、大于0或者等于0。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CASE</span><br><span class="line">WHEN val IS NULL THEN SELECT &#x27;val is null&#x27;;</span><br><span class="line">WHEN val &lt; 0 THEN SELECT &#x27;val is less than 0&#x27;;</span><br><span class="line">WHEN val &gt; 0 THEN SELECT &#x27;val is greater than 0&#x27;;</span><br><span class="line">ELSE SELECT &#x27;val is 0&#x27;;</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure><ul><li><strong>举例3：</strong>声明存储过程“update_salary_by_eid4”，定义IN参数emp_id，输入员工编号。判断该员工薪资如果低于9000元，就更新薪资为9000元；薪资大于等于9000元且低于10000的，但是奖金比例为NULL的，就更新奖金比例为0.01；其他的涨薪100元。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE update_salary_by_eid4(IN emp_id INT)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE emp_sal DOUBLE;</span><br><span class="line">DECLARE bonus DECIMAL(3,2);</span><br><span class="line"></span><br><span class="line">SELECT salary INTO emp_sal FROM employees WHERE employee_id = emp_id;</span><br><span class="line">SELECT commission_pct INTO bonus FROM employees WHERE employee_id = emp_id;</span><br><span class="line"></span><br><span class="line">CASE</span><br><span class="line">WHEN emp_sal&lt;9000</span><br><span class="line">THEN UPDATE employees SET salary=9000 WHERE employee_id = emp_id;</span><br><span class="line">WHEN emp_sal&lt;10000 AND bonus IS NULL</span><br><span class="line">THEN UPDATE employees SET commission_pct=0.01 WHERE employee_id = emp_id;</span><br><span class="line">ELSE</span><br><span class="line">UPDATE employees SET salary=salary+100 WHERE employee_id = emp_id;</span><br><span class="line">END CASE;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><ul><li>举例4：声明存储过程update_salary_by_eid5，定义IN参数emp_id，输入员工编号。判断该员工的入职年限，如果是0年，薪资涨50；如果是1年，薪资涨100；如果是2年，薪资涨200；如果是3年，薪资涨300；如果是4年，薪资涨400；其他的涨薪500。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE update_salary_by_eid5(IN emp_id INT)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE emp_sal DOUBLE;</span><br><span class="line">DECLARE hire_year DOUBLE;</span><br><span class="line"></span><br><span class="line">SELECT salary INTO emp_sal FROM employees WHERE employee_id = emp_id;</span><br><span class="line"></span><br><span class="line">SELECT ROUND(DATEDIFF(CURDATE(),hire_date)/365) INTO hire_year FROM employees WHERE employee_id = emp_id;</span><br><span class="line"></span><br><span class="line">CASE hire_year</span><br><span class="line">WHEN 0 THEN UPDATE employees SET salary=salary+50 WHERE employee_id = emp_id;</span><br><span class="line">WHEN 1 THEN UPDATE employees SET salary=salary+100 WHERE employee_id = emp_id;</span><br><span class="line">WHEN 2 THEN UPDATE employees SET salary=salary+200 WHERE employee_id = emp_id;</span><br><span class="line">WHEN 3 THEN UPDATE employees SET salary=salary+300 WHERE employee_id = emp_id;</span><br><span class="line">WHEN 4 THEN UPDATE employees SET salary=salary+400 WHERE employee_id = emp_id;</span><br><span class="line">ELSE UPDATE employees SET salary=salary+500 WHERE employee_id = emp_id;</span><br><span class="line">END CASE;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h3 id="循环结构之LOOP"><a href="#循环结构之LOOP" class="headerlink" title="循环结构之LOOP"></a>循环结构之LOOP</h3><p>LOOP循环语句用来重复执行某些语句。LOOP内的语句一直重复执行直到循环被退出（使用LEAVE子句），跳出循环过程。</p><p>LOOP语句的基本格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[loop_label:] LOOP</span><br><span class="line">循环执行的语句</span><br><span class="line">END LOOP [loop_label]</span><br></pre></td></tr></table></figure><p>其中，loop_label表示LOOP语句的标注名称，该参数可以省略。</p><p><strong>举例1：</strong></p><p>使用LOOP语句进行循环操作，id值小于10时将重复执行循环过程。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE id INT DEFAULT 0;</span><br><span class="line">add_loop:LOOP</span><br><span class="line">SET id = id +1;</span><br><span class="line">IF id &gt;= 10 THEN LEAVE add_loop;</span><br><span class="line">END IF;</span><br><span class="line"></span><br><span class="line">END LOOP add_loop;</span><br></pre></td></tr></table></figure><p><strong>举例2：</strong>当市场环境变好时，公司为了奖励大家，决定给大家涨工资。声明存储过程“update_salary_loop()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家涨薪，薪资涨为原来的1.1倍。直到全公司的平均薪资达到12000结束。并统计循环次数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE update_salary_loop(OUT num INT)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE avg_salary DOUBLE;</span><br><span class="line">DECLARE loop_count INT DEFAULT 0;</span><br><span class="line"></span><br><span class="line">SELECT AVG(salary) INTO avg_salary FROM employees;</span><br><span class="line"></span><br><span class="line">label_loop:LOOP</span><br><span class="line">IF avg_salary &gt;= 12000 THEN LEAVE label_loop;</span><br><span class="line">END IF;</span><br><span class="line"></span><br><span class="line">UPDATE employees SET salary = salary * 1.1;</span><br><span class="line">SET loop_count = loop_count + 1;</span><br><span class="line">SELECT AVG(salary) INTO avg_salary FROM employees;</span><br><span class="line">END LOOP label_loop;</span><br><span class="line"></span><br><span class="line">SET num = loop_count;</span><br><span class="line"></span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h3 id="循环结构之WHILE"><a href="#循环结构之WHILE" class="headerlink" title="循环结构之WHILE"></a>循环结构之WHILE</h3><p>WHILE语句创建一个带条件判断的循环过程。WHILE在执行语句执行时，先对指定的表达式进行判断，如果为真，就执行循环内的语句，否则退出循环。WHILE语句的基本格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[while_label:] WHILE 循环条件  DO</span><br><span class="line">循环体</span><br><span class="line">END WHILE [while_label];</span><br></pre></td></tr></table></figure><p>while_label为WHILE语句的标注名称；如果循环条件结果为真，WHILE语句内的语句或语句群被执行，直至循环条件为假，退出循环。</p><p><strong>举例1：</strong></p><p>WHILE语句示例，i值小于10时，将重复执行循环过程，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE test_while()</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line"></span><br><span class="line">WHILE i &lt; 10 DO</span><br><span class="line">SET i = i + 1;</span><br><span class="line">END WHILE;</span><br><span class="line"></span><br><span class="line">SELECT i;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line">#调用</span><br><span class="line">CALL test_while();</span><br></pre></td></tr></table></figure><p><strong>举例2：</strong>市场环境不好时，公司为了渡过难关，决定暂时降低大家的薪资。声明存储过程“update_salary_while()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家降薪，薪资降为原来的90%。直到全公司的平均薪资达到5000结束。并统计循环次数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE update_salary_while(OUT num INT)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE avg_sal DOUBLE ;</span><br><span class="line">DECLARE while_count INT DEFAULT 0;</span><br><span class="line"></span><br><span class="line">SELECT AVG(salary) INTO avg_sal FROM employees;</span><br><span class="line"></span><br><span class="line">WHILE avg_sal &gt; 5000 DO</span><br><span class="line">UPDATE employees SET salary = salary * 0.9;</span><br><span class="line"></span><br><span class="line">SET while_count = while_count + 1;</span><br><span class="line"></span><br><span class="line">SELECT AVG(salary) INTO avg_sal FROM employees;</span><br><span class="line">END WHILE;</span><br><span class="line"></span><br><span class="line">SET num = while_count;</span><br><span class="line"></span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h3 id="循环结构之REPEAT"><a href="#循环结构之REPEAT" class="headerlink" title="循环结构之REPEAT"></a>循环结构之REPEAT</h3><p>REPEAT语句创建一个带条件判断的循环过程。与WHILE循环不同的是，REPEAT 循环首先会执行一次循环，然后在 UNTIL 中进行表达式的判断，如果满足条件就退出，即 END REPEAT；如果条件不满足，则会就继续执行循环，直到满足退出条件为止。</p><p>REPEAT语句的基本格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[repeat_label:] REPEAT</span><br><span class="line">　　　　循环体的语句</span><br><span class="line">UNTIL 结束循环的条件表达式</span><br><span class="line">END REPEAT [repeat_label]</span><br></pre></td></tr></table></figure><p>repeat_label为REPEAT语句的标注名称，该参数可以省略；REPEAT语句内的语句或语句群被重复，直至expr_condition为真。</p><p><strong>举例1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE test_repeat()</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line"></span><br><span class="line">REPEAT </span><br><span class="line">SET i = i + 1;</span><br><span class="line">UNTIL i &gt;= 10</span><br><span class="line">END REPEAT;</span><br><span class="line"></span><br><span class="line">SELECT i;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p><strong>举例2：</strong>当市场环境变好时，公司为了奖励大家，决定给大家涨工资。声明存储过程“update_salary_repeat()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家涨薪，薪资涨为原来的1.15倍。直到全公司的平均薪资达到13000结束。并统计循环次数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE update_salary_repeat(OUT num INT)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE avg_sal DOUBLE ;</span><br><span class="line">DECLARE repeat_count INT DEFAULT 0;</span><br><span class="line"></span><br><span class="line">SELECT AVG(salary) INTO avg_sal FROM employees;</span><br><span class="line"></span><br><span class="line">REPEAT</span><br><span class="line">UPDATE employees SET salary = salary * 1.15;</span><br><span class="line"></span><br><span class="line">SET repeat_count = repeat_count + 1;</span><br><span class="line"></span><br><span class="line">SELECT AVG(salary) INTO avg_sal FROM employees;</span><br><span class="line">UNTIL avg_sal &gt;= 13000</span><br><span class="line">END REPEAT;</span><br><span class="line"></span><br><span class="line">SET num = repeat_count;</span><br><span class="line"></span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p><strong>对比三种循环结构：</strong></p><p>1、这三种循环都可以省略名称，但如果循环中添加了循环控制语句（LEAVE或ITERATE）则必须添加名称。<br>2、<br>LOOP：一般用于实现简单的”死”循环<br>WHILE：先判断后执行<br>REPEAT：先执行后判断，无条件至少执行一次</p><h3 id="跳转语句之LEAVE语句"><a href="#跳转语句之LEAVE语句" class="headerlink" title="跳转语句之LEAVE语句"></a>跳转语句之LEAVE语句</h3><p>LEAVE语句：可以用在循环语句内，或者以 BEGIN 和 END 包裹起来的程序体内，表示跳出循环或者跳出程序体的操作。如果你有面向过程的编程语言的使用经验，你可以把 LEAVE 理解为 break。</p><p>基本格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LEAVE 标记名</span><br></pre></td></tr></table></figure><p>其中，label参数表示循环的标志。LEAVE和BEGIN … END或循环一起被使用。</p><p><strong>举例1：</strong>创建存储过程 “leave_begin()”，声明INT类型的IN参数num。给BEGIN…END加标记名，并在BEGIN…END中使用IF语句判断num参数的值。</p><ul><li>如果num&lt;=0，则使用LEAVE语句退出BEGIN…END；</li><li>如果num=1，则查询“employees”表的平均薪资；</li><li>如果num=2，则查询“employees”表的最低薪资；</li><li>如果num&gt;2，则查询“employees”表的最高薪资。</li></ul><p>IF语句结束后查询“employees”表的总人数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE leave_begin(IN num INT)</span><br><span class="line"></span><br><span class="line">begin_label: BEGIN</span><br><span class="line">IF num&lt;=0 </span><br><span class="line">THEN LEAVE begin_label;</span><br><span class="line">ELSEIF num=1 </span><br><span class="line">THEN SELECT AVG(salary) FROM employees;</span><br><span class="line">ELSEIF num=2 </span><br><span class="line">THEN SELECT MIN(salary) FROM employees;</span><br><span class="line">ELSE </span><br><span class="line">SELECT MAX(salary) FROM employees;</span><br><span class="line">END IF;</span><br><span class="line"></span><br><span class="line">SELECT COUNT(*) FROM employees;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p><strong>举例2：</strong></p><p>当市场环境不好时，公司为了渡过难关，决定暂时降低大家的薪资。声明存储过程“leave_while()”，声明OUT参数num，输出循环次数，存储过程中使用WHILE循环给大家降低薪资为原来薪资的90%，直到全公司的平均薪资小于等于10000，并统计循环次数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE leave_while(OUT num INT)</span><br><span class="line"></span><br><span class="line">BEGIN </span><br><span class="line">#</span><br><span class="line">DECLARE avg_sal DOUBLE;#记录平均工资</span><br><span class="line">DECLARE while_count INT DEFAULT 0; #记录循环次数</span><br><span class="line"></span><br><span class="line">SELECT AVG(salary) INTO avg_sal FROM employees; #① 初始化条件</span><br><span class="line"></span><br><span class="line">while_label:WHILE TRUE DO  #② 循环条件</span><br><span class="line"></span><br><span class="line">#③ 循环体</span><br><span class="line">IF avg_sal &lt;= 10000 THEN</span><br><span class="line">LEAVE while_label;</span><br><span class="line">END IF;</span><br><span class="line"></span><br><span class="line">UPDATE employees SET salary  = salary * 0.9;</span><br><span class="line">SET while_count = while_count + 1;</span><br><span class="line"></span><br><span class="line">#④ 迭代条件</span><br><span class="line">SELECT AVG(salary) INTO avg_sal FROM employees;</span><br><span class="line"></span><br><span class="line">END WHILE;</span><br><span class="line"></span><br><span class="line">#赋值</span><br><span class="line">SET num = while_count;</span><br><span class="line"></span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h3 id="跳转语句之ITERATE语句"><a href="#跳转语句之ITERATE语句" class="headerlink" title="跳转语句之ITERATE语句"></a>跳转语句之ITERATE语句</h3><p>ITERATE语句：只能用在循环语句（LOOP、REPEAT和WHILE语句）内，表示重新开始循环，将执行顺序转到语句段开头处。如果你有面向过程的编程语言的使用经验，你可以把 ITERATE 理解为 continue，意思为“再次循环”。</p><p>语句基本格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ITERATE label</span><br></pre></td></tr></table></figure><p>label参数表示循环的标志。ITERATE语句必须跟在循环标志前面。</p><p><strong>举例：</strong>  定义局部变量num，初始值为0。循环结构中执行num + 1操作。</p><ul><li>如果num &lt; 10，则继续执行循环；</li><li>如果num &gt; 15，则退出循环结构；</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE test_iterate()</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line">DECLARE num INT DEFAULT 0;</span><br><span class="line"></span><br><span class="line">my_loop:LOOP</span><br><span class="line">SET num = num + 1;</span><br><span class="line"></span><br><span class="line">IF num &lt; 10 </span><br><span class="line">THEN ITERATE my_loop;</span><br><span class="line">ELSEIF num &gt; 15 </span><br><span class="line">THEN LEAVE my_loop;</span><br><span class="line">END IF;</span><br><span class="line"></span><br><span class="line">SELECT &#x27;尚硅谷：让天下没有难学的技术&#x27;;</span><br><span class="line"></span><br><span class="line">END LOOP my_loop;</span><br><span class="line"></span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><h3 id="什么是游标（或光标）"><a href="#什么是游标（或光标）" class="headerlink" title="什么是游标（或光标）"></a>什么是游标（或光标）</h3><p>虽然我们也可以通过筛选条件 WHERE 和 HAVING，或者是限定返回记录的关键字 LIMIT 返回一条记录，但是，却无法在结果集中像指针一样，向前定位一条记录、向后定位一条记录，或者是<code>随意定位到某一条记录</code>，并对记录的数据进行处理。</p><p>这个时候，就可以用到游标。游标，提供了一种灵活的操作方式，让我们能够对结果集中的每一条记录进行定位，并对指向的记录中的数据进行操作的数据结构。<strong>游标让 SQL 这种面向集合的语言有了面向过程开发的能力。</strong></p><p>在 SQL 中，游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。这里游标<code>充当了指针的作用</code>，我们可以通过操作游标来对数据行进行操作。</p><p>MySQL中游标可以在存储过程和函数中使用。</p><p>比如，我们查询了 employees 数据表中工资高于15000的员工都有哪些：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee_id,last_name,salary FROM employees</span><br><span class="line">WHERE salary &gt; 15000;</span><br></pre></td></tr></table></figure><p> <img src="/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC16%E7%AB%A0_%E5%8F%98%E9%87%8F%E3%80%81%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%B8%B8%E6%A0%87/image-20211111182656990.png" alt="image-20211111182656990"></p><p>这里我们就可以通过游标来操作数据行，如图所示此时游标所在的行是“108”的记录，我们也可以在结果集上滚动游标，指向结果集中的任意一行。</p><h3 id="使用游标步骤"><a href="#使用游标步骤" class="headerlink" title="使用游标步骤"></a>使用游标步骤</h3><p>游标必须在声明处理程序之前被声明，并且变量和条件还必须在声明游标或处理程序之前被声明。</p><p>如果我们想要使用游标，一般需要经历四个步骤。不同的 DBMS 中，使用游标的语法可能略有不同。</p><p><strong>第一步，声明游标</strong></p><p>在MySQL中，使用DECLARE关键字来声明游标，其语法的基本形式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE cursor_name CURSOR FOR select_statement; </span><br></pre></td></tr></table></figure><p>这个语法适用于 MySQL，SQL Server，DB2 和 MariaDB。如果是用 Oracle 或者 PostgreSQL，需要写成：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE cursor_name CURSOR IS select_statement;</span><br></pre></td></tr></table></figure><p>要使用 SELECT 语句来获取数据结果集，而此时还没有开始遍历数据，这里 select_statement 代表的是 SELECT 语句，返回一个用于创建游标的结果集。</p><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE cur_emp CURSOR FOR </span><br><span class="line">SELECT employee_id,salary FROM employees;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE cursor_fruit CURSOR FOR </span><br><span class="line">SELECT f_name, f_price FROM fruits ;</span><br></pre></td></tr></table></figure><p><strong>第二步，打开游标</strong></p><p>打开游标的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OPEN cursor_name</span><br></pre></td></tr></table></figure><p>当我们定义好游标之后，如果想要使用游标，必须先打开游标。打开游标的时候 SELECT 语句的查询结果集就会送到游标工作区，为后面游标的<code>逐条读取</code>结果集中的记录做准备。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OPEN　cur_emp ;</span><br></pre></td></tr></table></figure><p><strong>第三步，使用游标（从游标中取得数据）</strong></p><p>语法如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FETCH cursor_name INTO var_name [, var_name] ...</span><br></pre></td></tr></table></figure><p>这句的作用是使用 cursor_name 这个游标来读取当前行，并且将数据保存到 var_name 这个变量中，游标指针指到下一行。如果游标读取的数据行有多个列名，则在 INTO 关键字后面赋值给多个变量名即可。</p><p>注意：var_name必须在声明游标之前就定义好。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FETCH　cur_emp INTO emp_id, emp_sal ;</span><br></pre></td></tr></table></figure><p>注意：<strong>游标的查询结果集中的字段数，必须跟 INTO 后面的变量数一致</strong>，否则，在存储过程执行的时候，MySQL 会提示错误。</p><p><strong>第四步，关闭游标</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLOSE cursor_name</span><br></pre></td></tr></table></figure><p>有 OPEN 就会有 CLOSE，也就是打开和关闭游标。当我们使用完游标后需要关闭掉该游标。因为游标会<code>占用系统资源</code>，如果不及时关闭，<strong>游标会一直保持到存储过程结束</strong>，影响系统运行的效率。而关闭游标的操作，会释放游标占用的系统资源。</p><p>关闭游标之后，我们就不能再检索查询结果中的数据行，如果需要检索只能再次打开游标。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLOSE　cur_emp;</span><br></pre></td></tr></table></figure><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>创建存储过程“get_count_by_limit_total_salary()”，声明IN参数 limit_total_salary，DOUBLE类型；声明OUT参数total_count，INT类型。函数的功能可以实现累加薪资最高的几个员工的薪资值，直到薪资总和达到limit_total_salary参数的值，返回累加的人数给total_count。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE get_count_by_limit_total_salary(IN limit_total_salary DOUBLE,OUT total_count INT)</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line">DECLARE sum_salary DOUBLE DEFAULT 0;  #记录累加的总工资</span><br><span class="line">DECLARE cursor_salary DOUBLE DEFAULT 0; #记录某一个工资值</span><br><span class="line">DECLARE emp_count INT DEFAULT 0; #记录循环个数</span><br><span class="line">#定义游标</span><br><span class="line">DECLARE emp_cursor CURSOR FOR SELECT salary FROM employees ORDER BY salary DESC;</span><br><span class="line">#打开游标</span><br><span class="line">OPEN emp_cursor;</span><br><span class="line"></span><br><span class="line">REPEAT</span><br><span class="line">#使用游标（从游标中获取数据）</span><br><span class="line">FETCH emp_cursor INTO cursor_salary;</span><br><span class="line"></span><br><span class="line">SET sum_salary = sum_salary + cursor_salary;</span><br><span class="line">SET emp_count = emp_count + 1;</span><br><span class="line"></span><br><span class="line">UNTIL sum_salary &gt;= limit_total_salary</span><br><span class="line">END REPEAT;</span><br><span class="line"></span><br><span class="line">SET total_count = emp_count;</span><br><span class="line">#关闭游标</span><br><span class="line">CLOSE emp_cursor;</span><br><span class="line"></span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>游标是 MySQL 的一个重要的功能，为<code>逐条读取</code>结果集中的数据，提供了完美的解决方案。跟在应用层面实现相同的功能相比，游标可以在存储程序中使用，效率高，程序也更加简洁。</p><p>但同时也会带来一些性能问题，比如在使用游标的过程中，会对数据行进行<code>加锁</code>，这样在业务并发量大的时候，不仅会影响业务之间的效率，还会<code>消耗系统资源</code>，造成内存不足，这是因为游标是在内存中进行的处理。</p><p>建议：养成用完之后就关闭的习惯，这样才能提高系统的整体效率。</p><h2 id="补充：MySQL-8-0的新特性—全局变量的持久化"><a href="#补充：MySQL-8-0的新特性—全局变量的持久化" class="headerlink" title="补充：MySQL 8.0的新特性—全局变量的持久化"></a>补充：MySQL 8.0的新特性—全局变量的持久化</h2><p>在MySQL数据库中，全局变量可以通过SET GLOBAL语句来设置。例如，设置服务器语句超时的限制，可以通过设置系统变量max_execution_time来实现：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET GLOBAL MAX_EXECUTION_TIME=2000;</span><br></pre></td></tr></table></figure><p>使用SET GLOBAL语句设置的变量值只会<code>临时生效</code>。<code>数据库重启</code>后，服务器又会从MySQL配置文件中读取变量的默认值。<br>MySQL 8.0版本新增了<code>SET PERSIST</code>命令。例如，设置服务器的最大连接数为1000：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET PERSIST global max_connections = 1000;</span><br></pre></td></tr></table></figure><p>MySQL会将该命令的配置保存到数据目录下的<code>mysqld-auto.cnf</code>文件中，下次启动时会读取该文件，用其中的配置来覆盖默认的配置文件。</p><p>举例：</p><p>查看全局变量max_connections的值，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%max_connections%&#x27;;</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| Variable_name          | Value |</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| max_connections        | 151   |</span><br><span class="line">| mysqlx_max_connections | 100   |</span><br><span class="line">+------------------------+-------+</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>设置全局变量max_connections的值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; set persist max_connections=1000;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p><code>重启MySQL服务器</code>，再次查询max_connections的值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%max_connections%&#x27;;</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| Variable_name          | Value |</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| max_connections        | 1000  |</span><br><span class="line">| mysqlx_max_connections | 100   |</span><br><span class="line">+------------------------+-------+</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第16章-变量、流程控制与游标&quot;&gt;&lt;a href=&quot;#第16章-变量、流程控制与游标&quot; class=&quot;headerlink&quot; title=&quot;第16章_变量、流程控制与游标&quot;&gt;&lt;/a&gt;第16章_变量、流程控制与游标&lt;/h1&gt;&lt;p&gt;讲师：尚硅谷-宋红康（江湖人称：康师</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    <category term="基础版" scheme="http://example.com/categories/MySQL/%E5%9F%BA%E7%A1%80%E7%89%88/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>第15章_存储过程与函数</title>
    <link href="http://example.com/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC15%E7%AB%A0_%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC15%E7%AB%A0_%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%87%BD%E6%95%B0/</id>
    <published>2022-05-17T12:37:15.000Z</published>
    <updated>2022-05-17T13:02:20.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第15章-存储过程与函数"><a href="#第15章-存储过程与函数" class="headerlink" title="第15章_存储过程与函数"></a>第15章_存储过程与函数</h1><p>讲师：尚硅谷-宋红康（江湖人称：康师傅）</p><p>官网：<a href="http://www.atguigu.com/">http://www.atguigu.com</a></p><hr><p>MySQL从5.0版本开始支持存储过程和函数。存储过程和函数能够将复杂的SQL逻辑封装在一起，应用程序无须关注存储过程和函数内部复杂的SQL逻辑，而只需要简单地调用存储过程和函数即可。</p><h2 id="存储过程概述"><a href="#存储过程概述" class="headerlink" title="存储过程概述"></a>存储过程概述</h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p><strong>含义</strong>：存储过程的英文是 <code>Stored Procedure</code>。它的思想很简单，就是一组经过<code>预先编译</code>的 SQL 语句的封装。</p><p>执行过程：存储过程预先存储在 MySQL 服务器上，需要执行的时候，客户端只需要向服务器端发出调用存储过程的命令，服务器端就可以把预先存储好的这一系列 SQL 语句全部执行。</p><p><strong>好处</strong>：</p><p>1、简化操作，提高了sql语句的重用性，减少了开发程序员的压力<br>2、减少操作过程中的失误，提高效率<br>3、减少网络传输量（客户端不需要把所有的 SQL 语句通过网络发给服务器）<br>4、减少了 SQL 语句暴露在网上的风险，也提高了数据查询的安全性</p><p><strong>和视图、函数的对比</strong>：</p><p>它和视图有着同样的优点，清晰、安全，还可以减少网络传输量。不过它和视图不同，视图是<code>虚拟表</code>，通常不对底层数据表直接操作，而存储过程是程序化的 SQL，可以<code>直接操作底层数据表</code>，相比于面向集合的操作方式，能够实现一些更复杂的数据处理。</p><p>一旦存储过程被创建出来，使用它就像使用函数一样简单，我们直接通过调用存储过程名即可。相较于函数，存储过程是<code>没有返回值</code>的。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>存储过程的参数类型可以是IN、OUT和INOUT。根据这点分类如下：</p><p>1、没有参数（无参数无返回）<br>2、仅仅带 IN 类型（有参数无返回）<br>3、仅仅带 OUT 类型（无参数有返回）<br>4、既带 IN 又带 OUT（有参数有返回）<br>5、带 INOUT（有参数有返回）</p><p>注意：IN、OUT、INOUT 都可以在一个存储过程中带多个。</p><h2 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h2><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...)</span><br><span class="line">[characteristics ...]</span><br><span class="line">BEGIN</span><br><span class="line">存储过程体</span><br><span class="line"></span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>类似于Java中的方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 返回类型 方法名(参数类型 参数名,...)&#123;</span><br><span class="line"></span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><p>1、参数前面的符号的意思</p><ul><li><p><code>IN</code>：当前参数为输入参数，也就是表示入参；</p><p>存储过程只是读取这个参数的值。如果没有定义参数种类，<code>默认就是 IN</code>，表示输入参数。</p></li><li><p><code>OUT</code>：当前参数为输出参数，也就是表示出参；</p><p>执行完成之后，调用这个存储过程的客户端或者应用程序就可以读取这个参数返回的值了。</p></li><li><p><code>INOUT</code>：当前参数既可以为输入参数，也可以为输出参数。</p></li></ul><p>2、形参类型可以是 MySQL数据库中的任意类型。</p><p>3、<code>characteristics</code> 表示创建存储过程时指定的对存储过程的约束条件，其取值信息如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LANGUAGE SQL</span><br><span class="line">| [NOT] DETERMINISTIC</span><br><span class="line">| &#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125;</span><br><span class="line">| SQL SECURITY &#123; DEFINER | INVOKER &#125;</span><br><span class="line">| COMMENT &#x27;string&#x27;</span><br></pre></td></tr></table></figure><ul><li><code>LANGUAGE SQL</code>：说明存储过程执行体是由SQL语句组成的，当前系统支持的语言为SQL。</li><li><code>[NOT] DETERMINISTIC</code>：指明存储过程执行的结果是否确定。DETERMINISTIC表示结果是确定的。每次执行存储过程时，相同的输入会得到相同的输出。NOT DETERMINISTIC表示结果是不确定的，相同的输入可能得到不同的输出。如果没有指定任意一个值，默认为NOT DETERMINISTIC。</li><li><code>&#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125;</code>：指明子程序使用SQL语句的限制。<ul><li>CONTAINS SQL表示当前存储过程的子程序包含SQL语句，但是并不包含读写数据的SQL语句；</li><li>NO SQL表示当前存储过程的子程序中不包含任何SQL语句；</li><li>READS SQL DATA表示当前存储过程的子程序中包含读数据的SQL语句；</li><li>MODIFIES SQL DATA表示当前存储过程的子程序中包含写数据的SQL语句。</li><li>默认情况下，系统会指定为CONTAINS SQL。</li></ul></li><li><code>SQL SECURITY &#123; DEFINER | INVOKER &#125;</code>：执行当前存储过程的权限，即指明哪些用户能够执行当前存储过程。<ul><li><code>DEFINER</code>表示只有当前存储过程的创建者或者定义者才能执行当前存储过程；</li><li><code>INVOKER</code>表示拥有当前存储过程的访问权限的用户能够执行当前存储过程。</li><li>如果没有设置相关的值，则MySQL默认指定值为DEFINER。</li></ul></li><li><code>COMMENT &#39;string&#39;</code>：注释信息，可以用来描述存储过程。</li></ul><p>4、存储过程体中可以有多条 SQL 语句，如果仅仅一条SQL 语句，则可以省略 BEGIN 和 END</p><p>编写存储过程并不是一件简单的事情，可能存储过程中需要复杂的 SQL 语句。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. BEGIN…END：BEGIN…END 中间包含了多个语句，每个语句都以（;）号为结束符。</span><br><span class="line">2. DECLARE：DECLARE 用来声明变量，使用的位置在于 BEGIN…END 语句中间，而且需要在其他语句使用之前进行变量的声明。</span><br><span class="line">3. SET：赋值语句，用于对变量进行赋值。</span><br><span class="line">4. SELECT… INTO：把从数据表中查询的结果存放到变量中，也就是为变量赋值。</span><br></pre></td></tr></table></figure><p>5、需要设置新的结束标记</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER 新的结束标记</span><br></pre></td></tr></table></figure><p>因为MySQL默认的语句结束符号为分号‘;’。为了避免与存储过程中SQL语句结束符相冲突，需要使用DELIMITER改变存储过程的结束符。</p><p>比如：“DELIMITER //”语句的作用是将MySQL的结束符设置为//，并以“END //”结束存储过程。存储过程定义完毕之后再使用“DELIMITER ;”恢复默认结束符。DELIMITER也可以指定其他符号作为结束符。</p><p>当使用DELIMITER命令时，应该避免使用反斜杠（‘\’）字符，因为反斜线是MySQL的转义字符。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名  参数类型,...)</span><br><span class="line">[characteristics ...]</span><br><span class="line">BEGIN</span><br><span class="line">sql语句1;</span><br><span class="line">sql语句2;</span><br><span class="line"></span><br><span class="line">END $</span><br></pre></td></tr></table></figure><h3 id="代码举例"><a href="#代码举例" class="headerlink" title="代码举例"></a>代码举例</h3><p>举例1：创建存储过程select_all_data()，查看 emps 表的所有数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE select_all_data()</span><br><span class="line">BEGIN</span><br><span class="line">SELECT * FROM emps;</span><br><span class="line"></span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>举例2：创建存储过程avg_employee_salary()，返回所有员工的平均工资</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE avg_employee_salary ()</span><br><span class="line">BEGIN</span><br><span class="line">SELECT AVG(salary) AS avg_salary FROM emps;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>举例3：创建存储过程show_max_salary()，用来查看“emps”表的最高薪资值。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE show_max_salary()</span><br><span class="line">LANGUAGE SQL</span><br><span class="line">NOT DETERMINISTIC</span><br><span class="line">CONTAINS SQL</span><br><span class="line">SQL SECURITY DEFINER</span><br><span class="line">COMMENT &#x27;查看最高薪资&#x27;</span><br><span class="line">BEGIN</span><br><span class="line">SELECT MAX(salary) FROM emps;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>举例4：创建存储过程show_min_salary()，查看“emps”表的最低薪资值。并将最低薪资通过OUT参数“ms”输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE show_min_salary(OUT ms DOUBLE)</span><br><span class="line">BEGIN</span><br><span class="line">SELECT MIN(salary) INTO ms FROM emps;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>举例5：创建存储过程show_someone_salary()，查看“emps”表的某个员工的薪资，并用IN参数empname输入员工姓名。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE show_someone_salary(IN empname VARCHAR(20))</span><br><span class="line">BEGIN</span><br><span class="line">SELECT salary FROM emps WHERE ename = empname;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>举例6：创建存储过程show_someone_salary2()，查看“emps”表的某个员工的薪资，并用IN参数empname输入员工姓名，用OUT参数empsalary输出员工薪资。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE show_someone_salary2(IN empname VARCHAR(20),OUT empsalary DOUBLE)</span><br><span class="line">BEGIN</span><br><span class="line">SELECT salary INTO empsalary FROM emps WHERE ename = empname;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>举例7：创建存储过程show_mgr_name()，查询某个员工领导的姓名，并用INOUT参数“empname”输入员工姓名，输出领导的姓名。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE show_mgr_name(INOUT empname VARCHAR(20))</span><br><span class="line">BEGIN</span><br><span class="line">SELECT ename INTO empname FROM emps</span><br><span class="line">WHERE eid = (SELECT MID FROM emps WHERE ename=empname);</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h2 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h2><h3 id="调用格式"><a href="#调用格式" class="headerlink" title="调用格式"></a>调用格式</h3><p>存储过程有多种调用方法。存储过程必须使用CALL语句调用，并且存储过程和数据库相关，如果要执行其他数据库中的存储过程，需要指定数据库名称，例如CALL dbname.procname。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CALL 存储过程名(实参列表)</span><br></pre></td></tr></table></figure><p><strong>格式：</strong></p><p>1、调用in模式的参数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CALL sp1(&#x27;值&#x27;);</span><br></pre></td></tr></table></figure><p>2、调用out模式的参数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET @name;</span><br><span class="line">CALL sp1(@name);</span><br><span class="line">SELECT @name;</span><br></pre></td></tr></table></figure><p>3、调用inout模式的参数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET @name=值;</span><br><span class="line">CALL sp1(@name);</span><br><span class="line">SELECT @name;</span><br></pre></td></tr></table></figure><h3 id="代码举例-1"><a href="#代码举例-1" class="headerlink" title="代码举例"></a>代码举例</h3><p><strong>举例1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE CountProc(IN sid INT,OUT num INT)</span><br><span class="line">BEGIN</span><br><span class="line">SELECT COUNT(*) INTO num FROM fruits </span><br><span class="line">WHERE s_id = sid;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>调用存储过程：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CALL CountProc (101, @num);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>查看返回结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT @num;</span><br></pre></td></tr></table></figure><p>该存储过程返回了指定 s_id=101 的水果商提供的水果种类，返回值存储在num变量中，使用SELECT查看，返回结果为3。</p><p><strong>举例2：</strong>创建存储过程，实现累加运算，计算 1+2+…+n 等于多少。具体的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE `add_num`(IN n INT)</span><br><span class="line">BEGIN</span><br><span class="line">       DECLARE i INT;</span><br><span class="line">       DECLARE sum INT;</span><br><span class="line">       </span><br><span class="line">       SET i = 1;</span><br><span class="line">       SET sum = 0;</span><br><span class="line">       WHILE i &lt;= n DO</span><br><span class="line">              SET sum = sum + i;</span><br><span class="line">              SET i = i +1;</span><br><span class="line">       END WHILE;</span><br><span class="line">       SELECT sum;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>如果你用的是 Navicat 工具，那么在编写存储过程的时候，Navicat 会自动设置 DELIMITER 为其他符号，我们不需要再进行 DELIMITER 的操作。</p><p>直接使用 <code>CALL add_num(50);</code>即可。这里我传入的参数为 50，也就是统计 1+2+…+50 的积累之和。</p><h3 id="如何调试"><a href="#如何调试" class="headerlink" title="如何调试"></a>如何调试</h3><p>在 MySQL 中，存储过程不像普通的编程语言（比如 VC++、Java 等）那样有专门的集成开发环境。因此，你可以通过 SELECT 语句，把程序执行的中间结果查询出来，来调试一个 SQL 语句的正确性。调试成功之后，把 SELECT 语句后移到下一个 SQL 语句之后，再调试下一个 SQL 语句。这样<code>逐步推进</code>，就可以完成对存储过程中所有操作的调试了。当然，你也可以把存储过程中的 SQL 语句复制出来，逐段单独调试。</p><h2 id="存储函数的使用"><a href="#存储函数的使用" class="headerlink" title="存储函数的使用"></a>存储函数的使用</h2><p>前面学习了很多函数，使用这些函数可以对数据进行的各种处理操作，极大地提高用户对数据库的管理效率。MySQL支持自定义函数，定义好之后，调用方式与调用MySQL预定义的系统函数一样。</p><h3 id="语法分析-1"><a href="#语法分析-1" class="headerlink" title="语法分析"></a>语法分析</h3><p>学过的函数：LENGTH、SUBSTR、CONCAT等</p><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE FUNCTION 函数名(参数名 参数类型,...) </span><br><span class="line">RETURNS 返回值类型</span><br><span class="line">[characteristics ...]</span><br><span class="line">BEGIN</span><br><span class="line">函数体   #函数体中肯定有 RETURN 语句</span><br><span class="line"></span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>说明：</p><p>1、参数列表：指定参数为IN、OUT或INOUT只对PROCEDURE是合法的，FUNCTION中总是默认为IN参数。</p><p>2、RETURNS type 语句表示函数返回数据的类型；</p><p>RETURNS子句只能对FUNCTION做指定，对函数而言这是<code>强制</code>的。它用来指定函数的返回类型，而且函数体必须包含一个<code>RETURN value</code>语句。</p><p>3、characteristic 创建函数时指定的对函数的约束。取值与创建存储过程时相同，这里不再赘述。</p><p>4、函数体也可以用BEGIN…END来表示SQL代码的开始和结束。如果函数体只有一条语句，也可以省略BEGIN…END。</p><h3 id="调用存储函数"><a href="#调用存储函数" class="headerlink" title="调用存储函数"></a>调用存储函数</h3><p>在MySQL中，存储函数的使用方法与MySQL内部函数的使用方法是一样的。换言之，用户自己定义的存储函数与MySQL内部函数是一个性质的。区别在于，存储函数是<code>用户自己定义</code>的，而内部函数是MySQL的<code>开发者定义</code>的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 函数名(实参列表)</span><br></pre></td></tr></table></figure><h3 id="代码举例-2"><a href="#代码举例-2" class="headerlink" title="代码举例"></a>代码举例</h3><p><strong>举例1：</strong></p><p>创建存储函数，名称为email_by_name()，参数定义为空，该函数查询Abel的email，并返回，数据类型为字符串型。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE FUNCTION email_by_name()</span><br><span class="line">RETURNS VARCHAR(25)</span><br><span class="line">DETERMINISTIC</span><br><span class="line">CONTAINS SQL</span><br><span class="line">BEGIN</span><br><span class="line">RETURN (SELECT email FROM employees WHERE last_name = &#x27;Abel&#x27;);</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT email_by_name();</span><br></pre></td></tr></table></figure><p><strong>举例2：</strong></p><p>创建存储函数，名称为email_by_id()，参数传入emp_id，该函数查询emp_id的email，并返回，数据类型为字符串型。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE FUNCTION email_by_id(emp_id INT)</span><br><span class="line">RETURNS VARCHAR(25)</span><br><span class="line">DETERMINISTIC</span><br><span class="line">CONTAINS SQL</span><br><span class="line">BEGIN</span><br><span class="line">RETURN (SELECT email FROM employees WHERE employee_id = emp_id);</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET @emp_id = 102;</span><br><span class="line">SELECT email_by_id(102);</span><br></pre></td></tr></table></figure><p><strong>举例3：</strong></p><p>创建存储函数count_by_id()，参数传入dept_id，该函数查询dept_id部门的员工人数，并返回，数据类型为整型。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE FUNCTION count_by_id(dept_id INT)</span><br><span class="line">RETURNS INT</span><br><span class="line">LANGUAGE SQL</span><br><span class="line">NOT DETERMINISTIC</span><br><span class="line">READS SQL DATA</span><br><span class="line">SQL SECURITY DEFINER</span><br><span class="line">COMMENT &#x27;查询部门平均工资&#x27;</span><br><span class="line">BEGIN</span><br><span class="line">RETURN (SELECT COUNT(*) FROM employees WHERE department_id = dept_id);</span><br><span class="line"></span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET @dept_id = 50;</span><br><span class="line">SELECT count_by_id(@dept_id);</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>若在创建存储函数中报错“<code>you might want to use the less safe log_bin_trust_function_creators variable</code>”，有两种处理方法：</p><ul><li>方式1：加上必要的函数特性“[NOT] DETERMINISTIC”和“{CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA}”</li></ul><ul><li>方式2：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SET GLOBAL log_bin_trust_function_creators = 1;</span><br></pre></td></tr></table></figure><h3 id="4-4-对比存储函数和存储过程"><a href="#4-4-对比存储函数和存储过程" class="headerlink" title="4.4 对比存储函数和存储过程"></a>4.4 对比存储函数和存储过程</h3><div class="table-container"><table><thead><tr><th></th><th>关键字</th><th>调用语法</th><th>返回值</th><th>应用场景</th></tr></thead><tbody><tr><td>存储过程</td><td>PROCEDURE</td><td>CALL 存储过程()</td><td>理解为有0个或多个</td><td>一般用于更新</td></tr><tr><td>存储函数</td><td>FUNCTION</td><td>SELECT 函数()</td><td>只能是一个</td><td>一般用于查询结果为一个值并返回时</td></tr></tbody></table></div><p>此外，<strong>存储函数可以放在查询语句中使用，存储过程不行</strong>。反之，存储过程的功能更加强大，包括能够执行对表的操作（比如创建表，删除表等）和事务操作，这些功能是存储函数不具备的。</p><h2 id="存储过程和函数的查看、修改、删除"><a href="#存储过程和函数的查看、修改、删除" class="headerlink" title="存储过程和函数的查看、修改、删除"></a>存储过程和函数的查看、修改、删除</h2><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><p>创建完之后，怎么知道我们创建的存储过程、存储函数是否成功了呢？</p><p>MySQL存储了存储过程和函数的状态信息，用户可以使用SHOW STATUS语句或SHOW CREATE语句来查看，也可直接从系统的information_schema数据库中查询。这里介绍3种方法。</p><p><strong>1. 使用SHOW CREATE语句查看存储过程和函数的创建信息</strong></p><p>基本语法结构如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE &#123;PROCEDURE | FUNCTION&#125; 存储过程名或函数名</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE FUNCTION test_db.CountProc \G</span><br></pre></td></tr></table></figure><p><strong>2. 使用SHOW STATUS语句查看存储过程和函数的状态信息</strong></p><p>基本语法结构如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW &#123;PROCEDURE | FUNCTION&#125; STATUS [LIKE &#x27;pattern&#x27;]</span><br></pre></td></tr></table></figure><p>这个语句返回子程序的特征，如数据库、名字、类型、创建者及创建和修改日期。</p><p>[LIKE ‘pattern’]：匹配存储过程或函数的名称，可以省略。当省略不写时，会列出MySQL数据库中存在的所有存储过程或函数的信息。<br>举例：SHOW STATUS语句示例，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW PROCEDURE STATUS LIKE &#x27;SELECT%&#x27; \G </span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">                  Db: test_db</span><br><span class="line">                Name: SelectAllData</span><br><span class="line">                Type: PROCEDURE</span><br><span class="line">             Definer: root@localhost</span><br><span class="line">            Modified: 2021-10-16 15:55:07</span><br><span class="line">             Created: 2021-10-16 15:55:07</span><br><span class="line">       Security_type: DEFINER</span><br><span class="line">             Comment: </span><br><span class="line">character_set_client: utf8mb4</span><br><span class="line">collation_connection: utf8mb4_general_ci</span><br><span class="line">  Database Collation: utf8mb4_general_ci</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>3. 从information_schema.Routines表中查看存储过程和函数的信息</strong></p><p>MySQL中存储过程和函数的信息存储在information_schema数据库下的Routines表中。可以通过查询该表的记录来查询存储过程和函数的信息。其基本语法形式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM information_schema.Routines</span><br><span class="line">WHERE ROUTINE_NAME=&#x27;存储过程或函数的名&#x27; [AND ROUTINE_TYPE = &#123;&#x27;PROCEDURE|FUNCTION&#x27;&#125;];</span><br></pre></td></tr></table></figure><p>说明：如果在MySQL数据库中存在存储过程和函数名称相同的情况，最好指定ROUTINE_TYPE查询条件来指明查询的是存储过程还是函数。</p><p>举例：从Routines表中查询名称为CountProc的存储函数的信息，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM information_schema.Routines</span><br><span class="line">WHERE ROUTINE_NAME=&#x27;count_by_id&#x27;　AND　ROUTINE_TYPE = &#x27;FUNCTION&#x27; \G</span><br></pre></td></tr></table></figure><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>修改存储过程或函数，不影响存储过程或函数功能，只是修改相关特性。使用ALTER语句实现。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER &#123;PROCEDURE | FUNCTION&#125; 存储过程或函数的名 [characteristic ...]</span><br></pre></td></tr></table></figure><p>其中，characteristic指定存储过程或函数的特性，其取值信息与创建存储过程、函数时的取值信息略有不同。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125;</span><br><span class="line">| SQL SECURITY &#123; DEFINER | INVOKER &#125;</span><br><span class="line">| COMMENT &#x27;string&#x27;</span><br></pre></td></tr></table></figure><ul><li><code>CONTAINS SQL</code>，表示子程序包含SQL语句，但不包含读或写数据的语句。</li><li><code>NO SQL</code>，表示子程序中不包含SQL语句。</li><li><code>READS SQL DATA</code>，表示子程序中包含读数据的语句。</li><li><code>MODIFIES SQL DATA</code>，表示子程序中包含写数据的语句。</li><li><code>SQL SECURITY &#123; DEFINER | INVOKER &#125;</code>，指明谁有权限来执行。<ul><li><code>DEFINER</code>，表示只有定义者自己才能够执行。</li><li><code>INVOKER</code>，表示调用者可以执行。</li></ul></li><li><code>COMMENT &#39;string&#39;</code>，表示注释信息。</li></ul><blockquote><p>修改存储过程使用ALTER PROCEDURE语句，修改存储函数使用ALTER FUNCTION语句。但是，这两个语句的结构是一样的，语句中的所有参数也是一样的。</p></blockquote><p><strong>举例1：</strong></p><p>修改存储过程CountProc的定义。将读写权限改为MODIFIES SQL DATA，并指明调用者可以执行，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER　PROCEDURE　CountProc</span><br><span class="line">MODIFIES SQL DATA</span><br><span class="line">SQL SECURITY INVOKER ;</span><br></pre></td></tr></table></figure><p>查询修改后的信息：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT specific_name,sql_data_access,security_type</span><br><span class="line">FROM information_schema.`ROUTINES`</span><br><span class="line">WHERE routine_name = &#x27;CountProc&#x27; AND routine_type = &#x27;PROCEDURE&#x27;;</span><br></pre></td></tr></table></figure><p>结果显示，存储过程修改成功。从查询的结果可以看出，访问数据的权限（SQL<em>DATA</em> ACCESS）已经变成MODIFIES SQL DATA，安全类型（SECURITY_TYPE）已经变成INVOKER。</p><p><strong>举例2：</strong></p><p>修改存储函数CountProc的定义。将读写权限改为READS SQL DATA，并加上注释信息“FIND NAME”，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER　FUNCTION　CountProc</span><br><span class="line">READS SQL DATA</span><br><span class="line">COMMENT &#x27;FIND NAME&#x27; ;</span><br></pre></td></tr></table></figure><p>存储函数修改成功。从查询的结果可以看出，访问数据的权限（SQL_DATA_ACCESS）已经变成READS SQL DATA，函数注释（ROUTINE_COMMENT）已经变成FIND NAME。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除存储过程和函数，可以使用DROP语句，其语法结构如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP &#123;PROCEDURE | FUNCTION&#125; [IF EXISTS] 存储过程或函数的名</span><br></pre></td></tr></table></figure><p>IF EXISTS：如果程序或函数不存储，它可以防止发生错误，产生一个用SHOW WARNINGS查看的警告。</p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP PROCEDURE CountProc;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP FUNCTION CountProc;</span><br></pre></td></tr></table></figure><h2 id="关于存储过程使用的争议"><a href="#关于存储过程使用的争议" class="headerlink" title="关于存储过程使用的争议"></a>关于存储过程使用的争议</h2><p>尽管存储过程有诸多优点，但是对于存储过程的使用，<strong>一直都存在着很多争议</strong>，比如有些公司对于大型项目要求使用存储过程，而有些公司在手册中明确禁止使用存储过程，为什么这些公司对存储过程的使用需求差别这么大呢？</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p><strong>1、存储过程可以一次编译多次使用。</strong>存储过程只在创建时进行编译，之后的使用都不需要重新编译，这就提升了 SQL 的执行效率。</p><p><strong>2、可以减少开发工作量。</strong>将代码<code>封装</code>成模块，实际上是编程的核心思想之一，这样可以把复杂的问题拆解成不同的模块，然后模块之间可以<code>重复使用</code>，在减少开发工作量的同时，还能保证代码的结构清晰。</p><p><strong>3、存储过程的安全性强。</strong>我们在设定存储过程的时候可以<code>设置对用户的使用权限</code>，这样就和视图一样具有较强的安全性。</p><p><strong>4、可以减少网络传输量。</strong>因为代码封装到存储过程中，每次使用只需要调用存储过程即可，这样就减少了网络传输量。</p><p><strong>5、良好的封装性。</strong>在进行相对复杂的数据库操作时，原本需要使用一条一条的 SQL 语句，可能要连接多次数据库才能完成的操作，现在变成了一次存储过程，只需要<code>连接一次即可</code>。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>基于上面这些优点，不少大公司都要求大型项目使用存储过程，比如微软、IBM 等公司。但是国内的阿里并不推荐开发人员使用存储过程，这是为什么呢？</p><blockquote><h4 id="阿里开发规范"><a href="#阿里开发规范" class="headerlink" title="阿里开发规范"></a>阿里开发规范</h4><p>【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p></blockquote><p>存储过程虽然有诸如上面的好处，但缺点也是很明显的。</p><p><strong>1、可移植性差。</strong>存储过程不能跨数据库移植，比如在 MySQL、Oracle 和 SQL Server 里编写的存储过程，在换成其他数据库时都需要重新编写。</p><p><strong>2、调试困难。</strong>只有少数 DBMS 支持存储过程的调试。对于复杂的存储过程来说，开发和维护都不容易。虽然也有一些第三方工具可以对存储过程进行调试，但要收费。</p><p><strong>3、存储过程的版本管理很困难。</strong>比如数据表索引发生变化了，可能会导致存储过程失效。我们在开发软件的时候往往需要进行版本管理，但是存储过程本身没有版本控制，版本迭代更新的时候很麻烦。</p><p><strong>4、它不适合高并发的场景。</strong>高并发的场景需要减少数据库的压力，有时数据库会采用分库分表的方式，而且对可扩展性要求很高，在这种情况下，存储过程会变得难以维护，<code>增加数据库的压力</code>，显然就不适用了。</p><p>小结：</p><p>存储过程既方便，又有局限性。尽管不同的公司对存储过程的态度不一，但是对于我们开发人员来说，不论怎样，掌握存储过程都是必备的技能之一。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第15章-存储过程与函数&quot;&gt;&lt;a href=&quot;#第15章-存储过程与函数&quot; class=&quot;headerlink&quot; title=&quot;第15章_存储过程与函数&quot;&gt;&lt;/a&gt;第15章_存储过程与函数&lt;/h1&gt;&lt;p&gt;讲师：尚硅谷-宋红康（江湖人称：康师傅）&lt;/p&gt;
&lt;p&gt;官网</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    <category term="基础版" scheme="http://example.com/categories/MySQL/%E5%9F%BA%E7%A1%80%E7%89%88/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>第14章_视图</title>
    <link href="http://example.com/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC14%E7%AB%A0_%E8%A7%86%E5%9B%BE/"/>
    <id>http://example.com/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC14%E7%AB%A0_%E8%A7%86%E5%9B%BE/</id>
    <published>2022-05-17T12:37:14.000Z</published>
    <updated>2022-05-17T13:02:21.070Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第14章-视图"><a href="#第14章-视图" class="headerlink" title="第14章_视图"></a>第14章_视图</h1><p>讲师：尚硅谷-宋红康（江湖人称：康师傅）</p><p>官网：<a href="http://www.atguigu.com/">http://www.atguigu.com</a></p><hr><h2 id="常见的数据库对象"><a href="#常见的数据库对象" class="headerlink" title="常见的数据库对象"></a>常见的数据库对象</h2><div class="table-container"><table><thead><tr><th>对象</th><th>描述</th></tr></thead><tbody><tr><td>表(TABLE)</td><td>表是存储数据的逻辑单元，以行和列的形式存在，列就是字段，行就是记录</td></tr><tr><td>数据字典</td><td>就是系统表，存放数据库相关信息的表。系统表的数据通常由数据库系统维护，程序员通常不应该修改，只可查看</td></tr><tr><td>约束(CONSTRAINT)</td><td>执行数据校验的规则，用于保证数据完整性的规则</td></tr><tr><td>视图(VIEW)</td><td>一个或者多个数据表里的数据的逻辑显示，视图并不存储数据</td></tr><tr><td>索引(INDEX)</td><td>用于提高查询性能，相当于书的目录</td></tr><tr><td>存储过程(PROCEDURE)</td><td>用于完成一次完整的业务处理，没有返回值，但可通过传出参数将多个值传给调用环境</td></tr><tr><td>存储函数(FUNCTION)</td><td>用于完成一次特定的计算，具有一个返回值</td></tr><tr><td>触发器(TRIGGER)</td><td>相当于一个事件监听器，当数据库发生特定事件后，触发器被触发，完成相应的处理</td></tr></tbody></table></div><h2 id="视图概述"><a href="#视图概述" class="headerlink" title="视图概述"></a>视图概述</h2><p><img src="/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC14%E7%AB%A0_%E8%A7%86%E5%9B%BE/1555430281798.png" alt="1555430281798"></p><h3 id="为什么使用视图？"><a href="#为什么使用视图？" class="headerlink" title="为什么使用视图？"></a>为什么使用视图？</h3><p>视图一方面可以帮我们使用表的一部分而不是所有的表，另一方面也可以针对不同的用户制定不同的查询视图。比如，针对一个公司的销售人员，我们只想给他看部分数据，而某些特殊的数据，比如采购的价格，则不会提供给他。再比如，人员薪酬是个敏感的字段，那么只给某个级别以上的人员开放，其他人的查询视图中则不提供这个字段。</p><p>刚才讲的只是视图的一个使用场景，实际上视图还有很多作用。最后，我们总结视图的优点。</p><h3 id="视图的理解"><a href="#视图的理解" class="headerlink" title="视图的理解"></a>视图的理解</h3><ul><li><p>视图是一种<code>虚拟表</code>，本身是<code>不具有数据</code>的，占用很少的内存空间，它是 SQL 中的一个重要概念。</p></li><li><p><strong>视图建立在已有表的基础上</strong>, 视图赖以建立的这些表称为<strong>基表</strong>。</p><p><img src="/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC14%E7%AB%A0_%E8%A7%86%E5%9B%BE/image-20211006211206990.png" alt="image-20211006211206990" style="zoom:67%;"></p></li><li><p>视图的创建和删除只影响视图本身，不影响对应的基表。但是当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化，反之亦然。</p></li><li><p>向视图提供数据内容的语句为 SELECT 语句, 可以将视图理解为<strong>存储起来的</strong> <strong>SELECT</strong> <strong>语句</strong> </p><ul><li>在数据库中，视图不会保存数据，数据真正保存在数据表中。当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化；反之亦然。</li></ul></li><li><p>视图，是向用户提供基表数据的另一种表现形式。通常情况下，小型项目的数据库可以不使用视图，但是在大型项目中，以及数据表比较复杂的情况下，视图的价值就凸显出来了，它可以帮助我们把经常查询的结果集放到虚拟表中，提升使用效率。理解和使用起来都非常方便。</p></li></ul><h2 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h2><ul><li><strong>在</strong> <strong>CREATE VIEW</strong> <strong>语句中嵌入子查询</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE [OR REPLACE] </span><br><span class="line">[ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;] </span><br><span class="line">VIEW 视图名称 [(字段列表)]</span><br><span class="line">AS 查询语句</span><br><span class="line">[WITH [CASCADED|LOCAL] CHECK OPTION]</span><br></pre></td></tr></table></figure><ul><li>精简版</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW 视图名称 </span><br><span class="line">AS 查询语句</span><br></pre></td></tr></table></figure><h3 id="创建单表视图"><a href="#创建单表视图" class="headerlink" title="创建单表视图"></a>创建单表视图</h3><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW empvu80</span><br><span class="line">AS </span><br><span class="line">SELECT  employee_id, last_name, salary</span><br><span class="line">FROM    employees</span><br><span class="line">WHERE   department_id = 80;</span><br></pre></td></tr></table></figure><p>查询视图：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROMsalvu80;</span><br></pre></td></tr></table></figure><p><img src="/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC14%E7%AB%A0_%E8%A7%86%E5%9B%BE/1555430882363.png" alt="1555430882363" style="zoom:80%;"></p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW emp_year_salary (ename,year_salary)</span><br><span class="line">AS </span><br><span class="line">SELECT ename,salary*12*(1+IFNULL(commission_pct,0))</span><br><span class="line">FROM t_employee;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW salvu50</span><br><span class="line">AS </span><br><span class="line">SELECT  employee_id ID_NUMBER, last_name NAME,salary*12 ANN_SALARY</span><br><span class="line">FROM    employees</span><br><span class="line">WHERE   department_id = 50;</span><br></pre></td></tr></table></figure><p>说明1：实际上就是我们在 SQL 查询语句的基础上封装了视图 VIEW，这样就会基于 SQL 语句的结果集形成一张虚拟表。</p><p>说明2：在创建视图时，没有在视图名后面指定字段列表，则视图中字段列表默认和SELECT语句中的字段列表一致。如果SELECT语句中给字段取了别名，那么视图中的字段名和别名相同。</p><h3 id="创建多表联合视图"><a href="#创建多表联合视图" class="headerlink" title="创建多表联合视图"></a>创建多表联合视图</h3><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW empview </span><br><span class="line">AS </span><br><span class="line">SELECT employee_id emp_id,last_name NAME,department_name</span><br><span class="line">FROM employees e,departments d</span><br><span class="line">WHERE e.department_id = d.department_id;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW emp_dept</span><br><span class="line">AS </span><br><span class="line">SELECT ename,dname</span><br><span class="line">FROM t_employee LEFT JOIN t_department</span><br><span class="line">ON t_employee.did = t_department.did;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEWdept_sum_vu</span><br><span class="line">(name, minsal, maxsal, avgsal)</span><br><span class="line">AS </span><br><span class="line">SELECT d.department_name, MIN(e.salary), MAX(e.salary),AVG(e.salary)</span><br><span class="line">FROM employees e, departments d</span><br><span class="line">WHERE e.department_id = d.department_id </span><br><span class="line">GROUP BY  d.department_name;</span><br></pre></td></tr></table></figure><ul><li><strong>利用视图对数据进行格式化</strong></li></ul><p>我们经常需要输出某个格式的内容，比如我们想输出员工姓名和对应的部门名，对应格式为 emp_name(department_name)，就可以使用视图来完成数据格式化的操作：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW emp_depart</span><br><span class="line">AS</span><br><span class="line">SELECT CONCAT(last_name,&#x27;(&#x27;,department_name,&#x27;)&#x27;) AS emp_dept</span><br><span class="line">FROM employees e JOIN departments d</span><br><span class="line">WHERE e.department_id = d.department_id</span><br></pre></td></tr></table></figure><h3 id="基于视图创建视图"><a href="#基于视图创建视图" class="headerlink" title="基于视图创建视图"></a>基于视图创建视图</h3><p>当我们创建好一张视图之后，还可以在它的基础上继续创建视图。</p><p>举例：联合“emp_dept”视图和“emp_year_salary”视图查询员工姓名、部门名称、年薪信息创建 “emp_dept_ysalary”视图。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW emp_dept_ysalary</span><br><span class="line">AS </span><br><span class="line">SELECT emp_dept.ename,dname,year_salary</span><br><span class="line">FROM emp_dept INNER JOIN emp_year_salary</span><br><span class="line">ON emp_dept.ename = emp_year_salary.ename;</span><br></pre></td></tr></table></figure><h2 id="查看视图"><a href="#查看视图" class="headerlink" title="查看视图"></a>查看视图</h2><p>语法1：查看数据库的表对象、视图对象</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure><p>语法2：查看视图的结构</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESC / DESCRIBE 视图名称;</span><br></pre></td></tr></table></figure><p>语法3：查看视图的属性信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看视图信息（显示数据表的存储引擎、版本、数据行数和数据大小等）</span><br><span class="line">SHOW TABLE STATUS LIKE &#x27;视图名称&#x27;\G</span><br></pre></td></tr></table></figure><p>执行结果显示，注释Comment为VIEW，说明该表为视图，其他的信息为NULL，说明这是一个虚表。</p><p>语法4：查看视图的详细定义信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE VIEW 视图名称;</span><br></pre></td></tr></table></figure><h2 id="更新视图的数据"><a href="#更新视图的数据" class="headerlink" title="更新视图的数据"></a>更新视图的数据</h2><h3 id="一般情况"><a href="#一般情况" class="headerlink" title="一般情况"></a>一般情况</h3><p>MySQL支持使用INSERT、UPDATE和DELETE语句对视图中的数据进行插入、更新和删除操作。当视图中的数据发生变化时，数据表中的数据也会发生变化，反之亦然。</p><p>举例：UPDATE操作</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT ename,tel FROM emp_tel WHERE ename = &#x27;孙洪亮&#x27;;</span><br><span class="line">+---------+-------------+</span><br><span class="line">| ename   | tel         |</span><br><span class="line">+---------+-------------+</span><br><span class="line">| 孙洪亮 | 13789098765 |</span><br><span class="line">+---------+-------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE emp_tel SET tel = &#x27;13789091234&#x27; WHERE ename = &#x27;孙洪亮&#x27;;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT ename,tel FROM emp_tel WHERE ename = &#x27;孙洪亮&#x27;;</span><br><span class="line">+---------+-------------+</span><br><span class="line">| ename  | tel         |</span><br><span class="line">+---------+-------------+</span><br><span class="line">| 孙洪亮 | 13789091234 |</span><br><span class="line">+---------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT ename,tel FROM t_employee WHERE ename = &#x27;孙洪亮&#x27;;</span><br><span class="line">+---------+-------------+</span><br><span class="line">| ename   | tel         |</span><br><span class="line">+---------+-------------+</span><br><span class="line">| 孙洪亮 | 13789091234 |</span><br><span class="line">+---------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>举例：DELETE操作</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT ename,tel FROM emp_tel WHERE ename = &#x27;孙洪亮&#x27;;</span><br><span class="line">+---------+-------------+</span><br><span class="line">| ename  | tel           |</span><br><span class="line">+---------+-------------+</span><br><span class="line">| 孙洪亮 | 13789091234 |</span><br><span class="line">+---------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; DELETE FROM emp_tel  WHERE ename = &#x27;孙洪亮&#x27;;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT ename,tel FROM emp_tel WHERE ename = &#x27;孙洪亮&#x27;;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT ename,tel FROM t_employee WHERE ename = &#x27;孙洪亮&#x27;;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="不可更新的视图"><a href="#不可更新的视图" class="headerlink" title="不可更新的视图"></a>不可更新的视图</h3><p>要使视图可更新，视图中的行和底层基本表中的行之间必须存在<code>一对一</code>的关系。另外当视图定义出现如下情况时，视图不支持更新操作：</p><ul><li>在定义视图的时候指定了“ALGORITHM = TEMPTABLE”，视图将不支持INSERT和DELETE操作；</li><li>视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持INSERT操作；</li><li>在定义视图的SELECT语句中使用了<code>JOIN联合查询</code>，视图将不支持INSERT和DELETE操作；</li><li>在定义视图的SELECT语句后的字段列表中使用了<code>数学表达式</code>或<code>子查询</code>，视图将不支持INSERT，也不支持UPDATE使用了数学表达式、子查询的字段值；</li><li>在定义视图的SELECT语句后的字段列表中使用<code>DISTINCT</code>、<code>聚合函数</code>、<code>GROUP BY</code>、<code>HAVING</code>、<code>UNION</code>等，视图将不支持INSERT、UPDATE、DELETE；</li><li>在定义视图的SELECT语句中包含了子查询，而子查询中引用了FROM后面的表，视图将不支持INSERT、UPDATE、DELETE；</li><li>视图定义基于一个<code>不可更新视图</code>；</li><li>常量视图。</li></ul><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE OR REPLACE VIEW emp_dept</span><br><span class="line">    -&gt; (ename,salary,birthday,tel,email,hiredate,dname)</span><br><span class="line">    -&gt; AS SELECT ename,salary,birthday,tel,email,hiredate,dname</span><br><span class="line">    -&gt; FROM t_employee INNER JOIN t_department</span><br><span class="line">    -&gt; ON t_employee.did = t_department.did ;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; INSERT INTO emp_dept(ename,salary,birthday,tel,email,hiredate,dname)</span><br><span class="line">    -&gt; VALUES(&#x27;张三&#x27;,15000,&#x27;1995-01-08&#x27;,&#x27;18201587896&#x27;,</span><br><span class="line">    -&gt; &#x27;zs@atguigu.com&#x27;,&#x27;2022-02-14&#x27;,&#x27;新部门&#x27;);</span><br><span class="line">    </span><br><span class="line">#ERROR 1393 (HY000): Can not modify more than one base table through a join view &#x27;atguigu_chapter9.emp_dept&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面的SQL执行结果可以看出，在定义视图的SELECT语句中使用了JOIN联合查询，视图将不支持更新操作。</p><blockquote><p>虽然可以更新视图数据，但总的来说，视图作为<code>虚拟表</code>，主要用于<code>方便查询</code>，不建议更新视图的数据。<strong>对视图数据的更改，都是通过对实际数据表里数据的操作来完成的。</strong></p></blockquote><h2 id="修改、删除视图"><a href="#修改、删除视图" class="headerlink" title="修改、删除视图"></a>修改、删除视图</h2><h3 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a>修改视图</h3><p>方式1：使用CREATE <strong>OR REPLACE</strong> VIEW 子句<strong>修改视图</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE OR REPLACE VIEW empvu80</span><br><span class="line">(id_number, name, sal, department_id)</span><br><span class="line">AS </span><br><span class="line">SELECT  employee_id, first_name || &#x27; &#x27; || last_name, salary, department_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id = 80;</span><br></pre></td></tr></table></figure><blockquote><p>说明：CREATE VIEW 子句中各列的别名应和子查询中各列相对应。</p></blockquote><p>方式2：ALTER VIEW</p><p>修改视图的语法是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER VIEW 视图名称 </span><br><span class="line">AS</span><br><span class="line">查询语句</span><br></pre></td></tr></table></figure><h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><ul><li><p>删除视图只是删除视图的定义，并不会删除基表的数据。</p></li><li><p>删除视图的语法是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP VIEW IF EXISTS 视图名称;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP VIEW IF EXISTS 视图名称1,视图名称2,视图名称3,...;</span><br></pre></td></tr></table></figure></li><li><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP VIEW empvu80;</span><br></pre></td></tr></table></figure></li><li><p>说明：基于视图a、b创建了新的视图c，如果将视图a或者视图b删除，会导致视图c的查询失败。这样的视图c需要手动删除或修改，否则影响使用。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="视图优点"><a href="#视图优点" class="headerlink" title="视图优点"></a>视图优点</h3><p><strong>1. 操作简单</strong></p><p>将经常使用的查询操作定义为视图，可以使开发人员不需要关心视图对应的数据表的结构、表与表之间的关联关系，也不需要关心数据表之间的业务逻辑和查询条件，而只需要简单地操作视图即可，极大简化了开发人员对数据库的操作。</p><p><strong>2. 减少数据冗余</strong></p><p>视图跟实际数据表不一样，它存储的是查询语句。所以，在使用的时候，我们要通过定义视图的查询语句来获取结果集。而视图本身不存储数据，不占用数据存储的资源，减少了数据冗余。</p><p><strong>3. 数据安全</strong></p><p>MySQL将用户对数据的<code>访问限制</code>在某些数据的结果集上，而这些数据的结果集可以使用视图来实现。用户不必直接查询或操作数据表。这也可以理解为视图具有<code>隔离性</code>。视图相当于在用户和实际的数据表之间加了一层虚拟表。</p><p><img src="/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC14%E7%AB%A0_%E8%A7%86%E5%9B%BE/image-20211010211744459.png" alt="image-20211010211744459"></p><p>同时，MySQL可以根据权限将用户对数据的访问限制在某些视图上，<strong>用户不需要查询数据表，可以直接通过视图获取数据表中的信息</strong>。这在一定程度上保障了数据表中数据的安全性。</p><p><strong>4. 适应灵活多变的需求</strong><br>当业务系统的需求发生变化后，如果需要改动数据表的结构，则工作量相对较大，可以使用视图来减少改动的工作量。这种方式在实际工作中使用得比较多。</p><p><strong>5. 能够分解复杂的查询逻辑</strong><br>数据库中如果存在复杂的查询逻辑，则可以将问题进行分解，创建多个视图获取数据，再将创建的多个视图结合起来，完成复杂的查询逻辑。</p><h3 id="视图不足"><a href="#视图不足" class="headerlink" title="视图不足"></a>视图不足</h3><p>如果我们在实际数据表的基础上创建了视图，那么，<strong>如果实际数据表的结构变更了，我们就需要及时对相关的视图进行相应的维护</strong>。特别是嵌套的视图（就是在视图的基础上创建视图），维护会变得比较复杂，<code>可读性不好</code>，容易变成系统的潜在隐患。因为创建视图的 SQL 查询可能会对字段重命名，也可能包含复杂的逻辑，这些都会增加维护的成本。</p><p>实际项目中，如果视图过多，会导致数据库维护成本的问题。</p><p>所以，在创建视图的时候，你要结合实际项目需求，综合考虑视图的优点和不足，这样才能正确使用视图，使系统整体达到最优。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第14章-视图&quot;&gt;&lt;a href=&quot;#第14章-视图&quot; class=&quot;headerlink&quot; title=&quot;第14章_视图&quot;&gt;&lt;/a&gt;第14章_视图&lt;/h1&gt;&lt;p&gt;讲师：尚硅谷-宋红康（江湖人称：康师傅）&lt;/p&gt;
&lt;p&gt;官网：&lt;a href=&quot;http://www</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    <category term="基础版" scheme="http://example.com/categories/MySQL/%E5%9F%BA%E7%A1%80%E7%89%88/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>第13章_约束</title>
    <link href="http://example.com/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC13%E7%AB%A0_%E7%BA%A6%E6%9D%9F/"/>
    <id>http://example.com/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC13%E7%AB%A0_%E7%BA%A6%E6%9D%9F/</id>
    <published>2022-05-17T12:37:13.000Z</published>
    <updated>2022-05-21T05:24:03.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第13章-约束"><a href="#第13章-约束" class="headerlink" title="第13章_约束"></a>第13章_约束</h1><p>讲师：尚硅谷-宋红康（江湖人称：康师傅）</p><p>官网：<a href="http://www.atguigu.com/">http://www.atguigu.com</a></p><hr><h2 id="约束-constraint-概述"><a href="#约束-constraint-概述" class="headerlink" title="约束(constraint)概述"></a>约束(constraint)概述</h2><h3 id="为什么需要约束"><a href="#为什么需要约束" class="headerlink" title="为什么需要约束"></a>为什么需要约束</h3><p>数据完整性（Data Integrity）是指数据的精确性（Accuracy）和可靠性（Reliability）。它是防止数据库中存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的。</p><p>为了保证数据的完整性，SQL规范以约束的方式对<strong>表数据进行额外的条件限制</strong>。从以下四个方面考虑：</p><ul><li><code>实体完整性（Entity Integrity）</code>：例如，同一个表中，不能存在两条完全相同无法区分的记录</li><li><code>域完整性（Domain Integrity）</code>：例如：年龄范围0-120，性别范围“男/女”</li><li><code>引用完整性（Referential Integrity）</code>：例如：员工所在部门，在部门表中要能找到这个部门</li><li><code>用户自定义完整性（User-defined Integrity）</code>：例如：用户名唯一、密码不能为空等，本部门经理的工资不得高于本部门职工的平均工资的5倍。</li></ul><h3 id="什么是约束"><a href="#什么是约束" class="headerlink" title="什么是约束"></a>什么是约束</h3><p>约束是表级的强制规定。</p><p>可以在<strong>创建表时规定约束（通过 CREATE TABLE 语句）</strong>，或者在<strong>表创建之后通过 ALTER TABLE 语句规定约束</strong>。</p><h3 id="约束的分类"><a href="#约束的分类" class="headerlink" title="约束的分类"></a>约束的分类</h3><ul><li><strong>根据约束数据列的限制，</strong>约束可分为：<ul><li><strong>单列约束</strong>：每个约束只约束一列</li><li><strong>多列约束</strong>：每个约束可约束多列数据</li></ul></li><li><strong>根据约束的作用范围</strong>，约束可分为：<ul><li><strong>列级约束</strong>：只能作用在一个列上，跟在列的定义后面</li><li><strong>表级约束</strong>：可以作用在多个列上，不与列一起，而是单独定义</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">位置支持的约束类型是否可以起约束名</span><br><span class="line">列级约束：列的后面语法都支持，但外键没有效果不可以</span><br><span class="line">表级约束：所有列的下面   默认和非空不支持，其他支持   可以（主键没有效果）</span><br></pre></td></tr></table></figure><ul><li><strong>根据约束起的作用</strong>，约束可分为：<ul><li><strong>NOT NULL</strong> <strong>非空约束，规定某个字段不能为空</strong></li><li><strong>UNIQUE</strong>  <strong>唯一约束</strong>，<strong>规定某个字段在整个表中是唯一的</strong></li><li><strong>PRIMARY KEY  主键(非空且唯一)约束</strong></li><li><strong>FOREIGN KEY</strong>  <strong>外键约束</strong></li><li><strong>CHECK</strong>  <strong>检查约束</strong></li><li><strong>DEFAULT</strong>  <strong>默认值约束</strong></li></ul></li></ul><blockquote><p>注意： MySQL不支持check约束，但可以使用check约束，而没有任何效果</p></blockquote><ul><li>查看某个表已有的约束</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#information_schema数据库名（系统库）</span><br><span class="line">#table_constraints表名称（专门存储各个表的约束）</span><br><span class="line">SELECT * FROM information_schema.table_constraints </span><br><span class="line">WHERE table_name = &#x27;表名称&#x27;;</span><br></pre></td></tr></table></figure><h2 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>限定某个字段/某列的值不允许为空</p><p><img src="/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC13%E7%AB%A0_%E7%BA%A6%E6%9D%9F/1555426972098.png" alt="1555426972098"></p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>NOT NULL</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>默认，所有的类型的值都可以是NULL，包括INT、FLOAT等数据类型</li><li><p>非空约束只能出现在表对象的列上，只能某个列单独限定非空，不能组合非空</p></li><li><p>一个表可以有很多列都分别限定了非空</p></li><li><p>空字符串’’不等于NULL，0也不等于NULL</p></li></ul><h3 id="添加非空约束"><a href="#添加非空约束" class="headerlink" title="添加非空约束"></a>添加非空约束</h3><p>（1）建表时</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名称(</span><br><span class="line">字段名  数据类型,</span><br><span class="line">    字段名  数据类型 NOT NULL,  </span><br><span class="line">    字段名  数据类型 NOT NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE emp(</span><br><span class="line">id INT(10) NOT NULL,</span><br><span class="line">NAME VARCHAR(20) NOT NULL,</span><br><span class="line">sex CHAR NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE student(</span><br><span class="line">sid int,</span><br><span class="line">    sname varchar(20) not null,</span><br><span class="line">    tel char(11) ,</span><br><span class="line">    cardid char(18) not null</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into student values(1,&#x27;张三&#x27;,&#x27;13710011002&#x27;,&#x27;110222198912032545&#x27;); #成功</span><br><span class="line"></span><br><span class="line">insert into student values(2,&#x27;李四&#x27;,&#x27;13710011002&#x27;,null);#身份证号为空</span><br><span class="line">ERROR 1048 (23000): Column &#x27;cardid&#x27; cannot be null</span><br><span class="line"></span><br><span class="line">insert into student values(2,&#x27;李四&#x27;,null,&#x27;110222198912032546&#x27;);#成功，tel允许为空</span><br><span class="line"></span><br><span class="line">insert into student values(3,null,null,&#x27;110222198912032547&#x27;);#失败</span><br><span class="line">ERROR 1048 (23000): Column &#x27;sname&#x27; cannot be null</span><br></pre></td></tr></table></figure><p>（2）建表后</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名称 modify 字段名 数据类型 not null;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE emp</span><br><span class="line">MODIFY sex VARCHAR(30) NOT NULL;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table student modify sname varchar(20) not null;</span><br></pre></td></tr></table></figure><h3 id="2-5-删除非空约束"><a href="#2-5-删除非空约束" class="headerlink" title="2.5 删除非空约束"></a>2.5 删除非空约束</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名称 modify 字段名 数据类型 NULL;#去掉not null，相当于修改某个非注解字段，该字段允许为空</span><br><span class="line"></span><br><span class="line">或 </span><br><span class="line"></span><br><span class="line">alter table 表名称 modify 字段名 数据类型;#去掉not null，相当于修改某个非注解字段，该字段允许为空</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE emp</span><br><span class="line">MODIFY sex VARCHAR(30) NULL;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE emp</span><br><span class="line">MODIFY NAME VARCHAR(15) DEFAULT &#x27;abc&#x27; NULL;</span><br></pre></td></tr></table></figure><h2 id="唯一性约束"><a href="#唯一性约束" class="headerlink" title="唯一性约束"></a>唯一性约束</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>用来限制某个字段/某列的值不能重复。</p><p> <img src="/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC13%E7%AB%A0_%E7%BA%A6%E6%9D%9F/1555427198811.png" alt="1555427198811"></p><h3 id="关键字-1"><a href="#关键字-1" class="headerlink" title="关键字"></a>关键字</h3><p>UNIQUE</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>同一个表可以有多个唯一约束。</li><li>唯一约束可以是某一个列的值唯一，也可以多个列组合的值唯一。</li><li>唯一性约束允许列值为空。</li><li>在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。</li><li><strong>MySQL会给唯一约束的列上默认创建一个唯一索引。</strong></li></ul><h3 id="添加唯一约束"><a href="#添加唯一约束" class="headerlink" title="添加唯一约束"></a>添加唯一约束</h3><p>（1）建表时</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名称(</span><br><span class="line">字段名  数据类型,</span><br><span class="line">    字段名  数据类型  unique,  </span><br><span class="line">    字段名  数据类型  unique key,</span><br><span class="line">    字段名  数据类型</span><br><span class="line">);</span><br><span class="line">create table 表名称(</span><br><span class="line">字段名  数据类型,</span><br><span class="line">    字段名  数据类型,  </span><br><span class="line">    字段名  数据类型,</span><br><span class="line">    [constraint 约束名] unique key(字段名)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table student(</span><br><span class="line">sid int,</span><br><span class="line">    sname varchar(20),</span><br><span class="line">    tel char(11) unique,</span><br><span class="line">    cardid char(18) unique key</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE t_course(</span><br><span class="line">cid INT UNIQUE,</span><br><span class="line">cname VARCHAR(100) UNIQUE,</span><br><span class="line">description VARCHAR(200)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE USER(</span><br><span class="line"> id INT NOT NULL,</span><br><span class="line"> NAME VARCHAR(25),</span><br><span class="line"> PASSWORD VARCHAR(16),</span><br><span class="line"> -- 使用表级约束语法</span><br><span class="line"> CONSTRAINT uk_name_pwd UNIQUE(NAME,PASSWORD)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>表示用户名和密码组合不能重复</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into student values(1,&#x27;张三&#x27;,&#x27;13710011002&#x27;,&#x27;101223199012015623&#x27;);</span><br><span class="line">insert into student values(2,&#x27;李四&#x27;,&#x27;13710011003&#x27;,&#x27;101223199012015624&#x27;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student;</span><br><span class="line">+-----+-------+-------------+--------------------+</span><br><span class="line">| sid | sname | tel         | cardid             |</span><br><span class="line">+-----+-------+-------------+--------------------+</span><br><span class="line">|   1 | 张三  | 13710011002 | 101223199012015623 |</span><br><span class="line">|   2 | 李四  | 13710011003 | 101223199012015624 |</span><br><span class="line">+-----+-------+-------------+--------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into student values(3,&#x27;王五&#x27;,&#x27;13710011004&#x27;,&#x27;101223199012015624&#x27;); #身份证号重复</span><br><span class="line">ERROR 1062 (23000): Duplicate entry &#x27;101223199012015624&#x27; for key &#x27;cardid&#x27;</span><br><span class="line"></span><br><span class="line">insert into student values(3,&#x27;王五&#x27;,&#x27;13710011003&#x27;,&#x27;101223199012015625&#x27;); </span><br><span class="line">ERROR 1062 (23000): Duplicate entry &#x27;13710011003&#x27; for key &#x27;tel&#x27;</span><br></pre></td></tr></table></figure><p>（2）建表后指定唯一键约束</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#字段列表中如果是一个字段，表示该列的值唯一。如果是两个或更多个字段，那么复合唯一，即多个字段的组合是唯一的</span><br><span class="line">#方式1：</span><br><span class="line">alter table 表名称 add unique key(字段列表); </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#方式2：</span><br><span class="line">alter table 表名称 modify 字段名 字段类型 unique;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE USER </span><br><span class="line">ADD UNIQUE(NAME,PASSWORD);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE USER </span><br><span class="line">ADD CONSTRAINT uk_name_pwd UNIQUE(NAME,PASSWORD);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE USER </span><br><span class="line">MODIFY NAME VARCHAR(20) UNIQUE;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table student(</span><br><span class="line">sid int primary key,</span><br><span class="line">    sname varchar(20),</span><br><span class="line">    tel char(11) ,</span><br><span class="line">    cardid char(18) </span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table student add unique key(tel);</span><br><span class="line">alter table student add unique key(cardid);</span><br></pre></td></tr></table></figure><h3 id="3-5-关于复合唯一约束"><a href="#3-5-关于复合唯一约束" class="headerlink" title="3.5 关于复合唯一约束"></a>3.5 关于复合唯一约束</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名称(</span><br><span class="line">字段名  数据类型,</span><br><span class="line">    字段名  数据类型,  </span><br><span class="line">    字段名  数据类型,</span><br><span class="line">    unique key(字段列表) #字段列表中写的是多个字段名，多个字段名用逗号分隔，表示那么是复合唯一，即多个字段的组合是唯一的</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#学生表</span><br><span class="line">create table student(</span><br><span class="line">sid int,#学号</span><br><span class="line">    sname varchar(20),#姓名</span><br><span class="line">    tel char(11) unique key,  #电话</span><br><span class="line">    cardid char(18) unique key #身份证号</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#课程表</span><br><span class="line">create table course(</span><br><span class="line">cid int,  #课程编号</span><br><span class="line">    cname varchar(20)     #课程名称</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#选课表</span><br><span class="line">create table student_course(</span><br><span class="line">    id int,</span><br><span class="line">sid int,</span><br><span class="line">    cid int,</span><br><span class="line">    score int,</span><br><span class="line">    unique key(sid,cid)  #复合唯一</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into student values(1,&#x27;张三&#x27;,&#x27;13710011002&#x27;,&#x27;101223199012015623&#x27;);#成功</span><br><span class="line">insert into student values(2,&#x27;李四&#x27;,&#x27;13710011003&#x27;,&#x27;101223199012015624&#x27;);#成功</span><br><span class="line">insert into course values(1001,&#x27;Java&#x27;),(1002,&#x27;MySQL&#x27;);#成功</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student;</span><br><span class="line">+-----+-------+-------------+--------------------+</span><br><span class="line">| sid | sname | tel         | cardid             |</span><br><span class="line">+-----+-------+-------------+--------------------+</span><br><span class="line">|   1 | 张三  | 13710011002 | 101223199012015623 |</span><br><span class="line">|   2 | 李四  | 13710011003 | 101223199012015624 |</span><br><span class="line">+-----+-------+-------------+--------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from course;</span><br><span class="line">+------+-------+</span><br><span class="line">| cid  | cname |</span><br><span class="line">+------+-------+</span><br><span class="line">| 1001 | Java  |</span><br><span class="line">| 1002 | MySQL |</span><br><span class="line">+------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into student_course values</span><br><span class="line">(1, 1, 1001, 89),</span><br><span class="line">(2, 1, 1002, 90),</span><br><span class="line">(3, 2, 1001, 88),</span><br><span class="line">(4, 2, 1002, 56);#成功</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student_course;</span><br><span class="line">+----+------+------+-------+</span><br><span class="line">| id | sid  | cid  | score |</span><br><span class="line">+----+------+------+-------+</span><br><span class="line">|  1 |    1 | 1001 |    89 |</span><br><span class="line">|  2 |    1 | 1002 |    90 |</span><br><span class="line">|  3 |    2 | 1001 |    88 |</span><br><span class="line">|  4 |    2 | 1002 |    56 |</span><br><span class="line">+----+------+------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into student_course values (5, 1, 1001, 88);#失败</span><br><span class="line"></span><br><span class="line">#ERROR 1062 (23000): Duplicate entry &#x27;1-1001&#x27; for key &#x27;sid&#x27;   违反sid-cid的复合唯一</span><br></pre></td></tr></table></figure><h3 id="删除唯一约束"><a href="#删除唯一约束" class="headerlink" title="删除唯一约束"></a>删除唯一约束</h3><ul><li>添加唯一性约束的列上也会自动创建唯一索引。</li><li>删除唯一约束只能通过删除唯一索引的方式删除。</li><li>删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样。</li><li>如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；如果是组合列，那么默认和()中排在第一个的列名相同。也可以自定义唯一性约束名。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM information_schema.table_constraints WHERE table_name = &#x27;表名&#x27;; #查看都有哪些约束</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE USER </span><br><span class="line">DROP INDEX uk_name_pwd;</span><br></pre></td></tr></table></figure><blockquote><p>注意：可以通过 <code>show index from 表名称;</code>查看表的索引</p></blockquote><h2 id="PRIMARY-KEY-约束"><a href="#PRIMARY-KEY-约束" class="headerlink" title="PRIMARY KEY 约束"></a>PRIMARY KEY 约束</h2><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p>用来唯一标识表中的一行记录。</p><h3 id="关键字-2"><a href="#关键字-2" class="headerlink" title="关键字"></a>关键字</h3><p>primary key</p><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul><li>主键约束相当于<strong>唯一约束+非空约束的组合</strong>，主键约束列不允许重复，也不允许出现空值。</li></ul><p><img src="/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC13%E7%AB%A0_%E7%BA%A6%E6%9D%9F/1555427492244.png" alt="1555427492244"></p><ul><li>一个表最多只能有一个主键约束，建立主键约束可以在列级别创建，也可以在表级别上创建。</li></ul><ul><li>主键约束对应着表中的一列或者多列（复合主键）</li><li>如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复。</li><li><p><strong>MySQL的主键名总是PRIMARY</strong>，就算自己命名了主键约束名也没用。</p></li><li><p>当创建主键约束时，系统默认会在所在的列或列组合上建立对应的<strong>主键索引</strong>（能够根据主键查询的，就根据主键查询，效率更高）。如果删除主键约束了，主键约束对应的索引就自动删除了。</p></li></ul><ul><li>需要注意的一点是，不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性。</li></ul><h3 id="添加主键约束"><a href="#添加主键约束" class="headerlink" title="添加主键约束"></a>添加主键约束</h3><p>（1）建表时指定主键约束</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名称(</span><br><span class="line">字段名  数据类型  primary key, #列级模式</span><br><span class="line">    字段名  数据类型,  </span><br><span class="line">    字段名  数据类型  </span><br><span class="line">);</span><br><span class="line">create table 表名称(</span><br><span class="line">字段名  数据类型,</span><br><span class="line">    字段名  数据类型,  </span><br><span class="line">    字段名  数据类型,</span><br><span class="line">    [constraint 约束名] primary key(字段名) #表级模式</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table temp(</span><br><span class="line">id int primary key,</span><br><span class="line">    name varchar(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc temp;</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| id    | int(11)     | NO   | PRI | NULL    |       |</span><br><span class="line">| name  | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into temp values(1,&#x27;张三&#x27;);#成功</span><br><span class="line">insert into temp values(2,&#x27;李四&#x27;);#成功</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from temp;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | 张三 |</span><br><span class="line">|  2 | 李四 |</span><br><span class="line">+----+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into temp values(1,&#x27;张三&#x27;);#失败</span><br><span class="line">ERROR 1062 (23000): Duplicate（重复） entry（键入，输入） &#x27;1&#x27; for key &#x27;PRIMARY&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert into temp values(1,&#x27;王五&#x27;);#失败</span><br><span class="line">ERROR 1062 (23000): Duplicate entry &#x27;1&#x27; for key &#x27;PRIMARY&#x27;</span><br><span class="line"></span><br><span class="line">insert into temp values(3,&#x27;张三&#x27;);#成功</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from temp;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | 张三 |</span><br><span class="line">|  2 | 李四 |</span><br><span class="line">|  3 | 张三 |</span><br><span class="line">+----+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into temp values(4,null);#成功</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert into temp values(null,&#x27;李琦&#x27;);#失败</span><br><span class="line">ERROR 1048 (23000): Column &#x27;id&#x27; cannot be null</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from temp;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | 张三 |</span><br><span class="line">|  2 | 李四 |</span><br><span class="line">|  3 | 张三 |</span><br><span class="line">|  4 | NULL |</span><br><span class="line">+----+------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#演示一个表建立两个主键约束</span><br><span class="line">create table temp(</span><br><span class="line">id int primary key,</span><br><span class="line">    name varchar(20) primary key</span><br><span class="line">);</span><br><span class="line">ERROR 1068 (42000): Multiple（多重的） primary key defined（定义）</span><br></pre></td></tr></table></figure><p>再举例：</p><ul><li>列级约束</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE emp4(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT ,</span><br><span class="line">NAME VARCHAR(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>表级约束</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE emp5(</span><br><span class="line">id INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">NAME VARCHAR(20),</span><br><span class="line">pwd VARCHAR(15),</span><br><span class="line">CONSTRAINT emp5_id_pk PRIMARY KEY(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>（2）建表后增加主键约束</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名称 ADD PRIMARY KEY(字段列表); #字段列表可以是一个字段，也可以是多个字段，如果是多个字段的话，是复合主键</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE student ADD PRIMARY KEY (sid);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE emp5 ADD PRIMARY KEY(NAME,pwd);</span><br></pre></td></tr></table></figure><h3 id="关于复合主键"><a href="#关于复合主键" class="headerlink" title="关于复合主键"></a>关于复合主键</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名称(</span><br><span class="line">字段名  数据类型,</span><br><span class="line">    字段名  数据类型,  </span><br><span class="line">    字段名  数据类型,</span><br><span class="line">    primary key(字段名1,字段名2)  #表示字段1和字段2的组合是唯一的，也可以有更多个字段</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#学生表</span><br><span class="line">create table student(</span><br><span class="line">sid int primary key,  #学号</span><br><span class="line">    sname varchar(20)     #学生姓名</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#课程表</span><br><span class="line">create table course(</span><br><span class="line">cid int primary key,  #课程编号</span><br><span class="line">    cname varchar(20)     #课程名称</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#选课表</span><br><span class="line">create table student_course(</span><br><span class="line">sid int,</span><br><span class="line">    cid int,</span><br><span class="line">    score int,</span><br><span class="line">    primary key(sid,cid)  #复合主键</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into student values(1,&#x27;张三&#x27;),(2,&#x27;李四&#x27;);</span><br><span class="line">insert into course values(1001,&#x27;Java&#x27;),(1002,&#x27;MySQL&#x27;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student;</span><br><span class="line">+-----+-------+</span><br><span class="line">| sid | sname |</span><br><span class="line">+-----+-------+</span><br><span class="line">|   1 | 张三  |</span><br><span class="line">|   2 | 李四  |</span><br><span class="line">+-----+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from course;</span><br><span class="line">+------+-------+</span><br><span class="line">| cid  | cname |</span><br><span class="line">+------+-------+</span><br><span class="line">| 1001 | Java  |</span><br><span class="line">| 1002 | MySQL |</span><br><span class="line">+------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into student_course values(1, 1001, 89),(1,1002,90),(2,1001,88),(2,1002,56);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student_course;</span><br><span class="line">+-----+------+-------+</span><br><span class="line">| sid | cid  | score |</span><br><span class="line">+-----+------+-------+</span><br><span class="line">|   1 | 1001 |    89 |</span><br><span class="line">|   1 | 1002 |    90 |</span><br><span class="line">|   2 | 1001 |    88 |</span><br><span class="line">|   2 | 1002 |    56 |</span><br><span class="line">+-----+------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into student_course values(1, 1001, 100);</span><br><span class="line">ERROR 1062 (23000): Duplicate entry &#x27;1-1001&#x27; for key &#x27;PRIMARY&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc student_course;</span><br><span class="line">+-------+---------+------+-----+---------+-------+</span><br><span class="line">| Field | Type    | Null | Key | Default | Extra |</span><br><span class="line">+-------+---------+------+-----+---------+-------+</span><br><span class="line">| sid   | int(11) | NO   | PRI | NULL    |       |</span><br><span class="line">| cid   | int(11) | NO   | PRI | NULL    |       |</span><br><span class="line">| score | int(11) | YES  |     | NULL    |       |</span><br><span class="line">+-------+---------+------+-----+---------+-------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><ul><li>再举例</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE emp6(</span><br><span class="line">id INT NOT NULL,</span><br><span class="line">NAME VARCHAR(20),</span><br><span class="line">pwd VARCHAR(15),</span><br><span class="line">CONSTRAINT emp7_pk PRIMARY KEY(NAME,pwd)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="删除主键约束"><a href="#删除主键约束" class="headerlink" title="删除主键约束"></a>删除主键约束</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名称 drop primary key;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE student DROP PRIMARY KEY;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE emp5 DROP PRIMARY KEY;</span><br></pre></td></tr></table></figure><blockquote><p>说明：删除主键约束，不需要指定主键名，因为一个表只有一个主键，删除主键约束后，非空还存在。</p></blockquote><h2 id="自增列：AUTO-INCREMENT"><a href="#自增列：AUTO-INCREMENT" class="headerlink" title="自增列：AUTO_INCREMENT"></a>自增列：AUTO_INCREMENT</h2><h3 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h3><p>某个字段的值自增</p><h3 id="关键字-3"><a href="#关键字-3" class="headerlink" title="关键字"></a>关键字</h3><p>auto_increment</p><h3 id="特点和要求"><a href="#特点和要求" class="headerlink" title="特点和要求"></a>特点和要求</h3><p>（1）一个表最多只能有一个自增长列</p><p>（2）当需要产生唯一标识符或顺序值时，可设置自增长</p><p>（3）自增长列约束的列必须是键列（主键列，唯一键列）</p><p>（4）自增约束的列的数据类型必须是整数类型</p><p>（5）如果自增列指定了 0 和 null，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接赋值为具体值。</p><p>错误演示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table employee(</span><br><span class="line">eid int auto_increment,</span><br><span class="line">    ename varchar(20)</span><br><span class="line">);</span><br><span class="line"># ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key   </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table employee(</span><br><span class="line">eid int primary key,</span><br><span class="line">    ename varchar(20) unique key auto_increment</span><br><span class="line">);</span><br><span class="line"># ERROR 1063 (42000): Incorrect column specifier for column &#x27;ename&#x27;  因为ename不是整数类型</span><br></pre></td></tr></table></figure><h3 id="如何指定自增约束"><a href="#如何指定自增约束" class="headerlink" title="如何指定自增约束"></a>如何指定自增约束</h3><p><strong>（1）建表时</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名称(</span><br><span class="line">字段名  数据类型  primary key auto_increment,</span><br><span class="line">    字段名  数据类型  unique key not null,  </span><br><span class="line">    字段名  数据类型  unique key,</span><br><span class="line">    字段名  数据类型  not null default 默认值, </span><br><span class="line">);</span><br><span class="line">create table 表名称(</span><br><span class="line">字段名  数据类型 default 默认值 ,</span><br><span class="line">    字段名  数据类型 unique key auto_increment,  </span><br><span class="line">    字段名  数据类型 not null default 默认值,,</span><br><span class="line">    primary key(字段名)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table employee(</span><br><span class="line">eid int primary key auto_increment,</span><br><span class="line">    ename varchar(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc employee;</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra          |</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">| eid   | int(11)     | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| ename | varchar(20) | YES  |     | NULL    |                |</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>（2）建表后</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名称 modify 字段名 数据类型 auto_increment;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table employee(</span><br><span class="line">eid int primary key ,</span><br><span class="line">    ename varchar(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table employee modify eid int auto_increment;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc employee;</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra          |</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">| eid   | int(11)     | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| ename | varchar(20) | YES  |     | NULL    |                |</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="5-5-如何删除自增约束"><a href="#5-5-如何删除自增约束" class="headerlink" title="5.5 如何删除自增约束"></a>5.5 如何删除自增约束</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#alter table 表名称 modify 字段名 数据类型 auto_increment;#给这个字段增加自增约束</span><br><span class="line"></span><br><span class="line">alter table 表名称 modify 字段名 数据类型; #去掉auto_increment相当于删除</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table employee modify eid int;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc employee;</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| eid   | int(11)     | NO   | PRI | NULL    |       |</span><br><span class="line">| ename | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="MySQL-8-0新特性—自增变量的持久化"><a href="#MySQL-8-0新特性—自增变量的持久化" class="headerlink" title="MySQL 8.0新特性—自增变量的持久化"></a>MySQL 8.0新特性—自增变量的持久化</h3><p>在MySQL 8.0之前，自增主键AUTO_INCREMENT的值如果大于max(primary key)+1，在MySQL重启后，会重置AUTO_INCREMENT=max(primary key)+1，这种现象在某些情况下会导致业务主键冲突或者其他难以发现的问题。<br>下面通过案例来对比不同的版本中自增变量是否持久化。<br>在MySQL 5.7版本中，测试步骤如下：<br>创建的数据表中包含自增主键的id字段，语句如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test1(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>插入4个空值，执行如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test1</span><br><span class="line">VALUES(0),(0),(0),(0);</span><br></pre></td></tr></table></figure><p>查询数据表test1中的数据，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM test1;</span><br><span class="line">+----+</span><br><span class="line">| id |</span><br><span class="line">+----+</span><br><span class="line">|  1 |</span><br><span class="line">|  2 |</span><br><span class="line">|  3 |</span><br><span class="line">|  4 |</span><br><span class="line">+----+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>删除id为4的记录，语句如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM test1 WHERE id = 4;</span><br></pre></td></tr></table></figure><p>再次插入一个空值，语句如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test1 VALUES(0);</span><br></pre></td></tr></table></figure><p>查询此时数据表test1中的数据，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM test1;</span><br><span class="line">+----+</span><br><span class="line">| id |</span><br><span class="line">+----+</span><br><span class="line">|  1 |</span><br><span class="line">|  2 |</span><br><span class="line">|  3 |</span><br><span class="line">|  5 |</span><br><span class="line">+----+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>从结果可以看出，虽然删除了id为4的记录，但是再次插入空值时，并没有重用被删除的4，而是分配了5。<br>删除id为5的记录，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM test1 where id=5;</span><br></pre></td></tr></table></figure><p><strong>重启数据库</strong>，重新插入一个空值。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test1 values(0);</span><br></pre></td></tr></table></figure><p>再次查询数据表test1中的数据，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM test1;</span><br><span class="line">+----+</span><br><span class="line">| id |</span><br><span class="line">+----+</span><br><span class="line">|  1 |</span><br><span class="line">|  2 |</span><br><span class="line">|  3 |</span><br><span class="line">|  4 |</span><br><span class="line">+----+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>从结果可以看出，新插入的0值分配的是4，按照重启前的操作逻辑，此处应该分配6。出现上述结果的主要原因是自增主键没有持久化。<br>在MySQL 5.7系统中，对于自增主键的分配规则，是由InnoDB数据字典内部一个<code>计数器</code>来决定的，而该计数器只在<code>内存中维护</code>，并不会持久化到磁盘中。当数据库重启时，该计数器会被初始化。</p><p>在MySQL 8.0版本中，上述测试步骤最后一步的结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM test1;</span><br><span class="line">+----+</span><br><span class="line">| id |</span><br><span class="line">+----+</span><br><span class="line">|  1 |</span><br><span class="line">|  2 |</span><br><span class="line">|  3 |</span><br><span class="line">|  6 |</span><br><span class="line">+----+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>从结果可以看出，自增变量已经持久化了。</p><p>MySQL 8.0将自增主键的计数器持久化到<code>重做日志</code>中。每次计数器发生改变，都会将其写入重做日志中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值。</p><h2 id="FOREIGN-KEY-约束"><a href="#FOREIGN-KEY-约束" class="headerlink" title="FOREIGN KEY 约束"></a>FOREIGN KEY 约束</h2><h3 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h3><p>限定某个表的某个字段的引用完整性。</p><p>比如：员工表的员工所在部门的选择，必须在部门表能找到对应的部分。</p><p><img src="/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC13%E7%AB%A0_%E7%BA%A6%E6%9D%9F/1555428214706.png" alt="1555428214706"></p><h3 id="关键字-4"><a href="#关键字-4" class="headerlink" title="关键字"></a>关键字</h3><p>FOREIGN KEY</p><h3 id="主表和从表-父表和子表"><a href="#主表和从表-父表和子表" class="headerlink" title="主表和从表/父表和子表"></a>主表和从表/父表和子表</h3><p>主表（父表）：被引用的表，被参考的表</p><p>从表（子表）：引用别人的表，参考别人的表</p><p>例如：员工表的员工所在部门这个字段的值要参考部门表：部门表是主表，员工表是从表。</p><p>例如：学生表、课程表、选课表：选课表的学生和课程要分别参考学生表和课程表，学生表和课程表是主表，选课表是从表。</p><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><p>（1）从表的外键列，必须引用/参考主表的主键或唯一约束的列</p><p>​          为什么？因为被依赖/被参考的值必须是唯一的</p><p>（2）在创建外键约束时，如果不给外键约束命名，<strong>默认名不是列名，而是自动产生一个外键名</strong>（例如 student_ibfk_1;），也可以指定外键约束名。</p><p>（3）创建(CREATE)表时就指定外键约束的话，先创建主表，再创建从表</p><p>（4）删表时，先删从表（或先删除外键约束），再删除主表</p><p>（5）当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据</p><p>（6）在“从表”中指定外键约束，并且一个表可以建立多个外键约束</p><p>（7）从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样，逻辑意义一致。如果类型不一样，创建子表时，就会出现错误“ERROR 1005 (HY000): Can’t create table’database.tablename’(errno: 150)”。</p><p>​          例如：都是表示部门编号，都是int类型。</p><p>（8）<strong>当创建外键约束时，系统默认会在所在的列上建立对应的普通索引</strong>。但是索引名是外键的约束名。（根据外键查询效率很高）</p><p>（9）删除外键约束后，必须<code>手动</code>删除对应的索引</p><h3 id="添加外键约束"><a href="#添加外键约束" class="headerlink" title="添加外键约束"></a>添加外键约束</h3><p>（1）建表时</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 主表名称(</span><br><span class="line">字段1  数据类型  primary key,</span><br><span class="line">    字段2  数据类型</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table 从表名称(</span><br><span class="line">字段1  数据类型  primary key,</span><br><span class="line">    字段2  数据类型,</span><br><span class="line">    [CONSTRAINT &lt;外键约束名称&gt;] FOREIGN KEY（从表的某个字段) references 主表名(被参考字段)</span><br><span class="line">);</span><br><span class="line">#(从表的某个字段)的数据类型必须与主表名(被参考字段)的数据类型一致，逻辑意义也一样</span><br><span class="line">#(从表的某个字段)的字段名可以与主表名(被参考字段)的字段名一样，也可以不一样</span><br><span class="line"></span><br><span class="line">-- FOREIGN KEY: 在表级指定子表中的列</span><br><span class="line">-- REFERENCES: 标示在父表中的列</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table dept( #主表</span><br><span class="line">did int primary key,#部门编号</span><br><span class="line">    dname varchar(50)#部门名称</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table emp(#从表</span><br><span class="line">eid int primary key,  #员工编号</span><br><span class="line">    ename varchar(5),     #员工姓名</span><br><span class="line">    deptid int,#员工所在的部门</span><br><span class="line">    foreign key (deptid) references dept(did)   #在从表中指定外键约束</span><br><span class="line">    #emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">（1）主表dept必须先创建成功，然后才能创建emp表，指定外键成功。</span><br><span class="line">（2）删除表时，先删除从表emp，再删除主表dept</span><br></pre></td></tr></table></figure><p>（2）建表后</p><p>一般情况下，表与表的关联都是提前设计好了的，因此，会在创建表的时候就把外键约束定义好。不过，如果需要修改表的设计（比如添加新的字段，增加新的关联关系），但没有预先定义外键约束，那么，就要用修改表的方式来补充定义。</p><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 从表名 ADD [CONSTRAINT 约束名] FOREIGN KEY (从表的字段) REFERENCES 主表名(被引用字段) [on update xx][on delete xx];</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE emp1</span><br><span class="line">ADD [CONSTRAINT emp_dept_id_fk] FOREIGN KEY(dept_id) REFERENCES dept(dept_id);</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table dept(</span><br><span class="line">did int primary key,#部门编号</span><br><span class="line">    dname varchar(50)#部门名称</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table emp(</span><br><span class="line">eid int primary key,  #员工编号</span><br><span class="line">    ename varchar(5),     #员工姓名</span><br><span class="line">    deptid int#员工所在的部门</span><br><span class="line">);</span><br><span class="line">#这两个表创建时，没有指定外键的话，那么创建顺序是随意</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table emp add foreign key (deptid) references dept(did);</span><br></pre></td></tr></table></figure><h3 id="6-6-演示问题"><a href="#6-6-演示问题" class="headerlink" title="6.6 演示问题"></a>6.6 演示问题</h3><p>（1）失败：不是键列</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table dept(</span><br><span class="line">did int ,#部门编号</span><br><span class="line">    dname varchar(50)#部门名称</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table emp(</span><br><span class="line">eid int primary key,  #员工编号</span><br><span class="line">    ename varchar(5),     #员工姓名</span><br><span class="line">    deptid int,#员工所在的部门</span><br><span class="line">    foreign key (deptid) references dept(did)</span><br><span class="line">);</span><br><span class="line">#ERROR 1215 (HY000): Cannot add foreign key constraint  原因是dept的did不是键列</span><br></pre></td></tr></table></figure><p>（2）失败：数据类型不一致</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table dept(</span><br><span class="line">did int primary key,#部门编号</span><br><span class="line">    dname varchar(50)#部门名称</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table emp(</span><br><span class="line">eid int primary key,  #员工编号</span><br><span class="line">    ename varchar(5),     #员工姓名</span><br><span class="line">    deptid char,#员工所在的部门</span><br><span class="line">    foreign key (deptid) references dept(did)</span><br><span class="line">);</span><br><span class="line">#ERROR 1215 (HY000): Cannot add foreign key constraint  原因是从表的deptid字段和主表的did字段的数据类型不一致，并且要它俩的逻辑意义一致</span><br></pre></td></tr></table></figure><p>（3）成功，两个表字段名一样</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table dept(</span><br><span class="line">did int primary key,#部门编号</span><br><span class="line">    dname varchar(50)#部门名称</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table emp(</span><br><span class="line">eid int primary key,  #员工编号</span><br><span class="line">    ename varchar(5),     #员工姓名</span><br><span class="line">    did int,#员工所在的部门</span><br><span class="line">    foreign key (did) references dept(did)  </span><br><span class="line">    #emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号</span><br><span class="line">    #是否重名没问题，因为两个did在不同的表中</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>（4）添加、删除、修改问题</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table dept(</span><br><span class="line">did int primary key,#部门编号</span><br><span class="line">    dname varchar(50)#部门名称</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table emp(</span><br><span class="line">eid int primary key,  #员工编号</span><br><span class="line">    ename varchar(5),     #员工姓名</span><br><span class="line">    deptid int,#员工所在的部门</span><br><span class="line">    foreign key (deptid) references dept(did)  </span><br><span class="line">    #emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into dept values(1001,&#x27;教学部&#x27;);</span><br><span class="line">insert into dept values(1003, &#x27;财务部&#x27;);</span><br><span class="line"></span><br><span class="line">insert into emp values(1,&#x27;张三&#x27;,1001); #添加从表记录成功，在添加这条记录时，要求部门表有1001部门</span><br><span class="line"></span><br><span class="line">insert into emp values(2,&#x27;李四&#x27;,1005);#添加从表记录失败</span><br><span class="line">ERROR 1452 (23000): Cannot add（添加） or update（修改） a child row: a foreign key constraint fails (`atguigudb`.`emp`, CONSTRAINT `emp_ibfk_1` FOREIGN KEY (`deptid`) REFERENCES `dept` (`did`)) 从表emp添加记录失败，因为主表dept没有1005部门</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from dept;</span><br><span class="line">+------+--------+</span><br><span class="line">| did  | dname  |</span><br><span class="line">+------+--------+</span><br><span class="line">| 1001 | 教学部  |</span><br><span class="line">| 1003 | 财务部  |</span><br><span class="line">+------+--------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from emp;</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| eid | ename | deptid |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">|   1 | 张三   |   1001 |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update emp set deptid = 1002 where eid = 1;#修改从表失败 </span><br><span class="line">ERROR 1452 (23000): Cannot add（添加） or update（修改） a child row（子表的记录）: a foreign key constraint fails（外键约束失败） (`atguigudb`.`emp`, CONSTRAINT `emp_ibfk_1` FOREIGN KEY (`deptid`) REFERENCES `dept` (`did`))  #部门表did字段现在没有1002的值，所以员工表中不能修改员工所在部门deptid为1002</span><br><span class="line"></span><br><span class="line">update dept set did = 1002 where did = 1001;#修改主表失败</span><br><span class="line">ERROR 1451 (23000): Cannot delete（删除） or update（修改） a parent row（父表的记录）: a foreign key constraint fails (`atguigudb`.`emp`, CONSTRAINT `emp_ibfk_1` FOREIGN KEY (`deptid`) REFERENCES `dept` (`did`)) #部门表did的1001字段已经被emp引用了，所以部门表的1001字段就不能修改了。</span><br><span class="line"></span><br><span class="line">update dept set did = 1002 where did = 1003;#修改主表成功  因为部门表的1003部门没有被emp表引用，所以可以修改</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from dept where did=1001; #删除主表失败</span><br><span class="line">ERROR 1451 (23000): Cannot delete（删除） or update（修改） a parent row（父表记录）: a foreign key constraint fails (`atguigudb`.`emp`, CONSTRAINT `emp_ibfk_1` FOREIGN KEY (`deptid`) REFERENCES `dept` (`did`))  #因为部门表did的1001字段已经被emp引用了，所以部门表的1001字段对应的记录就不能被删除</span><br></pre></td></tr></table></figure><p>总结：约束关系是针对双方的</p><ul><li><p>添加了外键约束后，主表的修改和删除数据受约束</p></li><li><p>添加了外键约束后，从表的添加和修改数据受约束</p></li><li>在从表上建立外键，要求主表必须存在</li><li>删除主表时，要求从表从表先删除，或将从表中外键引用该主表的关系先删除</li></ul><h3 id="约束等级"><a href="#约束等级" class="headerlink" title="约束等级"></a>约束等级</h3><ul><li><p><code>Cascade方式</code>：在父表上update/delete记录时，同步update/delete掉子表的匹配记录 </p></li><li><p><code>Set null方式</code>：在父表上update/delete记录时，将子表上匹配记录的列设为null，但是要注意子表的外键列不能为not null  </p></li><li><p><code>No action方式</code>：如果子表中有匹配的记录，则不允许对父表对应候选键进行update/delete操作  </p></li><li><p><code>Restrict方式</code>：同no action， 都是立即检查外键约束</p></li><li><p><code>Set default方式</code>（在可视化工具SQLyog中可能显示空白）：父表有变更时，子表将外键列设置成一个默认的值，但Innodb不能识别</p></li></ul><p>如果没有指定等级，就相当于Restrict方式。</p><p>对于外键约束，最好是采用: <code>ON UPDATE CASCADE ON DELETE RESTRICT</code> 的方式。</p><p>（1）演示1：on update cascade on delete set null</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table dept(</span><br><span class="line">did int primary key,#部门编号</span><br><span class="line">    dname varchar(50)#部门名称</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table emp(</span><br><span class="line">eid int primary key,  #员工编号</span><br><span class="line">    ename varchar(5),     #员工姓名</span><br><span class="line">    deptid int,#员工所在的部门</span><br><span class="line">    foreign key (deptid) references dept(did)  on update cascade on delete set null</span><br><span class="line">    #把修改操作设置为级联修改等级，把删除操作设置为set null等级</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into dept values(1001,&#x27;教学部&#x27;);</span><br><span class="line">insert into dept values(1002, &#x27;财务部&#x27;);</span><br><span class="line">insert into dept values(1003, &#x27;咨询部&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert into emp values(1,&#x27;张三&#x27;,1001); #在添加这条记录时，要求部门表有1001部门</span><br><span class="line">insert into emp values(2,&#x27;李四&#x27;,1001);</span><br><span class="line">insert into emp values(3,&#x27;王五&#x27;,1002);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from dept;</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from emp;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#修改主表成功，从表也跟着修改，修改了主表被引用的字段1002为1004，从表的引用字段就跟着修改为1004了</span><br><span class="line">mysql&gt; update dept set did = 1004 where did = 1002;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from dept;</span><br><span class="line">+------+--------+</span><br><span class="line">| did  | dname  |</span><br><span class="line">+------+--------+</span><br><span class="line">| 1001 | 教学部 |</span><br><span class="line">| 1003 | 咨询部 |</span><br><span class="line">| 1004 | 财务部 | #原来是1002，修改为1004</span><br><span class="line">+------+--------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from emp;</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| eid | ename | deptid |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">|   1 | 张三  |   1001 |</span><br><span class="line">|   2 | 李四  |   1001 |</span><br><span class="line">|   3 | 王五  |   1004 | #原来是1002，跟着修改为1004</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#删除主表的记录成功，从表对应的字段的值被修改为null</span><br><span class="line">mysql&gt; delete from dept where did = 1001;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from dept;</span><br><span class="line">+------+--------+</span><br><span class="line">| did  | dname  | #记录1001部门被删除了</span><br><span class="line">+------+--------+</span><br><span class="line">| 1003 | 咨询部  |</span><br><span class="line">| 1004 | 财务部  |</span><br><span class="line">+------+--------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from emp;</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| eid | ename | deptid |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">|   1 | 张三  |   NULL | #原来引用1001部门的员工，deptid字段变为null</span><br><span class="line">|   2 | 李四  |   NULL |</span><br><span class="line">|   3 | 王五  |   1004 |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>（2）演示2：on update set null on delete cascade</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table dept(</span><br><span class="line">did int primary key,#部门编号</span><br><span class="line">    dname varchar(50)#部门名称</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table emp(</span><br><span class="line">eid int primary key,  #员工编号</span><br><span class="line">    ename varchar(5),     #员工姓名</span><br><span class="line">    deptid int,#员工所在的部门</span><br><span class="line">    foreign key (deptid) references dept(did)  on update set null on delete cascade</span><br><span class="line">    #把修改操作设置为set null等级，把删除操作设置为级联删除等级</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into dept values(1001,&#x27;教学部&#x27;);</span><br><span class="line">insert into dept values(1002, &#x27;财务部&#x27;);</span><br><span class="line">insert into dept values(1003, &#x27;咨询部&#x27;);</span><br><span class="line"></span><br><span class="line">insert into emp values(1,&#x27;张三&#x27;,1001); #在添加这条记录时，要求部门表有1001部门</span><br><span class="line">insert into emp values(2,&#x27;李四&#x27;,1001);</span><br><span class="line">insert into emp values(3,&#x27;王五&#x27;,1002);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from dept;</span><br><span class="line">+------+--------+</span><br><span class="line">| did  | dname  |</span><br><span class="line">+------+--------+</span><br><span class="line">| 1001 | 教学部 |</span><br><span class="line">| 1002 | 财务部 |</span><br><span class="line">| 1003 | 咨询部 |</span><br><span class="line">+------+--------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from emp;</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| eid | ename | deptid |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">|   1 | 张三  |   1001 |</span><br><span class="line">|   2 | 李四  |   1001 |</span><br><span class="line">|   3 | 王五  |   1002 |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#修改主表，从表对应的字段设置为null</span><br><span class="line">mysql&gt; update dept set did = 1004 where did = 1002;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from dept;</span><br><span class="line">+------+--------+</span><br><span class="line">| did  | dname  |</span><br><span class="line">+------+--------+</span><br><span class="line">| 1001 | 教学部 |</span><br><span class="line">| 1003 | 咨询部 |</span><br><span class="line">| 1004 | 财务部 | #原来did是1002</span><br><span class="line">+------+--------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from emp;</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| eid | ename | deptid |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">|   1 | 张三  |   1001 |</span><br><span class="line">|   2 | 李四  |   1001 |</span><br><span class="line">|   3 | 王五  |   NULL | #原来deptid是1002，因为部门表1002被修改了，1002没有对应的了，就设置为null</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#删除主表的记录成功，主表的1001行被删除了，从表相应的记录也被删除了</span><br><span class="line">mysql&gt; delete from dept where did=1001;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from dept;</span><br><span class="line">+------+--------+</span><br><span class="line">| did  | dname  | #部门表中1001部门被删除</span><br><span class="line">+------+--------+</span><br><span class="line">| 1003 | 咨询部 |</span><br><span class="line">| 1004 | 财务部 |</span><br><span class="line">+------+--------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from emp;</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| eid | ename | deptid |#原来1001部门的员工也被删除了</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">|   3 | 王五  |   NULL |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（3）演示：on update cascade on delete cascade</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table dept(</span><br><span class="line">did int primary key,#部门编号</span><br><span class="line">    dname varchar(50)#部门名称</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table emp(</span><br><span class="line">eid int primary key,  #员工编号</span><br><span class="line">    ename varchar(5),     #员工姓名</span><br><span class="line">    deptid int,#员工所在的部门</span><br><span class="line">    foreign key (deptid) references dept(did)  on update cascade on delete cascade</span><br><span class="line">    #把修改操作设置为级联修改等级，把删除操作也设置为级联删除等级</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into dept values(1001,&#x27;教学部&#x27;);</span><br><span class="line">insert into dept values(1002, &#x27;财务部&#x27;);</span><br><span class="line">insert into dept values(1003, &#x27;咨询部&#x27;);</span><br><span class="line"></span><br><span class="line">insert into emp values(1,&#x27;张三&#x27;,1001); #在添加这条记录时，要求部门表有1001部门</span><br><span class="line">insert into emp values(2,&#x27;李四&#x27;,1001);</span><br><span class="line">insert into emp values(3,&#x27;王五&#x27;,1002);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from dept;</span><br><span class="line">+------+--------+</span><br><span class="line">| did  | dname  |</span><br><span class="line">+------+--------+</span><br><span class="line">| 1001 | 教学部 |</span><br><span class="line">| 1002 | 财务部 |</span><br><span class="line">| 1003 | 咨询部 |</span><br><span class="line">+------+--------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from emp;</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| eid | ename | deptid |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">|   1 | 张三  |   1001 |</span><br><span class="line">|   2 | 李四  |   1001 |</span><br><span class="line">|   3 | 王五  |   1002 |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#修改主表，从表对应的字段自动修改</span><br><span class="line">mysql&gt; update dept set did = 1004 where did = 1002;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from dept;</span><br><span class="line">+------+--------+</span><br><span class="line">| did  | dname  |</span><br><span class="line">+------+--------+</span><br><span class="line">| 1001 | 教学部 |</span><br><span class="line">| 1003 | 咨询部 |</span><br><span class="line">| 1004 | 财务部 | #部门1002修改为1004</span><br><span class="line">+------+--------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from emp;</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| eid | ename | deptid |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">|   1 | 张三  |   1001 |</span><br><span class="line">|   2 | 李四  |   1001 |</span><br><span class="line">|   3 | 王五  |   1004 | #级联修改</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#删除主表的记录成功，主表的1001行被删除了，从表相应的记录也被删除了</span><br><span class="line">mysql&gt; delete from dept where did=1001;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from dept;</span><br><span class="line">+------+--------+</span><br><span class="line">| did  | dname  | #1001部门被删除了</span><br><span class="line">+------+--------+</span><br><span class="line">| 1003 | 咨询部 |</span><br><span class="line">| 1004 | 财务部 | </span><br><span class="line">+------+--------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from emp;</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| eid | ename | deptid |  #1001部门的员工也被删除了</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">|   3 | 王五  |   1004 |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="6-8-删除外键约束"><a href="#6-8-删除外键约束" class="headerlink" title="6.8 删除外键约束"></a>6.8 删除外键约束</h3><p>流程如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1)第一步先查看约束名和删除外键约束</span><br><span class="line">SELECT * FROM information_schema.table_constraints WHERE table_name = &#x27;表名称&#x27;;#查看某个表的约束名</span><br><span class="line"></span><br><span class="line">ALTER TABLE 从表名 DROP FOREIGN KEY 外键约束名;</span><br><span class="line"></span><br><span class="line">（2）第二步查看索引名和删除索引。（注意，只能手动删除）</span><br><span class="line">SHOW INDEX FROM 表名称; #查看某个表的索引名</span><br><span class="line"></span><br><span class="line">ALTER TABLE 从表名 DROP INDEX 索引名;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM information_schema.table_constraints WHERE table_name = &#x27;emp&#x27;;</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table emp drop foreign key emp_ibfk_1;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show index from emp;</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table emp drop index deptid;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt;  show index from emp;</span><br></pre></td></tr></table></figure><h3 id="6-9-开发场景"><a href="#6-9-开发场景" class="headerlink" title="6.9 开发场景"></a>6.9 开发场景</h3><p><strong>问题1：如果两个表之间有关系（一对一、一对多），比如：员工表和部门表（一对多），它们之间是否一定要建外键约束？</strong></p><p>答：不是的</p><p><strong>问题2：建和不建外键约束有什么区别？</strong></p><p>答：建外键约束，你的操作（创建表、删除表、添加、修改、删除）会受到限制，从语法层面受到限制。例如：在员工表中不可能添加一个员工信息，它的部门的值在部门表中找不到。</p><p>不建外键约束，你的操作（创建表、删除表、添加、修改、删除）不受限制，要保证数据的<code>引用完整性</code>，只能依<code>靠程序员的自觉</code>，或者是<code>在Java程序中进行限定</code>。例如：在员工表中，可以添加一个员工的信息，它的部门指定为一个完全不存在的部门。</p><p><strong>问题3：那么建和不建外键约束和查询有没有关系？</strong></p><p>答：没有</p><blockquote><p>在 MySQL 里，外键约束是有成本的，需要消耗系统资源。对于大并发的 SQL 操作，有可能会不适合。比如大型网站的中央数据库，可能会<code>因为外键约束的系统开销而变得非常慢</code>。所以， MySQL 允许你不使用系统自带的外键约束，在<code>应用层面</code>完成检查数据一致性的逻辑。也就是说，即使你不用外键约束，也要想办法通过应用层面的附加逻辑，来实现外键约束的功能，确保数据的一致性。</p></blockquote><h3 id="6-10-阿里开发规范"><a href="#6-10-阿里开发规范" class="headerlink" title="6.10 阿里开发规范"></a>6.10 阿里开发规范</h3><p>【<code>强制</code>】不得使用外键与级联，一切外键概念必须在应用层解决。 </p><p>说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于<code>单机低并发</code>，不适合<code>分布式</code>、<code>高并发集群</code>；级联更新是强阻塞，存在数据库<code>更新风暴</code>的风险；外键影响数据库的<code>插入速度</code>。</p><h2 id="7-CHECK-约束"><a href="#7-CHECK-约束" class="headerlink" title="7. CHECK 约束"></a>7. CHECK 约束</h2><h3 id="7-1-作用"><a href="#7-1-作用" class="headerlink" title="7.1 作用"></a>7.1 作用</h3><p>检查某个字段的值是否符号xx要求，一般指的是值的范围</p><h3 id="2、关键字"><a href="#2、关键字" class="headerlink" title="2、关键字"></a>2、关键字</h3><p>CHECK</p><h3 id="3、说明：MySQL-5-7-不支持"><a href="#3、说明：MySQL-5-7-不支持" class="headerlink" title="3、说明：MySQL 5.7 不支持"></a>3、说明：MySQL 5.7 不支持</h3><p>MySQL5.7 可以使用check约束，但check约束对数据验证没有任何作用。添加数据时，没有任何错误或警告</p><p>但是<strong>MySQL 8.0中可以使用check约束了</strong>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table employee(</span><br><span class="line">eid int primary key,</span><br><span class="line">    ename varchar(5),</span><br><span class="line">    gender char check (&#x27;男&#x27; or &#x27;女&#x27;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into employee values(1,&#x27;张三&#x27;,&#x27;妖&#x27;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from employee;</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| eid | ename | gender |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">|   1 | 张三   | 妖     |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><ul><li>再举例</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE temp(</span><br><span class="line">id INT AUTO_INCREMENT,</span><br><span class="line">NAME VARCHAR(20),</span><br><span class="line">age INT CHECK(age &gt; 20),</span><br><span class="line">PRIMARY KEY(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>再举例</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">age tinyint check(age &gt;20) 或 sex char(2) check(sex in(‘男’,’女’))</span><br></pre></td></tr></table></figure><ul><li>再举例</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHECK(height&gt;=0 AND height&lt;3)</span><br></pre></td></tr></table></figure><h2 id="8-DEFAULT约束"><a href="#8-DEFAULT约束" class="headerlink" title="8. DEFAULT约束"></a>8. DEFAULT约束</h2><h3 id="8-1-作用"><a href="#8-1-作用" class="headerlink" title="8.1 作用"></a>8.1 作用</h3><p>给某个字段/某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默认值。</p><h3 id="8-2-关键字"><a href="#8-2-关键字" class="headerlink" title="8.2 关键字"></a>8.2 关键字</h3><p>DEFAULT</p><h3 id="8-3-如何给字段加默认值"><a href="#8-3-如何给字段加默认值" class="headerlink" title="8.3 如何给字段加默认值"></a>8.3 如何给字段加默认值</h3><p>（1）建表时</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名称(</span><br><span class="line">字段名  数据类型  primary key,</span><br><span class="line">    字段名  数据类型  unique key not null,  </span><br><span class="line">    字段名  数据类型  unique key,</span><br><span class="line">    字段名  数据类型  not null default 默认值, </span><br><span class="line">);</span><br><span class="line">create table 表名称(</span><br><span class="line">字段名  数据类型 default 默认值 ,</span><br><span class="line">    字段名  数据类型 not null default 默认值,  </span><br><span class="line">    字段名  数据类型 not null default 默认值,</span><br><span class="line">    primary key(字段名),</span><br><span class="line">    unique key(字段名)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">说明：默认值约束一般不在唯一键和主键列上加</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table employee(</span><br><span class="line">eid int primary key,</span><br><span class="line">    ename varchar(20) not null,</span><br><span class="line">    gender char default &#x27;男&#x27;,</span><br><span class="line">    tel char(11) not null default &#x27;&#x27; #默认是空字符串</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc employee;</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field  | Type        | Null | Key | Default | Extra |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| eid    | int(11)     | NO   | PRI | NULL    |       |</span><br><span class="line">| ename  | varchar(20) | NO   |     | NULL    |       |</span><br><span class="line">| gender | char(1)     | YES  |     | 男      |       |</span><br><span class="line">| tel    | char(11)    | NO   |     |         |       |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into employee values(1,&#x27;汪飞&#x27;,&#x27;男&#x27;,&#x27;13700102535&#x27;); #成功</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from employee;</span><br><span class="line">+-----+-------+--------+-------------+</span><br><span class="line">| eid | ename | gender | tel         |</span><br><span class="line">+-----+-------+--------+-------------+</span><br><span class="line">|   1 | 汪飞  | 男     | 13700102535 |</span><br><span class="line">+-----+-------+--------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into employee(eid,ename) values(2,&#x27;天琪&#x27;); #成功</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from employee;</span><br><span class="line">+-----+-------+--------+-------------+</span><br><span class="line">| eid | ename | gender | tel         |</span><br><span class="line">+-----+-------+--------+-------------+</span><br><span class="line">|   1 | 汪飞  | 男     | 13700102535 |</span><br><span class="line">|   2 | 天琪  | 男     |             |</span><br><span class="line">+-----+-------+--------+-------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into employee(eid,ename) values(3,&#x27;二虎&#x27;);</span><br><span class="line">#ERROR 1062 (23000): Duplicate entry &#x27;&#x27; for key &#x27;tel&#x27;  </span><br><span class="line">#如果tel有唯一性约束的话会报错，如果tel没有唯一性约束，可以添加成功</span><br></pre></td></tr></table></figure><p>再举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE myemp(</span><br><span class="line">id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">NAME VARCHAR(15),</span><br><span class="line">salary DOUBLE(10,2) DEFAULT 2000</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>（2）建表后</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名称 modify 字段名 数据类型 default 默认值;</span><br><span class="line"></span><br><span class="line">#如果这个字段原来有非空约束，你还保留非空约束，那么在加默认值约束时，还得保留非空约束，否则非空约束就被删除了</span><br><span class="line">#同理，在给某个字段加非空约束也一样，如果这个字段原来有默认值约束，你想保留，也要在modify语句中保留默认值约束，否则就删除了</span><br><span class="line">alter table 表名称 modify 字段名 数据类型 default 默认值 not null;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table employee(</span><br><span class="line">eid int primary key,</span><br><span class="line">    ename varchar(20),</span><br><span class="line">    gender char,</span><br><span class="line">    tel char(11) not null</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc employee;</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field  | Type        | Null | Key | Default | Extra |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| eid    | int(11)     | NO   | PRI | NULL    |       |</span><br><span class="line">| ename  | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| gender | char(1)     | YES  |     | NULL    |       |</span><br><span class="line">| tel    | char(11)    | NO   |     | NULL    |       |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table employee modify gender char default &#x27;男&#x27;;  #给gender字段增加默认值约束</span><br><span class="line">alter table employee modify tel char(11) default &#x27;&#x27;; #给tel字段增加默认值约束</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc employee;</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field  | Type        | Null | Key | Default | Extra |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| eid    | int(11)     | NO   | PRI | NULL    |       |</span><br><span class="line">| ename  | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| gender | char(1)     | YES  |     | 男      |       |</span><br><span class="line">| tel    | char(11)    | YES  |     |         |       |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table employee modify tel char(11) default &#x27;&#x27;  not null;#给tel字段增加默认值约束，并保留非空约束</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc employee;</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field  | Type        | Null | Key | Default | Extra |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| eid    | int(11)     | NO   | PRI | NULL    |       |</span><br><span class="line">| ename  | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| gender | char(1)     | YES  |     | 男      |       |</span><br><span class="line">| tel    | char(11)    | NO   |     |         |       |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="8-4-如何删除默认值约束"><a href="#8-4-如何删除默认值约束" class="headerlink" title="8.4 如何删除默认值约束"></a>8.4 如何删除默认值约束</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名称 modify 字段名 数据类型 ;#删除默认值约束，也不保留非空约束</span><br><span class="line"></span><br><span class="line">alter table 表名称 modify 字段名 数据类型  not null; #删除默认值约束，保留非空约束</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table employee modify gender char; #删除gender字段默认值约束，如果有非空约束，也一并删除</span><br><span class="line">alter table employee modify tel char(11)  not null;#删除tel字段默认值约束，保留非空约束</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc employee;</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field  | Type        | Null | Key | Default | Extra |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| eid    | int(11)     | NO   | PRI | NULL    |       |</span><br><span class="line">| ename  | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| gender | char(1)     | YES  |     | NULL    |       |</span><br><span class="line">| tel    | char(11)    | NO   |     | NULL    |       |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><p><strong>面试1、为什么建表时，加 not null default ‘’ 或 default 0</strong></p><p>答：不想让表中出现null值。</p><p><strong>面试2、为什么不想要 null 的值</strong></p><p>答:（1）不好比较。null是一种特殊值，比较时只能用专门的is null 和 is not null来比较。碰到运算符，通常返回null。</p><p>​     （2）效率不高。影响提高索引效果。因此，我们往往在建表时 not null default ‘’ 或 default 0</p><p><strong>面试3、带AUTO_INCREMENT约束的字段值是从1开始的吗？</strong><br>在MySQL中，默认AUTO_INCREMENT的初始值是1，每新增一条记录，字段值自动加1。设置自增属性（AUTO_INCREMENT）的时候，还可以指定第一条插入记录的自增字段的值，这样新插入的记录的自增字段值从初始值开始递增，如在表中插入第一条记录，同时指定id值为5，则以后插入的记录的id值就会从6开始往上增加。添加主键约束时，往往需要设置字段自动增加属性。</p><p><strong>面试4、并不是每个表都可以任意选择存储引擎？</strong><br>外键约束（FOREIGN KEY）不能跨引擎使用。</p><p>MySQL支持多种存储引擎，每一个表都可以指定一个不同的存储引擎，需要注意的是：外键约束是用来保证数据的参照完整性的，如果表之间需要关联外键，却指定了不同的存储引擎，那么这些表之间是不能创建外键约束的。所以说，存储引擎的选择也不完全是随意的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第13章-约束&quot;&gt;&lt;a href=&quot;#第13章-约束&quot; class=&quot;headerlink&quot; title=&quot;第13章_约束&quot;&gt;&lt;/a&gt;第13章_约束&lt;/h1&gt;&lt;p&gt;讲师：尚硅谷-宋红康（江湖人称：康师傅）&lt;/p&gt;
&lt;p&gt;官网：&lt;a href=&quot;http://www</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    <category term="基础版" scheme="http://example.com/categories/MySQL/%E5%9F%BA%E7%A1%80%E7%89%88/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>第12章_MySQL数据类型精讲</title>
    <link href="http://example.com/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC12%E7%AB%A0_MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2/"/>
    <id>http://example.com/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC12%E7%AB%A0_MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2/</id>
    <published>2022-05-17T12:37:12.000Z</published>
    <updated>2022-05-17T13:02:20.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第12章-MySQL数据类型精讲"><a href="#第12章-MySQL数据类型精讲" class="headerlink" title="第12章_MySQL数据类型精讲"></a>第12章_MySQL数据类型精讲</h1><p>讲师：尚硅谷-宋红康（江湖人称：康师傅）</p><p>官网：<a href="http://www.atguigu.com/">http://www.atguigu.com</a></p><hr><h2 id="MySQL中的数据类型"><a href="#MySQL中的数据类型" class="headerlink" title="MySQL中的数据类型"></a>MySQL中的数据类型</h2><div class="table-container"><table><thead><tr><th>类型</th><th>类型举例</th></tr></thead><tbody><tr><td>整数类型</td><td>TINYINT、SMALLINT、MEDIUMINT、INT(或INTEGER)、BIGINT</td></tr><tr><td>浮点类型</td><td>FLOAT、DOUBLE</td></tr><tr><td>定点数类型</td><td>DECIMAL</td></tr><tr><td>位类型</td><td>BIT</td></tr><tr><td>日期时间类型</td><td>YEAR、TIME、DATE、DATETIME、TIMESTAMP</td></tr><tr><td>文本字符串类型</td><td>CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT</td></tr><tr><td>枚举类型</td><td>ENUM</td></tr><tr><td>集合类型</td><td>SET</td></tr><tr><td>二进制字符串类型</td><td>BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB</td></tr><tr><td>JSON类型</td><td>JSON对象、JSON数组</td></tr><tr><td>空间数据类型</td><td>单值类型：GEOMETRY、POINT、LINESTRING、POLYGON；<br>集合类型：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION</td></tr></tbody></table></div><p>常见数据类型的属性，如下：</p><div class="table-container"><table><thead><tr><th>MySQL关键字</th><th>含义</th></tr></thead><tbody><tr><td>NULL</td><td>数据列可包含NULL值</td></tr><tr><td>NOT NULL</td><td>数据列不允许包含NULL值</td></tr><tr><td>DEFAULT</td><td>默认值</td></tr><tr><td>PRIMARY KEY</td><td>主键</td></tr><tr><td>AUTO_INCREMENT</td><td>自动递增，适用于整数类型</td></tr><tr><td>UNSIGNED</td><td>无符号</td></tr><tr><td>CHARACTER SET name</td><td>指定一个字符集</td></tr></tbody></table></div><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><h3 id="类型介绍"><a href="#类型介绍" class="headerlink" title="类型介绍"></a>类型介绍</h3><p>整数类型一共有 5 种，包括 TINYINT、SMALLINT、MEDIUMINT、INT（INTEGER）和 BIGINT。</p><p>它们的区别如下表所示：</p><div class="table-container"><table><thead><tr><th><strong>整数类型</strong></th><th><strong>字节</strong></th><th>有符号数取值范围</th><th>无符号数取值范围</th></tr></thead><tbody><tr><td>TINYINT</td><td>1</td><td>-128~127</td><td>0~255</td></tr><tr><td>SMALLINT</td><td>2</td><td>-32768~32767</td><td>0~65535</td></tr><tr><td>MEDIUMINT</td><td>3</td><td>-8388608~8388607</td><td>0~16777215</td></tr><tr><td>INT、INTEGER</td><td>4</td><td>-2147483648~2147483647</td><td>0~4294967295</td></tr><tr><td>BIGINT</td><td>8</td><td>-9223372036854775808~9223372036854775807</td><td>0~18446744073709551615</td></tr></tbody></table></div><h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p><strong>整数类型的可选属性有三个：</strong></p><h4 id="M"><a href="#M" class="headerlink" title="M"></a>M</h4><p><code>M</code>: 表示显示宽度，M的取值范围是(0, 255)。例如，int(5)：当数据宽度小于5位的时候在数字前面需要用字符填满宽度。该项功能需要配合“<code>ZEROFILL</code>”使用，表示用“0”填满宽度，否则指定显示宽度无效。</p><p>如果设置了显示宽度，那么插入的数据宽度超过显示宽度限制，会不会截断或插入失败？</p><p>答案：不会对插入的数据有任何影响，还是按照类型的实际宽度进行保存，即<code>显示宽度与类型可以存储的值范围无关</code>。<strong>从MySQL 8.0.17开始，整数数据类型不推荐使用显示宽度属性。</strong></p><p>整型数据类型可以在定义表结构时指定所需要的显示宽度，如果不指定，则系统为每一种类型指定默认的宽度值。</p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_int1 ( x TINYINT,　y SMALLINT,　z MEDIUMINT,　m INT,　n BIGINT );</span><br></pre></td></tr></table></figure><p>查看表结构 （MySQL5.7中显式如下，MySQL8中不再显式范围）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc test_int1;</span><br><span class="line">+-------+--------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type         | Null | Key | Default | Extra |</span><br><span class="line">+-------+--------------+------+-----+---------+-------+</span><br><span class="line">|   x   | tinyint(4)   | YES  |     | NULL    |       |</span><br><span class="line">| 　y   | smallint(6)  | YES  |     | NULL    |       |</span><br><span class="line">| 　z   | mediumint(9) | YES  |     | NULL    |       |</span><br><span class="line">| 　m   | int(11)      | YES  |     | NULL    |       |</span><br><span class="line">| 　n   | bigint(20)   | YES  |     | NULL    |       |</span><br><span class="line">+-------+--------------+------+-----+---------+-------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>TINYINT有符号数和无符号数的取值范围分别为-128~127和0~255，由于负号占了一个数字位，因此TINYINT默认的显示宽度为4。同理，其他整数类型的默认显示宽度与其有符号数的最小值的宽度相同。</p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_int2(</span><br><span class="line">f1 INT,</span><br><span class="line">f2 INT(5),</span><br><span class="line">f3 INT(5) ZEROFILL</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">DESC test_int2;</span><br><span class="line"></span><br><span class="line">INSERT INTO test_int2(f1,f2,f3)</span><br><span class="line">VALUES(1,123,123);</span><br><span class="line"></span><br><span class="line">INSERT INTO test_int2(f1,f2)</span><br><span class="line">VALUES(123456,123456);</span><br><span class="line"></span><br><span class="line">INSERT INTO test_int2(f1,f2,f3)</span><br><span class="line">VALUES(123456,123456,123456);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM test_int2;</span><br><span class="line">+--------+--------+--------+</span><br><span class="line">| f1     | f2     | f3     |</span><br><span class="line">+--------+--------+--------+</span><br><span class="line">|      1 |    123 |  00123 |</span><br><span class="line">| 123456 | 123456 |   NULL |</span><br><span class="line">| 123456 | 123456 | 123456 |</span><br><span class="line">+--------+--------+--------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="UNSIGNED"><a href="#UNSIGNED" class="headerlink" title="UNSIGNED"></a>UNSIGNED</h4><p><code>UNSIGNED</code>: 无符号类型（非负），所有的整数类型都有一个可选的属性UNSIGNED（无符号属性），无符号整数类型的最小取值为0。所以，如果需要在MySQL数据库中保存非负整数值时，可以将整数类型设置为无符号类型。</p><p>int类型默认显示宽度为int(11)，无符号int类型默认显示宽度为int(10)。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_int3(</span><br><span class="line">f1 INT UNSIGNED</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">mysql&gt; desc test_int3;</span><br><span class="line">+-------+------------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type             | Null | Key | Default | Extra |</span><br><span class="line">+-------+------------------+------+-----+---------+-------+</span><br><span class="line">| f1    | int(10) unsigned | YES  |     | NULL    |       |</span><br><span class="line">+-------+------------------+------+-----+---------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="ZEROFILL"><a href="#ZEROFILL" class="headerlink" title="ZEROFILL"></a>ZEROFILL</h4><p><code>ZEROFILL</code>: 0填充,（如果某列是ZEROFILL，那么MySQL会自动为当前列添加UNSIGNED属性），如果指定了ZEROFILL只是表示不够M位时，用0在左边填充，如果超过M位，只要不超过数据存储范围即可。</p><p>原来，在 int(M) 中，M 的值跟 int(M) 所占多少存储空间并无任何关系。 int(3)、int(4)、int(8) 在磁盘上都是占用 4 bytes 的存储空间。也就是说，<strong>int(M)，必须和UNSIGNED ZEROFILL一起使用才有意义。</strong>如果整数值超过M位，就按照实际位数存储。只是无须再用字符 0 进行填充。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p><code>TINYINT</code>：一般用于枚举数据，比如系统设定取值范围很小且固定的场景。</p><p><code>SMALLINT</code>：可以用于较小范围的统计数据，比如统计工厂的固定资产库存数量等。</p><p><code>MEDIUMINT</code>：用于较大整数的计算，比如车站每日的客流量等。</p><p><code>INT、INTEGER</code>：取值范围足够大，一般情况下不用考虑超限问题，用得最多。比如商品编号。</p><p><code>BIGINT</code>：只有当你处理特别巨大的整数时才会用到。比如双十一的交易量、大型门户网站点击量、证券公司衍生产品持仓等。</p><h3 id="如何选择？"><a href="#如何选择？" class="headerlink" title="如何选择？"></a>如何选择？</h3><p>在评估用哪种整数类型的时候，你需要考虑<code>存储空间</code>和<code>可靠性</code>的平衡问题：一方 面，用占用字节数少的整数类型可以节省存储空间；另一方面，要是为了节省存储空间， 使用的整数类型取值范围太小，一旦遇到超出取值范围的情况，就可能引起<code>系统错误</code>，影响可靠性。 </p><p>举个例子，商品编号采用的数据类型是 INT。原因就在于，客户门店中流通的商品种类较多，而且，每天都有旧商品下架，新商品上架，这样不断迭代，日积月累。</p><p>如果使用 SMALLINT 类型，虽然占用字节数比 INT 类型的整数少，但是却不能保证数据不会超出范围 65535。相反，使用 INT，就能确保有足够大的取值范围，不用担心数据超出范围影响可靠性的问题。 </p><p>你要注意的是，在实际工作中，<strong>系统故障产生的成本远远超过增加几个字段存储空间所产生的成本</strong>。因此，我建议你首先确保数据不会超过取值范围，在这个前提之下，再去考虑如何节省存储空间。</p><h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h2><h3 id="类型介绍-1"><a href="#类型介绍-1" class="headerlink" title="类型介绍"></a>类型介绍</h3><p>浮点数和定点数类型的特点是可以<code>处理小数</code>，你可以把整数看成小数的一个特例。因此，浮点数和定点数的使用场景，比整数大多了。 MySQL支持的浮点数类型，分别是 FLOAT、DOUBLE、REAL。</p><ul><li>FLOAT 表示单精度浮点数；</li><li>DOUBLE 表示双精度浮点数；</li></ul><p><img src="/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC12%E7%AB%A0_MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2/image-20211007173312237.png" alt="image-20211007173312237"></p><ul><li><p>REAL默认就是 DOUBLE。如果你把 SQL 模式设定为启用“<code>REAL_AS_FLOAT</code>”，那 么，MySQL 就认为 REAL 是 FLOAT。如果要启用“REAL_AS_FLOAT”，可以通过以下 SQL 语句实现：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET sql_mode = “REAL_AS_FLOAT”;</span><br></pre></td></tr></table></figure></li></ul><p><strong>问题1：</strong>FLOAT 和 DOUBLE 这两种数据类型的区别是啥呢？</p><p>FLOAT 占用字节数少，取值范围小；DOUBLE 占用字节数多，取值范围也大。</p><p><strong>问题2：</strong>为什么浮点数类型的无符号数取值范围，只相当于有符号数取值范围的一半，也就是只相当于有符号数取值范围大于等于零的部分呢？ </p><p>MySQL 存储浮点数的格式为：<code>符号(S)</code>、<code>尾数(M)</code>和 <code>阶码(E)</code>。因此，无论有没有符号，MySQL 的浮点数都会存储表示符号的部分。因此， 所谓的无符号数取值范围，其实就是有符号数取值范围大于等于零的部分。</p><h3 id="数据精度说明"><a href="#数据精度说明" class="headerlink" title="数据精度说明"></a>数据精度说明</h3><p>对于浮点类型，在MySQL中单精度值使用<code>4</code>个字节，双精度值使用<code>8</code>个字节。</p><ul><li><p>MySQL允许使用<code>非标准语法</code>（其他数据库未必支持，因此如果涉及到数据迁移，则最好不要这么用）：<code>FLOAT(M,D)</code>或<code>DOUBLE(M,D)</code>。这里，M称为<code>精度</code>，D称为<code>标度</code>。(M,D)中 M=整数位+小数位，D=小数位。 D&lt;=M&lt;=255，0&lt;=D&lt;=30。</p><p>例如，定义为FLOAT(5,2)的一个列可以显示为-999.99-999.99。如果超过这个范围会报错。</p></li></ul><ul><li>FLOAT和DOUBLE类型在不指定(M,D)时，默认会按照实际的精度（由实际的硬件和操作系统决定）来显示。</li><li>说明：浮点类型，也可以加<code>UNSIGNED</code>，但是不会改变数据范围，例如：FLOAT(3,2) UNSIGNED仍然只能表示0-9.99的范围。</li></ul><ul><li><p>不管是否显式设置了精度(M,D)，这里MySQL的处理方案如下：</p><ul><li>如果存储时，整数部分超出了范围，MySQL就会报错，不允许存这样的值</li><li><p>如果存储时，小数点部分若超出范围，就分以下情况：</p><ul><li>若四舍五入后，整数部分没有超出范围，则只警告，但能成功操作并四舍五入删除多余的小数位后保存。例如在FLOAT(5,2)列内插入999.009，近似结果是999.01。</li><li>若四舍五入后，整数部分超出范围，则MySQL报错，并拒绝处理。如FLOAT(5,2)列内插入999.995和-999.995都会报错。</li></ul></li></ul></li><li><p><strong>从MySQL 8.0.17开始，FLOAT(M,D) 和DOUBLE(M,D)用法在官方文档中已经明确不推荐使用</strong>，将来可能被移除。另外，关于浮点型FLOAT和DOUBLE的UNSIGNED也不推荐使用了，将来也可能被移除。</p></li><li><p>举例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_double1(</span><br><span class="line">f1 FLOAT,</span><br><span class="line">f2 FLOAT(5,2),</span><br><span class="line">f3 DOUBLE,</span><br><span class="line">f4 DOUBLE(5,2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">DESC test_double1;</span><br><span class="line"></span><br><span class="line">INSERT INTO test_double1</span><br><span class="line">VALUES(123.456,123.456,123.4567,123.45);</span><br><span class="line"></span><br><span class="line">#Out of range value for column &#x27;f2&#x27; at row 1</span><br><span class="line">INSERT INTO test_double1</span><br><span class="line">VALUES(123.456,1234.456,123.4567,123.45); </span><br><span class="line"></span><br><span class="line">SELECT * FROM test_double1;</span><br></pre></td></tr></table></figure></li></ul><h3 id="精度误差说明"><a href="#精度误差说明" class="headerlink" title="精度误差说明"></a>精度误差说明</h3><p>浮点数类型有个缺陷，就是不精准。下面我来重点解释一下为什么 MySQL 的浮点数不够精准。比如，我们设计一个表，有f1这个字段，插入值分别为0.47,0.44,0.19，我们期待的运行结果是：0.47 + 0.44 + 0.19 = 1.1。而使用sum之后查询：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_double2(</span><br><span class="line">f1 DOUBLE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO test_double2</span><br><span class="line">VALUES(0.47),(0.44),(0.19);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT SUM(f1)</span><br><span class="line">    -&gt; FROM test_double2;</span><br><span class="line">+--------------------+</span><br><span class="line">| SUM(f1)            |</span><br><span class="line">+--------------------+</span><br><span class="line">| 1.0999999999999999 |</span><br><span class="line">+--------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT SUM(f1) = 1.1,1.1 = 1.1</span><br><span class="line">    -&gt; FROM test_double2;</span><br><span class="line">+---------------+-----------+</span><br><span class="line">| SUM(f1) = 1.1 | 1.1 = 1.1 |</span><br><span class="line">+---------------+-----------+</span><br><span class="line">|             0 |         1 |</span><br><span class="line">+---------------+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>查询结果是 1.0999999999999999。看到了吗？虽然误差很小，但确实有误差。 你也可以尝试把数据类型改成 FLOAT，然后运行求和查询，得到的是， 1.0999999940395355。显然，误差更大了。</p><p>那么，为什么会存在这样的误差呢？问题还是出在 MySQL 对浮点类型数据的存储方式上。 </p><p>MySQL 用 4 个字节存储 FLOAT 类型数据，用 8 个字节来存储 DOUBLE 类型数据。无论哪个，都是采用二进制的方式来进行存储的。比如 9.625，用二进制来表达，就是 1001.101，或者表达成 1.001101×2^3。如果尾数不是 0 或 5（比如 9.624），你就无法用一个二进制数来精确表达。进而，就只好在取值允许的范围内进行四舍五入。 </p><p>在编程中，如果用到浮点数，要特别注意误差问题，<strong>因为浮点数是不准确的，所以我们要避免使用“=”来判断两个数是否相等。</strong>同时，在一些对精确度要求较高的项目中，千万不要使用浮点数，不然会导致结果错误，甚至是造成不可挽回的损失。那么，MySQL 有没有精准的数据类型呢？当然有，这就是定点数类型：<code>DECIMAL</code>。</p><h2 id="定点数类型"><a href="#定点数类型" class="headerlink" title="定点数类型"></a>定点数类型</h2><h3 id="类型介绍-2"><a href="#类型介绍-2" class="headerlink" title="类型介绍"></a>类型介绍</h3><ul><li><p>MySQL中的定点数类型只有 DECIMAL 一种类型。</p><p>| 数据类型                 | 字节数  | 含义               |<br>| ———————————— | ———- | ————————— |<br>| DECIMAL(M,D),DEC,NUMERIC | M+2字节 | 有效范围由M和D决定 |</p><p>使用 DECIMAL(M,D) 的方式表示高精度小数。其中，M被称为精度，D被称为标度。0&lt;=M&lt;=65，0&lt;=D&lt;=30，D&lt;M。例如，定义DECIMAL（5,2）的类型，表示该列取值范围是-999.99~999.99。</p></li><li><p><strong>DECIMAL(M,D)的最大取值范围与DOUBLE类型一样</strong>，但是有效的数据范围是由M和D决定的。DECIMAL 的存储空间并不是固定的，由精度值M决定，总共占用的存储空间为M+2个字节。也就是说，在一些对精度要求不高的场景下，比起占用同样字节长度的定点数，浮点数表达的数值范围可以更大一些。</p></li><li><p>定点数在MySQL内部是以<code>字符串</code>的形式进行存储，这就决定了它一定是精准的。</p></li><li><p>当DECIMAL类型不指定精度和标度时，其默认为DECIMAL(10,0)。当数据的精度超出了定点数类型的精度范围时，则MySQL同样会进行四舍五入处理。</p></li><li><p><strong>浮点数 vs 定点数</strong></p><ul><li>浮点数相对于定点数的优点是在长度一定的情况下，浮点类型取值范围大，但是不精准，适用于需要取值范围大，又可以容忍微小误差的科学计算场景（比如计算化学、分子建模、流体动力学等）</li><li>定点数类型取值范围相对小，但是精准，没有误差，适合于对精度要求极高的场景 （比如涉及金额计算的场景）</li></ul></li><li><p>举例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_decimal1(</span><br><span class="line">f1 DECIMAL,</span><br><span class="line">f2 DECIMAL(5,2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">DESC test_decimal1;</span><br><span class="line"></span><br><span class="line">INSERT INTO test_decimal1(f1,f2)</span><br><span class="line">VALUES(123.123,123.456);</span><br><span class="line"></span><br><span class="line">#Out of range value for column &#x27;f2&#x27; at row 1</span><br><span class="line">INSERT INTO test_decimal1(f2)</span><br><span class="line">VALUES(1234.34);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM test_decimal1;</span><br><span class="line">+------+--------+</span><br><span class="line">| f1   | f2     |</span><br><span class="line">+------+--------+</span><br><span class="line">|  123 | 123.46 |</span><br><span class="line">+------+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>举例</p><p>我们运行下面的语句，把test_double2表中字段“f1”的数据类型修改为 DECIMAL(5,2)：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE test_double2</span><br><span class="line">MODIFY f1 DECIMAL(5,2);</span><br></pre></td></tr></table></figure><p>然后，我们再一次运行求和语句：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT SUM(f1)</span><br><span class="line">    -&gt; FROM test_double2;</span><br><span class="line">+---------+</span><br><span class="line">| SUM(f1) |</span><br><span class="line">+---------+</span><br><span class="line">|    1.10 |</span><br><span class="line">+---------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT SUM(f1) = 1.1</span><br><span class="line">    -&gt; FROM test_double2;</span><br><span class="line">+---------------+</span><br><span class="line">| SUM(f1) = 1.1 |</span><br><span class="line">+---------------+</span><br><span class="line">|             1 |</span><br><span class="line">+---------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><h3 id="开发中经验"><a href="#开发中经验" class="headerlink" title="开发中经验"></a>开发中经验</h3><blockquote><p>“由于 DECIMAL 数据类型的精准性，在我们的项目中，除了极少数（比如商品编号）用到整数类型外，其他的数值都用的是 DECIMAL，原因就是这个项目所处的零售行业，要求精准，一分钱也不能差。 ” ——来自某项目经理</p></blockquote><h2 id="位类型：BIT"><a href="#位类型：BIT" class="headerlink" title="位类型：BIT"></a>位类型：BIT</h2><p>BIT类型中存储的是二进制值，类似010110。</p><div class="table-container"><table><thead><tr><th>二进制字符串类型</th><th>长度</th><th>长度范围</th><th>占用空间</th></tr></thead><tbody><tr><td>BIT(M)</td><td>M</td><td>1 &lt;= M &lt;= 64</td><td>约为(M + 7)/8个字节</td></tr></tbody></table></div><p>BIT类型，如果没有指定(M)，默认是1位。这个1位，表示只能存1位的二进制值。这里(M)是表示二进制的位数，位数最小值为1，最大值为64。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_bit1(</span><br><span class="line">f1 BIT,</span><br><span class="line">f2 BIT(5),</span><br><span class="line">f3 BIT(64)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO test_bit1(f1)</span><br><span class="line">VALUES(1);</span><br><span class="line"></span><br><span class="line">#Data too long for column &#x27;f1&#x27; at row 1</span><br><span class="line">INSERT INTO test_bit1(f1)</span><br><span class="line">VALUES(2);</span><br><span class="line"></span><br><span class="line">INSERT INTO test_bit1(f2)</span><br><span class="line">VALUES(23);</span><br></pre></td></tr></table></figure><p>注意：在向BIT类型的字段中插入数据时，一定要确保插入的数据在BIT类型支持的范围内。</p><p>使用SELECT命令查询位字段时，可以用<code>BIN()</code>或<code>HEX()</code>函数进行读取。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM test_bit1;</span><br><span class="line">+------------+------------+------------+</span><br><span class="line">| f1         | f2         | f3         |</span><br><span class="line">+------------+------------+------------+</span><br><span class="line">| 0x01       | NULL       | NULL       |</span><br><span class="line">| NULL       | 0x17       | NULL       |</span><br><span class="line">+------------+------------+------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT BIN(f2),HEX(f2)</span><br><span class="line">    -&gt; FROM test_bit1;</span><br><span class="line">+---------+---------+</span><br><span class="line">| BIN(f2) | HEX(f2) |</span><br><span class="line">+---------+---------+</span><br><span class="line">| NULL    | NULL    |</span><br><span class="line">| 10111   | 17      |</span><br><span class="line">+---------+---------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT f2 + 0</span><br><span class="line">    -&gt; FROM test_bit1;</span><br><span class="line">+--------+</span><br><span class="line">| f2 + 0 |</span><br><span class="line">+--------+</span><br><span class="line">|   NULL |</span><br><span class="line">|     23 |</span><br><span class="line">+--------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>可以看到，使用b+0查询数据时，可以直接查询出存储的十进制数据的值。</p><h2 id="日期与时间类型"><a href="#日期与时间类型" class="headerlink" title="日期与时间类型"></a>日期与时间类型</h2><p>日期与时间是重要的信息，在我们的系统中，几乎所有的数据表都用得到。原因是客户需要知道数据的时间标签，从而进行数据查询、统计和处理。 </p><p>MySQL有多种表示日期和时间的数据类型，不同的版本可能有所差异，MySQL8.0版本支持的日期和时间类型主要有：YEAR类型、TIME类型、DATE类型、DATETIME类型和TIMESTAMP类型。</p><ul><li><code>YEAR</code>类型通常用来表示年</li><li><code>DATE</code>类型通常用来表示年、月、日</li><li><code>TIME</code>类型通常用来表示时、分、秒</li><li><code>DATETIME</code>类型通常用来表示年、月、日、时、分、秒</li><li><code>TIMESTAMP</code>类型通常用来表示带时区的年、月、日、时、分、秒</li></ul><div class="table-container"><table><thead><tr><th>类型</th><th>名称</th><th>字节</th><th>日期格式</th><th>最小值</th><th>最大值</th></tr></thead><tbody><tr><td>YEAR</td><td>年</td><td>1</td><td>YYYY或YY</td><td>1901</td><td>2155</td></tr><tr><td>TIME</td><td>时间</td><td>3</td><td>HH:MM:SS</td><td>-838:59:59</td><td>838:59:59</td></tr><tr><td>DATE</td><td>日期</td><td>3</td><td>YYYY-MM-DD</td><td>1000-01-01</td><td>9999-12-03</td></tr><tr><td>DATETIME</td><td>日期时间</td><td>8</td><td>YYYY-MM-DD HH:MM:SS</td><td>1000-01-01 00:00:00</td><td>9999-12-31 23:59:59</td></tr><tr><td>TIMESTAMP</td><td>日期时间</td><td>4</td><td>YYYY-MM-DD HH:MM:SS</td><td>1970-01-01 00:00:00 UTC</td><td>2038-01-19 03:14:07UTC</td></tr></tbody></table></div><p>可以看到，不同数据类型表示的时间内容不同、取值范围不同，而且占用的字节数也不一样，你要根据实际需要灵活选取。</p><p>为什么时间类型 TIME 的取值范围不是 -23:59:59～23:59:59 呢？原因是 MySQL 设计的 TIME 类型，不光表示一天之内的时间，而且可以用来表示一个时间间隔，这个时间间隔可以超过 24 小时。</p><h3 id="YEAR类型"><a href="#YEAR类型" class="headerlink" title="YEAR类型"></a>YEAR类型</h3><p>YEAR类型用来表示年份，在所有的日期时间类型中所占用的存储空间最小，只需要<code>1个字节</code>的存储空间。</p><p>在MySQL中，YEAR有以下几种存储格式：</p><ul><li>以4位字符串或数字格式表示YEAR类型，其格式为YYYY，最小值为1901，最大值为2155。</li><li>以2位字符串格式表示YEAR类型，最小值为00，最大值为99。<ul><li>当取值为01到69时，表示2001到2069；</li><li>当取值为70到99时，表示1970到1999；</li><li>当取值整数的0或00添加的话，那么是0000年；</li><li>当取值是日期/字符串的’0’添加的话，是2000年。</li></ul></li></ul><p><strong>从MySQL5.5.27开始，2位格式的YEAR已经不推荐使用</strong>。YEAR默认格式就是“YYYY”，没必要写成YEAR(4)，从MySQL 8.0.19开始，不推荐使用指定显示宽度的YEAR(4)数据类型。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_year(</span><br><span class="line">f1 YEAR,</span><br><span class="line">f2 YEAR(4)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; DESC test_year;</span><br><span class="line">+-------+---------+------+-----+---------+-------+</span><br><span class="line">| Field | Type    | Null | Key | Default | Extra |</span><br><span class="line">+-------+---------+------+-----+---------+-------+</span><br><span class="line">| f1    | year(4) | YES  |     | NULL    |       |</span><br><span class="line">| f2    | year(4) | YES  |     | NULL    |       |</span><br><span class="line">+-------+---------+------+-----+---------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test_year</span><br><span class="line">VALUES(&#x27;2020&#x27;,&#x27;2021&#x27;);</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM test_year;</span><br><span class="line">+------+------+</span><br><span class="line">| f1   | f2   |</span><br><span class="line">+------+------+</span><br><span class="line">| 2020 | 2021 |</span><br><span class="line">+------+------+</span><br><span class="line">1 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test_year</span><br><span class="line">VALUES(&#x27;45&#x27;,&#x27;71&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO test_year</span><br><span class="line">VALUES(0,&#x27;0&#x27;);</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM test_year;</span><br><span class="line">+------+------+</span><br><span class="line">| f1   | f2   |</span><br><span class="line">+------+------+</span><br><span class="line">| 2020 | 2021 |</span><br><span class="line">| 2045 | 1971 |</span><br><span class="line">| 0000 | 2000 |</span><br><span class="line">+------+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="DATE类型"><a href="#DATE类型" class="headerlink" title="DATE类型"></a>DATE类型</h3><p>DATE类型表示日期，没有时间部分，格式为<code>YYYY-MM-DD</code>，其中，YYYY表示年份，MM表示月份，DD表示日期。需要<code>3个字节</code>的存储空间。在向DATE类型的字段插入数据时，同样需要满足一定的格式条件。</p><ul><li>以<code>YYYY-MM-DD</code>格式或者<code>YYYYMMDD</code>格式表示的字符串日期，其最小取值为1000-01-01，最大取值为9999-12-03。YYYYMMDD格式会被转化为YYYY-MM-DD格式。</li><li>以<code>YY-MM-DD</code>格式或者<code>YYMMDD</code>格式表示的字符串日期，此格式中，年份为两位数值或字符串满足YEAR类型的格式条件为：当年份取值为00到69时，会被转化为2000到2069；当年份取值为70到99时，会被转化为1970到1999。</li><li>使用<code>CURRENT_DATE()</code>或者<code>NOW()</code>函数，会插入当前系统的日期。</li></ul><p><strong>举例：</strong></p><p>创建数据表，表中只包含一个DATE类型的字段f1。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_date1(</span><br><span class="line">f1 DATE</span><br><span class="line">);</span><br><span class="line">Query OK, 0 rows affected (0.13 sec)</span><br></pre></td></tr></table></figure><p>插入数据：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test_date1</span><br><span class="line">VALUES (&#x27;2020-10-01&#x27;), (&#x27;20201001&#x27;),(20201001);</span><br><span class="line"></span><br><span class="line">INSERT INTO test_date1</span><br><span class="line">VALUES (&#x27;00-01-01&#x27;), (&#x27;000101&#x27;), (&#x27;69-10-01&#x27;), (&#x27;691001&#x27;), (&#x27;70-01-01&#x27;), (&#x27;700101&#x27;), (&#x27;99-01-01&#x27;), (&#x27;990101&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO test_date1</span><br><span class="line">VALUES (000301), (690301), (700301), (990301); </span><br><span class="line"></span><br><span class="line">INSERT INTO test_date1</span><br><span class="line">VALUES (CURRENT_DATE()), (NOW());</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM test_date1;</span><br></pre></td></tr></table></figure><h3 id="TIME类型"><a href="#TIME类型" class="headerlink" title="TIME类型"></a>TIME类型</h3><p>TIME类型用来表示时间，不包含日期部分。在MySQL中，需要<code>3个字节</code>的存储空间来存储TIME类型的数据，可以使用“HH:MM:SS”格式来表示TIME类型，其中，HH表示小时，MM表示分钟，SS表示秒。</p><p>在MySQL中，向TIME类型的字段插入数据时，也可以使用几种不同的格式。<br>（1）可以使用带有冒号的字符串，比如’<code>D HH:MM:SS&#39;</code>、’<code>HH:MM:SS</code>‘、’<code>HH:MM</code>‘、’<code>D HH:MM</code>‘、’<code>D HH</code>‘或’<code>SS</code>‘格式，都能被正确地插入TIME类型的字段中。其中D表示天，其最小值为0，最大值为34。如果使用带有D格式的字符串插入TIME类型的字段时，D会被转化为小时，计算格式为D*24+HH。当使用带有冒号并且不带D的字符串表示时间时，表示当天的时间，比如12:10表示12:10:00，而不是00:12:10。<br>（2）可以使用不带有冒号的字符串或者数字，格式为’<code>HHMMSS</code>‘或者<code>HHMMSS</code>。如果插入一个不合法的字符串或者数字，MySQL在存储数据时，会将其自动转化为00:00:00进行存储。比如1210，MySQL会将最右边的两位解析成秒，表示00:12:10，而不是12:10:00。<br>（3）使用<code>CURRENT_TIME()</code>或者<code>NOW()</code>，会插入当前系统的时间。</p><p><strong>举例：</strong></p><p>创建数据表，表中包含一个TIME类型的字段f1。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_time1(</span><br><span class="line">f1 TIME</span><br><span class="line">);</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test_time1</span><br><span class="line">VALUES(&#x27;2 12:30:29&#x27;), (&#x27;12:35:29&#x27;), (&#x27;12:40&#x27;), (&#x27;2 12:40&#x27;),(&#x27;1 05&#x27;), (&#x27;45&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO test_time1</span><br><span class="line">VALUES (&#x27;123520&#x27;), (124011),(1210);</span><br><span class="line"></span><br><span class="line">INSERT INTO test_time1</span><br><span class="line">VALUES (NOW()), (CURRENT_TIME());</span><br><span class="line"></span><br><span class="line">SELECT * FROM test_time1;</span><br></pre></td></tr></table></figure><h3 id="DATETIME类型"><a href="#DATETIME类型" class="headerlink" title="DATETIME类型"></a>DATETIME类型</h3><p>DATETIME类型在所有的日期时间类型中占用的存储空间最大，总共需要<code>8</code>个字节的存储空间。在格式上为DATE类型和TIME类型的组合，可以表示为<code>YYYY-MM-DD HH:MM:SS</code>，其中YYYY表示年份，MM表示月份，DD表示日期，HH表示小时，MM表示分钟，SS表示秒。</p><p>在向DATETIME类型的字段插入数据时，同样需要满足一定的格式条件。</p><ul><li>以<code>YYYY-MM-DD HH:MM:SS</code>格式或者<code>YYYYMMDDHHMMSS</code>格式的字符串插入DATETIME类型的字段时，最小值为1000-01-01 00:00:00，最大值为9999-12-03 23:59:59。<ul><li>以YYYYMMDDHHMMSS格式的数字插入DATETIME类型的字段时，会被转化为YYYY-MM-DD HH:MM:SS格式。</li></ul></li><li>以<code>YY-MM-DD HH:MM:SS</code>格式或者<code>YYMMDDHHMMSS</code>格式的字符串插入DATETIME类型的字段时，两位数的年份规则符合YEAR类型的规则，00到69表示2000到2069；70到99表示1970到1999。</li><li>使用函数<code>CURRENT_TIMESTAMP()</code>和<code>NOW()</code>，可以向DATETIME类型的字段插入系统的当前日期和时间。</li></ul><p><strong>举例：</strong></p><p>创建数据表，表中包含一个DATETIME类型的字段dt。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_datetime1(</span><br><span class="line">dt DATETIME</span><br><span class="line">);</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br></pre></td></tr></table></figure><p>插入数据：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test_datetime1</span><br><span class="line">VALUES (&#x27;2021-01-01 06:50:30&#x27;), (&#x27;20210101065030&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO test_datetime1</span><br><span class="line">VALUES (&#x27;99-01-01 00:00:00&#x27;), (&#x27;990101000000&#x27;), (&#x27;20-01-01 00:00:00&#x27;), (&#x27;200101000000&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO test_datetime1</span><br><span class="line">VALUES (20200101000000), (200101000000), (19990101000000), (990101000000);</span><br><span class="line"> </span><br><span class="line">INSERT INTO test_datetime1</span><br><span class="line">VALUES (CURRENT_TIMESTAMP()), (NOW());</span><br></pre></td></tr></table></figure><h3 id="TIMESTAMP类型"><a href="#TIMESTAMP类型" class="headerlink" title="TIMESTAMP类型"></a>TIMESTAMP类型</h3><p>TIMESTAMP类型也可以表示日期时间，其显示格式与DATETIME类型相同，都是<code>YYYY-MM-DD HH:MM:SS</code>，需要4个字节的存储空间。但是TIMESTAMP存储的时间范围比DATETIME要小很多，只能存储“1970-01-01 00:00:01 UTC”到“2038-01-19 03:14:07 UTC”之间的时间。其中，UTC表示世界统一时间，也叫作世界标准时间。</p><ul><li><strong>存储数据的时候需要对当前时间所在的时区进行转换，查询数据的时候再将时间转换回当前的时区。因此，使用TIMESTAMP存储的同一个时间值，在不同的时区查询时会显示不同的时间。</strong></li></ul><p>向TIMESTAMP类型的字段插入数据时，当插入的数据格式满足YY-MM-DD HH:MM:SS和YYMMDDHHMMSS时，两位数值的年份同样符合YEAR类型的规则条件，只不过表示的时间范围要小很多。</p><p>如果向TIMESTAMP类型的字段插入的时间超出了TIMESTAMP类型的范围，则MySQL会抛出错误信息。</p><p><strong>举例：</strong></p><p>创建数据表，表中包含一个TIMESTAMP类型的字段ts。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_timestamp1(</span><br><span class="line">ts TIMESTAMP</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>插入数据：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test_timestamp1</span><br><span class="line">VALUES (&#x27;1999-01-01 03:04:50&#x27;), (&#x27;19990101030405&#x27;), (&#x27;99-01-01 03:04:05&#x27;), (&#x27;990101030405&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO test_timestamp1</span><br><span class="line">VALUES (&#x27;2020@01@01@00@00@00&#x27;), (&#x27;20@01@01@00@00@00&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO test_timestamp1</span><br><span class="line">VALUES (CURRENT_TIMESTAMP()), (NOW());</span><br><span class="line"></span><br><span class="line">#Incorrect datetime value</span><br><span class="line">INSERT INTO test_timestamp1</span><br><span class="line">VALUES (&#x27;2038-01-20 03:14:07&#x27;);</span><br></pre></td></tr></table></figure><p><strong>TIMESTAMP和DATETIME的区别：</strong></p><ul><li><p>TIMESTAMP存储空间比较小，表示的日期时间范围也比较小</p></li><li><p>底层存储方式不同，TIMESTAMP底层存储的是毫秒值，距离1970-1-1 0:0:0 0毫秒的毫秒值。</p></li><li><p>两个日期比较大小或日期计算时，TIMESTAMP更方便、更快。</p></li><li><p>TIMESTAMP和时区有关。TIMESTAMP会根据用户的时区不同，显示不同的结果。而DATETIME则只能反映出插入时当地的时区，其他时区的人查看数据必然会有误差的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE temp_time(</span><br><span class="line">d1 DATETIME,</span><br><span class="line">d2 TIMESTAMP</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO temp_time VALUES(&#x27;2021-9-2 14:45:52&#x27;,&#x27;2021-9-2 14:45:52&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO temp_time VALUES(NOW(),NOW());</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM temp_time;</span><br><span class="line">+---------------------+---------------------+</span><br><span class="line">| d1                  | d2                  |</span><br><span class="line">+---------------------+---------------------+</span><br><span class="line">| 2021-09-02 14:45:52 | 2021-09-02 14:45:52 |</span><br><span class="line">| 2021-11-03 17:38:17 | 2021-11-03 17:38:17 |</span><br><span class="line">+---------------------+---------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#修改当前的时区</span><br><span class="line">SET time_zone = &#x27;+9:00&#x27;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM temp_time;</span><br><span class="line">+---------------------+---------------------+</span><br><span class="line">| d1                  | d2                  |</span><br><span class="line">+---------------------+---------------------+</span><br><span class="line">| 2021-09-02 14:45:52 | 2021-09-02 15:45:52 |</span><br><span class="line">| 2021-11-03 17:38:17 | 2021-11-03 18:38:17 |</span><br><span class="line">+---------------------+---------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><h3 id="开发中经验-1"><a href="#开发中经验-1" class="headerlink" title="开发中经验"></a>开发中经验</h3><p>用得最多的日期时间类型，就是 <code>DATETIME</code>。虽然 MySQL 也支持 YEAR（年）、 TIME（时间）、DATE（日期），以及 TIMESTAMP 类型，但是在实际项目中，尽量用 DATETIME 类型。因为这个数据类型包括了完整的日期和时间信息，取值范围也最大，使用起来比较方便。毕竟，如果日期时间信息分散在好几个字段，很不容易记，而且查询的时候，SQL 语句也会更加复杂。 </p><p>此外，一般存注册时间、商品发布时间等，不建议使用DATETIME存储，而是使用<code>时间戳</code>，因为DATETIME虽然直观，但不便于计算。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT UNIX_TIMESTAMP();</span><br><span class="line">+------------------+</span><br><span class="line">| UNIX_TIMESTAMP() |</span><br><span class="line">+------------------+</span><br><span class="line">|       1635932762 |</span><br><span class="line">+------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="文本字符串类型"><a href="#文本字符串类型" class="headerlink" title="文本字符串类型"></a>文本字符串类型</h2><p>在实际的项目中，我们还经常遇到一种数据，就是字符串数据。</p><p>MySQL中，文本字符串总体上分为<code>CHAR</code>、<code>VARCHAR</code>、<code>TINYTEXT</code>、<code>TEXT</code>、<code>MEDIUMTEXT</code>、<code>LONGTEXT</code>、<code>ENUM</code>、<code>SET</code>等类型。</p><p><img src="/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC12%E7%AB%A0_MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2/image-20211012003508730.png" alt="image-20211012003508730"></p><h3 id="CHAR与VARCHAR类型"><a href="#CHAR与VARCHAR类型" class="headerlink" title="CHAR与VARCHAR类型"></a>CHAR与VARCHAR类型</h3><p>CHAR和VARCHAR类型都可以存储比较短的字符串。</p><div class="table-container"><table><thead><tr><th>字符串(文本)类型</th><th>特点</th><th>长度</th><th>长度范围</th><th>占用的存储空间</th></tr></thead><tbody><tr><td>CHAR(M)</td><td>固定长度</td><td>M</td><td>0 &lt;= M &lt;= 255</td><td>M个字节</td></tr><tr><td>VARCHAR(M)</td><td>可变长度</td><td>M</td><td>0 &lt;= M &lt;= 65535</td><td>(实际长度 + 1) 个字节</td></tr></tbody></table></div><p><strong>CHAR类型：</strong></p><ul><li>CHAR(M) 类型一般需要预先定义字符串长度。如果不指定(M)，则表示长度默认是1个字符。</li><li>如果保存时，数据的实际长度比CHAR类型声明的长度小，则会在<code>右侧填充</code>空格以达到指定的长度。当MySQL检索CHAR类型的数据时，CHAR类型的字段会去除尾部的空格。</li><li>定义CHAR类型字段时，声明的字段长度即为CHAR类型字段所占的存储空间的字节数。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_char1(</span><br><span class="line">c1 CHAR,</span><br><span class="line">c2 CHAR(5)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">DESC test_char1;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test_char1</span><br><span class="line">VALUES(&#x27;a&#x27;,&#x27;Tom&#x27;);</span><br><span class="line"></span><br><span class="line">SELECT c1,CONCAT(c2,&#x27;***&#x27;) FROM test_char1;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test_char1(c2)</span><br><span class="line">VALUES(&#x27;a  &#x27;);</span><br><span class="line"></span><br><span class="line">SELECT CHAR_LENGTH(c2)</span><br><span class="line">FROM test_char1;</span><br></pre></td></tr></table></figure><p><strong>VARCHAR类型：</strong></p><ul><li>VARCHAR(M) 定义时，<code>必须指定</code>长度M，否则报错。</li><li>MySQL4.0版本以下，varchar(20)：指的是20字节，如果存放UTF8汉字时，只能存6个（每个汉字3字节） ；MySQL5.0版本以上，varchar(20)：指的是20字符。</li><li>检索VARCHAR类型的字段数据时，会保留数据尾部的空格。VARCHAR类型的字段所占用的存储空间为字符串实际长度加1个字节。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_varchar1(</span><br><span class="line">NAME VARCHAR  #错误</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#Column length too big for column &#x27;NAME&#x27; (max = 21845);</span><br><span class="line">CREATE TABLE test_varchar2(</span><br><span class="line">NAME VARCHAR(65535)  #错误</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_varchar3(</span><br><span class="line">NAME VARCHAR(5)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO test_varchar3</span><br><span class="line">VALUES(&#x27;尚硅谷&#x27;),(&#x27;尚硅谷教育&#x27;);</span><br><span class="line"></span><br><span class="line">#Data too long for column &#x27;NAME&#x27; at row 1</span><br><span class="line">INSERT INTO test_varchar3</span><br><span class="line">VALUES(&#x27;尚硅谷IT教育&#x27;);</span><br></pre></td></tr></table></figure><p><strong>哪些情况使用 CHAR 或 VARCHAR 更好</strong></p><div class="table-container"><table><thead><tr><th>类型</th><th>特点</th><th>空间上</th><th>时间上</th><th>适用场景</th></tr></thead><tbody><tr><td>CHAR(M)</td><td>固定长度</td><td>浪费存储空间</td><td>效率高</td><td>存储不大，速度要求高</td></tr><tr><td>VARCHAR(M)</td><td>可变长度</td><td>节省存储空间</td><td>效率低</td><td>非CHAR的情况</td></tr></tbody></table></div><p>情况1：存储很短的信息。比如门牌号码101，201……这样很短的信息应该用char，因为varchar还要占个byte用于存储信息长度，本来打算节约存储的，结果得不偿失。</p><p>情况2：固定长度的。比如使用uuid作为主键，那用char应该更合适。因为他固定长度，varchar动态根据长度的特性就消失了，而且还要占个长度信息。</p><p>情况3：十分频繁改变的column。因为varchar每次存储都要有额外的计算，得到长度等工作，如果一个非常频繁改变的，那就要有很多的精力用于计算，而这些对于char来说是不需要的。</p><p>情况4：具体存储引擎中的情况：</p><ul><li><p><code>MyISAM</code> 数据存储引擎和数据列：MyISAM数据表，最好使用固定长度(CHAR)的数据列代替可变长度(VARCHAR)的数据列。这样使得整个表静态化，从而使<code>数据检索更快</code>，用空间换时间。</p></li><li><p><code>MEMORY</code> 存储引擎和数据列：MEMORY数据表目前都使用固定长度的数据行存储，因此无论使用CHAR或VARCHAR列都没有关系，两者都是作为CHAR类型处理的。</p></li><li><code>InnoDB</code>存储引擎，建议使用VARCHAR类型。因为对于InnoDB数据表，内部的行存储格式并没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），而且<strong>主要影响性能的因素是数据行使用的存储总量</strong>，由于char平均占用的空间多于varchar，所以除了简短并且固定长度的，其他考虑varchar。这样节省空间，对磁盘I/O和数据存储总量比较好。</li></ul><h3 id="TEXT类型"><a href="#TEXT类型" class="headerlink" title="TEXT类型"></a>TEXT类型</h3><p>在MySQL中，TEXT用来保存文本类型的字符串，总共包含4种类型，分别为TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT 类型。</p><p>在向TEXT类型的字段保存和查询数据时，系统自动按照实际长度存储，不需要预先定义长度。这一点和 VARCHAR类型相同。</p><p>每种TEXT类型保存的数据长度和所占用的存储空间不同，如下：</p><div class="table-container"><table><thead><tr><th>文本字符串类型</th><th>特点</th><th>长度</th><th>长度范围</th><th>占用的存储空间</th></tr></thead><tbody><tr><td>TINYTEXT</td><td>小文本、可变长度</td><td>L</td><td>0 &lt;= L &lt;= 255</td><td>L + 2 个字节</td></tr><tr><td>TEXT</td><td>文本、可变长度</td><td>L</td><td>0 &lt;= L &lt;= 65535</td><td>L + 2 个字节</td></tr><tr><td>MEDIUMTEXT</td><td>中等文本、可变长度</td><td>L</td><td>0 &lt;= L &lt;= 16777215</td><td>L + 3 个字节</td></tr><tr><td>LONGTEXT</td><td>大文本、可变长度</td><td>L</td><td>0 &lt;= L&lt;= 4294967295（相当于4GB）</td><td>L + 4 个字节</td></tr></tbody></table></div><p><strong>由于实际存储的长度不确定，MySQL 不允许 TEXT 类型的字段做主键</strong>。遇到这种情况，你只能采用 CHAR(M)，或者 VARCHAR(M)。</p><p><strong>举例：</strong></p><p>创建数据表：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_text(</span><br><span class="line">tx TEXT</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test_text</span><br><span class="line">VALUES(&#x27;atguigu   &#x27;);</span><br><span class="line"></span><br><span class="line">SELECT CHAR_LENGTH(tx)</span><br><span class="line">FROM test_text; #10</span><br></pre></td></tr></table></figure><p>说明在保存和查询数据时，并没有删除TEXT类型的数据尾部的空格。</p><p><strong>开发中经验：</strong></p><p>TEXT文本类型，可以存比较大的文本段，搜索速度稍慢，因此如果不是特别大的内容，建议使用CHAR，VARCHAR来代替。还有TEXT类型不用加默认值，加了也没用。而且text和blob类型的数据删除后容易导致“空洞”，使得文件碎片比较多，所以频繁使用的表不建议包含TEXT类型字段，建议单独分出去，单独用一个表。</p><h2 id="ENUM类型"><a href="#ENUM类型" class="headerlink" title="ENUM类型"></a>ENUM类型</h2><p>ENUM类型也叫作枚举类型，ENUM类型的取值范围需要在定义字段时进行指定。设置字段值时，ENUM类型只允许从成员中选取单个值，不能一次选取多个值。</p><p>其所需要的存储空间由定义ENUM类型时指定的成员个数决定。</p><div class="table-container"><table><thead><tr><th>文本字符串类型</th><th>长度</th><th>长度范围</th><th>占用的存储空间</th></tr></thead><tbody><tr><td>ENUM</td><td>L</td><td>1 &lt;= L &lt;= 65535</td><td>1或2个字节</td></tr></tbody></table></div><ul><li><p>当ENUM类型包含1～255个成员时，需要1个字节的存储空间；</p></li><li><p>当ENUM类型包含256～65535个成员时，需要2个字节的存储空间。</p></li><li>ENUM类型的成员个数的上限为65535个。</li></ul><p>举例：</p><p>创建表如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_enum(</span><br><span class="line">season ENUM(&#x27;春&#x27;,&#x27;夏&#x27;,&#x27;秋&#x27;,&#x27;冬&#x27;,&#x27;unknow&#x27;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>添加数据：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test_enum</span><br><span class="line">VALUES(&#x27;春&#x27;),(&#x27;秋&#x27;);</span><br><span class="line"></span><br><span class="line"># 忽略大小写</span><br><span class="line">INSERT INTO test_enum</span><br><span class="line">VALUES(&#x27;UNKNOW&#x27;);</span><br><span class="line"></span><br><span class="line"># 允许按照角标的方式获取指定索引位置的枚举值</span><br><span class="line">INSERT INTO test_enum</span><br><span class="line">VALUES(&#x27;1&#x27;),(3);</span><br><span class="line"></span><br><span class="line"># Data truncated for column &#x27;season&#x27; at row 1</span><br><span class="line">INSERT INTO test_enum</span><br><span class="line">VALUES(&#x27;ab&#x27;);</span><br><span class="line"></span><br><span class="line"># 当ENUM类型的字段没有声明为NOT NULL时，插入NULL也是有效的</span><br><span class="line">INSERT INTO test_enum</span><br><span class="line">VALUES(NULL);</span><br></pre></td></tr></table></figure><h2 id="SET类型"><a href="#SET类型" class="headerlink" title="SET类型"></a>SET类型</h2><p>SET表示一个字符串对象，可以包含0个或多个成员，但成员个数的上限为<code>64</code>。设置字段值时，可以取取值范围内的 0 个或多个值。</p><p>当SET类型包含的成员个数不同时，其所占用的存储空间也是不同的，具体如下：</p><div class="table-container"><table><thead><tr><th>成员个数范围（L表示实际成员个数）</th><th>占用的存储空间</th></tr></thead><tbody><tr><td>1 &lt;= L &lt;= 8</td><td>1个字节</td></tr><tr><td>9 &lt;= L &lt;= 16</td><td>2个字节</td></tr><tr><td>17 &lt;= L &lt;= 24</td><td>3个字节</td></tr><tr><td>25 &lt;= L &lt;= 32</td><td>4个字节</td></tr><tr><td>33 &lt;= L &lt;= 64</td><td>8个字节</td></tr></tbody></table></div><p>SET类型在存储数据时成员个数越多，其占用的存储空间越大。注意：SET类型在选取成员时，可以一次选择多个成员，这一点与ENUM类型不同。</p><p>举例：</p><p>创建表：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_set(</span><br><span class="line">s SET (&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>向表中插入数据：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test_set (s) VALUES (&#x27;A&#x27;), (&#x27;A,B&#x27;);</span><br><span class="line"></span><br><span class="line">#插入重复的SET类型成员时，MySQL会自动删除重复的成员</span><br><span class="line">INSERT INTO test_set (s) VALUES (&#x27;A,B,C,A&#x27;);</span><br><span class="line"></span><br><span class="line">#向SET类型的字段插入SET成员中不存在的值时，MySQL会抛出错误。</span><br><span class="line">INSERT INTO test_set (s) VALUES (&#x27;A,B,C,D&#x27;);</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM test_set;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE temp_mul(</span><br><span class="line">gender ENUM(&#x27;男&#x27;,&#x27;女&#x27;),</span><br><span class="line">hobby SET(&#x27;吃饭&#x27;,&#x27;睡觉&#x27;,&#x27;打豆豆&#x27;,&#x27;写代码&#x27;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO temp_mul VALUES(&#x27;男&#x27;,&#x27;睡觉,打豆豆&#x27;); #成功</span><br><span class="line"></span><br><span class="line"># Data truncated for column &#x27;gender&#x27; at row 1</span><br><span class="line">INSERT INTO temp_mul VALUES(&#x27;男,女&#x27;,&#x27;睡觉,写代码&#x27;); #失败</span><br><span class="line"></span><br><span class="line"># Data truncated for column &#x27;gender&#x27; at row 1</span><br><span class="line">INSERT INTO temp_mul VALUES(&#x27;妖&#x27;,&#x27;睡觉,写代码&#x27;);#失败</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO temp_mul VALUES(&#x27;男&#x27;,&#x27;睡觉,写代码,吃饭&#x27;); #成功</span><br></pre></td></tr></table></figure><h2 id="二进制字符串类型"><a href="#二进制字符串类型" class="headerlink" title="二进制字符串类型"></a>二进制字符串类型</h2><p>MySQL中的二进制字符串类型主要存储一些二进制数据，比如可以存储图片、音频和视频等二进制数据。</p><p>MySQL中支持的二进制字符串类型主要包括BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB类型。</p><h3 id="BINARY与VARBINARY类型"><a href="#BINARY与VARBINARY类型" class="headerlink" title="BINARY与VARBINARY类型"></a>BINARY与VARBINARY类型</h3><p>BINARY和VARBINARY类似于CHAR和VARCHAR，只是它们存储的是二进制字符串。</p><p>BINARY (M)为固定长度的二进制字符串，M表示最多能存储的字节数，取值范围是0~255个字符。如果未指定(M)，表示只能存储<code>1个字节</code>。例如BINARY (8)，表示最多能存储8个字节，如果字段值不足(M)个字节，将在右边填充’\0’以补齐指定长度。</p><p>VARBINARY (M)为可变长度的二进制字符串，M表示最多能存储的字节数，总字节数不能超过行的字节长度限制65535，另外还要考虑额外字节开销，VARBINARY类型的数据除了存储数据本身外，还需要1或2个字节来存储数据的字节数。VARBINARY类型<code>必须指定(M)</code>，否则报错。</p><div class="table-container"><table><thead><tr><th>二进制字符串类型</th><th>特点</th><th>值的长度</th><th>占用空间</th></tr></thead><tbody><tr><td>BINARY(M)</td><td>固定长度</td><td>M （0 &lt;= M &lt;= 255）</td><td>M个字节</td></tr><tr><td>VARBINARY(M)</td><td>可变长度</td><td>M（0 &lt;= M &lt;= 65535）</td><td>M+1个字节</td></tr></tbody></table></div><p>举例：</p><p>创建表：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_binary1(</span><br><span class="line">f1 BINARY,</span><br><span class="line">f2 BINARY(3),</span><br><span class="line"># f3 VARBINARY,</span><br><span class="line">f4 VARBINARY(10)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>添加数据：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test_binary1(f1,f2)</span><br><span class="line">VALUES(&#x27;a&#x27;,&#x27;a&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO test_binary1(f1,f2)</span><br><span class="line">VALUES(&#x27;尚&#x27;,&#x27;尚&#x27;);#失败</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test_binary1(f2,f4)</span><br><span class="line">VALUES(&#x27;ab&#x27;,&#x27;ab&#x27;);</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT LENGTH(f2),LENGTH(f4)</span><br><span class="line">    -&gt; FROM test_binary1;</span><br><span class="line">+------------+------------+</span><br><span class="line">| LENGTH(f2) | LENGTH(f4) |</span><br><span class="line">+------------+------------+</span><br><span class="line">|          3 |       NULL |</span><br><span class="line">|          3 |          2 |</span><br><span class="line">+------------+------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="BLOB类型"><a href="#BLOB类型" class="headerlink" title="BLOB类型"></a>BLOB类型</h3><p>BLOB是一个<code>二进制大对象</code>，可以容纳可变数量的数据。</p><p>MySQL中的BLOB类型包括TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB 4种类型，它们可容纳值的最大长度不同。可以存储一个二进制的大对象，比如<code>图片</code>、<code>音频</code>和<code>视频</code>等。</p><p>需要注意的是，在实际工作中，往往不会在MySQL数据库中使用BLOB类型存储大对象数据，通常会将图片、音频和视频文件存储到<code>服务器的磁盘上</code>，并将图片、音频和视频的访问路径存储到MySQL中。</p><div class="table-container"><table><thead><tr><th>二进制字符串类型</th><th>值的长度</th><th>长度范围</th><th>占用空间</th></tr></thead><tbody><tr><td>TINYBLOB</td><td>L</td><td>0 &lt;= L &lt;= 255</td><td>L + 1 个字节</td></tr><tr><td>BLOB</td><td>L</td><td>0 &lt;= L &lt;= 65535（相当于64KB）</td><td>L + 2 个字节</td></tr><tr><td>MEDIUMBLOB</td><td>L</td><td>0 &lt;= L &lt;= 16777215 （相当于16MB）</td><td>L + 3 个字节</td></tr><tr><td>LONGBLOB</td><td>L</td><td>0 &lt;= L &lt;= 4294967295（相当于4GB）</td><td>L + 4 个字节</td></tr></tbody></table></div><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_blob1(</span><br><span class="line">id INT,</span><br><span class="line">img MEDIUMBLOB</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>TEXT和BLOB的使用注意事项：</strong></p><p>在使用text和blob字段类型时要注意以下几点，以便更好的发挥数据库的性能。</p><p>① BLOB和TEXT值也会引起自己的一些问题，特别是执行了大量的删除或更新操作的时候。删除这种值会在数据表中留下很大的”<code>空洞</code>“，以后填入这些”空洞”的记录可能长度不同。为了提高性能，建议定期使用 OPTIMIZE TABLE 功能对这类表进行<code>碎片整理</code>。</p><p>② 如果需要对大文本字段进行模糊查询，MySQL 提供了<code>前缀索引</code>。但是仍然要在不必要的时候避免检索大型的BLOB或TEXT值。例如，SELECT * 查询就不是很好的想法，除非你能够确定作为约束条件的WHERE子句只会找到所需要的数据行。否则，你可能毫无目的地在网络上传输大量的值。</p><p>③ 把BLOB或TEXT列<code>分离到单独的表</code>中。在某些环境中，如果把这些数据列移动到第二张数据表中，可以让你把原数据表中的数据列转换为固定长度的数据行格式，那么它就是有意义的。这会<code>减少主表中的碎片</code>，使你得到固定长度数据行的性能优势。它还使你在主数据表上运行 SELECT * 查询的时候不会通过网络传输大量的BLOB或TEXT值。</p><h2 id="JSON-类型"><a href="#JSON-类型" class="headerlink" title="JSON 类型"></a>JSON 类型</h2><p>JSON（JavaScript Object Notation）是一种轻量级的<code>数据交换格式</code>。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。它易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。<strong>JSON 可以将 JavaScript 对象中表示的一组数据转换为字符串，然后就可以在网络或者程序之间轻松地传递这个字符串，并在需要的时候将它还原为各编程语言所支持的数据格式。</strong></p><p>在MySQL 5.7中，就已经支持JSON数据类型。在MySQL 8.x版本中，JSON类型提供了可以进行自动验证的JSON文档和优化的存储结构，使得在MySQL中存储和读取JSON类型的数据更加方便和高效。<br>创建数据表，表中包含一个JSON类型的字段 js 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_json(</span><br><span class="line">js json</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>向表中插入JSON数据。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test_json (js) </span><br><span class="line">VALUES (&#x27;&#123;&quot;name&quot;:&quot;songhk&quot;, &quot;age&quot;:18, &quot;address&quot;:&#123;&quot;province&quot;:&quot;beijing&quot;, &quot;city&quot;:&quot;beijing&quot;&#125;&#125;&#x27;);</span><br></pre></td></tr></table></figure><p>查询t19表中的数据。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT *</span><br><span class="line">    -&gt; FROM test_json;</span><br></pre></td></tr></table></figure><p><img src="/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC12%E7%AB%A0_MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2/image-20211104192516324.png" alt="image-20211104192516324"></p><p>当需要检索JSON类型的字段中数据的某个具体值时，可以使用“-&gt;”和“-&gt;&gt;”符号。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT js -&gt; &#x27;$.name&#x27; AS NAME,js -&gt; &#x27;$.age&#x27; AS age ,js -&gt; &#x27;$.address.province&#x27; AS province, js -&gt; &#x27;$.address.city&#x27; AS city</span><br><span class="line">    -&gt; FROM test_json;</span><br><span class="line">+----------+------+-----------+-----------+</span><br><span class="line">| NAME     | age  | province  | city      |</span><br><span class="line">+----------+------+-----------+-----------+</span><br><span class="line">| &quot;songhk&quot; | 18   | &quot;beijing&quot; | &quot;beijing&quot; |</span><br><span class="line">+----------+------+-----------+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>通过“-&gt;”和“-&gt;&gt;”符号，从JSON字段中正确查询出了指定的JSON数据的值。</p><h2 id="空间类型"><a href="#空间类型" class="headerlink" title="空间类型"></a>空间类型</h2><p>MySQL 空间类型扩展支持地理特征的生成、存储和分析。这里的地理特征表示世界上具有位置的任何东西，可以是一个实体，例如一座山；可以是空间，例如一座办公楼；也可以是一个可定义的位置，例如一个十字路口等等。MySQL中使用<code>Geometry（几何）</code>来表示所有地理特征。Geometry指一个点或点的集合，代表世界上任何具有位置的事物。</p><p>MySQL的空间数据类型（Spatial Data Type）对应于OpenGIS类，包括单值类型：GEOMETRY、POINT、LINESTRING、POLYGON以及集合类型：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION 。</p><ul><li>Geometry是所有空间集合类型的基类，其他类型如POINT、LINESTRING、POLYGON都是Geometry的子类。<ul><li>Point，顾名思义就是点，有一个坐标值。例如POINT(121.213342 31.234532)，POINT(30 10)，坐标值支持DECIMAL类型，经度（longitude）在前，维度（latitude）在后，用空格分隔。</li><li>LineString，线，由一系列点连接而成。如果线从头至尾没有交叉，那就是简单的（simple）；如果起点和终点重叠，那就是封闭的（closed）。例如LINESTRING(30 10,10 30,40 40)，点与点之间用逗号分隔，一个点中的经纬度用空格分隔，与POINT格式一致。</li><li>Polygon，多边形。可以是一个实心平面形，即没有内部边界，也可以有空洞，类似纽扣。最简单的就是只有一个外边界的情况，例如POLYGON((0 0,10 0,10 10, 0 10))。</li></ul></li></ul><p>下面展示几种常见的几何图形元素：</p><p><img src="/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC12%E7%AB%A0_MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2/image-20211104192912988.png" alt="image-20211104192912988"></p><ul><li>MultiPoint、MultiLineString、MultiPolygon、GeometryCollection 这4种类型都是集合类，是多个Point、LineString或Polygon组合而成。</li></ul><p>下面展示的是多个同类或异类几何图形元素的组合：</p><p><img src="/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC12%E7%AB%A0_MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2/image-20211104193330204.png" alt="image-20211104193330204"></p><h2 id="小结及选择建议"><a href="#小结及选择建议" class="headerlink" title="小结及选择建议"></a>小结及选择建议</h2><p>在定义数据类型时，如果确定是<code>整数</code>，就用<code>INT</code>； 如果是<code>小数</code>，一定用定点数类型 <code>DECIMAL(M,D)</code>； 如果是日期与时间，就用 <code>DATETIME</code>。 </p><p>这样做的好处是，首先确保你的系统不会因为数据类型定义出错。不过，凡事都是有两面的，可靠性好，并不意味着高效。比如，TEXT 虽然使用方便，但是效率不如 CHAR(M) 和 VARCHAR(M)。</p><p>关于字符串的选择，建议参考如下阿里巴巴的《Java开发手册》规范：</p><p><strong>阿里巴巴《Java开发手册》之MySQL数据库：</strong></p><ul><li>任何字段如果为非负数，必须是 UNSIGNED</li><li>【<code>强制</code>】小数类型为 DECIMAL，禁止使用 FLOAT 和 DOUBLE。 <ul><li>说明：在存储的时候，FLOAT 和 DOUBLE 都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过 DECIMAL 的范围，建议将数据拆成整数和小数并分开存储。</li></ul></li><li>【<code>强制</code>】如果存储的字符串长度几乎相等，使用 CHAR 定长字符串类型。 </li><li>【<code>强制</code>】VARCHAR 是可变长字符串，不预先分配存储空间，长度不要超过 5000。如果存储长度大于此值，定义字段类型为 TEXT，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第12章-MySQL数据类型精讲&quot;&gt;&lt;a href=&quot;#第12章-MySQL数据类型精讲&quot; class=&quot;headerlink&quot; title=&quot;第12章_MySQL数据类型精讲&quot;&gt;&lt;/a&gt;第12章_MySQL数据类型精讲&lt;/h1&gt;&lt;p&gt;讲师：尚硅谷-宋红康（江湖人</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    <category term="基础版" scheme="http://example.com/categories/MySQL/%E5%9F%BA%E7%A1%80%E7%89%88/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>第11章_数据处理之增删改</title>
    <link href="http://example.com/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC11%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8B%E5%A2%9E%E5%88%A0%E6%94%B9/"/>
    <id>http://example.com/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC11%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8B%E5%A2%9E%E5%88%A0%E6%94%B9/</id>
    <published>2022-05-17T12:37:11.000Z</published>
    <updated>2022-05-17T13:02:20.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第11章-数据处理之增删改"><a href="#第11章-数据处理之增删改" class="headerlink" title="第11章_数据处理之增删改"></a>第11章_数据处理之增删改</h1><p>讲师：尚硅谷-宋红康（江湖人称：康师傅）</p><p>官网：<a href="http://www.atguigu.com/">http://www.atguigu.com</a></p><hr><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><h3 id="实际问题"><a href="#实际问题" class="headerlink" title="实际问题"></a>实际问题</h3><p><img src="/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC11%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8B%E5%A2%9E%E5%88%A0%E6%94%B9/1555425366064.png" alt="1555425366064" style="zoom:80%;"></p><p>解决方式：使用 INSERT 语句向表中插入数据。</p><h3 id="方式1：VALUES的方式添加"><a href="#方式1：VALUES的方式添加" class="headerlink" title="方式1：VALUES的方式添加"></a>方式1：VALUES的方式添加</h3><p>使用这种语法一次只能向表中插入<strong>一条</strong>数据。</p><p><strong>情况1：为表的所有字段按默认顺序插入数据</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO 表名</span><br><span class="line">VALUES (value1,value2,....);</span><br></pre></td></tr></table></figure><p>值列表中需要为表的每一个字段指定值，并且值的顺序必须和数据表中字段定义时的顺序相同。</p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO departments</span><br><span class="line">VALUES (70, &#x27;Pub&#x27;, 100, 1700);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTOdepartments</span><br><span class="line">VALUES(100, &#x27;Finance&#x27;, NULL, NULL);</span><br></pre></td></tr></table></figure><p><strong>情况2：为表的指定字段插入数据</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO 表名(column1 [, column2, …, columnn]) </span><br><span class="line">VALUES (value1 [,value2, …, valuen]);</span><br></pre></td></tr></table></figure><p>为表的指定字段插入数据，就是在INSERT语句中只向部分字段中插入值，而其他字段的值为表定义时的默认值。</p><p>在 INSERT 子句中随意列出列名，但是一旦列出，VALUES中要插入的value1,….valuen需要与column1,…columnn列一一对应。如果类型不同，将无法插入，并且MySQL会产生错误。</p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO departments(department_id, department_name)</span><br><span class="line">VALUES (80, &#x27;IT&#x27;);</span><br></pre></td></tr></table></figure><p> <strong>情况3：同时插入多条记录</strong></p><p>INSERT语句可以同时向数据表中插入多条记录，插入时指定多个值列表，每个值列表之间用逗号分隔开，基本语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO table_name </span><br><span class="line">VALUES </span><br><span class="line">(value1 [,value2, …, valuen]),</span><br><span class="line">(value1 [,value2, …, valuen]),</span><br><span class="line">……</span><br><span class="line">(value1 [,value2, …, valuen]);</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO table_name(column1 [, column2, …, columnn]) </span><br><span class="line">VALUES </span><br><span class="line">(value1 [,value2, …, valuen]),</span><br><span class="line">(value1 [,value2, …, valuen]),</span><br><span class="line">……</span><br><span class="line">(value1 [,value2, …, valuen]);</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; INSERT INTO emp(emp_id,emp_name)</span><br><span class="line">    -&gt; VALUES (1001,&#x27;shkstart&#x27;),</span><br><span class="line">    -&gt; (1002,&#x27;atguigu&#x27;),</span><br><span class="line">    -&gt; (1003,&#x27;Tom&#x27;);</span><br><span class="line">Query OK, 3 rows affected (0.00 sec)</span><br><span class="line">Records: 3  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p>使用INSERT同时插入多条记录时，MySQL会返回一些在执行单行插入时没有的额外信息，这些信息的含义如下：<br>●　Records：表明插入的记录条数。<br>●　Duplicates：表明插入时被忽略的记录，原因可能是这些记录包含了重复的主键值。<br>●　Warnings：表明有问题的数据值，例如发生数据类型转换。</p><blockquote><p>一个同时插入多行记录的INSERT语句等同于多个单行插入的INSERT语句，但是多行的INSERT语句在处理过程中<code>效率更高</code>。因为MySQL执行单条INSERT语句插入多行数据比使用多条INSERT语句快，所以在插入多条记录时最好选择使用单条INSERT语句的方式插入。</p></blockquote><p><strong>小结：</strong></p><ul><li><code>VALUES</code>也可以写成<code>VALUE</code>，但是VALUES是标准写法。</li></ul><ul><li>字符和日期型数据应包含在单引号中。</li></ul><h3 id="方式2：将查询结果插入到表中"><a href="#方式2：将查询结果插入到表中" class="headerlink" title="方式2：将查询结果插入到表中"></a>方式2：将查询结果插入到表中</h3><p>INSERT还可以将SELECT语句查询的结果插入到表中，此时不需要把每一条记录的值一个一个输入，只需要使用一条INSERT语句和一条SELECT语句组成的组合语句即可快速地从一个或多个表中向一个表中插入多行。</p><p>基本语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO 目标表名</span><br><span class="line">(tar_column1 [, tar_column2, …, tar_columnn])</span><br><span class="line">SELECT</span><br><span class="line">(src_column1 [, src_column2, …, src_columnn])</span><br><span class="line">FROM 源表名</span><br><span class="line">[WHERE condition]</span><br></pre></td></tr></table></figure><ul><li>在 INSERT 语句中加入子查询。 </li><li><strong>不必书写</strong> <strong>VALUES</strong> <strong>子句。</strong> </li><li>子查询中的值列表应与 INSERT 子句中的列名对应。</li></ul><p>举例：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp2 </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">90</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> sales_reps(id, name, salary, commission_pct)</span><br><span class="line"><span class="keyword">SELECT</span> employee_id, last_name, salary, commission_pct</span><br><span class="line"><span class="keyword">FROM</span>   employees</span><br><span class="line"><span class="keyword">WHERE</span>  job_id <span class="keyword">LIKE</span> <span class="string">&#x27;%REP%&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><p><img src="/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC11%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8B%E5%A2%9E%E5%88%A0%E6%94%B9/1555425824246.png" alt="1555425824246"></p><ul><li>使用 UPDATE 语句更新数据。语法如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE table_name</span><br><span class="line">SET column1=value1, column2=value2, … , column=valuen</span><br><span class="line">[WHERE condition]</span><br></pre></td></tr></table></figure><ul><li><p>可以一次更新<strong>多条</strong>数据。</p></li><li><p>如果需要回滚数据，需要保证在DML前，进行设置：<strong>SET AUTOCOMMIT = FALSE;</strong></p></li></ul><hr><ul><li>使用 <strong>WHERE</strong> 子句指定需要更新的数据。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> employees</span><br><span class="line"><span class="keyword">SET</span>    department_id <span class="operator">=</span> <span class="number">70</span></span><br><span class="line"><span class="keyword">WHERE</span>  employee_id <span class="operator">=</span> <span class="number">113</span>;</span><br></pre></td></tr></table></figure><ul><li>如果省略 WHERE 子句，则表中的所有数据都将被更新。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> copy_emp</span><br><span class="line"><span class="keyword">SET</span>    department_id <span class="operator">=</span> <span class="number">110</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>更新中的数据完整性错误</strong></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> employees</span><br><span class="line"><span class="keyword">SET</span>    department_id <span class="operator">=</span> <span class="number">55</span></span><br><span class="line"><span class="keyword">WHERE</span>  department_id <span class="operator">=</span> <span class="number">110</span>;</span><br></pre></td></tr></table></figure><p> <img src="/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC11%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8B%E5%A2%9E%E5%88%A0%E6%94%B9/1555426069578.png" alt="1555426069578"></p><blockquote><p>说明：不存在 55 号部门</p></blockquote><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p><img src="/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC11%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8B%E5%A2%9E%E5%88%A0%E6%94%B9/1555426124751.png" alt="1555426124751"></p><ul><li>使用 DELETE 语句从表中删除数据</li></ul><p><img src="/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC11%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8B%E5%A2%9E%E5%88%A0%E6%94%B9/1555426162264.png" alt="1555426162264"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM table_name [WHERE &lt;condition&gt;];</span><br></pre></td></tr></table></figure><p>table_name指定要执行删除操作的表；“[WHERE <condition>]”为可选参数，指定删除条件，如果没有WHERE子句，DELETE语句将删除表中的所有记录。</condition></p><ul><li>使用 WHERE 子句删除指定的记录。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> departments</span><br><span class="line"><span class="keyword">WHERE</span>  department_name <span class="operator">=</span> <span class="string">&#x27;Finance&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>如果省略 WHERE 子句，则表中的全部数据将被删除</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span>  copy_emp;</span><br></pre></td></tr></table></figure><ul><li><strong>删除中的数据完整性错误</strong></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> departments</span><br><span class="line"><span class="keyword">WHERE</span>       department_id <span class="operator">=</span> <span class="number">60</span>;</span><br></pre></td></tr></table></figure><p> <img src="/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC11%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8B%E5%A2%9E%E5%88%A0%E6%94%B9/1555426258516.png" alt="1555426258516"></p><blockquote><p>说明：You cannot delete a row that contains a primary key that is used as a foreign key in another table.</p></blockquote><h2 id="MySQL8新特性：计算列"><a href="#MySQL8新特性：计算列" class="headerlink" title="MySQL8新特性：计算列"></a>MySQL8新特性：计算列</h2><p>什么叫计算列呢？简单来说就是某一列的值是通过别的列计算得来的。例如，a列值为1、b列值为2，c列不需要手动插入，定义a+b的结果为c的值，那么c就是计算列，是通过别的列计算得来的。</p><p>在MySQL 8.0中，CREATE TABLE 和 ALTER TABLE 中都支持增加计算列。下面以CREATE TABLE为例进行讲解。</p><p>举例：定义数据表tb1，然后定义字段id、字段a、字段b和字段c，其中字段c为计算列，用于计算a+b的值。<br>首先创建测试表tb1，语句如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tb1(</span><br><span class="line">id INT,</span><br><span class="line">a INT,</span><br><span class="line">b INT,</span><br><span class="line">c INT GENERATED ALWAYS AS (a + b) VIRTUAL</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>插入演示数据，语句如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO tb1(a,b) VALUES (100,200);</span><br></pre></td></tr></table></figure><p>查询数据表tb1中的数据，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM tb1;</span><br><span class="line">+------+------+------+------+</span><br><span class="line">| id   | a    | b    | c    |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">| NULL |  100 |  200 |  300 |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>更新数据中的数据，语句如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; UPDATE tb1 SET a = 500;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 0  Warnings: 0</span><br></pre></td></tr></table></figure><h2 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1、创建数据库test01_library</span><br><span class="line"></span><br><span class="line"># 2、创建表 books，表结构如下：</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>字段名</th><th>字段说明</th><th>数据类型</th></tr></thead><tbody><tr><td>id</td><td>书编号</td><td>INT</td></tr><tr><td>name</td><td>书名</td><td>VARCHAR(50)</td></tr><tr><td>authors</td><td>作者</td><td>VARCHAR(100)</td></tr><tr><td>price</td><td>价格</td><td>FLOAT</td></tr><tr><td>pubdate</td><td>出版日期</td><td>YEAR</td></tr><tr><td>note</td><td>说明</td><td>VARCHAR(100)</td></tr><tr><td>num</td><td>库存</td><td>INT</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 3、向books表中插入记录</span><br><span class="line"></span><br><span class="line"># 1）不指定字段名称，插入第一条记录</span><br><span class="line"># 2）指定所有字段名称，插入第二记录</span><br><span class="line"># 3）同时插入多条记录（剩下的所有记录）</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>id</th><th>name</th><th>authors</th><th>price</th><th>pubdate</th><th>note</th><th>num</th></tr></thead><tbody><tr><td>1</td><td>Tal of AAA</td><td>Dickes</td><td>23</td><td>1995</td><td>novel</td><td>11</td></tr><tr><td>2</td><td>EmmaT</td><td>Jane lura</td><td>35</td><td>1993</td><td>joke</td><td>22</td></tr><tr><td>3</td><td>Story of Jane</td><td>Jane Tim</td><td>40</td><td>2001</td><td>novel</td><td>0</td></tr><tr><td>4</td><td>Lovey Day</td><td>George Byron</td><td>20</td><td>2005</td><td>novel</td><td>30</td></tr><tr><td>5</td><td>Old land</td><td>Honore Blade</td><td>30</td><td>2010</td><td>law</td><td>0</td></tr><tr><td>6</td><td>The Battle</td><td>Upton Sara</td><td>30</td><td>1999</td><td>medicine</td><td>40</td></tr><tr><td>7</td><td>Rose Hood</td><td>Richard haggard</td><td>28</td><td>2008</td><td>cartoon</td><td>28</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 4、将小说类型(novel)的书的价格都增加5。</span><br><span class="line"></span><br><span class="line"># 5、将名称为EmmaT的书的价格改为40，并将说明改为drama。</span><br><span class="line"></span><br><span class="line"># 6、删除库存为0的记录。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 7、统计书名中包含a字母的书</span><br><span class="line"></span><br><span class="line"># 8、统计书名中包含a字母的书的数量和库存总量</span><br><span class="line"></span><br><span class="line"># 9、找出“novel”类型的书，按照价格降序排列</span><br><span class="line"></span><br><span class="line"># 10、查询图书信息，按照库存量降序排列，如果库存量相同的按照note升序排列</span><br><span class="line"></span><br><span class="line"># 11、按照note分类统计书的数量</span><br><span class="line"></span><br><span class="line"># 12、按照note分类统计书的库存量，显示库存量超过30本的</span><br><span class="line"></span><br><span class="line"># 13、查询所有图书，每页显示5本，显示第二页</span><br><span class="line"></span><br><span class="line"># 14、按照note分类统计书的库存量，显示库存量最多的</span><br><span class="line"></span><br><span class="line"># 15、查询书名达到10个字符的书，不包括里面的空格</span><br><span class="line"></span><br><span class="line"># 16、查询书名和类型，其中note值为novel显示小说，law显示法律，medicine显示医药，cartoon显示卡通，joke显示笑话</span><br><span class="line"></span><br><span class="line"># 17、查询书名、库存，其中num值超过30本的，显示滞销，大于0并低于10的，显示畅销，为0的显示需要无货</span><br><span class="line"></span><br><span class="line"># 18、统计每一种note的库存量，并合计总量</span><br><span class="line"></span><br><span class="line"># 19、统计每一种note的数量，并合计总量</span><br><span class="line"></span><br><span class="line"># 20、统计库存量前三名的图书</span><br><span class="line"></span><br><span class="line"># 21、找出最早出版的一本书</span><br><span class="line"></span><br><span class="line"># 22、找出novel中价格最高的一本书</span><br><span class="line"></span><br><span class="line"># 23、找出书名中字数最多的一本书，不含空格</span><br></pre></td></tr></table></figure><p>答案：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1、创建数据库test01_library</span><br><span class="line">CREATE DATABASE IF NOT EXISTS test01_library CHARACTER SET &#x27;utf8&#x27;;</span><br><span class="line"></span><br><span class="line">#指定使用哪个数据库</span><br><span class="line">USE test01_library;</span><br><span class="line"></span><br><span class="line">#2、创建表 books</span><br><span class="line">CREATE TABLE books(</span><br><span class="line">id INT,</span><br><span class="line">name VARCHAR(50),</span><br><span class="line">`authors` VARCHAR(100) ,</span><br><span class="line">price FLOAT,</span><br><span class="line">pubdate YEAR ,</span><br><span class="line">note VARCHAR(100),</span><br><span class="line">num INT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#3、向books表中插入记录</span><br><span class="line"># 1）不指定字段名称，插入第一条记录</span><br><span class="line">INSERT INTO books </span><br><span class="line">VALUES(1,&#x27;Tal of AAA&#x27;,&#x27;Dickes&#x27;,23,1995,&#x27;novel&#x27;,11);</span><br><span class="line"># 2）指定所有字段名称，插入第二记录</span><br><span class="line">INSERT INTO books (id,name,`authors`,price,pubdate,note,num)</span><br><span class="line">VALUES(2,&#x27;EmmaT&#x27;,&#x27;Jane lura&#x27;,35,1993,&#x27;Joke&#x27;,22);</span><br><span class="line"># 3）同时插入多条记录（剩下的所有记录）</span><br><span class="line">INSERT INTO books (id,name,`authors`,price,pubdate,note,num) VALUES</span><br><span class="line">(3,&#x27;Story of Jane&#x27;,&#x27;Jane Tim&#x27;,40,2001,&#x27;novel&#x27;,0),</span><br><span class="line">(4,&#x27;Lovey Day&#x27;,&#x27;George Byron&#x27;,20,2005,&#x27;novel&#x27;,30),</span><br><span class="line">(5,&#x27;Old land&#x27;,&#x27;Honore Blade&#x27;,30,2010,&#x27;Law&#x27;,0),</span><br><span class="line">(6,&#x27;The Battle&#x27;,&#x27;Upton Sara&#x27;,30,1999,&#x27;medicine&#x27;,40),</span><br><span class="line">(7,&#x27;Rose Hood&#x27;,&#x27;Richard haggard&#x27;,28,2008,&#x27;cartoon&#x27;,28);</span><br><span class="line"></span><br><span class="line"># 4、将小说类型(novel)的书的价格都增加5。</span><br><span class="line">UPDATE books SET price=price+5 WHERE note = &#x27;novel&#x27;;</span><br><span class="line"></span><br><span class="line"># 5、将名称为EmmaT的书的价格改为40，并将说明改为drama。</span><br><span class="line">UPDATE books SET price=40,note=&#x27;drama&#x27; WHERE name=&#x27;EmmaT&#x27;;</span><br><span class="line"></span><br><span class="line"># 6、删除库存为0的记录。</span><br><span class="line">DELETE FROM books WHERE num=0;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 7、统计书名中包含a字母的书</span><br><span class="line">SELECT * FROM books WHERE name LIKE &#x27;%a%&#x27;;</span><br><span class="line"></span><br><span class="line"># 8、统计书名中包含a字母的书的数量和库存总量</span><br><span class="line">SELECT COUNT(*),SUM(num) FROM books WHERE name LIKE &#x27;%a%&#x27;;</span><br><span class="line"></span><br><span class="line"># 9、找出“novel”类型的书，按照价格降序排列</span><br><span class="line">SELECT * FROM books WHERE note = &#x27;novel&#x27; ORDER BY price DESC;</span><br><span class="line"></span><br><span class="line"># 10、查询图书信息，按照库存量降序排列，如果库存量相同的按照note升序排列</span><br><span class="line">SELECT * FROM books ORDER BY num DESC,note ASC;</span><br><span class="line"></span><br><span class="line"># 11、按照note分类统计书的数量</span><br><span class="line">SELECT note,COUNT(*) FROM books GROUP BY note;</span><br><span class="line"></span><br><span class="line"># 12、按照note分类统计书的库存量，显示库存量超过30本的</span><br><span class="line">SELECT note,SUM(num) FROM books GROUP BY note HAVING SUM(num)&gt;30;</span><br><span class="line"></span><br><span class="line"># 13、查询所有图书，每页显示5本，显示第二页</span><br><span class="line">SELECT * FROM books LIMIT 5,5;</span><br><span class="line"></span><br><span class="line"># 14、按照note分类统计书的库存量，显示库存量最多的</span><br><span class="line">SELECT note,SUM(num) sum_num FROM books GROUP BY note ORDER BY sum_num DESC LIMIT 0,1;</span><br><span class="line"></span><br><span class="line"># 15、查询书名达到10个字符的书，不包括里面的空格</span><br><span class="line">SELECT * FROM books WHERE CHAR_LENGTH(REPLACE(name,&#x27; &#x27;,&#x27;&#x27;))&gt;=10;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">16、查询书名和类型，</span><br><span class="line"> 其中note值为 novel显示小说，law显示法律，medicine显示医药，cartoon显示卡通，joke显示笑话</span><br><span class="line">*/</span><br><span class="line">SELECT name AS &quot;书名&quot; ,note, CASE note </span><br><span class="line"> WHEN &#x27;novel&#x27; THEN &#x27;小说&#x27;</span><br><span class="line"> WHEN &#x27;law&#x27; THEN &#x27;法律&#x27;</span><br><span class="line"> WHEN &#x27;medicine&#x27; THEN &#x27;医药&#x27;</span><br><span class="line"> WHEN &#x27;cartoon&#x27; THEN &#x27;卡通&#x27;</span><br><span class="line"> WHEN &#x27;joke&#x27; THEN &#x27;笑话&#x27;</span><br><span class="line"> END AS &quot;类型&quot;</span><br><span class="line">FROM books;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 17、查询书名、库存，其中num值超过30本的，显示滞销，大于0并低于10的，显示畅销，为0的显示需要无货</span><br><span class="line">SELECT name,num,CASE </span><br><span class="line">  WHEN num&gt;30 THEN &#x27;滞销&#x27;</span><br><span class="line">  WHEN num&gt;0 AND num&lt;10 THEN &#x27;畅销&#x27;</span><br><span class="line">  WHEN num=0 THEN &#x27;无货&#x27;</span><br><span class="line">  ELSE &#x27;正常&#x27;</span><br><span class="line">  END AS &quot;库存状态&quot;</span><br><span class="line">FROM books;</span><br><span class="line"></span><br><span class="line"># 18、统计每一种note的库存量，并合计总量</span><br><span class="line">SELECT IFNULL(note,&#x27;合计总库存量&#x27;) AS note,SUM(num) FROM books GROUP BY note WITH ROLLUP;</span><br><span class="line"></span><br><span class="line"># 19、统计每一种note的数量，并合计总量</span><br><span class="line">SELECT IFNULL(note,&#x27;合计总数&#x27;) AS note,COUNT(*) FROM books GROUP BY note WITH ROLLUP;</span><br><span class="line"></span><br><span class="line"># 20、统计库存量前三名的图书</span><br><span class="line">SELECT * FROM books ORDER BY num DESC LIMIT 0,3;</span><br><span class="line"></span><br><span class="line"># 21、找出最早出版的一本书</span><br><span class="line">SELECT * FROM books ORDER BY pubdate ASC LIMIT 0,1;</span><br><span class="line"></span><br><span class="line"># 22、找出novel中价格最高的一本书</span><br><span class="line">SELECT * FROM books WHERE note = &#x27;novel&#x27; ORDER BY price DESC LIMIT 0,1;</span><br><span class="line"></span><br><span class="line"># 23、找出书名中字数最多的一本书，不含空格</span><br><span class="line">SELECT * FROM books ORDER BY CHAR_LENGTH(REPLACE(name,&#x27; &#x27;,&#x27;&#x27;)) DESC LIMIT 0,1;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第11章-数据处理之增删改&quot;&gt;&lt;a href=&quot;#第11章-数据处理之增删改&quot; class=&quot;headerlink&quot; title=&quot;第11章_数据处理之增删改&quot;&gt;&lt;/a&gt;第11章_数据处理之增删改&lt;/h1&gt;&lt;p&gt;讲师：尚硅谷-宋红康（江湖人称：康师傅）&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    <category term="基础版" scheme="http://example.com/categories/MySQL/%E5%9F%BA%E7%A1%80%E7%89%88/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>第10章_创建和管理表</title>
    <link href="http://example.com/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC10%E7%AB%A0_%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86%E8%A1%A8/"/>
    <id>http://example.com/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC10%E7%AB%A0_%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86%E8%A1%A8/</id>
    <published>2022-05-17T12:37:10.000Z</published>
    <updated>2022-05-17T13:02:20.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第10章-创建和管理表"><a href="#第10章-创建和管理表" class="headerlink" title="第10章_创建和管理表"></a>第10章_创建和管理表</h1><p>讲师：尚硅谷-宋红康（江湖人称：康师傅）</p><p>官网：<a href="http://www.atguigu.com/">http://www.atguigu.com</a></p><hr><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="一条数据存储的过程"><a href="#一条数据存储的过程" class="headerlink" title="一条数据存储的过程"></a>一条数据存储的过程</h3><p><code>存储数据是处理数据的第一步</code>。只有正确地把数据存储起来，我们才能进行有效的处理和分析。否则，只能是一团乱麻，无从下手。</p><p>那么，怎样才能把用户各种经营相关的、纷繁复杂的数据，有序、高效地存储起来呢？ 在 MySQL 中，一个完整的数据存储过程总共有 4 步，分别是创建数据库、确认字段、创建数据表、插入数据。</p><p><img src="/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC10%E7%AB%A0_%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86%E8%A1%A8/image-20211007155810920.png" alt="image-20211007155810920"></p><p>我们要先创建一个数据库，而不是直接创建数据表呢？ </p><p>因为从系统架构的层次上看，MySQL 数据库系统从大到小依次是<code>数据库服务器</code>、<code>数据库</code>、<code>数据表</code>、数据表的<code>行与列</code>。 </p><p>MySQL 数据库服务器之前已经安装。所以，我们就从创建数据库开始。</p><h3 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h3><ul><li>数据库名、表名不得超过30个字符，变量名限制为29个</li><li>必须只能包含 A–Z, a–z, 0–9, _共63个字符</li><li>数据库名、表名、字段名等对象名中间不要包含空格</li><li>同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名</li><li>必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使用`（着重号）引起来</li><li>保持字段名和类型的一致性：在命名字段并为其指定数据类型的时候一定要保证一致性，假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了</li></ul><h3 id="MySQL中的数据类型"><a href="#MySQL中的数据类型" class="headerlink" title="MySQL中的数据类型"></a>MySQL中的数据类型</h3><div class="table-container"><table><thead><tr><th>类型</th><th>类型举例</th></tr></thead><tbody><tr><td>整数类型</td><td>TINYINT、SMALLINT、MEDIUMINT、<strong>INT(或INTEGER)</strong>、BIGINT</td></tr><tr><td>浮点类型</td><td>FLOAT、DOUBLE</td></tr><tr><td>定点数类型</td><td><strong>DECIMAL</strong></td></tr><tr><td>位类型</td><td>BIT</td></tr><tr><td>日期时间类型</td><td>YEAR、TIME、<strong>DATE</strong>、DATETIME、TIMESTAMP</td></tr><tr><td>文本字符串类型</td><td>CHAR、<strong>VARCHAR</strong>、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT</td></tr><tr><td>枚举类型</td><td>ENUM</td></tr><tr><td>集合类型</td><td>SET</td></tr><tr><td>二进制字符串类型</td><td>BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB</td></tr><tr><td>JSON类型</td><td>JSON对象、JSON数组</td></tr><tr><td>空间数据类型</td><td>单值：GEOMETRY、POINT、LINESTRING、POLYGON；<br>集合：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION</td></tr></tbody></table></div><p>其中，常用的几类类型介绍如下：</p><div class="table-container"><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>INT</td><td>从-2^31到2^31-1的整型数据。存储大小为 4个字节</td></tr><tr><td>CHAR(size)</td><td>定长字符数据。若未指定，默认为1个字符，最大长度255</td></tr><tr><td>VARCHAR(size)</td><td>可变长字符数据，根据字符串实际长度保存，<strong>必须指定长度</strong></td></tr><tr><td>FLOAT(M,D)</td><td>单精度，占用4个字节，M=整数位+小数位，D=小数位。 D&lt;=M&lt;=255,0&lt;=D&lt;=30，默认M+D&lt;=6</td></tr><tr><td>DOUBLE(M,D)</td><td>双精度，占用8个字节，D&lt;=M&lt;=255,0&lt;=D&lt;=30，默认M+D&lt;=15</td></tr><tr><td>DECIMAL(M,D)</td><td>高精度小数，占用M+2个字节，D&lt;=M&lt;=65，0&lt;=D&lt;=30，最大取值范围与DOUBLE相同。</td></tr><tr><td>DATE</td><td>日期型数据，格式’YYYY-MM-DD’</td></tr><tr><td>BLOB</td><td>二进制形式的长文本数据，最大可达4G</td></tr><tr><td>TEXT</td><td>长文本数据，最大可达4G</td></tr></tbody></table></div><h2 id="创建和管理数据库"><a href="#创建和管理数据库" class="headerlink" title="创建和管理数据库"></a>创建和管理数据库</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><ul><li>方式1：创建数据库</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE 数据库名; </span><br></pre></td></tr></table></figure><ul><li>方式2：创建数据库并指定字符集</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE 数据库名 CHARACTER SET 字符集;</span><br></pre></td></tr></table></figure><ul><li>方式3：判断数据库是否已经存在，不存在则创建数据库（<code>推荐</code>）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE IF NOT EXISTS 数据库名; </span><br></pre></td></tr></table></figure><p>如果MySQL中已经存在相关的数据库，则忽略创建语句，不再创建数据库。</p><blockquote><p>注意：DATABASE 不能改名。一些可视化工具可以改名，它是建新库，把所有表复制到新库，再删旧库完成的。</p></blockquote><h3 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h3><ul><li>查看当前所有的数据库</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW DATABASES; #有一个S，代表多个数据库</span><br></pre></td></tr></table></figure><ul><li>查看当前正在使用的数据库</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DATABASE();  #使用的一个 mysql 中的全局函数</span><br></pre></td></tr></table></figure><ul><li>查看指定库下所有的表</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TABLES FROM 数据库名;</span><br></pre></td></tr></table></figure><ul><li>查看数据库的创建信息</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE DATABASE 数据库名;</span><br><span class="line">或者：</span><br><span class="line">SHOW CREATE DATABASE 数据库名\G</span><br></pre></td></tr></table></figure><ul><li>使用/切换数据库</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USE 数据库名;</span><br></pre></td></tr></table></figure><blockquote><p>注意：要操作表格和数据之前必须先说明是对哪个数据库进行操作，否则就要对所有对象加上“数据库名.”。</p></blockquote><h3 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h3><ul><li>更改数据库字符集</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER DATABASE 数据库名 CHARACTER SET 字符集;  #比如：gbk、utf8等</span><br></pre></td></tr></table></figure><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><ul><li>方式1：删除指定的数据库</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP DATABASE 数据库名;</span><br></pre></td></tr></table></figure><ul><li>方式2：删除指定的数据库（<code>推荐</code>）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP DATABASE IF EXISTS 数据库名;</span><br></pre></td></tr></table></figure><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><h3 id="创建方式1"><a href="#创建方式1" class="headerlink" title="创建方式1"></a>创建方式1</h3><ul><li><strong>必须具备：</strong><ul><li>CREATE TABLE权限</li><li>存储空间</li></ul></li><li><strong>语法格式：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE [IF NOT EXISTS] 表名(</span><br><span class="line">字段1, 数据类型 [约束条件] [默认值],</span><br><span class="line">字段2, 数据类型 [约束条件] [默认值],</span><br><span class="line">字段3, 数据类型 [约束条件] [默认值],</span><br><span class="line">……</span><br><span class="line">[表约束条件]</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>加上了IF NOT EXISTS关键字，则表示：如果当前数据库中不存在要创建的数据表，则创建数据表；如果当前数据库中已经存在要创建的数据表，则忽略建表语句，不再创建数据表。</p></blockquote><ul><li><strong>必须指定：</strong><ul><li>表名</li><li>列名(或字段名)，数据类型，<strong>长度</strong></li></ul></li><li><strong>可选指定：</strong><ul><li>约束条件</li><li>默认值</li></ul></li><li>创建表举例1：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建表</span><br><span class="line">CREATE TABLE emp (</span><br><span class="line">  -- int类型</span><br><span class="line">  emp_id INT,</span><br><span class="line">  -- 最多保存20个中英文字符</span><br><span class="line">  emp_name VARCHAR(20),</span><br><span class="line">  -- 总位数不超过15位</span><br><span class="line">  salary DOUBLE,</span><br><span class="line">  -- 日期类型</span><br><span class="line">  birthday DATE</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESC emp;</span><br></pre></td></tr></table></figure><p> <img src="/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC10%E7%AB%A0_%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86%E8%A1%A8/image-20211016160557995.png" alt="image-20211016160557995"></p><p>MySQL在执行建表语句时，将id字段的类型设置为int(11)，这里的11实际上是int类型指定的显示宽度，默认的显示宽度为11。也可以在创建数据表的时候指定数据的显示宽度。</p><ul><li>创建表举例2：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE dept(</span><br><span class="line">    -- int类型，自增</span><br><span class="line">deptno INT(2) AUTO_INCREMENT,</span><br><span class="line">dname VARCHAR(14),</span><br><span class="line">loc VARCHAR(13),</span><br><span class="line">    -- 主键</span><br><span class="line">    PRIMARY KEY (deptno)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESCRIBE dept;</span><br></pre></td></tr></table></figure><p><img src="/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC10%E7%AB%A0_%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86%E8%A1%A8/image-20211016160643445.png" alt="image-20211016160643445"></p><blockquote><p>在MySQL 8.x版本中，不再推荐为INT类型指定显示长度，并在未来的版本中可能去掉这样的语法。</p></blockquote><h3 id="创建方式2"><a href="#创建方式2" class="headerlink" title="创建方式2"></a>创建方式2</h3><ul><li><p>使用 AS subquery 选项，<strong>将创建表和插入数据结合起来</strong></p><p><img src="/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC10%E7%AB%A0_%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86%E8%A1%A8/1554997882872.png" alt="1554997882872"></p></li><li><p>指定的列和子查询中的列要一一对应</p></li><li><p>通过列名和默认值定义列</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE emp1 AS SELECT * FROM employees;</span><br><span class="line"></span><br><span class="line">CREATE TABLE emp2 AS SELECT * FROM employees WHERE 1=2; -- 创建的emp2是空表</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE dept80</span><br><span class="line">AS </span><br><span class="line">SELECT  employee_id, last_name, salary*12 ANNSAL, hire_date</span><br><span class="line">FROM    employees</span><br><span class="line">WHERE   department_id = 80;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESCRIBE dept80;</span><br></pre></td></tr></table></figure><p> <img src="/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC10%E7%AB%A0_%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86%E8%A1%A8/1554997998148.png" alt="1554997998148"></p><p> <img src="/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC10%E7%AB%A0_%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86%E8%A1%A8/1554998004494.png" alt="1554998004494"></p><h3 id="查看数据表结构"><a href="#查看数据表结构" class="headerlink" title="查看数据表结构"></a>查看数据表结构</h3><p>在MySQL中创建好数据表之后，可以查看数据表的结构。MySQL支持使用<code>DESCRIBE/DESC</code>语句查看数据表结构，也支持使用<code>SHOW CREATE TABLE</code>语句查看数据表结构。</p><p>语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE TABLE 表名\G</span><br></pre></td></tr></table></figure><p>使用SHOW CREATE TABLE语句不仅可以查看表创建时的详细语句，还可以查看存储引擎和字符编码。</p><h2 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h2><p>修改表指的是修改数据库中已经存在的数据表的结构。</p><p><strong>使用 ALTER TABLE 语句可以实现：</strong></p><ul><li><p>向已有的表中添加列</p></li><li><p>修改现有表中的列</p></li><li><p>删除现有表中的列</p></li><li><p>重命名现有表中的列</p></li></ul><h3 id="追加一个列"><a href="#追加一个列" class="headerlink" title="追加一个列"></a>追加一个列</h3><p>语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD 【COLUMN】 字段名 字段类型 【FIRST|AFTER 字段名】;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE dept80 </span><br><span class="line">ADD job_id varchar(15);</span><br></pre></td></tr></table></figure><p><img src="/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC10%E7%AB%A0_%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86%E8%A1%A8/1554998139815.png" alt="1554998139815"></p><h3 id="修改一个列"><a href="#修改一个列" class="headerlink" title="修改一个列"></a>修改一个列</h3><ul><li><p>可以修改列的数据类型，长度、默认值和位置</p></li><li><p>修改字段数据类型、长度、默认值、位置的语法格式如下：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 【COLUMN】 字段名1 字段类型 【DEFAULT 默认值】【FIRST|AFTER 字段名2】;</span><br></pre></td></tr></table></figure><ul><li>举例：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLEdept80</span><br><span class="line">MODIFY last_name VARCHAR(30);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLEdept80</span><br><span class="line">MODIFY salary double(9,2) default 1000;</span><br></pre></td></tr></table></figure><ul><li>对默认值的修改只影响今后对表的修改</li><li>此外，还可以通过此种方式修改列的约束。这里暂先不讲。</li></ul><h3 id="重命名一个列"><a href="#重命名一个列" class="headerlink" title="重命名一个列"></a>重命名一个列</h3><p>使用 CHANGE old_column  new_column  dataType子句重命名列。语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 CHANGE 【column】 列名 新列名 新数据类型;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE  dept80</span><br><span class="line">CHANGE department_name dept_name varchar(15); </span><br></pre></td></tr></table></figure><h3 id="删除一个列"><a href="#删除一个列" class="headerlink" title="删除一个列"></a>删除一个列</h3><p>删除表中某个字段的语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP 【COLUMN】字段名</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE  dept80</span><br><span class="line">DROP COLUMN  job_id; </span><br></pre></td></tr></table></figure><h2 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h2><ul><li>方式一：使用RENAME</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RENAME TABLE emp</span><br><span class="line">TO myemp;</span><br></pre></td></tr></table></figure><ul><li>方式二：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER table dept</span><br><span class="line">RENAME [TO] detail_dept;  -- [TO]可以省略</span><br></pre></td></tr></table></figure><ul><li>必须是对象的拥有者</li></ul><h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h2><ul><li><p>在MySQL中，当一张数据表<code>没有与其他任何数据表形成关联关系</code>时，可以将当前数据表直接删除。</p></li><li><p>数据和结构都被删除</p></li><li>所有正在运行的相关事务被提交</li><li>所有相关索引被删除</li><li>语法格式：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE [IF EXISTS] 数据表1 [, 数据表2, …, 数据表n];</span><br></pre></td></tr></table></figure><p><code>IF EXISTS</code>的含义为：如果当前数据库中存在相应的数据表，则删除数据表；如果当前数据库中不存在相应的数据表，则忽略删除语句，不再执行删除数据表的操作。</p><ul><li>举例：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE dept80;</span><br></pre></td></tr></table></figure><ul><li>DROP TABLE 语句不能回滚</li></ul><h2 id="清空表"><a href="#清空表" class="headerlink" title="清空表"></a>清空表</h2><ul><li><p>TRUNCATE TABLE语句：</p><ul><li>删除表中所有的数据</li><li>释放表的存储空间</li></ul></li><li><p>举例：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TRUNCATE TABLE detail_dept;</span><br></pre></td></tr></table></figure><ul><li><p>TRUNCATE语句<strong>不能回滚</strong>，而使用 DELETE 语句删除数据，可以回滚</p></li><li><p>对比：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET autocommit = FALSE;</span><br><span class="line">  </span><br><span class="line">DELETE FROM emp2; </span><br><span class="line">#TRUNCATE TABLE emp2;</span><br><span class="line">  </span><br><span class="line">SELECT * FROM emp2;</span><br><span class="line">  </span><br><span class="line">ROLLBACK;</span><br><span class="line">  </span><br><span class="line">SELECT * FROM emp2;</span><br></pre></td></tr></table></figure><blockquote><p>阿里开发规范：</p><p>【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无事务且不触发 TRIGGER，有可能造成事故，故不建议在开发代码中使用此语句。 </p><p>说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。</p></blockquote><h2 id="内容拓展"><a href="#内容拓展" class="headerlink" title="内容拓展"></a>内容拓展</h2><h3 id="拓展1：阿里巴巴《Java开发手册》之MySQL字段命名"><a href="#拓展1：阿里巴巴《Java开发手册》之MySQL字段命名" class="headerlink" title="拓展1：阿里巴巴《Java开发手册》之MySQL字段命名"></a>拓展1：阿里巴巴《Java开发手册》之MySQL字段命名</h3><ul><li><p>【<code>强制</code>】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。</p><ul><li>正例：aliyun_admin，rdc_config，level3_name </li><li>反例：AliyunAdmin，rdcConfig，level_3_name</li></ul></li><li><p>【<code>强制</code>】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。</p></li><li><p>【<code>强制</code>】表必备三字段：id, gmt_create, gmt_modified。 </p><ul><li>说明：其中 id 必为主键，类型为BIGINT UNSIGNED、单表时自增、步长为 1。gmt_create, gmt_modified 的类型均为 DATETIME 类型，前者现在时表示主动式创建，后者过去分词表示被动式更新</li></ul></li><li><p>【<code>推荐</code>】表的命名最好是遵循 “业务名称_表的作用”。 </p><ul><li>正例：alipay_task 、 force_project、 trade_config</li></ul></li><li><p>【<code>推荐</code>】库名与应用名称尽量一致。</p></li><li><p>【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。 </p><ul><li>正例：无符号值可以避免误存负数，且扩大了表示范围。</li></ul><p><img src="/2022/05/17/MySQL/mysql%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/%E7%AC%AC10%E7%AB%A0_%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86%E8%A1%A8/image-20211024012735469.png" alt="image-20211024012735469"></p></li></ul><h3 id="拓展2：如何理解清空表、删除表等操作需谨慎？！"><a href="#拓展2：如何理解清空表、删除表等操作需谨慎？！" class="headerlink" title="拓展2：如何理解清空表、删除表等操作需谨慎？！"></a>拓展2：如何理解清空表、删除表等操作需谨慎？！</h3><p><code>表删除</code>操作将把表的定义和表中的数据一起删除，并且MySQL在执行删除操作时，不会有任何的确认信息提示，因此执行删除操时应当慎重。在删除表前，最好对表中的数据进行<code>备份</code>，这样当操作失误时可以对数据进行恢复，以免造成无法挽回的后果。</p><p>同样的，在使用 <code>ALTER TABLE</code> 进行表的基本修改操作时，在执行操作过程之前，也应该确保对数据进行完整的<code>备份</code>，因为数据库的改变是<code>无法撤销</code>的，如果添加了一个不需要的字段，可以将其删除；相同的，如果删除了一个需要的列，该列下面的所有数据都将会丢失。</p><h3 id="拓展3：MySQL8新特性—DDL的原子化"><a href="#拓展3：MySQL8新特性—DDL的原子化" class="headerlink" title="拓展3：MySQL8新特性—DDL的原子化"></a>拓展3：MySQL8新特性—DDL的原子化</h3><p>在MySQL 8.0版本中，InnoDB表的DDL支持事务完整性，即<code>DDL操作要么成功要么回滚</code>。DDL操作回滚日志写入到data dictionary数据字典表mysql.innodb_ddl_log（该表是隐藏的表，通过show tables无法看到）中，用于回滚操作。通过设置参数，可将DDL操作日志打印输出到MySQL错误日志中。</p><p>分别在MySQL 5.7版本和MySQL 8.0版本中创建数据库和数据表，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE mytest;</span><br><span class="line"></span><br><span class="line">USE mytest;</span><br><span class="line"></span><br><span class="line">CREATE TABLE book1(</span><br><span class="line">book_id INT ,</span><br><span class="line">book_name VARCHAR(255)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure><p>（1）在MySQL 5.7版本中，测试步骤如下：<br>删除数据表book1和数据表book2，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; DROP TABLE book1,book2;</span><br><span class="line">ERROR 1051 (42S02): Unknown table &#x27;mytest.book2&#x27;</span><br></pre></td></tr></table></figure><p>再次查询数据库中的数据表名称，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW TABLES;</span><br><span class="line">Empty set (0.00 sec)</span><br></pre></td></tr></table></figure><p>从结果可以看出，虽然删除操作时报错了，但是仍然删除了数据表book1。</p><p>（2）在MySQL 8.0版本中，测试步骤如下：<br>删除数据表book1和数据表book2，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; DROP TABLE book1,book2;</span><br><span class="line">ERROR 1051 (42S02): Unknown table &#x27;mytest.book2&#x27;</span><br></pre></td></tr></table></figure><p>再次查询数据库中的数据表名称，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show tables;</span><br><span class="line">+------------------+</span><br><span class="line">| Tables_in_mytest |</span><br><span class="line">+------------------+</span><br><span class="line">| book1            |</span><br><span class="line">+------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>从结果可以看出，数据表book1并没有被删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第10章-创建和管理表&quot;&gt;&lt;a href=&quot;#第10章-创建和管理表&quot; class=&quot;headerlink&quot; title=&quot;第10章_创建和管理表&quot;&gt;&lt;/a&gt;第10章_创建和管理表&lt;/h1&gt;&lt;p&gt;讲师：尚硅谷-宋红康（江湖人称：康师傅）&lt;/p&gt;
&lt;p&gt;官网：&lt;a </summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    <category term="基础版" scheme="http://example.com/categories/MySQL/%E5%9F%BA%E7%A1%80%E7%89%88/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
</feed>
