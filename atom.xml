<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YZ</title>
  
  <subtitle>这是一名小学生</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-06-14T03:00:33.309Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>YZ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue3学习</title>
    <link href="http://example.com/2023/06/13/%E5%89%8D%E7%AB%AF/vue3%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2023/06/13/%E5%89%8D%E7%AB%AF/vue3%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-06-13T07:06:49.000Z</published>
    <updated>2023-06-14T03:00:33.309Z</updated>
    
    <content type="html"><![CDATA[<h2 id="computed和methods的区别"><a href="#computed和methods的区别" class="headerlink" title="computed和methods的区别"></a><code>computed</code>和<code>methods</code>的区别</h2><p>在<code>Vue</code>中，<code>computed</code>和<code>methods</code>都是用于计算属性的，但它们有以下几个主要的区别：</p><p><code>computed</code> 和 <code>methods</code> 都是 <code>Vue</code>组件中用来定义方法的选项，但它们有一些不同之处。</p><p>1.<code>computed</code><br>是计算属性的选项，它会根据它所依赖的数据动态计算出一个新的值，当依赖的数据发生变化时，计算属性会自动重新计算。计算属性的值会被缓存，只有当它所依赖的数据发生变化时才会重新计算。因此，计算属性适合用来处理需要根据数据动态计算的值，比如过滤、排序等操作。</p><p>2.<code>methods</code> 是普通方法的选项，它定义的方法可以被组件内部的其他方法调用，也可以在模板中被直接调用。方法不会被缓存，每次调用都会重新执行。因此，方法适合用来处理需要进行一些操作的逻辑，比如点击事件、表单提交等操作。</p><p>总的来说，<code>computed</code> 和 <code>methods</code><br>都是用来定义方法的选项，但它们的使用场景不同。如果需要根据数据动态计算一个值，就应该使用 <code>computed</code><br>；如果需要进行一些操作，就应该使用 <code>methods</code>。</p><h2 id="v-if和v-show的区别"><a href="#v-if和v-show的区别" class="headerlink" title="v-if和v-show的区别"></a><code>v-if</code>和<code>v-show</code>的区别</h2><p><code>v-if</code>和<code>v-show</code>都是<code>Vue</code>框架中的指令，用于根据表达式的值来控制元素的显示状态，不同的是它们的使用场景和实现方式略有不同，主要区别如下：</p><ol><li>初始化渲染时的差异</li></ol><p><code>v-if</code><br>在初始渲染时不会挂载到DOM中，只有在条件为真时才会挂载到DOM中，并且切换时会销毁或重新创建元素和绑定的事件监听器等，因此初始渲染时的开销较高。而<code>v-show</code><br>在初始渲染时就会挂载到DOM中，仅控制元素的显示与隐藏，因此开销较小。</p><ol><li>控制显示与隐藏的方式不同</li></ol><p><code>v-if</code>控制元素的显示与隐藏是通过销毁或创建元素来实现，因此显示和隐藏的切换有一定的开销。而<code>v-show</code><br>是通过切换CSS样式来实现元素的显示和隐藏，不需要销毁和创建元素，因此开销较小。</p><ol><li>适用场景的不同</li></ol><p><code>v-if</code>适合在需要频繁切换的场景中使用，例如需要根据用户的操作改变页面的显示内容。而<code>v-show</code><br>适合在需要频繁显示和隐藏的场景中使用，例如通过按钮来控制子菜单的显示和隐藏。</p><ol><li>编译后生成的代码不同</li></ol><p><code>v-if</code>在编译后会生成条件判断语句来控制元素的显示和隐藏。而<code>v-show</code>在编译后会生成一个简单的<code>if-else</code>语句来切换CSS样式来控制元素的显示和隐藏。</p><p>总之，如果需要频繁切换元素的显示和隐藏，可以使用<code>v-show</code><br>。如果元素的显示和隐藏不需要频繁切换，或者需要根据复杂的条件来判断，就可以使用<code>v-if</code>。</p><h2 id="v-for为什么要加key"><a href="#v-for为什么要加key" class="headerlink" title="v-for为什么要加key"></a><code>v-for</code>为什么要加<code>key</code></h2><p>在使用<code>v-for</code>指令循环渲染DOM元素时，每个子元素都应该唯一地对应一个标识。这个标识可以是一个字符串或数字类型的键值，用于指示循环中每个节点的唯一身份。</p><p>在<code>Vue</code>中，添加<code>key</code>属性也可以帮助<code>Vue</code>避免不必要地销毁和重新创建DOM元素，从而提高性能。</p><ol><li>提高复用性能</li></ol><p>当没有为<code>v-for</code>提供<code>key</code>属性时，<code>Vue</code><br>在渲染每个循环节点时会进行强制替换，也就是说每次循环渲染都会重新创建DOM元素。当为每个节点提供唯一的<code>key</code>属性后，<code>Vue</code><br>保存了节点的真实DOM状态，并在元素之间进行复用，不再进行强制替换操作，提高了DOM复用性能。</p><ol><li>便于维护</li></ol><p>为<code>v-for</code>添加<code>key</code>属性还可以便于查找和维护。</p><p>通过添加<code>key</code>属性，我们可以清晰地指定每个元素的身份，便于开发者在调试过程中更清晰地查找问题。同时，添加<code>key</code><br>属性还可以让其他开发者更容易理解代码，并且避免不必要的重复渲染导致的性能问题。</p><p>因此，在使用<code>v-for</code>指令循环渲染DOM元素时，添加<code>key</code>属性既可以提高性能，也可以方便开发者维护和查找问题。</p><h2 id="关于事件冒泡"><a href="#关于事件冒泡" class="headerlink" title="关于事件冒泡"></a>关于事件冒泡</h2><p>在<code>Vue</code><br>中，与传统的DOM事件冒泡机制类似，事件也会在组件树中自下而上地冒泡，直至到达根级别的组件。与传统DOM事件不同的是，在<code>Vue</code><br>中，可以使用<code>@click.stop</code>的方式阻止事件冒泡。例如，当在组件树内部某个元素上使用<code>@click.stop</code><br>修饰符时，该元素的点击事件不会再继续向上冒泡，而是在该元素上停止。</p><p>此外，<code>Vue</code>还提供了一个<code>@click.capture</code>修饰符，用于在从外向内触发事件时，在捕获阶段添加一个事件监听器。这种方式可以让开发者在事件捕获阶段中处理事件，可以在某些特定场景下提供更准确的控制。</p><p>除此之外，<code>Vue</code>还提供了<code>@click.self</code>修饰符，用于限制只有点击事件的目标元素完全等于事件绑定元素时，才会触发该事件处理器。这在某些需要限制目标元素的场景下非常有用。</p><h2 id="v-model原理"><a href="#v-model原理" class="headerlink" title="v-model原理"></a>v-model原理</h2><p><code>v-model</code>是<code>Vue</code>中一个非常重要的指令，它用于将表单元素的值和<code>Vue</code>实例中的数据绑定起来。虽然<code>v-model</code><br>在使用时非常简单，但是它背后的原理却比较复杂。</p><p>在HTML表单中，首先要想实现数据的双向绑定，需要监听输入框的<code>input</code>事件，再根据输入框的值修改绑定的数据。而在<code>Vue</code>中，<code>v-model</code><br>做了这些工作。</p><p>简而言之，当我们在模板中使用<code>v-model</code>指令时，<code>Vue</code>实际上是将该指令转化为一个普通的<code>value</code>绑定和一个<code>input</code><br>事件监听,在用户输入时，input事件被触发，<code>Vue</code>自动更新绑定的数据并将变化反映到视图中更新数据。当我们修改<code>Vue</code><br>实例中的数据时，<code>Vue</code>又会自动将更新反映到相应的<code>value</code>属性中，最终更新输入框的值。</p><p>具体来说，<code>v-model</code>的实现依赖于组件的<code>props</code>和自定义事件。对于一个组件的<code>v-model</code>使用场景，例如<code>MyComponent</code>，<code>Vue</code>做的事情如下：</p><p>1.将<code>value</code>和<code>input</code>分别作为<code>props</code>和自定义事件传给该组件。</p><p>2.该组件在内部更新<code>value</code>属性并触发<code>input</code>自定义事件时，将相应的数据修改后传递给父组件。</p><p>这意味着，使用<code>v-model</code>时，与表单元素相关的数据都由<code>Vue</code>实例中的数据来维护，从而达到了数据的双向绑定效果。</p><h2 id="vue3中组件之间通信有那些方式？"><a href="#vue3中组件之间通信有那些方式？" class="headerlink" title="vue3中组件之间通信有那些方式？"></a>vue3中组件之间通信有那些方式？</h2><p>在 <code>Vue3</code>中，组件之间的通信可以使用以下方式：</p><ol><li><p><code>Props</code> 和<code>Events</code>：父组件通过 props 把数据传递给子组件，子组件通过 events 把数据传递给父组件。</p></li><li><p>插槽（<code>Slots</code>）：父组件可以通过插槽把内容传递给子组件。</p></li><li><p><code>Provide</code> 和 <code>Inject</code>：父组件通过 <code>provide</code>提供数据，子组件通过<code>inject</code>注入数据。</p></li><li><p>全局事件总线（Global Event Bus）：通过创建一个空的 <code>Vue</code> 实例作为事件总线，不同组件之间可以通过事件总线来通信。</p></li><li><p><code>Vuex</code>：<code>Vuex</code> 是一个状态管理库，可以用于管理应用程序中的共享状态。</p></li></ol><p>这些方法的区别在于它们的使用场景和适用范围。<code>props</code> 适用于父子组件之间的数据传递，<code>$emit</code>/<code>$on</code><br>适用于子组件向父组件发送事件，<code>provide</code>/<code>inject</code> 适用于祖先组件向后代组件传递数据，<code>Vuex</code>适用于大型应用的状态管理，事件总线适用于任意组件之间的事件通信。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;computed和methods的区别&quot;&gt;&lt;a href=&quot;#computed和methods的区别&quot; class=&quot;headerlink&quot; title=&quot;computed和methods的区别&quot;&gt;&lt;/a&gt;&lt;code&gt;computed&lt;/code&gt;和&lt;code&gt;m</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>自定义线程池创建的线程名称</title>
    <link href="http://example.com/2023/03/17/Java%E5%9F%BA%E7%A1%80/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%9B%E5%BB%BA%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%90%8D%E7%A7%B0/"/>
    <id>http://example.com/2023/03/17/Java%E5%9F%BA%E7%A1%80/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%9B%E5%BB%BA%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%90%8D%E7%A7%B0/</id>
    <published>2023-03-17T03:14:15.000Z</published>
    <updated>2023-06-14T02:41:20.733Z</updated>
    
    <content type="html"><![CDATA[<p>在Java中，可以通过实现<code>ThreadFactory</code>接口并在创建线程池时将其作为参数传递来自定义线程池创建的线程的名称。<code>ThreadFactory</code>接口只有一个方法，即<code>newThread(Runnable r)</code>，该方法返回一个新的<code>Thread</code>对象。在此方法中，可以通过调用<code>Thread</code>类的<code>setName(String name)</code>方法为新线程设置自定义名称。</p><p>以下是一个示例代码，演示如何使用<code>ThreadFactory</code>接口自定义线程池创建的线程名称：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.exec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jdk.jfr.internal.tool.Main;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AtomicInteger 是 Java 中的一个原子类，它提供了一种线程安全的方式来操作整数类型的变量。</span></span><br><span class="line"><span class="comment">     * 在多线程环境下，多个线程同时对同一个变量进行操作可能会导致数据不一致的问题，使用 AtomicInteger 可以避免这种情况的发生。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">threadNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomThreadFactory</span><span class="params">(String groupName)</span> &#123;</span><br><span class="line">        namePrefix = groupName + <span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, namePrefix + threadNumber.getAndIncrement());</span><br><span class="line">        t.setDaemon(<span class="literal">false</span>);</span><br><span class="line">        t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程池并指定自定义线程工厂</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>, <span class="keyword">new</span> <span class="title class_">CustomThreadFactory</span>(<span class="string">&quot;my-group&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        executor.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;This is a task.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>CustomThreadFactory</code>类实现了<code>ThreadFactory</code>接口，并覆盖了<code>newThread(Runnable r)</code>方法。在该方法中，线程的名称由一个前缀和一个递增的数字组成，前缀为传递给<code>CustomThreadFactory</code>构造函数的参数。在创建线程池时，将<code>CustomThreadFactory</code>实例作为参数传递给<code>Executors.newFixedThreadPool()</code>方法。通过这种方式，线程池创建的所有线程都将使用<code>CustomThreadFactory</code>中定义的命名方案。</p><p>请注意，在实现<code>ThreadFactory</code>接口时，应该谨慎处理线程名称，以确保名称在多线程环境中是唯一的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Java中，可以通过实现&lt;code&gt;ThreadFactory&lt;/code&gt;接口并在创建线程池时将其作为参数传递来自定义线程池创建的线程的名称。&lt;code&gt;ThreadFactory&lt;/code&gt;接口只有一个方法，即&lt;code&gt;newThread(Runnable r)&lt;</summary>
      
    
    
    
    
    <category term="线程池" scheme="http://example.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot使用阿里云短信服务发送验证码</title>
    <link href="http://example.com/2023/03/14/Spring%E7%9B%B8%E5%85%B3/SpringBoot%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E7%9F%AD%E4%BF%A1%E6%9C%8D%E5%8A%A1%E5%8F%91%E9%80%81%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    <id>http://example.com/2023/03/14/Spring%E7%9B%B8%E5%85%B3/SpringBoot%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E7%9F%AD%E4%BF%A1%E6%9C%8D%E5%8A%A1%E5%8F%91%E9%80%81%E9%AA%8C%E8%AF%81%E7%A0%81/</id>
    <published>2023-03-14T01:58:00.000Z</published>
    <updated>2023-03-14T06:19:49.957Z</updated>
    
    <content type="html"><![CDATA[<h1 id="申请阿里云短信服务"><a href="#申请阿里云短信服务" class="headerlink" title="申请阿里云短信服务"></a>申请阿里云短信服务</h1><p>需要在阿里云上注册并开通短信服务。在控制台中创建签名和模板。签名是短信发送者的名称，模板是您要发送的短信内容。在创建模板时，您可以使用变量来定制短信内容，例如验证码。</p><p>一般来说，在短信验证时需要签名管理和模板管理，但是签名管理需要备案或者上线服务，所以对于没有备案和上线应用的用户来说，就进行不了这一项，但是阿里云提供了免费的API测试短信验证服务（当然测试信息验证码也是收费的），具体过程如下：</p><p>主要参数如下：</p><p><img src="/2023/03/14/Spring%E7%9B%B8%E5%85%B3/SpringBoot%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E7%9F%AD%E4%BF%A1%E6%9C%8D%E5%8A%A1%E5%8F%91%E9%80%81%E9%AA%8C%E8%AF%81%E7%A0%81/aliyun-sms.png" alt="aliyun-sms"></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="引入maven依赖"><a href="#引入maven依赖" class="headerlink" title="引入maven依赖"></a>引入maven依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--hutool 用来将Java对象转为Json字符串--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--阿里云短信服务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-java-sdk-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="application-yml-根据实际情况修改"><a href="#application-yml-根据实际情况修改" class="headerlink" title="application.yml(根据实际情况修改)"></a>application.yml(根据实际情况修改)</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">aliyun:</span></span><br><span class="line">  <span class="attr">sms:</span></span><br><span class="line">    <span class="attr">accessKeyId:</span> </span><br><span class="line">    <span class="attr">accessKeySecret:</span> </span><br><span class="line">    <span class="attr">signName:</span> <span class="string">阿里云短信测试</span></span><br><span class="line">    <span class="attr">templateCode:</span> <span class="string">SMS_154950909</span></span><br><span class="line">    <span class="attr">regionId:</span> <span class="string">cn-hangzhou</span></span><br></pre></td></tr></table></figure><h2 id="将配置文件的值绑定到配置类属性上"><a href="#将配置文件的值绑定到配置类属性上" class="headerlink" title="将配置文件的值绑定到配置类属性上"></a>将配置文件的值绑定到配置类属性上</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;aliyun.sms&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String regionId;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String accessKeyId;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String accessKeySecret;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String signName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String templateCode;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写发送短信接口"><a href="#写发送短信接口" class="headerlink" title="写发送短信接口"></a>写发送短信接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MsmService</span> &#123;</span><br><span class="line">    <span class="comment">//阿里云短信服务发送手机验证码</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">send</span><span class="params">(String phone, String code)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写发送短信接口实现类"><a href="#写发送短信接口实现类" class="headerlink" title="写发送短信接口实现类"></a>写发送短信接口实现类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.hutool.json.JSONUtil;</span><br><span class="line"><span class="keyword">import</span> com.aliyuncs.CommonRequest;</span><br><span class="line"><span class="keyword">import</span> com.aliyuncs.CommonResponse;</span><br><span class="line"><span class="keyword">import</span> com.aliyuncs.DefaultAcsClient;</span><br><span class="line"><span class="keyword">import</span> com.aliyuncs.IAcsClient;</span><br><span class="line"><span class="keyword">import</span> com.aliyuncs.exceptions.ClientException;</span><br><span class="line"><span class="keyword">import</span> com.aliyuncs.exceptions.ServerException;</span><br><span class="line"><span class="keyword">import</span> com.aliyuncs.http.MethodType;</span><br><span class="line"><span class="keyword">import</span> com.aliyuncs.profile.DefaultProfile;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.config.SmsConfig;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.service.MsmService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MsmServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">MsmService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SmsConfig smsConfig;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阿里云短信服务发送手机验证码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> phone</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">send</span><span class="params">(String phone, String code)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//传入smsConfig配置类中从application.yaml配置文件中获取的三个值</span></span><br><span class="line">        <span class="type">DefaultProfile</span> <span class="variable">profile</span> <span class="operator">=</span> DefaultProfile.</span><br><span class="line">                getProfile(smsConfig.getRegionId(),</span><br><span class="line">                        smsConfig.getAccessKeyId(),</span><br><span class="line">                        smsConfig.getAccessKeySecret());</span><br><span class="line"></span><br><span class="line">        <span class="type">IAcsClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultAcsClient</span>(profile);</span><br><span class="line">        <span class="type">CommonRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonRequest</span>();</span><br><span class="line">        <span class="comment">//request.setProtocol(ProtocolType.HTTPS);  //发送的协议如果是https就不注释</span></span><br><span class="line">        request.setMethod(MethodType.POST); <span class="comment">//这一行是固定的</span></span><br><span class="line">        request.setDomain(<span class="string">&quot;dysmsapi.aliyuncs.com&quot;</span>); <span class="comment">//这一行是固定的</span></span><br><span class="line">        request.setVersion(<span class="string">&quot;2017-05-25&quot;</span>);   <span class="comment">//这一行是固定的</span></span><br><span class="line">        request.setAction(<span class="string">&quot;SendSms&quot;</span>);   <span class="comment">//这一行是固定的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//手机号</span></span><br><span class="line">        request.putQueryParameter(<span class="string">&quot;PhoneNumbers&quot;</span>, phone);</span><br><span class="line">        <span class="comment">//签名名称</span></span><br><span class="line">        request.putQueryParameter(<span class="string">&quot;SignName&quot;</span>, smsConfig.getSignName());</span><br><span class="line">        <span class="comment">//模板code</span></span><br><span class="line">        request.putQueryParameter(<span class="string">&quot;TemplateCode&quot;</span>, smsConfig.getTemplateCode());</span><br><span class="line">        <span class="comment">//验证码  使用json格式   &#123;&quot;code&quot;:&quot;123456&quot;&#125;</span></span><br><span class="line">        Map&lt;String, Object&gt; param = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        param.put(<span class="string">&quot;code&quot;</span>, code);</span><br><span class="line">        request.putQueryParameter(<span class="string">&quot;TemplateParam&quot;</span>, JSONUtil.toJsonStr(param));</span><br><span class="line">        <span class="comment">//调用方法进行短信发送</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">CommonResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.getCommonResponse(request);</span><br><span class="line">            System.out.println(response.getData());</span><br><span class="line">            <span class="keyword">return</span> response.getHttpResponse().isSuccess();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ServerException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//失败就返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="写测试类"><a href="#写测试类" class="headerlink" title="写测试类"></a>写测试类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IUserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送手机验证码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/code&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(<span class="meta">@RequestParam(&quot;phone&quot;)</span> String phone, HttpSession session)</span> &#123;</span><br><span class="line">        <span class="comment">// 发送短信验证码并保存验证码</span></span><br><span class="line">        <span class="keyword">return</span> userService.sendCode(phone, session);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Service</span><br><span class="line">public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements IUserService &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    @Resource</span><br><span class="line">    private MsmServiceImpl msmService;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Result sendCode(String phone, HttpSession session) &#123;</span><br><span class="line">        //1.校验手机号</span><br><span class="line">        if (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">            //2.不符合，重新提交</span><br><span class="line">            Result.fail(&quot;手机号不符合&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //3.符合，生成验证码</span><br><span class="line">        String code = RandomUtil.randomNumbers(6);</span><br><span class="line">        boolean isSuccess = msmService.send(phone, code);</span><br><span class="line">        if (!isSuccess) &#123;</span><br><span class="line">            return Result.fail(&quot;验证码发送失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //4.保存验证码</span><br><span class="line">        stringRedisTemplate.opsForValue().set(RedisConstants.LOGIN_CODE_KEY + phone, code, RedisConstants.LOGIN_CODE_TTL, TimeUnit.MINUTES);</span><br><span class="line">        //5.发送验证码</span><br><span class="line">        log.debug(&quot;发送验证码成功，code&#123;&#125;&quot;, code);</span><br><span class="line">        //返回ok</span><br><span class="line">        return Result.ok();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Apifox发送快捷请求"><a href="#Apifox发送快捷请求" class="headerlink" title="Apifox发送快捷请求"></a>Apifox发送快捷请求</h2><p><img src="/2023/03/14/Spring%E7%9B%B8%E5%85%B3/SpringBoot%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E7%9F%AD%E4%BF%A1%E6%9C%8D%E5%8A%A1%E5%8F%91%E9%80%81%E9%AA%8C%E8%AF%81%E7%A0%81/Apifox发送短信.png" alt="Apifox发送请求"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;申请阿里云短信服务&quot;&gt;&lt;a href=&quot;#申请阿里云短信服务&quot; class=&quot;headerlink&quot; title=&quot;申请阿里云短信服务&quot;&gt;&lt;/a&gt;申请阿里云短信服务&lt;/h1&gt;&lt;p&gt;需要在阿里云上注册并开通短信服务。在控制台中创建签名和模板。签名是短信发送者的名称，</summary>
      
    
    
    
    <category term="Spring相关" scheme="http://example.com/categories/Spring%E7%9B%B8%E5%85%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>第01章_Java语言概述</title>
    <link href="http://example.com/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/</id>
    <published>2023-02-18T12:37:01.000Z</published>
    <updated>2023-02-19T07:35:35.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第01章-Java语言概述"><a href="#第01章-Java语言概述" class="headerlink" title="第01章_Java语言概述"></a>第01章_Java语言概述</h1><p>讲师：尚硅谷-宋红康（江湖人称：康师傅）</p><p>官网：<a href="http://www.atguigu.com/">http://www.atguigu.com</a></p><hr><h2 id="1-Java知识脉络图"><a href="#1-Java知识脉络图" class="headerlink" title="1. Java知识脉络图"></a>1. Java知识脉络图</h2><h3 id="1-1-Java基础全程脉络图"><a href="#1-1-Java基础全程脉络图" class="headerlink" title="1.1 Java基础全程脉络图"></a>1.1 Java基础全程脉络图</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/Java基础全程脉络图.png" alt="Java基础全程脉络图" style="zoom: 50%;"></p><h3 id="1-2-本章专题与脉络"><a href="#1-2-本章专题与脉络" class="headerlink" title="1.2 本章专题与脉络"></a>1.2 本章专题与脉络</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/第1阶段：Java基本语法-第01章.png" alt="第1阶段：Java基本语法-第01章" style="zoom: 45%;"></p><h2 id="2-抽丝剥茧话Java"><a href="#2-抽丝剥茧话Java" class="headerlink" title="2. 抽丝剥茧话Java"></a>2. 抽丝剥茧话Java</h2><h3 id="2-1-当前大学生就业形势"><a href="#2-1-当前大学生就业形势" class="headerlink" title="2.1 当前大学生就业形势"></a>2.1 当前大学生就业形势</h3><ul><li><code>麦可思研究院</code>发布了《<strong>2022年中国大学生就业报告</strong>》，针对2021届毕业生收入较高的本科专业排行榜：</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/37cb4fd26b284de3913374e9660e870d.jpeg" alt="img" style="zoom: 50%;"></p><ul><li><p><code>麦可思研究院</code>发布过《<strong>2021年中国大学生就业报告</strong>》，应届本科毕业生就业数量较大的前十位行业类的就业质量：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/jiuyezhiliang1.jpg" alt="jiuyezhiliang1" style="zoom: 67%;"></p></li><li><p>报告还对毕业三年后的2017届毕业生所在十大行业进行了统计：</p></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/jiuyezhiliang2.jpg" alt="jiuyezhiliang2" style="zoom: 60%;"></p><ul><li>从国家统计局发布的2021年全国平均工资来看，不管在城镇非私营单位还是私营单位，<code>IT业均为最高</code>。</li></ul><h3 id="2-2-IT互联网是否依旧靠谱"><a href="#2-2-IT互联网是否依旧靠谱" class="headerlink" title="2.2 IT互联网是否依旧靠谱"></a>2.2 IT互联网是否依旧靠谱</h3><p>过去不能代表未来！互联网是否依旧靠谱？！</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220523002428542.png" alt="image-20220523002428542" style="zoom:80%;"></p><blockquote><p>2014 年至 2018 年间，我国网民规模从 6.49 亿增长为 8.29 亿，增幅为 <code>27.5%</code>。同一时间段，全国移动互联网接入的流量却从 20.6EB 增长到了 711.1EB，增幅达 <code>3352%</code>（获取和处理的信息量大幅增加）。 </p><p>随着 5G 技术进一步拓宽移动互联网的速度和容量，<code>产业互联网</code>将在消费型流量的基础上创造生产型流量，根据报告的预测，至 2024 年，全国移动互联网的接入流量将达到 127663.8EB， <code>流量规模达到2018年的179.5倍</code>。</p><p>当下，5G、物联网、人工智能、产业互联网都是国家政策大方向，需要大量<code>能与机器对话</code>的中高端人才。</p></blockquote><h3 id="2-3-IT行业岗位分析"><a href="#2-3-IT行业岗位分析" class="headerlink" title="2.3 IT行业岗位分析"></a>2.3 IT行业岗位分析</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220522234544537.png" alt="image-20220522234544537" style="zoom: 80%;"></p><p><strong>软件开发，是进入互联网IT圈最好的选择之一！</strong></p><ul><li>起始薪资高</li><li>工作环境好</li><li>涨薪幅度高</li><li>行业更公平</li></ul><h3 id="2-4-软件开发之Java开发"><a href="#2-4-软件开发之Java开发" class="headerlink" title="2.4 软件开发之Java开发"></a>2.4 软件开发之Java开发</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220504101615999.png" alt="image-20220504101615999"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220608160444947.png" alt="image-20220608160444947"></p><ul><li><p><strong>移动应用领域（集成Android平台）</strong>：Java在Android端是主要开发的语言，占有重要的地位。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220511092649122.png" alt="image-20220511092649122" style="zoom: 65%;"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/20220608_160310.jpg" alt="20220608_160310" style="zoom:67%;"></p></li><li><p><strong>企业级应用领域（JavaEE后台）</strong>：用来开发企业级的应用程序，大型网站如淘宝、京东、12306，以及各大物流、银行、金融、社交、医疗、交通、各种OA系统等都是用JavaEE技术开发的。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220511090528043.png" alt="image-20220511090528043" style="zoom:67%;"></p></li><li><p><strong>大数据分析、人工智能领域</strong>：流行的大数据框架，如Hadoop、Flink都是用Java编写的。Spark使用Scala编写，但可以用Java开发应用。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220511091647358.png" alt="image-20220511091647358" style="zoom:70%;"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220513233529610.png" alt="image-20220513233529610"></p><blockquote><p>Eversoft公司在提到2022年Java发展趋势时写道：</p><p><code>Java 是用于开发大数据项目的最主流的语言</code>。我们可以轻松地预测它也将在之后继续<code>主导大数据</code>！</p></blockquote></li><li><p><strong>游戏领域、桌面应用、嵌入式领域：</strong>很多大型游戏的后台、桌面应用等也是Java开发的。</p></li></ul><h3 id="2-5-到底多少人在用Java"><a href="#2-5-到底多少人在用Java" class="headerlink" title="2.5 到底多少人在用Java"></a>2.5 到底多少人在用Java</h3><blockquote><p>2020年，根据 IDC 的报告“Java Turns 25”显示，超过 <code>900 万</code>名开发人员（全球专职开发人员中的 <code>69%</code>）在使用 Java——比其他任何语言都多。该报告指出，大多数企业业务服务都依靠 Java 来实现。</p><p>… Java 一直是开发人员中最流行的编程语言，被誉为“<code>宇宙第一语言</code>”。</p><p>我想告诉大家：</p><p>“市场的需求比较大，市场的供给比较大”</p><p>“如果你在Java领域里持续积累5-7年以上，那么你至少会成为这个行业的一个专家！”</p></blockquote><h3 id="2-6-八卦一下程序员"><a href="#2-6-八卦一下程序员" class="headerlink" title="2.6 八卦一下程序员"></a>2.6 八卦一下程序员</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220602105134523.png" alt="image-20220602105134523" style="zoom:80%;"></p><p>还可以是：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220602105213557.png" alt="image-20220602105213557"></p><h3 id="2-7-Java系列课程体系"><a href="#2-7-Java系列课程体系" class="headerlink" title="2.7 Java系列课程体系"></a>2.7 Java系列课程体系</h3><ul><li>见02_学习路线图之《Java中高级程序员全程学习路线图.xmind》</li></ul><h3 id="2-8-Java职业晋升路线图"><a href="#2-8-Java职业晋升路线图" class="headerlink" title="2.8 Java职业晋升路线图"></a>2.8 Java职业晋升路线图</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/技术发展路线.jpg" alt="技术发展路线"></p><p>薪资数据统计来源：拉勾网</p><h2 id="3-计算机的硬件与软件"><a href="#3-计算机的硬件与软件" class="headerlink" title="3. 计算机的硬件与软件"></a>3. 计算机的硬件与软件</h2><h3 id="3-1-计算机组成：硬件-软件"><a href="#3-1-计算机组成：硬件-软件" class="headerlink" title="3.1 计算机组成：硬件+软件"></a>3.1 计算机组成：硬件+软件</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220524152902812.png" alt="image-20220524152902812"></p><h3 id="3-2-CPU、内存与硬盘"><a href="#3-2-CPU、内存与硬盘" class="headerlink" title="3.2 CPU、内存与硬盘"></a>3.2 CPU、内存与硬盘</h3><ul><li><p><strong>CPU（Central Processing Unit，中央处理器）</strong></p><ul><li>人靠大脑思考，电脑靠CPU来运算、控制。</li></ul></li><li><p><strong>硬盘（Hard Disk Drive）</strong></p><ul><li>计算机最主要的存储设备，容量大，断电数据不丢失。</li><li>正常分类：<code>机械硬盘（HDD）</code>、<code>固态硬盘（SSD）</code>以及<code>混合硬盘（SSHD）</code></li><li>固态硬盘在开机速度和程序加载速度远远高于机械硬盘，缺点就是贵，所有无法完全取代机械硬盘。</li></ul></li><li><strong>内存（Memory）</strong><ul><li>负责硬盘上的数据与CPU之间数据交换处理</li><li>具体的：保存从硬盘读取的数据，提供给CPU使用；保存CPU的一些临时执行结果，以便CPU下次使用或保存到硬盘。</li><li>断电后数据丢失。</li></ul></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220731234604511.png" alt="image-20220731234604511"></p><h3 id="3-3-输入设备：键盘输入"><a href="#3-3-输入设备：键盘输入" class="headerlink" title="3.3 输入设备：键盘输入"></a>3.3 输入设备：键盘输入</h3><ul><li>熟悉指法</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220517100223784.png" alt="image-20220517100223784" style="zoom: 80%;"></p><p>不熟悉键盘的小伙伴，可以“<code>金山打字通</code>”走起了。坚决杜绝<code>二指禅</code>！！</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220517100543176.png" alt="image-20220517100543176" style="zoom:67%;"></p><h2 id="4-软件相关介绍"><a href="#4-软件相关介绍" class="headerlink" title="4. 软件相关介绍"></a>4. 软件相关介绍</h2><h3 id="4-1-什么是软件"><a href="#4-1-什么是软件" class="headerlink" title="4.1 什么是软件"></a>4.1 什么是软件</h3><p>软件，即一系列按照<code>特定顺序组织</code>的计算机<code>数据</code>和<code>指令</code>的集合。有<strong>系统软件</strong>和<strong>应用软件</strong>之分。</p><blockquote><p>Pascal之父Nicklaus Wirth： “Programs = Data Structures + Algorithms”</p></blockquote><p>系统软件：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220522215226273.png" alt="image-20220522215226273"></p><p>应用软件：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/macdesk.png" alt="macdesk"></p><h3 id="4-2-人机交互方式"><a href="#4-2-人机交互方式" class="headerlink" title="4.2 人机交互方式"></a>4.2 人机交互方式</h3><ul><li><p><strong>图形化界面</strong>（Graphical User Interface，GUI），这种方式简单直观，使用者易于接受，容易上手操作。</p></li><li><p><strong>命令行方式</strong>（Command Line Interface，CLI），需要在控制台输入特定的<code>指令</code>，让计算机完成一些操作。需要记忆一些指令，较为麻烦。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/u=2668016850,3232153547&fm=253&fmt=auto&app=138&f=JPEG" alt="img" style="zoom:67%;"></p></li></ul><h3 id="4-3-常用的DOS命令"><a href="#4-3-常用的DOS命令" class="headerlink" title="4.3 常用的DOS命令"></a>4.3 常用的DOS命令</h3><p>DOS（Disk Operating System，磁盘操作系统）是Microsoft公司在Windows之前推出的一个操作系统，是单用户、单任务（即只能执行一个任务）的操作系统。现在被Windows系统取代。</p><p>对于Java初学者，学习一些DOS命令，会非常有帮助。</p><p><strong>进入DOS操作窗口：</strong></p><ul><li><p>按下Windows+R键盘，打开运行窗口，输入cmd回车，进入到DOS的操作窗口。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220520100110104.png" alt="image-20220520100110104" style="zoom:80%;"></p></li></ul><p><strong>常用指令：</strong></p><ul><li><code>操作1：进入和回退</code></li></ul><div class="table-container"><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>盘符名称:</td><td>盘符切换。E:回车，表示切换到E盘。</td></tr><tr><td>dir</td><td>列出当前目录下的文件以及文件夹</td></tr><tr><td>cd 目录</td><td>进入指定单级目录。</td></tr><tr><td>cd 目录1\目录2\…</td><td>进入指定多级目录。cd atguigu\JavaSE</td></tr><tr><td>cd ..</td><td>回退到上一级目录。</td></tr><tr><td>cd \ 或 cd /</td><td>回退到盘符目录。</td></tr></tbody></table></div><ul><li><code>操作2：增、删</code></li></ul><div class="table-container"><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>md 文件目录名</td><td>创建指定的文件目录。</td></tr><tr><td>rd 文件目录名</td><td>删除指定的文件目录（如文件目录内有数据，删除失败）</td></tr></tbody></table></div><ul><li><code>操作3：其它</code></li></ul><div class="table-container"><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>cls</td><td>清屏。</td></tr><tr><td>exit</td><td>退出命令提示符窗口。</td></tr><tr><td>←  →</td><td>移动光标</td></tr><tr><td>↑  ↓</td><td>调阅历史操作命令</td></tr><tr><td>Delete和Backspace</td><td>删除字符</td></tr></tbody></table></div><h2 id="5-计算机编程语言"><a href="#5-计算机编程语言" class="headerlink" title="5. 计算机编程语言"></a>5. 计算机编程语言</h2><h3 id="5-1-计算机语言是什么"><a href="#5-1-计算机语言是什么" class="headerlink" title="5.1 计算机语言是什么"></a>5.1 计算机语言是什么</h3><ul><li><p><strong>语言</strong>：是人与人之间用于沟通的一种方式。例如：中国人与中国人用普通话沟通。而中国人要和英国人交流，可以使用英语或普通话。</p></li><li><p><strong>计算机编程语言</strong>，就是人与计算机交流的方式。人们可以使用<code>编程语言</code>对计算机下达<code>命令</code>，让计算机完成人们需要的功能。</p></li><li>计算机语言有很多种。如：C 、C++、Java、Go、JavaScript、Python，Scala等。</li></ul><blockquote><p>体会：语言 = 语法 + 逻辑</p></blockquote><h3 id="5-2-计算机语言简史"><a href="#5-2-计算机语言简史" class="headerlink" title="5.2 计算机语言简史"></a>5.2 计算机语言简史</h3><ul><li><p><strong>第一代：机器语言（相当于人类的石器时代）</strong></p><ul><li><p>1946年2月14日，世界上第一台计算机<code>ENAC</code>诞生，使用的是最原始的<code>穿孔卡片</code>。这种卡片上使用的是用<code>二进制代码</code>表示的语言，与人类语言差别极大，这种语言就称为<code>机器语言</code>。比如一段典型的机器码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.0000,0000,000000010000 代表 LOAD A, 16</span><br><span class="line">2.0000,0001,000000000001 代表 LOAD B, 1</span><br><span class="line">3.0001,0001,000000010000 代表 STORE B, 16</span><br></pre></td></tr></table></figure></li><li><p>这种语言本质上是计算机能识别的唯一语言，人类很难理解。可以大胆想象”<code>此时的程序员99.9%都是异类！</code>“</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220309223406537.png" alt="image-20220309223406537"></p></li></ul></li><li><p><strong>第二代：汇编语言（相当于人类的青铜&amp;铁器时代）</strong></p><ul><li><p>使用英文缩写的<code>助记符</code>来表示基本的操作，这些助记符构成了汇编语言的基础。比如：<code>LOAD</code>、<code>MOVE</code>等，使人更容易使用。因此，汇编语言也称为<code>符号语言</code>。</p></li><li><p>优点：能编写<code>高效率</code>的程序</p></li><li><p>缺点：汇编语言是<code>面向机器的</code>，不同计算机机型特点不同，因此会有不同的汇编语言，彼此之间<code>不能通用</code>。程序不易移植，较难调试。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220309223725671.png" alt="image-20220309223725671" style="zoom:67%;"></p></li><li><p>比起机器语言，汇编大大进步了，是机器语言向更高级的语言进化的<code>桥梁</code>。目前仍然应用于工业电子编程领域、软件的加密解密、计算机病毒分析等。</p></li></ul></li><li><p><strong>第三代：高级语言（相当于人类的信息时代）</strong></p><ul><li><p>高级语言发展于20世纪50年代中叶到70年代，是一种<code>接近于人们使用习惯</code>的程序设计语言。它允许程序员使用<code>接近日常英语</code>的指令来编写程序，程序中的符号和算式也与<code>日常用的数学式子</code>差不多，接近于自然语言和数学语言，容易为人们掌握。比如：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20211218092541175.png" alt="image-20211218092541175"></p></li><li><p>高级语言<code>独立于机器</code>，有一定的通用性；计算机不能直接识别和执行用高级语言编写的程序，需要使用编译器或者解释器，<code>转换为机器语言</code>才能被识别和执行。</p></li></ul></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20211218092630678.png" alt="image-20211218092630678" style="zoom:80%;"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20211218092541075.png" alt="image-20211218092541075"></p><p>此外，高级语言按照程序设计方法的不同，又分为：<code>面向过程的语言</code>、<code>面向对象的语言</code>。</p><ul><li>C、Pascal、Fortran面向过程的语言</li><li>C++面向过程/面向对象</li><li>Java跨平台的纯面向对象的语言</li><li>C#、Python、JavaScript、Scala…</li></ul><blockquote><p>目前以及可预见的将来，计算机语言仍然处于“第三代高级语言”阶段。但是不管是什么语言，最后都要向机器语言靠近，因为CPU只认识0和1。</p></blockquote><h3 id="5-3-计算机语言排行榜"><a href="#5-3-计算机语言排行榜" class="headerlink" title="5.3 计算机语言排行榜"></a>5.3 计算机语言排行榜</h3><p>TIOBE （<a href="https://www.tiobe.com/tiobe-index/）是一个流行编程语言排行，每月更新。排名权重基于世界范围内">https://www.tiobe.com/tiobe-index/）是一个流行编程语言排行，每月更新。排名权重基于世界范围内</a> 工程师数量，Google、Bing、Yahoo! 、Wikipedia、Amazon、Youtube和百度这些主流的搜索引擎，也将作为排名权重的参考指标。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20221027112824724.png" alt="image-20221027112824724"></p><p>计算机语言走势</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20221027113511832.png" alt="image-20221027113511832"></p><h3 id="5-4-编程语言，该学哪个？"><a href="#5-4-编程语言，该学哪个？" class="headerlink" title="5.4 编程语言，该学哪个？"></a>5.4 编程语言，该学哪个？</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220310151657860.png" alt="image-20220310151657860" style="zoom: 50%;"></p><p>网传的编程语言鄙视链：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220310151750665.png" alt="image-20220310151750665"></p><ul><li>C语言：万物之源</li></ul><blockquote><ul><li><p>诞生于<code>1972年</code>，由AT&amp;T公司旗下<code>贝尔实验室</code>创建完成，用于构建Unix操作系统。</p></li><li><p>偏向计算机底层操作（操作系统、网络、硬件驱动等）。</p></li><li>优势：几乎所有现代编程语言都脱胎于C</li><li>劣势：相当陡的学习曲线；不支持面向对象编程</li></ul></blockquote><ul><li>C++语言：难学的语言</li></ul><blockquote><ul><li>诞生于1983年，作为C语言的增强方案、<code>升级版本</code>。C++是C语言的超集，C语言的大部分知识也适用于C++。</li><li>用途：windows 或 MacOS UI、office全家桶、主流的浏览器、Oracle、MySQL、著名的游戏引擎（如星际争霸、魔兽世界）等</li><li>优势：很多公司都用 C++ 开发核心架构，如 Google、腾讯、百度、阿里云等；面向对象性</li><li>劣势：体系极为庞大，这是世界目前来说<code>最复杂</code>也是<code>最难</code>的编程语言。</li></ul></blockquote><ul><li>C#语言：背靠大树的语言</li></ul><blockquote><ul><li>诞生于<code>2000年</code>，一款强大而灵活的编程语言。靠着<code>微软</code>这棵大树，是多年来windows平台的一门主流编程语言。</li><li>用途：windows桌面应用开发、Windows Azure、游戏开发</li></ul></blockquote><ul><li>PHP语言：最好的语言？</li></ul><blockquote><ul><li>诞生于1994年，一款<code>服务器端脚本语言</code>。最初表示个人主页（Personal Home Page）</li><li>PHP语法和C类似，有很多的模板和框架，简单易懂，也许你可以在短短几天做出web app。它主要用于web端，快速建站网络开发</li><li>劣势：学习门槛太低；其代码运行速度低于大部分编程语言党争对手</li></ul></blockquote><ul><li>Python：易学的语言</li></ul><blockquote><ul><li>诞生于1991年，一种面向对象的语言，虽然运行效率不高，但是<code>开发效率非常高</code>。</li><li>Python被称为<code>胶水语言</code>，哪里都可以用。</li></ul></blockquote><ul><li>JavaScript语言：前端为王</li></ul><blockquote><ul><li>诞生于1995年，网景公司开发完成。</li><li>JavaScript是JavaScript 是目前<code>所有主流浏览器</code>上唯一支持的脚本语言。在前端开发中，占有不可替代的地位。</li></ul></blockquote><ul><li>Java语言：需求旺盛</li></ul><blockquote><ul><li>创建于1995年，Java是一种面向对象、基于类的编程语言。</li><li>Java可能是目前<code>运用最广的项目语言</code>。代码稳定性超过 C 和 C++，生产力远超 C 和 C++。有 JVM 在，可以轻松地跨平台。</li><li>具有强大的开源开发工具，大量的开源共享库。</li><li>Java拥有世界上<code>数量最多</code>的程序员，最不缺人。</li></ul></blockquote><ul><li>Go语言：夹缝中生存</li></ul><blockquote><ul><li>Go 语言现在很受关注，它是取代 C 和 C++ 的另一门有潜力的语言。<ul><li>C 语言太原始了，C++ 太复杂了，Java 太高级了，所以 Go 语言就在这个夹缝中出现了。</li></ul></li><li>Go语言已成为<code>云计算领域</code>事实上的标准语言，尤其是在 Docker/Kubernetes 等项目中。</li><li>Go 语言语法特别简单，你有了 C 和 C++ 的基础，学习 Go 的学习成本基本为零。</li><li>Go社区从Java社区移植了各种优秀的框架或库。</li></ul></blockquote><p>总结：</p><ul><li>程序设计语言有很多种，每种语言都是为了实现某个特定的目的而发明的。</li><li><strong>没有“最好”的语言</strong>，只有在特定场景下相对来说，最适合的语言而已。</li><li>如果你掌握了一种编程语言，也会更容易上手其它的编程语言。关键是学习如何使用<code>程序设计方法</code>来解决问题。这也是本套课程的主旨。</li><li><code>Talk is cheap，Show me the code</code>。</li></ul><h2 id="6-Java语言概述"><a href="#6-Java语言概述" class="headerlink" title="6. Java语言概述"></a>6. Java语言概述</h2><h3 id="6-1-Java概述"><a href="#6-1-Java概述" class="headerlink" title="6.1 Java概述"></a>6.1 Java概述</h3><ul><li><p>是<code>SUN</code>(Stanford University Network，斯坦福大学网络公司 ) <code>1995年</code>推出的一门高级编程语言。</p></li><li><p>是一种面向Internet的编程语言。Java一开始富有吸引力是因为Java程序可以在<code>Web浏览器</code>中运行。这些Java程序被称为<code>Java小程序</code>（applet），内嵌在HTML代码中。</p></li><li><p>伴随着互联网的迅猛发展，以及Java技术在web方面的不断成熟，已经成为Web应用程序的首选开发语言。</p></li></ul><h3 id="6-2-Java语言简史"><a href="#6-2-Java语言简史" class="headerlink" title="6.2 Java语言简史"></a>6.2 Java语言简史</h3><p><strong>起步阶段：</strong></p><p>1991年，Sun公司的工程师小组想要设计一种语言，应用在<code>电视机</code>、<code>电话</code>、<code>闹钟</code>、<code>烤面包机</code>等家用电器的控制和通信。由于这些设备的<code>处理能力</code>和<code>内存</code>都很有限，并且不同的厂商会选择不同的中央处理器(CPU)，因此这种语言的关键是<code>代码短小</code>、<code>紧凑</code>且<code>与平台无关</code>（即不能与任何特定的体系结构捆绑在一起）。</p><p>Gosling团队率先创造了这个语言，并命名为“<code>Oak</code>“（起名的原因是因为他非常喜欢自己办公室外的橡树)。后因智能化家电的市场需求没有预期的高，Sun公司放弃了该项计划。</p><p>随着20世纪90年代互联网的发展，Sun公司发现该语言在互联网上应用的前景，于是改造了Oak，于1995年5月以Java的名称正式发布。（Java是印度尼西亚<code>爪哇岛</code>的英文名称，因盛产咖啡而闻名。）</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220309230839100.png" alt="image-20220309230839100"></p><p><strong>发展阶段：</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">发行版本</th><th style="text-align:center">发行时间</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">Java 1.0</td><td style="text-align:center">1996.01.23</td><td style="text-align:center">Sun公司发布了Java的第一个开发工具包</td></tr><tr><td style="text-align:center">Java 1.1</td><td style="text-align:center">1997.02.19</td><td style="text-align:center">JavaOne会议召开，创当时全球同类会议规模之最。</td></tr><tr><td style="text-align:center">Java 1.2</td><td style="text-align:center">1998.12.08</td><td style="text-align:center">Java拆分成：J2SE（标准版）、J2EE（企业版）、J2ME（小型版）</td></tr><tr><td style="text-align:center">Java 1.3</td><td style="text-align:center">2000.05.08</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Java1.4</td><td style="text-align:center">2004.02.06</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>Java 5.0</strong></td><td style="text-align:center"><strong>2004.09.30</strong></td><td style="text-align:center"><strong>①版本号从1.4直接更新至5.0；②平台更名为JavaSE、JavaEE、JavaME</strong></td></tr><tr><td style="text-align:center">Java 6.0</td><td style="text-align:center">2006.12.11</td><td style="text-align:center">2009.04.20 Oracle宣布收购SUN公司</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">2009.04.20</td><td style="text-align:center">Oracle公司收购SUN，交易价格<code>74亿</code>美元。</td></tr><tr><td style="text-align:center">Java 7.0</td><td style="text-align:center">2011.07.02</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>Java 8.0</strong></td><td style="text-align:center"><strong>2014.03.18</strong></td><td style="text-align:center"><strong>此版本是继Java 5.0以来变化最大的版本。是长期支持版本（LTS）</strong></td></tr><tr><td style="text-align:center">Java 9.0</td><td style="text-align:center">2017.09.22</td><td style="text-align:center">①此版本开始，<strong>每半年更新一次</strong>；②Java 9.0开始不再支持windows 32位系统</td></tr><tr><td style="text-align:center">Java 10.0</td><td style="text-align:center">2018.03.21</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>Java 11.0</strong></td><td style="text-align:center"><strong>2018.09.25</strong></td><td style="text-align:center"><strong>JDK安装包取消独立JRE安装包，是长期支持版本（LTS）</strong></td></tr><tr><td style="text-align:center">Java 12.0</td><td style="text-align:center">2019.03.19</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>Java17.0</strong></td><td style="text-align:center"><strong>2021.09</strong></td><td style="text-align:center"><strong>发布Java 17.0，版本号也称为21.9，是长期支持版本。</strong></td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Java19.0</td><td style="text-align:center">2022.09</td><td style="text-align:center">发布Java19.0，版本号也称为22.9。</td></tr></tbody></table></div><h3 id="6-3-Java之父"><a href="#6-3-Java之父" class="headerlink" title="6.3 Java之父"></a>6.3 Java之父</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220310152923961.png" alt="image-20220310152923961" style="zoom:67%;"></p><ul><li><code>詹姆斯·高斯林(James Gosling)</code>先生以“Java 技术之父”而闻名于世。他是Java 技术的创始人，他亲手设计了Java语言，并开发了Java编译器和Java虚拟机，使Java成为了世界上最流行的开发语言。</li><li>James Gosling于1984 年加入Sun公司，并一直服务于Sun公司，直至2010年前后，Sun被Oracle并购而加入Oracle，担任客户端软件集团的首席技术官; 2010年4月从Oracle离职。</li></ul><h3 id="6-4-公司八卦"><a href="#6-4-公司八卦" class="headerlink" title="6.4 公司八卦"></a>6.4 公司八卦</h3><ul><li><strong>SUN 与 Oracle</strong></li></ul><blockquote><p>SUN是一家<code>极具创新能力</code>的公司，2001年 “9.11”以前，SUN公司市值<code>超过1000亿</code>美元。 但是没能利用Java构建一个强有力、可变现的生态系统，没打好Java这张牌。此后，互联网泡沫破裂，硬件需求大幅减少，它的市值在一个月之内跌幅超过90%。<strong>SUN公司的成长用了20年，而衰落只用了1年！</strong></p></blockquote><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220309230923533.png" alt="image-20220309230923533" style="zoom: 67%;"></p><ul><li><strong>Oracle 与 Google</strong></li></ul><blockquote><p>Google和Oracle的侵权事件：</p><p>2010 年 8 月，Oracle 起诉 Google 的 Android 系统侵权，要求赔偿 26 亿美元。</p><ul><li>Oracle认为Google的代码中使用了Java的<code>37个API</code>，并且认为Google是故意为之，因为这样做的好处是可以让更多的Java程序员更容易接受Android的代码。</li><li>Oracle认为Android 中有<code>9行代码</code>直接抄袭了Java的实现。这9行牛气哄哄的代码都出自一人之手，他就是Java 大牛———<code>Joshua Bloch</code>。</li></ul><p>2018 年 3 月，美国联邦巡回上诉法院裁决，谷歌侵犯了甲骨文的版权，支付高达<code>88亿美元</code>的赔偿金。</p><p>2021 年 4 月，美国最高法院给出了最终裁决：谷歌胜诉，其代码属于“合理使用”的范畴。为期十多年的软件行业“第一版权案”落幕。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Code In OpenJDK / Android ：</span></span><br><span class="line"><span class="number">1.</span> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rangeCheck</span><span class="params">(<span class="type">int</span> arrayLen, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> &#123;</span><br><span class="line"><span class="number">2.</span>    <span class="keyword">if</span> (fromIndex &gt; toIndex)</span><br><span class="line"><span class="number">3.</span>        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;fromIndex(&quot;</span> + fromIndex +</span><br><span class="line"><span class="number">4.</span>                   <span class="string">&quot;) &gt; toIndex(&quot;</span> + toIndex+<span class="string">&quot;)&quot;</span>);</span><br><span class="line"><span class="number">5.</span>    <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>)</span><br><span class="line"><span class="number">6.</span>        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(fromIndex);</span><br><span class="line"><span class="number">7.</span>    <span class="keyword">if</span> (toIndex &gt; arrayLen)</span><br><span class="line"><span class="number">8.</span>        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(toIndex);</span><br><span class="line"><span class="number">9.</span> &#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20221027145908490.png" alt="image-20221027145908490"></p><h3 id="6-5-Java技术体系平台"><a href="#6-5-Java技术体系平台" class="headerlink" title="6.5 Java技术体系平台"></a>6.5 Java技术体系平台</h3><ul><li><strong>Java SE(Java Standard Edition)标准版</strong><ul><li>支持面向<code>桌面级应用</code>（如Windows下的应用程序）的Java平台，即定位个人计算机的应用开发。</li><li>包括用户界面接口AWT及Swing，网络功能与国际化、图像处理能力以及输入输出支持等。</li><li>此版本以前称为J2SE</li></ul></li><li><strong>Java EE(Java Enterprise Edition)企业版</strong><ul><li>为开发企业环境下的应用程序提供的一套解决方案，即定位<code>在服务器端的Web应用开发</code>。</li><li>JavaEE是JavaSE的扩展，增加了用于服务器开发的类库。如：Servlet能够延伸服务器的功能，通过请求-响应的模式来处理客户端的请求；JSP是一种可以将Java程序代码内嵌在网页内的技术。</li><li>版本以前称为J2EE</li></ul></li><li><strong>Java ME(Java Micro Edition)小型版</strong><ul><li>支持Java程序运行在<code>移动终端（手机、机顶盒）上的平台</code>，即定位在消费性电子产品的应用开发</li><li>JavaME是JavaSE的内伸，精简了JavaSE 的核心类库，同时也提供自己的扩展类。增加了适合微小装置的类库：javax.microedition.io.*等。</li><li>此版本以前称为J2ME</li></ul></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20211218093009884.png" alt="image-20211218093009884"></p><blockquote><p>注意：</p><p>Android开发不等同于Java ME的开发</p></blockquote><h2 id="7-Java开发环境搭建（掌握）"><a href="#7-Java开发环境搭建（掌握）" class="headerlink" title="7. Java开发环境搭建（掌握）"></a>7. Java开发环境搭建（掌握）</h2><h3 id="7-1-什么是JDK、JRE"><a href="#7-1-什么是JDK、JRE" class="headerlink" title="7.1 什么是JDK、JRE"></a>7.1 什么是JDK、JRE</h3><ul><li><strong>JDK</strong>  (<code>J</code>ava <code>D</code>evelopment <code>K</code>it)：是Java程序开发工具包，包含<code>JRE</code> 和开发人员使用的工具。</li><li><strong>JRE </strong> (<code>J</code>ava <code>R</code>untime <code>E</code>nvironment) ：是Java程序的运行时环境，包含<code>JVM</code> 和运行时所需要的<code>核心类库</code>。</li></ul><p>如下是Java 8.0 Platform：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/JDKJRE.jpg" alt></p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220310200731185.png" alt="image-20220310200731185" style="zoom:67%;"></p><blockquote><p>小结：</p><p>JDK = JRE + 开发工具集（例如Javac编译工具等）</p><p>JRE = JVM + Java SE标准类库</p></blockquote><h3 id="7-2-JDK版本选择"><a href="#7-2-JDK版本选择" class="headerlink" title="7.2 JDK版本选择"></a>7.2 JDK版本选择</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20221108221057540.png" alt="image-20221108221057540" style="zoom:80%;"></p><hr><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220310201541841.png" alt="image-20220310201541841"></p><ul><li>自Java 8版本发布以来，其后的每次更新，都会有小伙伴高呼：<strong>Java8 YYDS！</strong></li><li>论坛的声音：“<code>你发任你发，我用Java 8！</code>”</li></ul><p><strong>数据说话1：</strong></p><p>JRebel 于2022年4月前后发布了《2022 年Java生态系统状况报告》，报告中提到使用Java11 的占比最多，Java 8 紧随其后，如下图。而此前2020年的报告显示，Java8占比达到了<code>84.48%</code>。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/d315.jpeg" alt="d315"></p><blockquote><p>我的分析：</p><p>G1是最受欢迎的GC算法。Java 11及更高版本的G1收集器是默认的GC，而Java 8中并不是。出于对G1的喜爱，很多开发者才会选择抛弃Java 8。</p></blockquote><p><strong>数据说话2：</strong></p><p>此外，某美国软件开发商在对近千名专业的Java开发者调研后，发布的《2022年Java开发者生产力报告》称：八年前发布的Java 8依然是Java中应用最广泛的版本，占比 <code>37%</code>，其次是 Java 11，占比<code>29%</code> 。</p><p><strong>高斯林说话：</strong></p><hr><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220428151952049.png" alt="image-20220428151952049" style="zoom: 67%;"></p><p><strong>Spring框架说话：</strong></p><p>在Java 17正式发布之前，Java开发框架Spring率先在官博宣布，Spring Framework 6和Spring Boot 3计划在2022年第四季度实现总体可用性的高端基线：</p><ul><li>Java 17+(来自 Spring Framework 5.3.x 线中的 Java 8-17)</li></ul><ul><li>Jakarta EE 9+（来自Spring框架5.3.x 线中的 Java EE 7-8）</li></ul><p>Spring 官方说明：<code>https://spring.io/blog/2022/01/20/spring-boot-3-0-0-m1-is-now-available</code></p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220527155439683.png" alt="image-20220527155439683"></p><blockquote><p>意味着：springboot3.0 是需要用java17和spring6.0为基础建设。如果从企业选型最新springboot3.0作为架构来说，它搭配jdk17肯定是标配了。</p></blockquote><h3 id="7-3-JDK的下载"><a href="#7-3-JDK的下载" class="headerlink" title="7.3 JDK的下载"></a>7.3 JDK的下载</h3><ul><li>下载网址（Oracle公司官网）：www.oracle.com</li><li>下载步骤：如图所示，在官网底部选择Developers开发者</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/下载1.png" alt="1572254490435"></p><p>（1）在Developers页面中间的技术分类部分，选择<code>Java</code>，单击进入，如图所示：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20211019110551338.png" alt="image-20211019110551338" style="zoom: 50%;"></p><p>（2）这里展示的是最新Java版本，例如Java17。单击<code>Download Java</code>，然后选择具体的版本下载。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20211019110843394.png" alt="image-20211019110843394" style="zoom:80%;"></p><p>（3）选择Download Java按钮后</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20211019111110242.png" alt="image-20211019111110242"></p><p>（4）如果想安装Java8 可以选择如下位置：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20211019111150970.png" alt="image-20211019111150970" style="zoom:80%;"></p><p>（5）选择Accept License Agreement，</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20211019111252989.png" alt="image-20211019111252989" style="zoom:80%;"></p><p>（6）注册或登录后下载：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20211019111922387.png" alt="image-20211019111922387" style="zoom:50%;"></p><p>（7）如果需要安装其它版本，可以选择Java archive：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220801004606762.png" alt="image-20220801004606762" style="zoom: 67%;"></p><p>接着进行选择下载即可：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220801004648997.png" alt="image-20220801004648997" style="zoom:67%;"></p><h3 id="7-4-JDK的安装"><a href="#7-4-JDK的安装" class="headerlink" title="7.4 JDK的安装"></a>7.4 JDK的安装</h3><ul><li>安装说明<ul><li>傻瓜式安装，下一步即可。</li><li><strong>建议：安装路径不要有中文或者空格等特殊符号。</strong></li><li><strong>本套课程会同时安装JDK8 和 JDK17，并以JDK17为默认版本进行讲解。</strong></li></ul></li></ul><ul><li>安装步骤：</li></ul><p>（1）双击<code>jdk-17_windows-x64_bin.exe</code>文件，并单击下一步，如图所示：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220303083718546.png" alt="image-20220303083718546"></p><p>（2）修改安装路径，单击更改，如图所示：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220303083759546.png" alt="image-20220303083759546"></p><p>（3）将安装路径修改为<code>D:\develop_tools\jdk\jdk-17.0.2\</code>，并单击下一步，如图所示：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220303083845794.png" alt="image-20220303083845794"></p><p>（4）稍后几秒，安装完成，如图所示：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220303083905277.png" alt="image-20220303083905277"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220303083931309.png" alt="image-20220303083931309"></p><h3 id="7-5-配置path环境变量"><a href="#7-5-配置path环境变量" class="headerlink" title="7.5 配置path环境变量"></a>7.5 配置path环境变量</h3><h4 id="7-5-1-理解path环境变量"><a href="#7-5-1-理解path环境变量" class="headerlink" title="7.5.1 理解path环境变量"></a>7.5.1 理解path环境变量</h4><p><strong>什么是path环境变量？</strong></p><p>答：window操作系统执行命令时，所要搜寻的路径。</p><p><strong>为什么配置path？</strong></p><p>答：希望在命令行使用javac.exe等工具时，任意目录下都可以找到这个工具所在的目录。</p><p><strong>以JDK为例演示</strong></p><p>我们在<code>C:\Users\songhk</code>目录下使用javac命令，结果如下：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220310223852720.png" alt="image-20220310223852720"></p><p>我们在JDK的安装目录的bin目录下使用javac命令，结果如下：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220607113708022.png" alt="image-20220607113708022" style="zoom:75%;"></p><p>我们不可能每次使用java.exe，javac.exe等工具的时候都进入到JDK的安装目录下，太麻烦了。这时就需要配置path环境变量。</p><h4 id="7-5-2-JDK8配置方案1：只配置path"><a href="#7-5-2-JDK8配置方案1：只配置path" class="headerlink" title="7.5.2 JDK8配置方案1：只配置path"></a>7.5.2 JDK8配置方案1：只配置path</h4><ul><li>步骤：</li></ul><p>（1）打开桌面上的计算机，进入后在左侧找到<code>此电脑</code>，单击鼠标<code>右键</code>，选择<code>属性</code>，如图所示：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220310224844837.png" alt="image-20220310224844837"></p><p>（2）选择<code>高级系统设置</code>，如图所示：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220310224912273.png" alt="image-20220310224912273"></p><p>（3）在<code>高级</code>选项卡，单击<code>环境变量</code>，如图所示：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220310224952745.png" alt="image-20220310224952745"></p><p>（4）在<code>系统变量</code>中，选中<code>Path</code> 环境变量，<code>双击</code>或者<code>点击编辑</code> ,如图所示：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220310225023208.png" alt="image-20220310225023208"></p><p>（5）点击<code>新建</code>，填入<code>D:\develop_tools\jdk\jdk1.8.0_271\bin</code>  ，并将此值<code>上移</code>到变量列表的首位。如图所示：</p><ul><li>编辑模式1：</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220607114102135.png" alt="image-20220607114102135" style="zoom:80%;"></p><ul><li>编辑模式2：（注意，结尾需要有英文模式下的;）</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220929104547925.png" alt="image-20220929104547925"></p><p>（6）环境变量配置完成，<strong>重新开启</strong>DOS命令行，在任意目录下输入<code>javac</code> 或<code>java</code>命令或<code>java -version</code>，运行成功。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220607114432286.png" alt="image-20220607114432286" style="zoom:80%;"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220607114517652.png" alt="image-20220607114517652" style="zoom:90%;"></p><h4 id="7-5-3-JDK8配置方案2：配置JAVA-HOME-path（推荐）"><a href="#7-5-3-JDK8配置方案2：配置JAVA-HOME-path（推荐）" class="headerlink" title="7.5.3 JDK8配置方案2：配置JAVA_HOME+path（推荐）"></a>7.5.3 JDK8配置方案2：配置JAVA_HOME+path（推荐）</h4><ul><li>步骤：</li></ul><p>（1）打开桌面上的计算机，进入后在左侧找到<code>计算机</code>，单击鼠标<code>右键</code>，选择<code>属性</code>，如图所示：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220310224844837.png" alt="image-20220310224844837"></p><p>（2）选择<code>高级系统设置</code>，如图所示：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220310224912273.png" alt="image-20220310224912273"></p><p>（3）在<code>高级</code>选项卡，单击<code>环境变量</code>，如图所示：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220310224952745.png" alt="image-20220310224952745"></p><p>（4）在<code>系统变量</code>中，单击<code>新建</code> ，创建新的环境变量，如图所示：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220310225245208.png" alt="image-20220310225245208" style="zoom:90%;"></p><p>（5）变量名输入<code>JAVA_HOME</code>，变量值输入 <code>D:\develop_tools\jdk\jdk1.8.0_271</code> ，单击<code>确定</code>，如图所示：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220607114800372.png" alt="image-20220607114800372" style="zoom:80%;"></p><p>（6）选中<code>Path</code> 环境变量，<code>双击</code>或者<code>点击编辑</code> ，如图所示：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220310225023208.png" alt="image-20220310225023208"></p><p>（7）在变量值的最前面，键入<code>%JAVA_HOME%\bin</code>。如图所示：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220607114953758.png" alt="image-20220607114953758" style="zoom:80%;"></p><blockquote><p>注意：强烈建议将%JAVA_HOME%\bin声明在path环境变量中所有变量的最前面！</p></blockquote><p>（8）环境变量配置完成，<strong>重启</strong>DOS命令行，在任意目录下输入<code>javac</code> 或<code>java</code>命令或<code>java -version</code>，运行成功。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220607114432286.png" alt="image-20220607114432286" style="zoom:80%;"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220607114517652.png" alt="image-20220607114517652" style="zoom:90%;"></p><blockquote><p>我想说：</p><p>有的书籍、论坛、视频上还提到配置classpath，用于指名class文件识别的路径。其实是没必要的，反而建议大家如果配置了classpath环境变量，要删除。对于初学者，反而不友好。</p></blockquote><p><strong>小结如下：</strong></p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220607115255562.png" alt="image-20220607115255562"></p><h4 id="7-5-4-JDK17配置方案：自动配置"><a href="#7-5-4-JDK17配置方案：自动配置" class="headerlink" title="7.5.4 JDK17配置方案：自动配置"></a>7.5.4 JDK17配置方案：自动配置</h4><p>不管大家有没有提前安装JDK8或其它版本JDK，在我们安装完JDK17之后，理应按JDK8的方式配置path环境变量。但是，我们发现在安装完JDK17以后，配置环境变量之前，执行CMD指令：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220607115700870.png" alt="image-20220607115700870" style="zoom:80%;"></p><p>竟然成功了！而且是17.0.2版本。因为JDK17在安装之后，自动进行了环境变量的配置。如下：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220607115840388.png" alt="image-20220607115840388" style="zoom:80%;"></p><p>这里建议，将JDK17安装的路径，设置为JAVA_HOME，并将<code>%JAVA_HOME%\bin</code>上移到首位。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20221110142710972.png" alt="image-20221110142710972" style="zoom:80%;"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20221110142734279.png" alt="image-20221110142734279" style="zoom:80%;"></p><blockquote><p>思考：如果你仍然希望在JDK8下开发Java程序？如何做呢？</p></blockquote><h2 id="8-开发体验：HelloWorld（掌握）"><a href="#8-开发体验：HelloWorld（掌握）" class="headerlink" title="8. 开发体验：HelloWorld（掌握）"></a>8. 开发体验：HelloWorld（掌握）</h2><p>JDK安装完毕，我们就可以开发第一个Java程序了，习惯性的称为：HelloWorld。</p><h3 id="8-1-开发步骤"><a href="#8-1-开发步骤" class="headerlink" title="8.1 开发步骤"></a>8.1 开发步骤</h3><p>Java程序开发三步骤：<strong>编写</strong>、<strong>编译</strong>、<strong>运行</strong>。</p><ul><li>将 Java 代码<strong>编写</strong>到扩展名为 .java 的源文件中</li><li>通过 javac.exe 命令对该 java 文件进行<strong>编译</strong>，生成一个或多个字节码文件</li><li>通过 java.exe 命令对生成的 class 文件进行<strong>运行</strong></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220310230210728.png" alt="image-20220310230210728"></p><h3 id="8-2-编写"><a href="#8-2-编写" class="headerlink" title="8.2 编写"></a>8.2 编写</h3><p>（1）在<code>D:\JavaSE\chapter01</code> 目录下新建文本文件，完整的文件名修改为<code>HelloWorld.java</code>，其中文件名为<code>HelloWorld</code>，后缀名必须为<code>.java</code>。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220801010222222.png" alt="image-20220801010222222" style="zoom:90%;"></p><p>（2）用记事本或editplus等文本编辑器打开（虽然记事本也可以，但是没有关键字颜色标识，不利于初学者学习）</p><p>（3）在文件中输入如下代码，并且保存：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HelloChina</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;HelloWorld!!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>友情提示1：每个字母和符号必须与示例代码一模一样，包括大小写在内。</strong></p></li><li><p>友情提示2：</p></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220310230618659.png" alt="image-20220310230618659" style="zoom:67%;"></p><p>或</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220521173215013.png" alt="image-20220521173215013" style="zoom:90%;"></p><p>第一个<code>HelloWord</code> 源程序就编写完成了，但是这个文件是程序员编写的，JVM是看不懂的，也就不能运行，因此我们必须将编写好的<code>Java源文件</code> 编译成JVM可以看懂的<code>字节码文件</code> ，也就是<code>.class</code>文件。</p><h3 id="8-3-编译"><a href="#8-3-编译" class="headerlink" title="8.3 编译"></a>8.3 编译</h3><p>在DOS命令行中，进入<code>D:\JavaSE\chapter01</code>目录，使用<code>javac</code> 命令进行编译。</p><p>使用文件资源管理器打开<code>D:\JavaSE\chapter01</code>目录，然后在地址栏输入cmd。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220801010435144.png" alt="image-20220801010435144" style="zoom:80%;"></p><p>命令：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javac Java源文件名.后缀名java</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac HelloWorld.java</span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220801010840640.png" alt="image-20220801010840640" style="zoom:80%;"></p><p>编译成功后，命令行没有任何提示。打开<code>D:\JavaSE\chapter01</code>目录，发现产生了一个新的文件 <code>HelloChina.class</code>，该文件就是编译后的文件，是Java的可运行文件，称为<strong>字节码文件</strong>，有了字节码文件，就可以运行程序了。 </p><h3 id="8-4-运行"><a href="#8-4-运行" class="headerlink" title="8.4 运行"></a>8.4 运行</h3><p>在DOS命令行中，在字节码文件目录下，使用<code>java</code> 命令进行运行。</p><p>命令：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java 主类名字</span><br></pre></td></tr></table></figure><p>主类是指包含main方法的类，main方法是Java程序的入口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java HelloChina</span><br></pre></td></tr></table></figure><blockquote><p>错误演示：</p><p>java HelloChina.class</p></blockquote><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220801011104381.png" alt="image-20220801011104381" style="zoom:80%;"></p><h2 id="9-Java开发工具"><a href="#9-Java开发工具" class="headerlink" title="9. Java开发工具"></a>9. Java开发工具</h2><h3 id="9-1-都有哪些开发Java的工具"><a href="#9-1-都有哪些开发Java的工具" class="headerlink" title="9.1 都有哪些开发Java的工具"></a>9.1 都有哪些开发Java的工具</h3><ul><li>级别一：文本开发工具</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220513185907022.png" alt="image-20220513185907022" style="zoom:50%;"></p><ul><li>级别二：集成开发环境（Integrated Development Environment，IDE）</li></ul><blockquote><p>把代码编写，编译，执行，调试等多种功能综合到一起的开发工具。</p></blockquote><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220513190655773.png" alt="image-20220513190655773" style="zoom:50%;"></p><h3 id="9-2-如何选择"><a href="#9-2-如何选择" class="headerlink" title="9.2 如何选择"></a>9.2 如何选择</h3><p>前期我们先使用文本开发工具，培养<code>代码感</code>，利于公司笔、面试。</p><p>后期我们使用IDE，提供<code>更强大的功能支持</code>。</p><h2 id="10-HelloWorld案例常见错误"><a href="#10-HelloWorld案例常见错误" class="headerlink" title="10. HelloWorld案例常见错误"></a>10. HelloWorld案例常见错误</h2><h3 id="10-1-拼写问题"><a href="#10-1-拼写问题" class="headerlink" title="10.1 拼写问题"></a>10.1 拼写问题</h3><ul><li>单词拼写问题<ul><li>正确：class                 错误：Class</li><li>正确：String                    错误：string</li><li>正确：System                  错误：system</li><li>正确：main                 错误：mian</li></ul></li><li>Java语言是一门严格区分大小写的语言</li><li>标点符号使用问题<ul><li>不能用中文符号，英文半角的标点符号（正确）</li><li>括号问题，成对出现</li></ul></li></ul><h3 id="10-2-编译、运行路径问题"><a href="#10-2-编译、运行路径问题" class="headerlink" title="10.2 编译、运行路径问题"></a>10.2 编译、运行路径问题</h3><p>举例1：</p><p> <img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220310231657692.png" alt="image-20220310231657692" style="zoom:80%;"></p><ul><li>源文件名不存在或者写错</li><li>当前路径错误</li><li>后缀名隐藏问题</li></ul><p>举例2：</p><p> <img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220310231717893.png" alt="image-20220310231717893" style="zoom:80%;"></p><ul><li>类文件名写错，尤其文件名与类名不一致时，要小心</li><li>类文件不在当前路径下，或者不在classpath指定路径下</li></ul><h3 id="10-3-语法问题"><a href="#10-3-语法问题" class="headerlink" title="10.3 语法问题"></a>10.3 语法问题</h3><p>举例1：</p><p> <img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220310231746581.png" alt="image-20220310231746581" style="zoom:90%;"></p><p>声明为public的类应与文件名一致，否知编译失败。</p><p>举例2：</p><p> <img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220310231815405.png" alt="image-20220310231815405" style="zoom:80%;"></p><p>编译失败，注意错误出现的行数，再到源代码中指定位置改错</p><h3 id="10-4-字符编码问题"><a href="#10-4-字符编码问题" class="headerlink" title="10.4 字符编码问题"></a>10.4 字符编码问题</h3><p>当cmd命令行窗口的字符编码与.java源文件的字符编码不一致，如何解决？</p><p> <img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/命令行编译乱码.png" alt="1557881223916"></p><p>解决方案一：</p><ul><li>在Notepad++等编辑器中，修改源文件的字符编码：</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/Notepad修改源文件字符编码.png" alt="1557881271819" style="zoom:80%;"></p><ul><li>在EditPlus中可以将Java源文件另存为ANSI编码方式（中文操作系统下即为GBK字符集）</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/1658810752424.png" alt="1658810752424" style="zoom:80%;"></p><p>解决方案二：</p><pre><code>在使用javac命令式，可以指定源文件的字符编码</code></pre><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">javac -encoding utf-<span class="number">8</span> Review01.java</span><br></pre></td></tr></table></figure><h3 id="10-5-建议"><a href="#10-5-建议" class="headerlink" title="10.5 建议"></a>10.5 建议</h3><ul><li><p>注意缩进!</p><ul><li><p>一定要有缩进。缩进就像人得体的衣着一样！</p></li><li><p>只要遇到{}就缩进，缩进的快捷键tab键。</p></li></ul></li><li><p>必要的空格</p><ul><li>变量类型、变量、赋值符号、变量值之间填充相应空格，更美观。比如： int num = 10;</li></ul></li></ul><h2 id="11-HelloWorld小结"><a href="#11-HelloWorld小结" class="headerlink" title="11. HelloWorld小结"></a>11. HelloWorld小结</h2><h3 id="11-1-Java程序的结构与格式"><a href="#11-1-Java程序的结构与格式" class="headerlink" title="11.1 Java程序的结构与格式"></a>11.1 Java程序的结构与格式</h3><p>结构：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类&#123;</span><br><span class="line">    方法&#123;</span><br><span class="line">        语句;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>格式：</p><p>（1）每一级缩进一个Tab键</p><p>（2）{}的左半部分在行尾，右半部分单独一行，与和它成对的”{“的行首对齐</p><h3 id="11-2-Java程序的入口"><a href="#11-2-Java程序的入口" class="headerlink" title="11.2 Java程序的入口"></a>11.2 Java程序的入口</h3><p>Java程序的入口是main方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-3-两种常见的输出语句"><a href="#11-3-两种常见的输出语句" class="headerlink" title="11.3 两种常见的输出语句"></a>11.3 两种常见的输出语句</h3><ul><li><p><strong>换行输出语句</strong>：输出内容，完毕后进行换行，格式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(输出内容);</span><br></pre></td></tr></table></figure></li><li><p><strong>直接输出语句</strong>：输出内容，完毕后不做任何处理，格式如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.print(输出内容);</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意事项：</p><p>​    换行输出语句，括号内可以什么都不写，只做换行处理</p><p>​    直接输出语句，括号内什么都不写的话，编译报错</p></blockquote><h3 id="11-4-源文件名与类名"><a href="#11-4-源文件名与类名" class="headerlink" title="11.4 源文件名与类名"></a>11.4 源文件名与类名</h3><p>（1）源文件名是否必须与类名一致？public呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">如果这个类不是<span class="keyword">public</span>，那么源文件名可以和类名不一致。但是不便于代码维护。</span><br><span class="line"></span><br><span class="line">如果这个类是<span class="keyword">public</span>，那么要求源文件名必须与类名一致。否则编译报错。</span><br><span class="line"></span><br><span class="line">我们建议大家，不管是否是<span class="keyword">public</span>，都与源文件名保持一致，而且一个源文件尽量只写一个类，目的是为了好维护。</span><br></pre></td></tr></table></figure><p>（2）一个源文件中是否可以有多个类？public呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">一个源文件中可以有多个类，编译后会生成多个.class字节码文件。</span><br><span class="line"></span><br><span class="line">但是一个源文件只能有一个<span class="keyword">public</span>的类。</span><br></pre></td></tr></table></figure><h2 id="12-注释-comment"><a href="#12-注释-comment" class="headerlink" title="12. 注释(comment)"></a>12. 注释(comment)</h2><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220610113151774.png" alt="image-20220610113151774" style="zoom: 67%;"></p><ul><li><p>什么是注释？</p><ul><li>源文件中用于解释、说明程序的文字就是注释。</li></ul></li><li><p>注释是一个程序员必须要具有的良好编程习惯。实际开发中，程序员可以先将自己的<code>思想</code>通过注释整理出来，再用<code>代码</code>去体现。</p><blockquote><p>程序员最讨厌两件事：</p><p>一件是自己写代码被要求加注释</p><p>另一件是接手别人代码，发现没有注释</p></blockquote></li><li><p>不加注释的危害</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/新来的菜鸟程序员闯祸了。。。这段代码好多年都没人敢动过的.gif" alt></p></li><li><p>Java中的注释类型：</p><ul><li><p>单行注释</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//注释文字</span><br></pre></td></tr></table></figure></li><li><p>多行注释</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* </span><br><span class="line">注释文字1 </span><br><span class="line">注释文字2</span><br><span class="line">注释文字3</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li><li><p>文档注释 (Java特有)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">  @author  指定java程序的作者</span><br><span class="line">  @version  指定源文件的版本</span><br><span class="line">*/ </span><br></pre></td></tr></table></figure></li></ul></li><li><p>注释的作用</p><ul><li>它提升了程序的可阅读性。（不加注释的危害性，见图。）</li><li>调试程序的重要方法。</li></ul></li><li><p><strong>具体使用1：单行注释、多行注释</strong></p><ul><li><p>对于单行和多行注释，被注释的文字，不会不会出现在字节码文件中，进而不会被JVM（java虚拟机）解释执行。</p></li><li><p>多行注释里面不允许有多行注释嵌套。</p></li><li><p>一个段子</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A：嘿 <span class="comment">//是什么意思啊？</span></span><br><span class="line">B：嘿.</span><br><span class="line">A：呃 我问你<span class="comment">//是什么意思？</span></span><br><span class="line">B：问吧.</span><br><span class="line">A：我刚才不是问了么？</span><br><span class="line">B：啊？</span><br><span class="line">A：你再看看记录...</span><br><span class="line">B：看完了.</span><br><span class="line">A：......所以<span class="comment">//是啥？</span></span><br><span class="line">B：所以什么？</span><br><span class="line">A：你存心耍我呢吧？</span><br><span class="line">B：没有啊 你想问什么？</span><br><span class="line">……</span><br><span class="line">不断循环之后，A一气之下和B绝交，自己苦学程序。</span><br><span class="line">N年之后，A终于修成正果，回想起B，又把聊天记录翻出来看，这时，他突然发现B没有耍他……</span><br><span class="line">而他自己也不知道当年他问B的究竟是什么问题……</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>具体使用2：文档注释（Java特有）</strong></p><ul><li><p>文档注释内容可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。</p></li><li><p>操作方式。比如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javadoc -d mydoc -author -version HelloWorld.java</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220310232527578.png" alt="image-20220310232527578" style="zoom:67%;"></p><p>案例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单行注释</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">文档注释演示。这是我的第一个Java程序！^_^</span></span><br><span class="line"><span class="comment"><span class="doctag">@author</span> songhk</span></span><br><span class="line"><span class="comment"><span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Java程序的入口</span></span><br><span class="line"><span class="comment"><span class="doctag">@param</span> args main方法的命令参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-Java-API文档"><a href="#13-Java-API文档" class="headerlink" title="13. Java API文档"></a>13. Java API文档</h2><ul><li>API （Application Programming Interface，应用程序编程接口）是 Java 提供的基本编程接口。</li><li>Java语言提供了大量的基础类，因此 Oracle 也为这些基础类提供了相应的说明文档，用于告诉开发者如何使用这些类，以及这些类里包含的方法。大多数Java书籍中的类的介绍都要参照它来完成，它是编程者经常查阅的资料。</li><li>Java API文档，即为JDK使用说明书、帮助文档。类似于：</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/新华字典.jpg" alt="新华字典" style="zoom:28%;"></p><ul><li>下载API文档：<ul><li>在线看：<a href="https://docs.oracle.com/en/java/javase/17/docs/api/index.html">https://docs.oracle.com/en/java/javase/17/docs/api/index.html</a></li><li>离线下载：<a href="https://www.oracle.com/java/technologies/javase-jdk17-doc-downloads.html">https://www.oracle.com/java/technologies/javase-jdk17-doc-downloads.html</a></li></ul></li></ul><h2 id="14-Java核心机制：JVM"><a href="#14-Java核心机制：JVM" class="headerlink" title="14. Java核心机制：JVM"></a>14. Java核心机制：JVM</h2><h3 id="14-1-Java语言的优缺点"><a href="#14-1-Java语言的优缺点" class="headerlink" title="14.1 Java语言的优缺点"></a>14.1 Java语言的优缺点</h3><p>Java确实是从C语言和C++语言继承了许多成份，甚至可以将Java看成是类C语言发展和衍生的产物。“青出于蓝，而胜于蓝”。</p><h4 id="14-1-1-优点"><a href="#14-1-1-优点" class="headerlink" title="14.1.1 优点"></a>14.1.1 优点</h4><ul><li><strong>跨平台性：</strong>这是Java的核心优势。Java在最初设计时就很注重移植和跨平台性。比如：Java的int永远都是32位。不像C++可能是16，32，可能是根据编译器厂商规定的变化。</li><li>通过Java语言编写的应用程序在不同的系统平台上都可以运行。“<code>Write once , Run Anywhere</code>”。</li><li>原理：只要在需要运行 java 应用程序的操作系统上，先安装一个Java虚拟机 (<code>J</code>VM ，Java <code>V</code>irtual <code>M</code>achine) 即可。由JVM来负责Java程序在该系统中的运行。</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/JVM的跨平台性-1666858570703.jpg" alt="JVM的跨平台性" style="zoom:70%;"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20211217111217831.png" alt="image-20211217111217831"></p><ul><li><p><strong>面向对象性：</strong></p><p>面向对象是一种程序设计技术，非常<code>适合大型软件的设计和开发</code>。面向对象编程支持封装、继承、多态等特性，让程序更好达到<code>高内聚</code>，<code>低耦合</code>的标准。</p></li><li><p><strong>健壮性：</strong>吸收了C/C++语言的优点，但去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制。</p></li><li><p><strong>安全性高：</strong></p><p>Java适合于网络/分布式环境，需要提供一个安全机制以防恶意代码的攻击。如：<code>安全防范机制</code>（ClassLoader类加载器），可以分配不同的命名空间以防替代本地的同名类、字节代码检查。</p></li><li><p><strong>简单性：</strong></p><p>Java就是C++语法的<code>简化版</code>，我们也可以将Java称之为“<code>C++--</code>”。比如：头文件，指针运算，结构，联合，操作符重载，虚基类等。</p></li><li><p><strong>高性能：</strong></p><ul><li><p>Java最初发展阶段，总是被人诟病“<code>性能低</code>”；客观上，高级语言运行效率总是低于低级语言的，这个无法避免。Java语言本身发展中通过虚拟机的优化提升了<code>几十倍运行效率</code>。比如，通过JIT(JUST IN TIME)即时编译技术提高运行效率。</p></li><li><p><code>Java低性能的短腿，已经被完全解决了</code>。业界发展上，我们也看到很多C++应用转到Java开发，很多C++程序员转型为Java程序员。</p></li></ul></li></ul><h4 id="14-1-2-缺点"><a href="#14-1-2-缺点" class="headerlink" title="14.1.2 缺点"></a>14.1.2 缺点</h4><ul><li><code>语法过于复杂、严谨</code>，对程序员的约束比较多，与python、php等相比入门较难。但是一旦学会了，就业岗位需求量大，而且<code>薪资待遇节节攀升</code>。</li><li>一般适用于大型网站开发，<code>整个架构会比较重</code>，对于初创公司开发和维护人员的成本比较高（即薪资高），选择用Java语言开发网站或应用系统的需要一定的经济实力。</li><li><code>并非适用于所有领域</code>。比如，Objective C、Swift在iOS设备上就有着无可取代的地位。浏览器中的处理几乎完全由JavaScript掌控。Windows程序通常都用C++或C#编写。Java在服务器端编程和跨平台客户端应用领域则很有优势。</li></ul><h3 id="14-2-JVM功能说明"><a href="#14-2-JVM功能说明" class="headerlink" title="14.2 JVM功能说明"></a>14.2 JVM功能说明</h3><p><strong>JVM</strong>（<code>J</code>ava <code>V</code>irtual <code>M</code>achine ，Java虚拟机）：是一个虚拟的计算机，是Java程序的运行环境。JVM具有指令集并使用不同的存储区域，负责执行指令，管理数据、内存、寄存器。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220310165805739.png" alt="image-20220310165805739" style="zoom:67%;"></p><h4 id="14-2-1-功能1：实现Java程序的跨平台性"><a href="#14-2-1-功能1：实现Java程序的跨平台性" class="headerlink" title="14.2.1 功能1：实现Java程序的跨平台性"></a>14.2.1 功能1：实现Java程序的跨平台性</h4><p>我们编写的Java代码，都运行在<strong>JVM</strong> 之上。正是因为有了JVM，才使得Java程序具备了跨平台性。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220513191856727.png" alt="image-20220513191856727" style="zoom:50%;"></p><p>使用JVM前后对比：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220514151716805.png" alt="image-20220514151716805"></p><h4 id="14-2-2-功能2：自动内存管理-内存分配、内存回收"><a href="#14-2-2-功能2：自动内存管理-内存分配、内存回收" class="headerlink" title="14.2.2 功能2：自动内存管理(内存分配、内存回收)"></a>14.2.2 功能2：自动内存管理(内存分配、内存回收)</h4><ul><li>Java程序在运行过程中，涉及到运算的<code>数据的分配</code>、<code>存储</code>等都由JVM来完成</li><li>Java消除了程序员回收无用内存空间的职责。提供了一种系统级线程跟踪存储空间的分配情况，在内存空间达到相应阈值时，检查并释放可被释放的存储器空间。</li><li>GC的自动回收，提高了内存空间的利用效率，也提高了编程人员的效率，很大程度上<code>减少了</code>因为没有释放空间而导致的<code>内存泄漏</code>。</li></ul><blockquote><p>面试题：</p><p>Java程序还会出现内存溢出和内存泄漏问题吗？  Yes!</p></blockquote><h2 id="15-章节案例"><a href="#15-章节案例" class="headerlink" title="15. 章节案例"></a>15. 章节案例</h2><p><strong>案例1：个人信息输出</strong></p><p> <img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220315221336038.png" alt="image-20220315221336038"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Exercise1</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;姓名：康师傅&quot;</span>);</span><br><span class="line">System.out.println();<span class="comment">//换行操作</span></span><br><span class="line">System.out.println(<span class="string">&quot;性别：男&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;家庭住址：北京程序员聚集地：回龙观&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例2：输出：心形</strong> </p><p>结合\n(换行)，\t(制表符)，空格等在控制台打印出如下图所示的效果。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/image-20220309004152219-1646757896991.png" alt="image-20220309004152219"> </p><p>方式一：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Exercise2</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"><span class="comment">//System.out.print(&quot;\t&quot;);</span></span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;I love java&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;    &quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Exercise3</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;*&quot;</span>+<span class="string">&quot;\t\t\t\t\t\t\t\t\t\t\t\t&quot;</span>+<span class="string">&quot;*&quot;</span>+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;*&quot;</span>+<span class="string">&quot;\t\t&quot;</span>+<span class="string">&quot;*&quot;</span>+<span class="string">&quot;\t\t\t\t&quot;</span>+<span class="string">&quot;I love Java&quot;</span>+<span class="string">&quot;\t\t\t\t&quot;</span>+<span class="string">&quot;*&quot;</span>+<span class="string">&quot;\t\t\t&quot;</span>+<span class="string">&quot;*&quot;</span>+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;*&quot;</span>+<span class="string">&quot;\t\t\t\t\t\t\t\t\t\t\t\t&quot;</span>+<span class="string">&quot;*&quot;</span>+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t\t&quot;</span>+<span class="string">&quot;*&quot;</span>+<span class="string">&quot;\t\t\t\t\t\t\t\t\t\t&quot;</span>+<span class="string">&quot;*&quot;</span>+<span class="string">&quot;\t\t&quot;</span>+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t\t\t&quot;</span>+<span class="string">&quot;*&quot;</span>+<span class="string">&quot;\t\t\t\t\t\t\t\t&quot;</span>+<span class="string">&quot;*&quot;</span>+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t\t\t\t&quot;</span>+<span class="string">&quot;*&quot;</span>+<span class="string">&quot;\t\t\t\t\t\t&quot;</span>+<span class="string">&quot;*&quot;</span>+<span class="string">&quot;&quot;</span>+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t\t\t\t\t&quot;</span>+<span class="string">&quot;*&quot;</span>+<span class="string">&quot;\t\t\t\t&quot;</span>+<span class="string">&quot;*&quot;</span>+<span class="string">&quot;&quot;</span>+<span class="string">&quot;\t\t&quot;</span>+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t\t\t\t\t\t&quot;</span>+<span class="string">&quot;*&quot;</span>+<span class="string">&quot;\t\t&quot;</span>+<span class="string">&quot;*&quot;</span>+<span class="string">&quot;&quot;</span>+<span class="string">&quot;\t\t&quot;</span>+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\t\t\t\t\t\t\t&quot;</span>+<span class="string">&quot;*&quot;</span>+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第01章-Java语言概述&quot;&gt;&lt;a href=&quot;#第01章-Java语言概述&quot; class=&quot;headerlink&quot; title=&quot;第01章_Java语言概述&quot;&gt;&lt;/a&gt;第01章_Java语言概述&lt;/h1&gt;&lt;p&gt;讲师：尚硅谷-宋红康（江湖人称：康师傅）&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Java2023" scheme="http://example.com/categories/Java2023/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第02章_变量与运算符</title>
    <link href="http://example.com/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://example.com/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
    <published>2023-02-18T12:37:01.000Z</published>
    <updated>2023-02-19T07:46:49.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第02章-变量与运算符"><a href="#第02章-变量与运算符" class="headerlink" title="第02章_变量与运算符"></a>第02章_变量与运算符</h1><p>讲师：尚硅谷-宋红康（江湖人称：康师傅）</p><p>官网：<a href="http://www.atguigu.com/">http://www.atguigu.com</a></p><hr><h2 id="本章专题与脉络"><a href="#本章专题与脉络" class="headerlink" title="本章专题与脉络"></a>本章专题与脉络</h2><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/第1阶段：Java基本语法-第02章.png" alt="第1阶段：Java基本语法-第02章" style="zoom:40%;"></p><h2 id="1-关键字（keyword）"><a href="#1-关键字（keyword）" class="headerlink" title="1. 关键字（keyword）"></a>1. 关键字（keyword）</h2><ul><li>定义：<strong>被Java语言赋予了特殊含义，用做专门用途的字符串（或单词）</strong><ul><li>HelloWorld案例中，出现的关键字有 <code>class</code>、<code>public</code>  、 <code>static</code> 、  <code>void</code>  等，这些单词已经被Java定义好了。</li></ul></li><li>特点：全部关键字都是<code>小写字母</code>。</li><li>关键字比较多，不需要死记硬背，学到哪里记到哪里即可。</li><li>官方地址： <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html">https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html</a></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20220310234414849.png" alt="image-20220310234414849"></p><blockquote><p> 说明：</p><ol><li>关键字一共<code>50个</code>，其中<code>const</code>和<code>goto</code>是<code>保留字</code>(reserved word)。</li><li><code>true</code>，<code>false</code>，<code>null</code>不在其中，它们看起来像关键字，其实是字面量，表示特殊的布尔值和空值。</li></ol></blockquote><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20220310234557454.png" alt="image-20220310234557454" style="zoom: 67%;"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20220801143635356.png" alt="image-20220801143635356" style="zoom:66%;"></p><h2 id="2-标识符-identifier"><a href="#2-标识符-identifier" class="headerlink" title="2. 标识符( identifier)"></a>2. 标识符( identifier)</h2><p>Java中变量、方法、类等要素命名时使用的字符序列，称为标识符。</p><p>技巧：凡是自己可以起名字的地方都叫标识符。</p><p><strong>标识符的命名规则</strong>（必须遵守的<code>硬性规定</code>）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 由26个英文字母大小写，0-9 ，_或 $ 组成  </span><br><span class="line">&gt; 数字不可以开头。</span><br><span class="line">&gt; 不可以使用关键字和保留字，但能包含关键字和保留字。</span><br><span class="line">&gt; Java中严格区分大小写，长度无限制。</span><br><span class="line">&gt; 标识符不能包含空格。</span><br></pre></td></tr></table></figure><blockquote><p>练习：miles、Test、a++、 —a、4#R、$4、 #44、apps、class、public、int、x、y、radius</p></blockquote><p><strong>标识符的命名规范</strong>（建议遵守的<code>软性要求</code>，否则工作时容易被鄙视）:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 包名：多单词组成时所有字母都小写：xxxyyyzzz。</span><br><span class="line">  例如：java.lang、com.atguigu.bean</span><br><span class="line">  </span><br><span class="line">&gt; 类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz</span><br><span class="line">  例如：HelloWorld，String，System等</span><br><span class="line">  </span><br><span class="line">&gt; 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz</span><br><span class="line">  例如：age,name,bookName,main,binarySearch,getName</span><br><span class="line">  </span><br><span class="line">&gt; 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ</span><br><span class="line">  例如：MAX_VALUE,PI,DEFAULT_CAPACITY</span><br></pre></td></tr></table></figure><p>注意：在起名字时，为了提高阅读性，要尽量有意义，“见名知意”。</p><blockquote><p>更多细节详见《代码整洁之道_关于标识符.txt》《阿里巴巴Java开发手册-1.7.1-黄山版》</p></blockquote><h2 id="3-变量"><a href="#3-变量" class="headerlink" title="3. 变量"></a>3. 变量</h2><h3 id="3-1-为什么需要变量"><a href="#3-1-为什么需要变量" class="headerlink" title="3.1 为什么需要变量"></a>3.1 为什么需要变量</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20220513235020527.png" alt="image-20220513235020527"></p><p>一花一世界，如果把一个程序看做一个世界或一个社会的话，那么变量就是程序世界的花花草草、万事万物。即，<strong>变量是程序中不可或缺的组成单位，最基本的存储单元</strong>。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20220513235828042.png" alt="image-20220513235828042"></p><h3 id="3-2-初识变量"><a href="#3-2-初识变量" class="headerlink" title="3.2 初识变量"></a>3.2 初识变量</h3><ul><li><p>变量的概念：</p><ul><li><p>内存中的一个存储区域，该区域的数据可以在同一类型范围内不断变化</p></li><li><p>变量的构成包含三个要素：<code>数据类型</code>、<code>变量名</code>、<code>存储的值</code></p></li><li><p>Java中变量声明的格式：<code>数据类型 变量名 = 变量值</code></p><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20220311000744867.png" alt="image-20220311000744867" style="zoom:67%;"></p></li></ul></li><li><p>变量的作用：用于在内存中保存数据。</p></li><li><p>使用变量注意：</p><ul><li>Java中每个变量必须先声明，后使用。</li><li>使用变量名来访问这块区域的数据。</li><li>变量的作用域：其定义所在的一对{ }内。</li><li>变量只有在其<code>作用域</code>内才有效。出了作用域，变量不可以再被调用。</li><li>同一个作用域内，不能定义重名的变量。</li></ul></li></ul><h3 id="3-3-Java中变量的数据类型"><a href="#3-3-Java中变量的数据类型" class="headerlink" title="3.3 Java中变量的数据类型"></a>3.3 Java中变量的数据类型</h3><p>Java中变量的数据类型分为两大类：</p><ul><li><p><strong>基本数据类型</strong>：包括 <code>整数类型</code>、<code>浮点数类型</code>、<code>字符类型</code>、<code>布尔类型</code>。 </p></li><li><p><strong>引用数据类型</strong>：包括<code>数组</code>、 <code>类</code>、<code>接口</code>、<code>枚举</code>、<code>注解</code>、<code>记录</code>。 </p><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/Java的数据类型.png" alt="Java的数据类型"></p></li></ul><h3 id="3-4-变量的使用"><a href="#3-4-变量的使用" class="headerlink" title="3.4 变量的使用"></a>3.4 变量的使用</h3><h4 id="3-4-1-步骤1：变量的声明"><a href="#3-4-1-步骤1：变量的声明" class="headerlink" title="3.4.1 步骤1：变量的声明"></a>3.4.1 步骤1：变量的声明</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：数据类型  变量名;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="comment">//存储一个整数类型的年龄</span></span><br><span class="line"><span class="type">int</span> age; </span><br><span class="line"></span><br><span class="line"><span class="comment">//存储一个小数类型的体重</span></span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储一个单字符类型的性别 </span></span><br><span class="line"><span class="type">char</span> gender;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储一个布尔类型的婚姻状态</span></span><br><span class="line"><span class="type">boolean</span> marry;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储一个字符串类型的姓名</span></span><br><span class="line">String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明多个同类型的变量</span></span><br><span class="line"><span class="type">int</span> a,b,c; <span class="comment">//表示a,b,c三个变量都是int类型。</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：变量的数据类型可以是基本数据类型，也可以是引用数据类型。</p></blockquote><h4 id="3-4-2-步骤2：变量的赋值"><a href="#3-4-2-步骤2：变量的赋值" class="headerlink" title="3.4.2 步骤2：变量的赋值"></a>3.4.2 步骤2：变量的赋值</h4><p>给变量赋值，就是把“值”存到该变量代表的内存空间中。同时，给变量赋的值类型必须与变量声明的类型一致或兼容。</p><p><strong>变量赋值的语法格式：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">变量名 = 值;</span><br></pre></td></tr></table></figure><p>举例1：可以使用合适类型的<code>常量值</code>给已经声明的变量赋值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">age = <span class="number">18</span>;</span><br><span class="line">weight = <span class="number">109</span>;</span><br><span class="line">gender = <span class="string">&#x27;女&#x27;</span>;</span><br></pre></td></tr></table></figure><p>举例2：可以使用其他<code>变量</code>或者<code>表达式</code>给变量赋值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> m;</span><br><span class="line">        </span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">2</span> * x + y;</span><br></pre></td></tr></table></figure><p>3：变量可以反复赋值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先声明，后初始化</span></span><br><span class="line"><span class="type">char</span> gender;</span><br><span class="line">gender = <span class="string">&#x27;女&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给变量重新赋值，修改gender变量的值</span></span><br><span class="line">gender = <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;gender = &quot;</span> + gender);<span class="comment">//gender = 男</span></span><br></pre></td></tr></table></figure><p>举例4：也可以将变量的声明和赋值一并执行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isBeauty</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;迪丽热巴&quot;</span>;</span><br></pre></td></tr></table></figure><p>内存结构如图：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20220514152216148.png" alt="image-20220514152216148" style="zoom: 80%;"></p><h2 id="4-基本数据类型介绍"><a href="#4-基本数据类型介绍" class="headerlink" title="4. 基本数据类型介绍"></a>4. 基本数据类型介绍</h2><h3 id="4-1-整数类型：byte、short、int、long"><a href="#4-1-整数类型：byte、short、int、long" class="headerlink" title="4.1 整数类型：byte、short、int、long"></a>4.1 整数类型：byte、short、int、long</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20220520111756274.png" alt="image-20220520111756274" style="zoom: 50%;"></p><ul><li>Java各整数类型有固定的表数范围和字段长度，不受具体操作系统的影响，以保证Java程序的可移植性。</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20220311001553945.png" alt="image-20220311001553945" style="zoom:80%;"></p><ul><li><p>定义long类型的变量，赋值时需要以”<code>l</code>“或”<code>L</code>“作为后缀。</p></li><li><p>Java程序中变量通常声明为int型，除非不足以表示较大的数，才使用long。</p></li><li><p>Java的整型<code>常量默认为 int 型</code>。</p></li></ul><h4 id="4-1-1-补充：计算机存储单位"><a href="#4-1-1-补充：计算机存储单位" class="headerlink" title="4.1.1 补充：计算机存储单位"></a>4.1.1 补充：计算机存储单位</h4><ul><li><p><strong>字节（Byte）：</strong>是计算机用于<code>计量存储容量</code>的<code>基本</code>单位，一个字节等于8 bit。</p></li><li><p><strong>位（bit）：</strong>是数据存储的<code>最小</code>单位。二进制数系统中，每个0或1就是一个位，叫做bit（比特），其中8 bit 就称为一个字节(Byte)。</p></li><li><p><strong>转换关系：</strong></p><ul><li>8 bit = 1 Byte</li><li>1024 Byte = 1 KB</li><li>1024 KB = 1 MB</li><li>1024 MB = 1 GB</li><li>1024 GB = 1 TB</li></ul></li></ul><h3 id="4-2-浮点类型：float、double"><a href="#4-2-浮点类型：float、double" class="headerlink" title="4.2 浮点类型：float、double"></a>4.2 浮点类型：float、double</h3><ul><li>与整数类型类似，Java 浮点类型也有固定的表数范围和字段长度，不受具体操作系统的影响。</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20220311001749699.png" alt="image-20220311001749699" style="zoom:80%;"></p><ul><li>浮点型常量有两种表示形式：<ul><li>十进制数形式。如：5.12       512.0f        .512   (必须有小数点）</li><li>科学计数法形式。如：5.12e2      512E2     100E-2</li></ul></li><li>float：<code>单精度</code>，尾数可以精确到7位有效数字。很多情况下，精度很难满足需求。    </li><li>double：<code>双精度</code>，精度是float的两倍。通常采用此类型。</li><li>定义float类型的变量，赋值时需要以”<code>f</code>“或”<code>F</code>“作为后缀。</li><li>Java 的浮点型<code>常量默认为double型</code>。</li></ul><h4 id="4-2-1-关于浮点型精度的说明"><a href="#4-2-1-关于浮点型精度的说明" class="headerlink" title="4.2.1 关于浮点型精度的说明"></a>4.2.1 关于浮点型精度的说明</h4><ul><li><p>并不是所有的小数都能可以精确的用二进制浮点数表示。二进制浮点数不能精确的表示0.1、0.01、0.001这样10的负次幂。</p></li><li><p>浮点类型float、double的数据不适合在<code>不容许舍入误差</code>的金融计算领域。如果需要<code>精确</code>数字计算或保留指定位数的精度，需要使用<code>BigDecimal类</code>。</p></li><li><p>测试用例：</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试1：（解释见章末企业真题：为什么0.1 + 0.2不等于0.3）</span></span><br><span class="line">System.out.println(<span class="number">0.1</span> + <span class="number">0.2</span>);<span class="comment">//0.30000000000000004</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试2：</span></span><br><span class="line"><span class="type">float</span> <span class="variable">ff1</span> <span class="operator">=</span> <span class="number">123123123f</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">ff2</span> <span class="operator">=</span> ff1 + <span class="number">1</span>;</span><br><span class="line">System.out.println(ff1);</span><br><span class="line">System.out.println(ff2);</span><br><span class="line">System.out.println(ff1 == ff2);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-2-2-应用举例"><a href="#4-2-2-应用举例" class="headerlink" title="4.2.2 应用举例"></a>4.2.2 应用举例</h4><p>案例1：定义圆周率并赋值为3.14，现有3个圆的半径分别为1.2、2.5、6，求它们的面积。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 12:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exercise1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14</span>; <span class="comment">//圆周率</span></span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">radius1</span> <span class="operator">=</span> <span class="number">1.2</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">radius2</span> <span class="operator">=</span> <span class="number">2.5</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">radius3</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;第1个圆的面积：&quot;</span> + PI * radius1 * radius1);</span><br><span class="line">        System.out.println(<span class="string">&quot;第2个圆的面积：&quot;</span> + PI * radius2 * radius2);</span><br><span class="line">        System.out.println(<span class="string">&quot;第3个圆的面积：&quot;</span> + PI * radius3 * radius3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例2：小明要到美国旅游，可是那里的温度是以华氏度为单位记录的。<br>它需要一个程序将华氏温度（80度）转换为摄氏度，并以华氏度和摄氏度为单位分别显示该温度。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">℃ = (℉ - 32) / 1.8</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 12:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exercise2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">hua</span> <span class="operator">=</span> <span class="number">80</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">she</span> <span class="operator">=</span> (hua-<span class="number">32</span>)/<span class="number">1.8</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;华氏度&quot;</span> + hua+<span class="string">&quot;℉转为摄氏度是&quot;</span> +she+<span class="string">&quot;℃&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-字符类型：char"><a href="#4-3-字符类型：char" class="headerlink" title="4.3 字符类型：char"></a>4.3 字符类型：char</h3><ul><li><p>char 型数据用来表示通常意义上“<code>字符</code>”（占2字节）</p></li><li><p>Java中的所有字符都使用Unicode编码，故一个字符可以存储一个字母，一个汉字，或其他书面语的一个字符。</p></li><li><p>字符型变量的三种表现形式：</p><ul><li><p><strong>形式1：</strong>使用单引号(‘ ‘)括起来的<code>单个字符</code>。</p><p>例如：char c1 = ‘a’;   char c2 = ‘中’; char c3 =  ‘9’;</p></li><li><p><strong>形式2：</strong>直接使用 <code>Unicode值</code>来表示字符型常量：‘<code>\uXXXX</code>’。其中，XXXX代表一个十六进制整数。</p><p>例如：\u0023 表示 ‘#’。</p></li><li><p><strong>形式3：</strong>Java中还允许使用<code>转义字符‘\’</code>来将其后的字符转变为特殊字符型常量。</p><p>例如：char c3 = ‘\n’;  // ‘\n’表示换行符</p></li></ul><p>| 转义字符 |  说明  | Unicode表示方式 |<br>| :———: | :——: | :——————-: |<br>|   <code>\n</code>   | 换行符 |     \u000a      |<br>|   <code>\t</code>   | 制表符 |     \u0009      |<br>|   <code>\&quot;</code>   | 双引号 |     \u0022      |<br>|   <code>\&#39;</code>   | 单引号 |     \u0027      |<br>|   <code>\\</code>   | 反斜线 |     \u005c      |<br>|   <code>\b</code>   | 退格符 |     \u0008      |<br>|   <code>\r</code>   | 回车符 |     \u000d      |</p></li><li><p>char类型是可以进行运算的。因为它都对应有Unicode码，可以看做是一个数值。</p></li></ul><h3 id="4-4-布尔类型：boolean"><a href="#4-4-布尔类型：boolean" class="headerlink" title="4.4 布尔类型：boolean"></a>4.4 布尔类型：boolean</h3><ul><li><p>boolean 类型用来判断逻辑条件，一般用于流程控制语句中：</p><ul><li>if条件控制语句；                  </li><li>while循环控制语句；     </li><li>for循环控制语句；</li><li>do-while循环控制语句； </li></ul></li><li><p><strong>boolean类型数据只有两个值：true、false，无其它。</strong></p><ul><li>不可以使用0或非 0 的整数替代false和true，这点和C语言不同。</li><li>拓展：Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达所操作的boolean值，在编译之后都使用java虚拟机中的int数据类型来代替：true用1表示，false用0表示。——《java虚拟机规范 8版》</li></ul></li><li>举例：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isFlag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(isFlag)&#123;</span><br><span class="line">    <span class="comment">//true分支</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">    <span class="comment">//false分支</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>经验之谈：</p><p>Less is More！建议不要这样写：if ( isFlag = = true )，只有新手才如此。关键也很容易写错成if(isFlag = true)，这样就变成赋值isFlag为true而不是判断！<code>老鸟的写法</code>是if (isFlag)或者if ( !isFlag)。</p></blockquote><h2 id="5-基本数据类型变量间运算规则"><a href="#5-基本数据类型变量间运算规则" class="headerlink" title="5. 基本数据类型变量间运算规则"></a>5. 基本数据类型变量间运算规则</h2><p>在Java程序中，不同的基本数据类型（只有7种，不包含boolean类型）变量的值经常需要进行相互转换。</p><p>转换的方式有两种：<code>自动类型提升</code>和<code>强制类型转换</code>。</p><h3 id="5-1-自动类型提升"><a href="#5-1-自动类型提升" class="headerlink" title="5.1 自动类型提升"></a>5.1 自动类型提升</h3><p><strong>规则：将取值范围小（或容量小）的类型自动提升为取值范围大（或容量大）的类型 。</strong></p><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20220523162200891.png" alt="image-20220523162200891" style="zoom:67%;"></p><p>基本数据类型的转换规则如图所示：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20220311002543688.png" alt="image-20220311002543688"></p><p>（1）当把存储范围小的值（常量值、变量的值、表达式计算的结果值）赋值给了存储范围大的变量时</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;<span class="comment">//char自动升级为int，其实就是把字符的编码值赋值给i变量了</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//int自动升级为double</span></span><br><span class="line"><span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1234567</span>; <span class="comment">//右边的整数常量值如果在int范围呢，编译和运行都可以通过，这里涉及到数据类型转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//byte bigB = 130;//错误，右边的整数常量值超过byte范围</span></span><br><span class="line"><span class="type">long</span> <span class="variable">bigNum</span> <span class="operator">=</span> <span class="number">12345678912L</span>;<span class="comment">//右边的整数常量值如果超过int范围，必须加L，显式表示long类型。否则编译不通过</span></span><br></pre></td></tr></table></figure><p>（2）当存储范围小的数据类型与存储范围大的数据类型变量一起混合运算时，会按照其中最大的类型运算。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> i + b + d;<span class="comment">//混合运算，升级为double</span></span><br></pre></td></tr></table></figure><p>（3）当byte,short,char数据类型的变量进行算术运算时，按照int类型处理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b3</span> <span class="operator">=</span> b1 + b2;<span class="comment">//编译报错，b1 + b2自动升级为int</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> c1 + c2;<span class="comment">//至少需要使用int类型来接收</span></span><br><span class="line">System.out.println(c1 + c2);<span class="comment">//113 </span></span><br></pre></td></tr></table></figure><p><strong>练习：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设 x 为float型变量，y为double型变量，a为int型变量，b为long型变量，c为char型变量，则表达式</span><br><span class="line">x + y * a / x + b / y + c的值类型为：</span><br><span class="line"></span><br><span class="line">A. int   B. long  C. double  D. char</span><br></pre></td></tr></table></figure><h3 id="5-2-强制类型转换"><a href="#5-2-强制类型转换" class="headerlink" title="5.2 强制类型转换"></a>5.2 强制类型转换</h3><p>将<code>3.14</code> 赋值到<code>int</code> 类型变量会发生什么？产生编译失败，肯定无法赋值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3.14</span>; <span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure><p>想要赋值成功，只有通过<code>强制类型转换</code>，将<code>double</code> 类型强制转换成<code>int</code> 类型才能赋值。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20220523162407722.png" alt="image-20220523162407722" style="zoom:67%;"></p><p><strong>规则：将取值范围大（或容量大）的类型强制转换成取值范围小（或容量小）的类型。</strong></p><blockquote><p>自动类型提升是Java自动执行的，而强制类型转换是自动类型提升的逆运算，需要我们自己手动执行。</p></blockquote><p><strong>转换格式：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型<span class="number">1</span> 变量名 = (数据类型<span class="number">1</span>)被强转数据值;  <span class="comment">//()中的数据类型必须&lt;=变量值的数据类型</span></span><br></pre></td></tr></table></figure><p>（1）当把存储范围大的值（常量值、变量的值、表达式计算的结果值）强制转换为存储范围小的变量时，可能会<code>损失精度</code>或<code>溢出</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">3.14</span>;<span class="comment">//损失精度</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1.2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">int</span>)d;<span class="comment">//损失精度</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>)i;<span class="comment">//溢出</span></span><br></pre></td></tr></table></figure><p>（2）当某个值想要提升数据类型时，也可以使用强制类型转换。这种情况的强制类型转换是<code>没有风险</code>的，通常省略。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">bigger</span> <span class="operator">=</span> (<span class="type">double</span>)(i/j);</span><br></pre></td></tr></table></figure><p>（3）声明long类型变量时，可以出现省略后缀的情况。float则不同。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="number">123L</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="number">123</span>;<span class="comment">//如何理解呢？ 此时可以看做是int类型的123自动类型提升为long类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//long l3 = 123123123123; //报错，因为123123123123超出了int的范围。</span></span><br><span class="line"><span class="type">long</span> <span class="variable">l4</span> <span class="operator">=</span> <span class="number">123123123123L</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//float f1 = 12.3; //报错，因为12.3看做是double，不能自动转换为float类型</span></span><br><span class="line"><span class="type">float</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="number">12.3F</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">f3</span> <span class="operator">=</span> (<span class="type">float</span>)<span class="number">12.3</span>;</span><br></pre></td></tr></table></figure><p><strong>练习：判断是否能通过编译</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）<span class="type">short</span>  <span class="variable">s</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">   s = s-<span class="number">2</span>;                     <span class="comment">//判断：no</span></span><br><span class="line"><span class="number">2</span>） <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    b = b + <span class="number">4</span>;                  <span class="comment">//判断：no</span></span><br><span class="line">    b = (<span class="type">byte</span>)(b+<span class="number">4</span>);            <span class="comment">//判断：yes</span></span><br><span class="line"><span class="number">3</span>）<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> ‘a’;</span><br><span class="line">   <span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">   <span class="type">float</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">.314F</span>;</span><br><span class="line">   <span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> c+i+d;       <span class="comment">//判断：yes</span></span><br><span class="line"><span class="number">4</span>） <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="type">short</span> <span class="variable">t</span> <span class="operator">=</span> s + b;            <span class="comment">//判断：no</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>问答：为什么标识符的声明规则里要求不能数字开头？</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果允许数字开头，则如下的声明编译就可以通过：</span></span><br><span class="line"><span class="type">int</span> <span class="number">123L</span> = <span class="number">12</span>;</span><br><span class="line"><span class="comment">//进而，如下的声明中l的值到底是123？还是变量123L对应的取值12呢？ 出现歧义了。</span></span><br><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">123L</span>;</span><br></pre></td></tr></table></figure><h3 id="5-3-基本数据类型与String的运算"><a href="#5-3-基本数据类型与String的运算" class="headerlink" title="5.3 基本数据类型与String的运算"></a>5.3 基本数据类型与String的运算</h3><h4 id="5-3-1-字符串类型：String"><a href="#5-3-1-字符串类型：String" class="headerlink" title="5.3.1 字符串类型：String"></a>5.3.1 字符串类型：String</h4><ul><li>String不是基本数据类型，属于引用数据类型</li><li>使用一对<code>&quot;&quot;</code>来表示一个字符串，内部可以包含0个、1个或多个字符。</li><li>声明方式与基本数据类型类似。例如：String str = “尚硅谷”;</li></ul><h4 id="5-3-2-运算规则"><a href="#5-3-2-运算规则" class="headerlink" title="5.3.2 运算规则"></a>5.3.2 运算规则</h4><p>1、任意八种基本数据类型的数据与String类型只能进行连接“+”运算，且结果一定也是String类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;&quot;</span> + <span class="number">1</span> + <span class="number">2</span>);<span class="comment">//12</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1 + num + b1;</span><br><span class="line">System.out.println(s2);<span class="comment">//abc10true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//String s3 = num + b1 + s1;//编译不通过，因为int类型不能与boolean运算</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> num + (b1 + s1);<span class="comment">//编译通过</span></span><br></pre></td></tr></table></figure><p>2、String类型不能通过强制类型()转换，转为其他的类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">int</span>)str;<span class="comment">//错误的</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(str);<span class="comment">//正确的，后面才能讲到，借助包装类的方法才能转</span></span><br></pre></td></tr></table></figure><h4 id="5-3-3-案例与练习"><a href="#5-3-3-案例与练习" class="headerlink" title="5.3.3 案例与练习"></a>5.3.3 案例与练习</h4><p><strong>案例：公安局身份登记</strong></p><p>要求填写自己的姓名、年龄、性别、体重、婚姻状况（已婚用true表示，单身用false表示）、联系方式等等。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 12:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;康师傅&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">37</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">gender</span> <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">weight</span> <span class="operator">=</span> <span class="number">145.6</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isMarried</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">phoneNumber</span> <span class="operator">=</span> <span class="string">&quot;13112341234&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + name);</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span> + age);</span><br><span class="line">        System.out.println(<span class="string">&quot;性别：&quot;</span> + gender);</span><br><span class="line">        System.out.println(<span class="string">&quot;体重：&quot;</span> + weight);</span><br><span class="line">        System.out.println(<span class="string">&quot;婚否：&quot;</span> + isMarried);</span><br><span class="line">        System.out.println(<span class="string">&quot;电话：&quot;</span> + phoneNumber);</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;,age = &quot;</span> + age + <span class="string">&quot;，gender = &quot;</span> + </span><br><span class="line">                           gender + <span class="string">&quot;,weight = &quot;</span> + weight + <span class="string">&quot;,isMarried = &quot;</span> + isMarried +</span><br><span class="line">                           <span class="string">&quot;,phoneNumber = &quot;</span> + phoneNumber);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习：</strong></p><p>练习1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="number">4</span>;                       <span class="comment">//判断对错：</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="number">3.5f</span> + <span class="string">&quot;&quot;</span>;               <span class="comment">//判断str2对错：</span></span><br><span class="line">System.out.println(str2);              <span class="comment">//输出：</span></span><br><span class="line">System.out .println(<span class="number">3</span>+<span class="number">4</span>+<span class="string">&quot;Hello!&quot;</span>);     <span class="comment">//输出：</span></span><br><span class="line">System.out.println(<span class="string">&quot;Hello!&quot;</span>+<span class="number">3</span>+<span class="number">4</span>);      <span class="comment">//输出：</span></span><br><span class="line">System.out.println(<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>+<span class="string">&quot;Hello!&quot;</span>);    <span class="comment">//输出：</span></span><br><span class="line">System.out.println(<span class="string">&quot;Hello&quot;</span>+<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>);     <span class="comment">//输出：</span></span><br></pre></td></tr></table></figure><p>练习2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;*    *&quot;</span>);<span class="comment">//输出：</span></span><br><span class="line">System.out.println(<span class="string">&quot;*\t*&quot;</span>);<span class="comment">//输出：</span></span><br><span class="line">System.out.println(<span class="string">&quot;*&quot;</span> + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;*&quot;</span>);<span class="comment">//输出：</span></span><br><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span> + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;*&quot;</span>);<span class="comment">//输出：</span></span><br><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span> + <span class="string">&#x27;\t&#x27;</span> + <span class="string">&quot;*&quot;</span>);<span class="comment">//输出：</span></span><br><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span> + <span class="string">&quot;\t&quot;</span> + <span class="string">&#x27;*&#x27;</span>);<span class="comment">//输出：</span></span><br><span class="line">System.out.println(<span class="string">&quot;*&quot;</span> + <span class="string">&#x27;\t&#x27;</span> + <span class="string">&#x27;*&#x27;</span>);<span class="comment">//输出：</span></span><br><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span> + <span class="string">&#x27;\t&#x27;</span> + <span class="string">&#x27;*&#x27;</span>);<span class="comment">//输出：</span></span><br></pre></td></tr></table></figure><h2 id="6-计算机底层如何存储数据"><a href="#6-计算机底层如何存储数据" class="headerlink" title="6. 计算机底层如何存储数据"></a>6. 计算机底层如何存储数据</h2><p>计算机世界中只有二进制，所以计算机中存储和运算的<code>所有数据</code>都要转为<code>二进制</code>。包括数字、字符、图片、声音、视频等。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/010101.jpg" alt="010101" style="zoom: 33%;"></p><p><strong>世界上有10种人 ，认识和不认识二进制的。</strong></p><h3 id="6-1-进制的分类"><a href="#6-1-进制的分类" class="headerlink" title="6.1 进制的分类"></a>6.1 进制的分类</h3><ul><li><p><strong>十进制（decimal）</strong></p><ul><li>数字组成：0-9</li><li>进位规则：满十进一</li></ul></li><li><p><strong>二进制（binary）</strong></p><ul><li>数字组成：0-1</li><li>进位规则：满二进一，以<code>0b</code>或<code>0B</code>开头</li></ul></li><li><p><strong>八进制（octal）：很少使用</strong></p><ul><li>数字组成：0-7</li><li>进位规则：满八进一，以数字<code>0</code>开头表示</li></ul></li><li><p><strong>十六进制</strong></p><ul><li>数字组成：0-9，a-f</li><li>进位规则：满十六进一，以<code>0x</code>或<code>0X</code>开头表示。此处的 a-f 不区分大小写</li></ul></li></ul><p>代码演示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">123</span>;<span class="comment">//十进制</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">0b101</span>;<span class="comment">//二进制</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num3</span> <span class="operator">=</span> <span class="number">0127</span>;<span class="comment">//八进制</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num4</span> <span class="operator">=</span> <span class="number">0x12aF</span>;<span class="comment">//十六进制</span></span><br><span class="line"></span><br><span class="line">System.out.println(num1);</span><br><span class="line">System.out.println(num2);</span><br><span class="line">System.out.println(num3);</span><br><span class="line">System.out.println(num4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-进制的换算举例"><a href="#6-2-进制的换算举例" class="headerlink" title="6.2 进制的换算举例"></a>6.2 进制的换算举例</h3><div class="table-container"><table><thead><tr><th>十进制</th><th>二进制</th><th>八进制</th><th>十六进制</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>2</td><td>10</td><td>2</td><td>2</td></tr><tr><td>3</td><td>11</td><td>3</td><td>3</td></tr><tr><td>4</td><td>100</td><td>4</td><td>4</td></tr><tr><td>5</td><td>101</td><td>5</td><td>5</td></tr><tr><td>6</td><td>110</td><td>6</td><td>6</td></tr><tr><td>7</td><td>111</td><td>7</td><td>7</td></tr><tr><td>8</td><td>1000</td><td>10</td><td>8</td></tr><tr><td>9</td><td>1001</td><td>11</td><td>9</td></tr><tr><td>10</td><td>1010</td><td>12</td><td>a或A</td></tr><tr><td>11</td><td>1011</td><td>13</td><td>b或B</td></tr><tr><td>12</td><td>1100</td><td>14</td><td>c或C</td></tr><tr><td>13</td><td>1101</td><td>15</td><td>d或D</td></tr><tr><td>14</td><td>1110</td><td>16</td><td>e或E</td></tr><tr><td>15</td><td>1111</td><td>17</td><td>f或F</td></tr><tr><td>16</td><td>10000</td><td>20</td><td>10</td></tr></tbody></table></div><h3 id="6-3-二进制的由来"><a href="#6-3-二进制的由来" class="headerlink" title="6.3 二进制的由来"></a>6.3 二进制的由来</h3><p>二进制，是计算技术中广泛采用的一种数制，由德国数理哲学大师<code>莱布尼茨</code>于1679年发明。</p><p>二进制数据是用0和1两个数码来表示的数。它的基数为2，进位规则是“<code>逢二进一</code>”。</p><p>二进制广泛应用于我们生活的方方面面。比如，广泛使用的摩尔斯电码（Morse Code），它由两种基本信号组成：短促的点信号“<code>·</code>”，读“<code>滴</code>”；保持一定时间的长信号“<code>—</code>”，读“<code>嗒</code>”。然后，组成了26个字母，从而拼写出相应的单词。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20220520105721126.png" alt="image-20220520105721126" style="zoom:67%;"></p><p>记忆技巧：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/morsecode.jpg" alt="morsecode" style="zoom:50%;"></p><p>我们偶尔会看到的：SOS，即为：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20220520110206899.png" alt="image-20220520110206899"></p><h3 id="6-4-二进制转十进制"><a href="#6-4-二进制转十进制" class="headerlink" title="6.4 二进制转十进制"></a>6.4 二进制转十进制</h3><p><strong>二进制如何表示整数？</strong></p><ul><li>计算机数据的存储使用二进制<code>补码</code>形式存储，并且<code>最高位是符号位</code>。<ul><li>正数：<code>最高位是0</code></li><li>负数：<code>最高位是1</code></li></ul></li></ul><ul><li>规 定<ul><li>正数的补码与反码、原码一样，称为<code>三码合一</code></li><li>负数的补码与反码、原码不一样：<ul><li>负数的<code>原码</code>：把十进制转为二进制，然后最高位设置为1</li><li>负数的<code>反码</code>：在原码的基础上，最高位不变，其余位取反（0变1,1变0）</li><li>负数的<code>补码</code>：反码+1</li></ul></li></ul></li></ul><p><strong>二进制转十进制：权相加法</strong></p><p>针对于byte数据举例来说：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20220523114701881.png" alt="image-20220523114701881"></p><ul><li><p>例如：byte类型（1个字节，8位）</p><p>25 ==&gt; 原码  0001 1001 ==&gt; 反码  0001 1001 —&gt;补码  0001 1001</p><p>-25 ==&gt;原码  1001 1001 ==&gt; 反码1110 0110 ==&gt;补码 1110 0111</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">整数：</span><br><span class="line">正数：<span class="number">25</span>   <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">000000000</span> <span class="number">00011001</span>（原码）</span><br><span class="line">正数：<span class="number">25</span>   <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">000000000</span> <span class="number">00011001</span>（反码）</span><br><span class="line">正数：<span class="number">25</span>   <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">000000000</span> <span class="number">00011001</span>（补码）</span><br><span class="line"></span><br><span class="line">负数：-<span class="number">25</span>  <span class="number">10000000</span> <span class="number">00000000</span> <span class="number">000000000</span> <span class="number">00011001</span>（原码）</span><br><span class="line">负数：-<span class="number">25</span>  <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">111111111</span> <span class="number">11100110</span>（反码）</span><br><span class="line">负数：-<span class="number">25</span>  <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">111111111</span> <span class="number">11100111</span>（补码）</span><br></pre></td></tr></table></figure><p><strong>一个字节可以存储的整数范围是多少？</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1个字节：8位</span></span><br><span class="line"></span><br><span class="line"><span class="number">0000</span> <span class="number">0001</span>  ~  <span class="number">0111</span> <span class="number">111</span> ==&gt; <span class="number">1</span>~<span class="number">127</span></span><br><span class="line"></span><br><span class="line"><span class="number">1000</span> <span class="number">0001</span> ~ <span class="number">1111</span> <span class="number">1111</span> ==&gt; -<span class="number">127</span> ~ -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> ==&gt;<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">1000</span> <span class="number">0000</span> ==&gt; -<span class="number">128</span>（特殊规定）=-<span class="number">127</span>-<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="6-5-十进制转二进制"><a href="#6-5-十进制转二进制" class="headerlink" title="6.5 十进制转二进制"></a>6.5 十进制转二进制</h3><p>十进制转二进制：<code>除2取余的逆</code></p><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20220312000042595.png" alt="image-20220312000042595" style="zoom:67%;"></p><h3 id="6-6-二进制与八进制、十六进制间的转换"><a href="#6-6-二进制与八进制、十六进制间的转换" class="headerlink" title="6.6 二进制与八进制、十六进制间的转换"></a>6.6 二进制与八进制、十六进制间的转换</h3><p><strong>二进制转八进制</strong></p><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20220312000233863.png" alt="image-20220312000233863" style="zoom:80%;"></p><p><strong>二进制转十六进制</strong></p><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20220312000251113.png" alt="image-20220312000251113" style="zoom:80%;"></p><p><strong>八进制、十六进制转二进制</strong></p><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20220312000341297.png" alt="image-20220312000341297" style="zoom: 67%;"></p><h3 id="6-7-各进制间的转换"><a href="#6-7-各进制间的转换" class="headerlink" title="6.7 各进制间的转换"></a>6.7 各进制间的转换</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20220312000143438.png" alt="image-20220312000143438" style="zoom:80%;"></p><p><strong>练习：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.将以下十进制数转换为十六进制和二进制</span><br><span class="line">123  256  87  62</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.将以下十六进制数转换为十进制和二进制</span><br><span class="line">0x123   0x25F  0x38  0x62</span><br></pre></td></tr></table></figure><h2 id="7-运算符（Operator）（掌握）"><a href="#7-运算符（Operator）（掌握）" class="headerlink" title="7. 运算符（Operator）（掌握）"></a>7. 运算符（Operator）（掌握）</h2><p>运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。</p><p>运算符的分类：</p><ul><li>按照<code>功能</code>分为：算术运算符、赋值运算符、比较(或关系)运算符、逻辑运算符、位运算符、条件运算符、Lambda运算符</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">运算符</th></tr></thead><tbody><tr><td style="text-align:center">算术运算符（7个）</td><td style="text-align:center">+、-、*、/、%、++、—</td></tr><tr><td style="text-align:center">赋值运算符（12个）</td><td style="text-align:center">=、+=、-=、*=、/=、%=、&gt;&gt;=、&lt;&lt;=、&gt;&gt;&gt;=、&amp;=、\</td><td>=、^=等</td></tr><tr><td style="text-align:center">比较(或关系)运算符（6个）</td><td style="text-align:center">&gt;、&gt;=、&lt;、&lt;=、==、!=</td></tr><tr><td style="text-align:center">逻辑运算符（6个）</td><td style="text-align:center">&amp;、\</td><td>、^、!、&amp;&amp;、\</td><td>\</td><td></td></tr><tr><td style="text-align:center">位运算符（7个）</td><td style="text-align:center">&amp;、\</td><td>、^、~、&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;</td></tr><tr><td style="text-align:center">条件运算符（1个）</td><td style="text-align:center">(条件表达式)?结果1:结果2</td></tr><tr><td style="text-align:center">Lambda运算符（1个）</td><td style="text-align:center">-&gt;（第18章时讲解）</td></tr></tbody></table></div><ul><li>按照<code>操作数个数</code>分为：一元运算符（单目运算符）、二元运算符（双目运算符）、三元运算符 （三目运算符）</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">运算符</th></tr></thead><tbody><tr><td style="text-align:center">一元运算符（单目运算符）</td><td style="text-align:center">正号（+）、负号（-）、++、—、!、~</td></tr><tr><td style="text-align:center">二元运算符（双目运算符）</td><td style="text-align:center">除了一元和三元运算符剩下的都是二元运算符</td></tr><tr><td style="text-align:center">三元运算符 （三目运算符）</td><td style="text-align:center">(条件表达式)?结果1:结果2</td></tr></tbody></table></div><h3 id="7-1-算术运算符"><a href="#7-1-算术运算符" class="headerlink" title="7.1 算术运算符"></a>7.1 算术运算符</h3><h4 id="7-1-1-基本语法"><a href="#7-1-1-基本语法" class="headerlink" title="7.1.1 基本语法"></a>7.1.1 基本语法</h4><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20220312000848332.png" alt="image-20220312000848332"></p><p>举例1：加减乘除模</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArithmeticTest1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(a + b);<span class="comment">// 7</span></span><br><span class="line">System.out.println(a - b);<span class="comment">// -1</span></span><br><span class="line">System.out.println(a * b);<span class="comment">// 12</span></span><br><span class="line">System.out.println(a / b);<span class="comment">// 计算机结果是0，为什么不是0.75呢？</span></span><br><span class="line">System.out.println(a % b);<span class="comment">// 3</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//结果与被模数符号相同</span></span><br><span class="line">        System.out.println(<span class="number">5</span>%<span class="number">2</span>);<span class="comment">//1</span></span><br><span class="line">System.out.println(<span class="number">5</span>%-<span class="number">2</span>);<span class="comment">//1</span></span><br><span class="line">System.out.println(-<span class="number">5</span>%<span class="number">2</span>);<span class="comment">//-1</span></span><br><span class="line">System.out.println(-<span class="number">5</span>%-<span class="number">2</span>);<span class="comment">//-1</span></span><br><span class="line"><span class="comment">//商*除数 + 余数 = 被除数</span></span><br><span class="line"><span class="comment">//5%-2  ==&gt;商是-2，余数时1    (-2)*(-2)+1 = 5</span></span><br><span class="line"><span class="comment">//-5%2  ==&gt;商是-2，余数是-1   (-2)*2+(-1) = -4-1=-5</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例2：“+”号的两种用法</p><ul><li>第一种：对于<code>+</code>两边都是数值的话，<code>+</code>就是加法的意思</li><li>第二种：对于<code>+</code>两边至少有一边是字符串的话，<code>+</code>就是拼接的意思</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArithmeticTest2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// 字符串类型的变量基本使用</span></span><br><span class="line"><span class="comment">// 数据类型 变量名称 = 数据值;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">System.out.println(str1); <span class="comment">// Hello</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Hello&quot;</span> + <span class="string">&quot;World&quot;</span>); <span class="comment">// HelloWorld</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line"><span class="comment">// String + int --&gt; String</span></span><br><span class="line">System.out.println(str2 + <span class="number">520</span>); <span class="comment">// Java520</span></span><br><span class="line"><span class="comment">// String + int + int</span></span><br><span class="line"><span class="comment">// String+ int</span></span><br><span class="line"><span class="comment">// String</span></span><br><span class="line">System.out.println(str2 + <span class="number">5</span> + <span class="number">20</span>); <span class="comment">// Java520</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例3：自加自减运算</p><p>理解：<code>++</code>  运算，表示<code>自增1</code>。同理，<code>--</code> 运算，表示<code>自减1</code>，用法与++ 一致。</p><p>1、单独使用</p><ul><li>变量在单独运算的时候，变量<code>前++</code>和变量<code>后++</code>，是没有区别的。</li><li>变量<code>前++</code>   ：例如 <code>++a</code> 。</li><li>变量<code>后++</code>   ：例如 <code>a++</code> 。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArithmeticTest3</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// 定义一个int类型的变量a</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="comment">//++a;</span></span><br><span class="line">a++;</span><br><span class="line">        <span class="comment">// 无论是变量前++还是变量后++，结果都是4</span></span><br><span class="line">System.out.println(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、复合使用</p><ul><li>和<code>其他变量放在一起使用</code>或者和<code>输出语句放在一起使用</code>，<code>前++</code>和<code>后++</code>就产生了不同。</li></ul><ul><li>变量<code>前++</code> ：变量先自增1，然后再运算。</li><li>变量<code>后++</code> ：变量先运算，然后再自增1。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArithmeticTest4</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// 其他变量放在一起使用</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="comment">//int y = ++x; // y的值是4，x的值是4，</span></span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x++; <span class="comment">// y的值是3，x的值是4</span></span><br><span class="line"></span><br><span class="line">System.out.println(x);</span><br><span class="line">System.out.println(y);</span><br><span class="line">System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 和输出语句一起</span></span><br><span class="line"><span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">//System.out.println(++z);// 输出结果是6，z的值也是6</span></span><br><span class="line">System.out.println(z++);<span class="comment">// 输出结果是5，z的值是6</span></span><br><span class="line">System.out.println(z);</span><br><span class="line">        </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-1-2-案例与练习"><a href="#7-1-2-案例与练习" class="headerlink" title="7.1.2 案例与练习"></a>7.1.2 案例与练习</h4><p><strong>案例1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">随意给出一个整数，打印显示它的个位数，十位数，百位数的值。</span><br><span class="line">格式如下：</span><br><span class="line">数字xxx的情况如下：</span><br><span class="line">个位数：</span><br><span class="line">十位数：</span><br><span class="line">百位数：</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">数字153的情况如下：</span><br><span class="line">个位数：3</span><br><span class="line">十位数：5</span><br><span class="line">百位数：1</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 12:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArithmeticExer1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">187</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">bai</span> <span class="operator">=</span> num / <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">shi</span> <span class="operator">=</span> num % <span class="number">100</span> / <span class="number">10</span>;<span class="comment">//int shi = num / 10 % 10;</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ge</span> <span class="operator">=</span> num % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;百位为：&quot;</span> + bai);</span><br><span class="line">System.out.println(<span class="string">&quot;十位为：&quot;</span> + shi);</span><br><span class="line">System.out.println(<span class="string">&quot;个位为：&quot;</span> + ge);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拓展：获取一个四位数的个位，十位，百位，千位</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 12:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArithmeticExer01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String [] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.定义一个变量，赋值为一个四位数整数，例如1234</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1234</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.通过运算操作求出个位，十位，百位，千位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ge</span> <span class="operator">=</span> num % <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">shi</span> <span class="operator">=</span> num /<span class="number">10</span> % <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bai</span> <span class="operator">=</span> num /<span class="number">100</span> % <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">qian</span> <span class="operator">=</span> num / <span class="number">1000</span> % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;个位上的数字是：&quot;</span> + ge);</span><br><span class="line">        System.out.println(<span class="string">&quot;十位上的数字是：&quot;</span> + shi);</span><br><span class="line">        System.out.println(<span class="string">&quot;百位上的数字是：&quot;</span> + bai);</span><br><span class="line">        System.out.println(<span class="string">&quot;千位上的数字是：&quot;</span> + qian);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例2：</strong>为抵抗洪水，战士连续作战89小时，编程计算共多少天零多少小时？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 17:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArithmeticExer2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hours</span> <span class="operator">=</span> <span class="number">89</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> hours / <span class="number">24</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hour</span> <span class="operator">=</span> hours % <span class="number">24</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;为抵抗洪水，战士连续作战89小时：&quot;</span>);</span><br><span class="line">        System.out.println(hours + <span class="string">&quot;是&quot;</span> + day + <span class="string">&quot;天&quot;</span> + hour +<span class="string">&quot;小时&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习1：算术运算符：自加、自减</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArithmeticExer3</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> i1++;</span><br><span class="line">        System.out.print(<span class="string">&quot;i=&quot;</span>+i); <span class="comment">//</span></span><br><span class="line">        System.out.println(<span class="string">&quot;i1=&quot;</span>+i1);<span class="comment">//</span></span><br><span class="line">        i = ++i1;</span><br><span class="line">        System.out.print(<span class="string">&quot;i=&quot;</span>+i);<span class="comment">//</span></span><br><span class="line">        System.out.println(<span class="string">&quot;i1=&quot;</span>+i1);<span class="comment">//</span></span><br><span class="line">        i = i2--;</span><br><span class="line">        System.out.print(<span class="string">&quot;i=&quot;</span>+i);<span class="comment">//</span></span><br><span class="line">        System.out.println(<span class="string">&quot;i2=&quot;</span>+i2);<span class="comment">//</span></span><br><span class="line">        i = --i2;</span><br><span class="line">        System.out.print(<span class="string">&quot;i=&quot;</span>+i);<span class="comment">//</span></span><br><span class="line">        System.out.println(<span class="string">&quot;i2=&quot;</span>+i2);<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;5+5=&quot;</span> + <span class="number">5</span> + <span class="number">5</span>); <span class="comment">//打印结果是？ 5+5=55 ?</span></span><br></pre></td></tr></table></figure><p>练习3：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">bb1</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">bb1++;</span><br><span class="line">System.out.println(<span class="string">&quot;bb1 = &quot;</span> + bb1);<span class="comment">//-128</span></span><br></pre></td></tr></table></figure><p>练习4：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i++ + ++i * i++;</span><br><span class="line">System.out.println(<span class="string">&quot;j = &quot;</span> + j);</span><br></pre></td></tr></table></figure><p>练习5：（企业真题）写出下列程序的输出结果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i++;</span><br><span class="line">System.out.println(j);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">m = m++; <span class="comment">//(1)先取b的值“2”放操作数栈 (2)m再自增,m=3 (3)再把操作数栈中的&quot;2&quot;赋值给m,m=2</span></span><br><span class="line">System.out.println(m);</span><br></pre></td></tr></table></figure><h3 id="7-2-赋值运算符"><a href="#7-2-赋值运算符" class="headerlink" title="7.2 赋值运算符"></a>7.2 赋值运算符</h3><h4 id="7-2-1-基本语法"><a href="#7-2-1-基本语法" class="headerlink" title="7.2.1 基本语法"></a>7.2.1 基本语法</h4><ul><li><p>符号：= </p><ul><li>当“=”两侧数据类型不一致时，可以使用自动类型转换或使用强制类型转换原则进行处理。</li><li>支持<code>连续赋值</code>。</li></ul></li><li><p>扩展赋值运算符： +=、 -=、*=、 /=、%=</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">赋值运算符</th><th style="text-align:center">符号解释</th></tr></thead><tbody><tr><td style="text-align:center"><code>+=</code></td><td style="text-align:center">将符号<code>左边的值</code>和<code>右边的值</code>进行<code>相加</code>操作，最后将结果<code>赋值给左边的变量</code></td></tr><tr><td style="text-align:center"><code>-=</code></td><td style="text-align:center">将符号<code>左边的值</code>和<code>右边的值</code>进行<code>相减</code>操作，最后将结果<code>赋值给左边的变量</code></td></tr><tr><td style="text-align:center"><code>*=</code></td><td style="text-align:center">将符号<code>左边的值</code>和<code>右边的值</code>进行<code>相乘</code>操作，最后将结果<code>赋值给左边的变量</code></td></tr><tr><td style="text-align:center"><code>/=</code></td><td style="text-align:center">将符号<code>左边的值</code>和<code>右边的值</code>进行<code>相除</code>操作，最后将结果<code>赋值给左边的变量</code></td></tr><tr><td style="text-align:center"><code>%=</code></td><td style="text-align:center">将符号<code>左边的值</code>和<code>右边的值</code>进行<code>取余</code>操作，最后将结果<code>赋值给左边的变量</code></td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetValueTest1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">l1</span> <span class="operator">=</span> i1; <span class="comment">//自动类型转换</span></span><br><span class="line"></span><br><span class="line"><span class="type">byte</span> <span class="variable">bb1</span> <span class="operator">=</span> (<span class="type">byte</span>)i1; <span class="comment">//强制类型转换</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> i1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连续赋值的测试</span></span><br><span class="line"><span class="comment">//以前的写法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连续赋值的写法</span></span><br><span class="line"><span class="type">int</span> a2,b2;</span><br><span class="line">a2 = b2 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">a3</span> <span class="operator">=</span> <span class="number">10</span>,b3 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//举例说明+=  -=  *=  /=   %=  </span></span><br><span class="line"><span class="type">int</span> <span class="variable">m1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">m1 += <span class="number">5</span>; <span class="comment">//类似于 m1 = m1 + 5的操作，但不等同于。</span></span><br><span class="line">System.out.println(m1);<span class="comment">//15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//练习1：开发中，如何实现一个变量+2的操作呢？</span></span><br><span class="line"><span class="comment">// += 的操作不会改变变量本身的数据类型。其他拓展的运算符也如此。</span></span><br><span class="line"><span class="comment">//写法1：推荐</span></span><br><span class="line"><span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">s1 += <span class="number">2</span>; <span class="comment">//编译通过，因为在得到int类型的结果后，JVM自动完成一步强制类型转换，将int类型强转成short</span></span><br><span class="line">System.out.println(s1);<span class="comment">//12</span></span><br><span class="line"><span class="comment">//写法2：</span></span><br><span class="line"><span class="type">short</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//s2 = s2 + 2;//编译报错，因为将int类型的结果赋值给short类型的变量s时，可能损失精度</span></span><br><span class="line">s2 = (<span class="type">short</span>)(s2 + <span class="number">2</span>);</span><br><span class="line">System.out.println(s2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//练习2：开发中，如何实现一个变量+1的操作呢？</span></span><br><span class="line"><span class="comment">//写法1：推荐</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">num1++;</span><br><span class="line">System.out.println(num1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//写法2：</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">num2 += <span class="number">1</span>;</span><br><span class="line">System.out.println(num2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//写法3：</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num3</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">num3 = num3 + <span class="number">1</span>;</span><br><span class="line">System.out.println(num3);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-2-2-练习"><a href="#7-2-2-练习" class="headerlink" title="7.2.2 练习"></a>7.2.2 练习</h4><p>练习1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">3</span>; </span><br><span class="line">s = s+<span class="number">2</span>;  <span class="comment">//① 编译报错</span></span><br><span class="line">s += <span class="number">2</span>;   <span class="comment">//② 正常执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//①和②有什么区别？ </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>练习2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">i *= <span class="number">0.1</span>;</span><br><span class="line">System.out.println(i);<span class="comment">//0</span></span><br><span class="line">i++;</span><br><span class="line">System.out.println(i);<span class="comment">//1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>练习3：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">n *= m++; <span class="comment">//n = n * m++;</span></span><br><span class="line">System.out.println(<span class="string">&quot;m=&quot;</span> + m);<span class="comment">//3</span></span><br><span class="line">System.out.println(<span class="string">&quot;n=&quot;</span> + n);<span class="comment">//6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>练习4：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">n += (n++) + (++n);  <span class="comment">//n = n + (n++) + (++n)</span></span><br><span class="line">System.out.println(n);<span class="comment">//32</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>练习5：你有几种办法实现变量值减1？变量值减2呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 16:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinusTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//练习①：变量值减1</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//方式1：</span></span><br><span class="line">        <span class="comment">//s = (short)(s - 1);</span></span><br><span class="line">        <span class="comment">//方式2：推荐</span></span><br><span class="line">        s--; <span class="comment">//或者 --s</span></span><br><span class="line">        <span class="comment">//方式3：</span></span><br><span class="line">        s -= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//练习②：变量值减2</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//方式1：</span></span><br><span class="line">        <span class="comment">//s1 = (short)(s1 - 2);</span></span><br><span class="line">        <span class="comment">//方式2：推荐</span></span><br><span class="line">        s1 -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-比较-关系-运算符"><a href="#7-3-比较-关系-运算符" class="headerlink" title="7.3 比较(关系)运算符"></a>7.3 比较(关系)运算符</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20220312001742263.png" alt="image-20220312001742263"></p><ul><li><p>比较运算符的结果都是boolean型，也就是要么是true，要么是false。</p></li><li><p>>   &lt;   &gt;=  &lt;= ：只适用于基本数据类型（除boolean类型之外）</p><p>==   != ：适用于基本数据类型和引用数据类型</p></li><li><p>比较运算符“<code>==</code>”不能误写成“<code>=</code>” </p></li></ul><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CompareTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(i1 == i2);<span class="comment">//false</span></span><br><span class="line">System.out.println(i1 != i2);<span class="comment">//true</span></span><br><span class="line">System.out.println(i1 &gt;= i2);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">System.out.println(m == n);<span class="comment">//false</span></span><br><span class="line">System.out.println(m = n);<span class="comment">//20</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">System.out.println(b1 == b2);<span class="comment">//false</span></span><br><span class="line">System.out.println(b1 = b2);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//区分好==和=的区别。</span></span><br><span class="line"><span class="keyword">if</span>(b1 == <span class="literal">true</span>)  <span class="comment">//if(b1 = true)</span></span><br><span class="line">System.out.println(<span class="string">&quot;结果为真&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">System.out.println(<span class="string">&quot;结果为假&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-4-逻辑运算符"><a href="#7-4-逻辑运算符" class="headerlink" title="7.4 逻辑运算符"></a>7.4 逻辑运算符</h3><h4 id="7-4-1-基本语法"><a href="#7-4-1-基本语法" class="headerlink" title="7.4.1 基本语法"></a>7.4.1 基本语法</h4><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20220312001943403.png" alt="image-20220312001943403" style="zoom: 67%;"></p><ul><li><p>逻辑运算符，操作的都是boolean类型的变量或常量，而且运算得结果也是boolean类型的值。</p></li><li><p>运算符说明：</p><ul><li>&amp; 和 &amp;&amp;：表示”且”关系，当符号左右两边布尔值都是true时，结果才能为true。否则，为false。</li><li>| 和 || ：表示”或”关系，当符号两边布尔值有一边为true时，结果为true。当两边都为false时，结果为false</li><li>! ：表示”非”关系，当变量布尔值为true时，结果为false。当变量布尔值为false时，结果为true。</li><li>^ ：当符号左右两边布尔值不同时，结果为true。当两边布尔值相同时，结果为false。<ul><li>理解：<code>异或，追求的是“异”！</code></li></ul></li></ul></li><li><p>逻辑运算符用于连接布尔型表达式，在Java中不可以写成 3 &lt; x &lt; 6，应该写成x &gt; 3 &amp; x &lt; 6 。</p></li></ul><ul><li><p><strong>区分“&amp;”和“&amp;&amp;”：</strong></p><ul><li><p>相同点：如果符号左边是true，则二者都执行符号右边的操作</p></li><li><p>不同点：&amp; ： 如果符号左边是false,则继续执行符号右边的操作</p></li></ul><p>​                     &amp;&amp; ：如果符号左边是false,则不再继续执行符号右边的操作</p><ul><li>建议：开发中，推荐使用 &amp;&amp; </li></ul></li><li><p><strong>区分“|”和“||”：</strong></p></li></ul><ul><li><p>相同点：如果符号左边是false，则二者都执行符号右边的操作</p></li><li><p>不同点：| ： 如果符号左边是true，则继续执行符号右边的操作</p><p>​               || ：如果符号左边是true，则不再继续执行符号右边的操作</p></li><li><p>建议：开发中，推荐使用 ||</p><p>代码举例：</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &amp; 与，且；有false则false</span></span><br><span class="line">System.out.println((a &gt; b) &amp; (a &gt; c)); </span><br><span class="line">System.out.println((a &gt; b) &amp; (a &lt; c)); </span><br><span class="line">System.out.println((a &lt; b) &amp; (a &gt; c)); </span><br><span class="line">System.out.println((a &lt; b) &amp; (a &lt; c)); </span><br><span class="line">System.out.println(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"><span class="comment">// | 或；有true则true</span></span><br><span class="line">System.out.println((a &gt; b) | (a &gt; c)); </span><br><span class="line">System.out.println((a &gt; b) | (a &lt; c)); </span><br><span class="line">System.out.println((a &lt; b) | (a &gt; c));</span><br><span class="line">System.out.println((a &lt; b) | (a &lt; c));</span><br><span class="line">System.out.println(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"><span class="comment">// ^ 异或；相同为false，不同为true</span></span><br><span class="line">System.out.println((a &gt; b) ^ (a &gt; c));</span><br><span class="line">System.out.println((a &gt; b) ^ (a &lt; c)); </span><br><span class="line">System.out.println((a &lt; b) ^ (a &gt; c)); </span><br><span class="line">System.out.println((a &lt; b) ^ (a &lt; c)); </span><br><span class="line">System.out.println(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"><span class="comment">// ! 非；非false则true，非true则false</span></span><br><span class="line">System.out.println(!<span class="literal">false</span>);</span><br><span class="line">System.out.println(!<span class="literal">true</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//&amp;和&amp;&amp;的区别</span></span><br><span class="line">        System.out.println((a &gt; b) &amp; (a++ &gt; c)); </span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">        System.out.println((a &gt; b) &amp;&amp; (a++ &gt; c)); </span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">        System.out.println((a == b) &amp;&amp; (a++ &gt; c)); </span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//|和||的区别</span></span><br><span class="line">        System.out.println((a &gt; b) | (a++ &gt; c)); </span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">        System.out.println((a &gt; b) || (a++ &gt; c)); </span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">        System.out.println((a == b) || (a++ &gt; c)); </span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-4-2-案例与练习"><a href="#7-4-2-案例与练习" class="headerlink" title="7.4.2 案例与练习"></a>7.4.2 案例与练习</h4><p><strong>案例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 定义类 CompareLogicExer</span><br><span class="line">2. 定义 main方法</span><br><span class="line">3. 定义一个int类型变量a,变量b,都赋值为20</span><br><span class="line">4. 定义boolean类型变量bo1 , 判断++a 是否被3整除,并且a++ 是否被7整除,将结果赋值给bo1</span><br><span class="line">5. 输出a的值,bo1的值</span><br><span class="line">6. 定义boolean类型变量bo2 , 判断b++ 是否被3整除,并且++b 是否被7整除,将结果赋值给bo2</span><br><span class="line">7. 输出b的值,bo2的值</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 12:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompareLogicExer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">bo1</span> <span class="operator">=</span> ((++a % <span class="number">3</span>) == <span class="number">0</span>) &amp;&amp; ((a++ % <span class="number">7</span>) == <span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;bo1的值：&quot;</span> + bo1);</span><br><span class="line">        System.out.println(<span class="string">&quot;a的值：&quot;</span> + a);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">boolean</span> <span class="variable">bo2</span> <span class="operator">=</span> ((b++ % <span class="number">3</span>) == <span class="number">0</span>) &amp;&amp; ((++b % <span class="number">7</span>) == <span class="number">0</span>); </span><br><span class="line">        System.out.println(<span class="string">&quot;bo2的值：&quot;</span> + bo2);</span><br><span class="line">        System.out.println(<span class="string">&quot;b的值：&quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习1：</strong>区分 &amp; 和 &amp;&amp; </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(x++ == <span class="number">2</span> &amp; ++y == <span class="number">2</span>)&#123;</span><br><span class="line">x = <span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;x=&quot;</span> + x + <span class="string">&quot;,y=&quot;</span> + y);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>,y = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(x++ == <span class="number">2</span> &amp;&amp; ++y == <span class="number">2</span>)&#123;</span><br><span class="line">x =<span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;x=&quot;</span>+x+<span class="string">&quot;,y=&quot;</span>+y);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>练习2：</strong>区分 | 和 ||</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>,y = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(x++==<span class="number">1</span> | ++y==<span class="number">1</span>)&#123;</span><br><span class="line">x =<span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;x=&quot;</span>+x+<span class="string">&quot;,y=&quot;</span>+y);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>,y = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(x++==<span class="number">1</span> || ++y==<span class="number">1</span>)&#123;</span><br><span class="line">x =<span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;x=&quot;</span>+x+<span class="string">&quot;,y=&quot;</span>+y);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>练习3：</strong>程序输出</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Test</span>  &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String []  args)</span>  &#123;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">x</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">y</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">short</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">42</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((z++ == <span class="number">42</span>) &amp;&amp; (y = <span class="literal">true</span>)) &#123;</span><br><span class="line">            z++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((x = <span class="literal">false</span>) || (++z == <span class="number">45</span>)) &#123;</span><br><span class="line">            z++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;z=&quot;</span> + z);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结果为：</span></span><br><span class="line"><span class="comment">//z= 46</span></span><br></pre></td></tr></table></figure><h3 id="7-5-位运算符（难点、非重点）"><a href="#7-5-位运算符（难点、非重点）" class="headerlink" title="7.5 位运算符（难点、非重点）"></a>7.5 位运算符（难点、非重点）</h3><h4 id="7-5-1-基本语法"><a href="#7-5-1-基本语法" class="headerlink" title="7.5.1 基本语法"></a>7.5.1 基本语法</h4><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20220313174721111.png" alt="image-20220313174721111" style="zoom:75%;"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20220312002506339.png" alt="image-20220312002506339" style="zoom:67%;"></p><ul><li>位运算符的运算过程都是基于二进制的补码运算</li></ul><p><strong>（1）左移：&lt;&lt;</strong></p><p>运算规则：在一定范围内，数据每向左移动一位，相当于原数据*2。（正数、负数都适用）</p><p>【注意】当左移的位数n超过该数据类型的总位数时，相当于左移（n-总位数）位</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>&lt;&lt;<span class="number">4</span>  类似于  <span class="number">3</span>*<span class="number">2</span>的<span class="number">4</span>次幂 =&gt; <span class="number">3</span>*<span class="number">16</span> =&gt; <span class="number">48</span></span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20200225113651675.png" alt="image-20200225113651675"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-<span class="number">3</span>&lt;&lt;<span class="number">4</span>  类似于  -<span class="number">3</span>*<span class="number">2</span>的<span class="number">4</span>次幂 =&gt; -<span class="number">3</span>*<span class="number">16</span> =&gt; -<span class="number">48</span></span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20200225114707524.png" alt="image-20200225114707524"></p><p><strong>（2）右移：&gt;&gt;</strong></p><p>运算规则：在一定范围内，数据每向右移动一位，相当于原数据/2。（正数、负数都适用）</p><p>【注意】如果不能整除，<code>向下取整</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">69</span>&gt;&gt;<span class="number">4</span>  类似于  <span class="number">69</span>/<span class="number">2</span>的<span class="number">4</span>次 = <span class="number">69</span>/<span class="number">16</span> =<span class="number">4</span></span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20200225115636844.png" alt="image-20200225115636844"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-69&gt;&gt;4  类似于  -69/2的4次 = -69/16 = -5</span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20200225120112188.png" alt="image-20200225120112188"></p><p><strong>（3）无符号右移：&gt;&gt;&gt;</strong></p><p>运算规则：往右移动后，左边空出来的位直接补0。（正数、负数都适用）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">69&gt;&gt;&gt;4  类似于  69/2的4次 = 69/16 =4</span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20200225121104734.png" alt="image-20200225121104734"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-69&gt;&gt;&gt;4   结果：268435451</span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20200225121244290.png" alt="image-20200225121244290"></p><p><strong>（4）按位与：&amp;</strong></p><p>运算规则：对应位都是1才为1，否则为0。</p><ul><li><p>1 &amp; 1 结果为1</p></li><li><p>1 &amp; 0 结果为0</p></li><li><p>0 &amp; 1 结果为0</p></li></ul><ul><li>0 &amp; 0 结果为0</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span> &amp; <span class="number">7</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20200225122440953.png" alt="image-20200225122440953"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-<span class="number">9</span> &amp; <span class="number">7</span> = <span class="number">7</span></span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20200225122221616.png" alt="image-20200225122221616"></p><p><strong>（5）按位或：|</strong></p><p>运算规则：对应位只要有1即为1，否则为0。</p><ul><li><p>1 | 1 结果为1</p></li><li><p>1 | 0 结果为1</p></li><li><p>0 | 1 结果为1</p></li><li><p>0 &amp; 0 结果为0</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span> | <span class="number">7</span>  <span class="comment">//结果： 15</span></span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20200225122758851.png" alt="image-20200225122758851"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-<span class="number">9</span> | <span class="number">7</span> <span class="comment">//结果： -9</span></span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20200225123409130.png" alt="image-20200225123409130"></p><p><strong>（6）按位异或：^</strong></p><p>运算规则：对应位一个为1一个为0，才为1，否则为0。</p><ul><li><p>1 ^ 1 结果为0</p></li><li><p>1 ^ 0 结果为1</p></li><li><p>0 ^ 1 结果为1</p></li></ul><ul><li>0 ^ 0 结果为0</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span> ^ <span class="number">7</span>  <span class="comment">//结果为14</span></span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20200225123445305.png" alt="image-20200225123445305"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-<span class="number">9</span> ^ <span class="number">7</span> <span class="comment">//结果为-16</span></span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20200225133145727.png" alt="image-20200225133145727"></p><p><strong>（7）按位取反：~</strong></p><p>运算规则：对应位为1，则结果为0；对应位为0，则结果为1。</p><ul><li><p>~0就是1  </p></li><li><p>~1就是0</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">~<span class="number">9</span>  <span class="comment">//结果：-10</span></span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20200225124112662.png" alt="image-20200225124112662"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">~-<span class="number">9</span>  <span class="comment">//结果：8</span></span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20200225124156862.png" alt="image-20200225124156862"></p><h4 id="7-5-2-举例"><a href="#7-5-2-举例" class="headerlink" title="7.5.2 举例"></a>7.5.2 举例</h4><p><strong>举例1：</strong></p><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/snipaste_20220312_002549.jpg" alt="snipaste_20220312_002549" style="zoom: 67%;"></p><p><strong>举例2：体会 m = k ^ n = (m ^ n) ^ n</strong></p><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20220312002736157.png" alt="image-20220312002736157" style="zoom:67%;"></p><h4 id="7-5-3-案例"><a href="#7-5-3-案例" class="headerlink" title="7.5.3 案例"></a>7.5.3 案例</h4><p><strong>案例1：</strong>高效的方式计算2 * 8的值（经典面试题）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">答案：2 &lt;&lt; 3 、  8  &lt;&lt; 1</span><br></pre></td></tr></table></figure><p><strong>案例2：</strong>如何交换两个int型变量的值？String呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 16:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BitExer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;m = &quot;</span> + m + <span class="string">&quot;, n = &quot;</span> + n);</span><br><span class="line"></span><br><span class="line"><span class="comment">//（推荐）实现方式1：优点：容易理解，适用于不同数据类型    缺点：需要额外定义变量</span></span><br><span class="line"><span class="comment">//int temp = m;</span></span><br><span class="line"><span class="comment">//m = n;</span></span><br><span class="line"><span class="comment">//n = temp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现方式2：优点：没有额外定义变量    缺点：可能超出int的范围；只能适用于数值类型</span></span><br><span class="line"><span class="comment">//m = m + n; //15 = 10 + 5</span></span><br><span class="line"><span class="comment">//n = m - n;//10 = 15 - 5</span></span><br><span class="line"><span class="comment">//m = m - n;//5 = 15 - 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现方式3：优点：没有额外定义变量    缺点：不易理解；只能适用于数值类型</span></span><br><span class="line">m = m ^ n; </span><br><span class="line">n = m ^ n; <span class="comment">//(m ^ n) ^ n</span></span><br><span class="line">m = m ^ n;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;m = &quot;</span> + m + <span class="string">&quot;, n = &quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-6-条件运算符"><a href="#7-6-条件运算符" class="headerlink" title="7.6 条件运算符"></a>7.6 条件运算符</h3><h4 id="7-6-1-基本语法"><a href="#7-6-1-基本语法" class="headerlink" title="7.6.1 基本语法"></a>7.6.1 基本语法</h4><ul><li>条件运算符格式：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(条件表达式)? 表达式<span class="number">1</span>:表达式<span class="number">2</span></span><br></pre></td></tr></table></figure><ul><li><p>说明：条件表达式是boolean类型的结果，根据boolean的值选择表达式1或表达式2</p><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20220312002841945.png" alt="image-20220312002841945" style="zoom:67%;"></p></li><li><p>如果运算后的结果赋给新的变量，要求表达式1和表达式2为同种或兼容的类型</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="number">1</span>==<span class="number">2</span> ? <span class="number">100</span> : <span class="number">200</span>);</span><br><span class="line">    System.out.println(i);<span class="comment">//200</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="variable">marry</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">System.out.println(marry ? <span class="string">&quot;已婚&quot;</span> : <span class="string">&quot;未婚&quot;</span>  );</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> (m1 &gt; m2)? <span class="number">1</span> : <span class="number">2.0</span>;</span><br><span class="line">System.out.println(d1);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">    System.out.println(num &gt; <span class="number">0</span>? <span class="literal">true</span> : <span class="string">&quot;num非正数&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-6-2-案例"><a href="#7-6-2-案例" class="headerlink" title="7.6.2 案例"></a>7.6.2 案例</h4><p><strong>案例1：</strong>获取两个数中的较大值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 12:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionExer1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取两个数的较大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">max1</span> <span class="operator">=</span> (m1 &gt; m2)? m1 : m2;</span><br><span class="line">        System.out.println(<span class="string">&quot;m1和m2中的较大值为&quot;</span> + max1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例2：</strong>获取三个数中的最大值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 12:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionExer2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">23</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">13</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="number">33</span>;</span><br><span class="line">        <span class="comment">//写法1：</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">tempMax</span> <span class="operator">=</span> (n1 &gt; n2)? n1:n2;</span><br><span class="line">        <span class="type">int</span> <span class="variable">finalMax</span> <span class="operator">=</span> (tempMax &gt; n3)? tempMax : n3;</span><br><span class="line">        System.out.println(<span class="string">&quot;三个数中最大值为：&quot;</span> + finalMax);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写法2：不推荐，可读性差</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">finalMax1</span> <span class="operator">=</span> (((n1 &gt; n2)? n1:n2) &gt; n3)? ((n1 &gt; n2)? n1:n2) : n3;</span><br><span class="line">        System.out.println(<span class="string">&quot;三个数中最大值为：&quot;</span> + finalMax1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例3：</strong>今天是周2，10天以后是周几？</p><p>要求：控制台输出”今天是周2，10天以后是周x”。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 12:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionExer3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">week</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        week += <span class="number">10</span>;</span><br><span class="line">        week %= <span class="number">7</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;今天是周2,10天以后是周&quot;</span> + (week == <span class="number">0</span> ? <span class="string">&quot;日&quot;</span> : week));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-6-3-与if-else的转换关系"><a href="#7-6-3-与if-else的转换关系" class="headerlink" title="7.6.3 与if-else的转换关系"></a>7.6.3 与if-else的转换关系</h4><ul><li>凡是可以使用条件运算符的地方，都可以改写为if-else结构。反之，不成立。</li></ul><ul><li>开发中，如果既可以使用条件运算符，又可以使用if-else，推荐使用条件运算符。因为执行效率稍高。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//if-else实现获取两个数的较大值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> max;<span class="comment">//声明变量max，用于记录i1和i2的较大值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i1 &gt; i2)&#123;</span><br><span class="line">    max = i1;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    max = i2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(max);</span><br></pre></td></tr></table></figure><h3 id="7-7-运算符优先级"><a href="#7-7-运算符优先级" class="headerlink" title="7.7 运算符优先级"></a>7.7 运算符优先级</h3><p>运算符有不同的优先级，所谓优先级就是在表达式运算中的运算符顺序。</p><p>上一行中的运算符总是优先于下一行的。</p><div class="table-container"><table><thead><tr><th>优先级</th><th style="text-align:center">运算符说明</th><th style="text-align:center">Java运算符</th></tr></thead><tbody><tr><td>1</td><td style="text-align:center">括号</td><td style="text-align:center"><code>()</code>、<code>[]</code>、<code>&#123;&#125;</code></td></tr><tr><td>2</td><td style="text-align:center">正负号</td><td style="text-align:center"><code>+</code>、<code>-</code></td></tr><tr><td>3</td><td style="text-align:center">单元运算符</td><td style="text-align:center"><code>++</code>、<code>--</code>、<code>~</code>、<code>！</code></td></tr><tr><td>4</td><td style="text-align:center">乘法、除法、求余</td><td style="text-align:center"><code>*</code>、<code>/</code>、<code>%</code></td></tr><tr><td>5</td><td style="text-align:center">加法、减法</td><td style="text-align:center"><code>+</code>、<code>-</code></td></tr><tr><td>6</td><td style="text-align:center">移位运算符</td><td style="text-align:center"><code>&lt;&lt;</code>、<code>&gt;&gt;</code>、<code>&gt;&gt;&gt;</code></td></tr><tr><td>7</td><td style="text-align:center">关系运算符</td><td style="text-align:center"><code>&lt;</code>、<code>&lt;=</code>、<code>&gt;=</code>、<code>&gt;</code>、<code>instanceof</code></td></tr><tr><td>8</td><td style="text-align:center">等价运算符</td><td style="text-align:center"><code>==</code>、<code>!=</code></td></tr><tr><td>9</td><td style="text-align:center">按位与</td><td style="text-align:center"><code>&amp;</code></td></tr><tr><td>10</td><td style="text-align:center">按位异或</td><td style="text-align:center"><code>^</code></td></tr><tr><td>11</td><td style="text-align:center">按位或</td><td style="text-align:center">`</td><td>`</td></tr><tr><td>12</td><td style="text-align:center">条件与</td><td style="text-align:center"><code>&amp;&amp;</code></td></tr><tr><td>13</td><td style="text-align:center">条件或</td><td style="text-align:center">`</td><td></td><td>`</td></tr><tr><td>14</td><td style="text-align:center">三元运算符</td><td style="text-align:center"><code>? :</code></td></tr><tr><td>15</td><td style="text-align:center">赋值运算符</td><td style="text-align:center"><code>=</code>、<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code></td></tr><tr><td>16</td><td style="text-align:center">位赋值运算符</td><td style="text-align:center"><code>&amp;=</code>、`</td><td>=<code>、</code>&lt;&lt;=<code>、</code>&gt;&gt;=<code>、</code>&gt;&gt;&gt;=`</td></tr></tbody></table></div><blockquote><p>开发建议：</p><ol><li>不要过多的依赖运算的优先级来控制表达式的执行顺序，这样可读性太差，尽量<code>使用()来控制</code>表达式的执行顺序。</li><li>不要把一个表达式写得过于复杂，如果一个表达式过于复杂，则把它<code>分成几步</code>来完成。例如：<br>​ (num1 + num2) * 2 &gt; num3 &amp;&amp; num2 &gt; num3 ? num3 : num1 + num2;</li></ol></blockquote><h2 id="8-【拓展】关于字符集"><a href="#8-【拓展】关于字符集" class="headerlink" title="8. 【拓展】关于字符集"></a>8. 【拓展】关于字符集</h2><h3 id="8-1-字符集"><a href="#8-1-字符集" class="headerlink" title="8.1 字符集"></a>8.1 字符集</h3><ul><li><strong>编码与解码</strong></li></ul><p>计算机中储存的信息都是用<code>二进制数</code>表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为<code>编码</code> 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为<code>解码</code> 。</p><ul><li><p><strong>字符编码（Character Encoding）</strong> : 就是一套自然语言的字符与二进制数之间的对应规则。</p></li><li><p><strong>字符集</strong>：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</p></li></ul><h3 id="8-2-ASCII码"><a href="#8-2-ASCII码" class="headerlink" title="8.2 ASCII码"></a>8.2 ASCII码</h3><ul><li>ASCII码（American Standard Code for Information Interchange，美国信息交换标准代码）：上个世纪60年代，美国制定了一套字符编码，对<code>英语字符</code>与二进制位之间的关系，做了统一规定。这被称为ASCII码。</li><li>ASCII码用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</li><li>基本的ASCII字符集，使用7位（bits）表示一个字符（最前面的1位统一规定为0），共<code>128个</code>字符。比如：空格“SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。</li><li>缺点：不能表示所有字符。</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20220513095907601.png" alt="image-20220513095907601"></p><h3 id="8-3-ISO-8859-1字符集"><a href="#8-3-ISO-8859-1字符集" class="headerlink" title="8.3 ISO-8859-1字符集"></a>8.3 ISO-8859-1字符集</h3><ul><li>拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰语、德语、意大利语、葡萄牙语等</li><li>ISO-8859-1使用单字节编码，兼容ASCII编码。</li></ul><h3 id="8-4-GBxxx字符集"><a href="#8-4-GBxxx字符集" class="headerlink" title="8.4 GBxxx字符集"></a>8.4 GBxxx字符集</h3><ul><li>GB就是国标的意思，是为了<code>显示中文</code>而设计的一套字符集。</li><li><strong>GB2312</strong>：简体中文码表。一个小于127的字符的意义与原来相同，即向下兼容ASCII码。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含<code>7000多个简体汉字</code>，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，这就是常说的”全角”字符，而原来在127号以下的那些符号就叫”半角”字符了。</li><li><strong>GBK</strong>：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了<code>双字节</code>编码方案，共收录了<code>21003个</code>汉字，完全兼容GB2312标准，同时支持<code>繁体汉字</code>以及日韩汉字等。</li><li><strong>GB18030</strong>：最新的中文码表。收录汉字<code>70244个</code>，采用<code>多字节</code>编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。</li></ul><h3 id="8-5-Unicode码"><a href="#8-5-Unicode码" class="headerlink" title="8.5 Unicode码"></a>8.5 Unicode码</h3><ul><li><p>Unicode编码为表达<code>任意语言的任意字符</code>而设计，也称为统一码、标准万国码。Unicode 将世界上所有的文字用<code>2个字节</code>统一进行编码，为每个字符设定唯一的二进制编码，以满足跨语言、跨平台进行文本处理的要求。</p></li><li><p>Unicode 的缺点：这里有三个问题：</p><ul><li>第一，英文字母只用一个字节表示就够了，如果用更多的字节存储是<code>极大的浪费</code>。</li><li>第二，如何才能<code>区别Unicode和ASCII</code>？计算机怎么知道两个字节表示一个符号，而不是分别表示两个符号呢？</li><li>第三，如果和GBK等双字节编码方式一样，用最高位是1或0表示两个字节和一个字节，就少了很多值无法用于表示字符，<code>不够表示所有字符</code>。</li></ul></li><li>Unicode在很长一段时间内无法推广，直到互联网的出现，为解决Unicode如何在网络上传输的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现。具体来说，有三种编码方案，UTF-8、UTF-16和UTF-32。</li></ul><h3 id="8-6-UTF-8"><a href="#8-6-UTF-8" class="headerlink" title="8.6 UTF-8"></a>8.6 UTF-8</h3><ul><li>Unicode是字符集，UTF-8、UTF-16、UTF-32是三种<code>将数字转换到程序数据</code>的编码方案。顾名思义，UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。其中，UTF-8 是在互联网上<code>使用最广</code>的一种 Unicode 的实现方式。</li><li>互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。UTF-8 是一种<code>变长的编码方式</code>。它可以使用 1-4 个字节表示一个符号它使用一至四个字节为每个字符编码，编码规则：<ol><li>128个US-ASCII字符，只需一个字节编码。</li><li>拉丁文等字符，需要二个字节编码。 </li><li>大部分常用字（含中文），使用三个字节编码。</li><li>其他极少使用的Unicode辅助字符，使用四字节编码。</li></ol></li></ul><ul><li>举例</li></ul><p>Unicode符号范围  | UTF-8编码方式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(十六进制)           | （二进制）</span><br><span class="line"></span><br><span class="line">————————————————————|—–—–—–—–—–—–—–—–—–—–—–—–—–—–</span><br><span class="line"></span><br><span class="line">0000 0000-0000 007F | 0xxxxxxx（兼容原来的ASCII）</span><br><span class="line"></span><br><span class="line">0000 0080-0000 07FF | 110xxxxx 10xxxxxx</span><br><span class="line"></span><br><span class="line">0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line"></span><br><span class="line">0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/image-20220525164636164.png" alt="image-20220525164636164"></p><h3 id="8-7-小结"><a href="#8-7-小结" class="headerlink" title="8.7 小结"></a>8.7 小结</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/字符集.jpg" alt="字符集"></p><blockquote><p>注意：在中文操作系统上，ANSI（美国国家标准学会、AMERICAN NATIONAL STANDARDS INSTITUTE: ANSI）编码即为GBK；在英文操作系统上，ANSI编码即为ISO-8859-1。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第02章-变量与运算符&quot;&gt;&lt;a href=&quot;#第02章-变量与运算符&quot; class=&quot;headerlink&quot; title=&quot;第02章_变量与运算符&quot;&gt;&lt;/a&gt;第02章_变量与运算符&lt;/h1&gt;&lt;p&gt;讲师：尚硅谷-宋红康（江湖人称：康师傅）&lt;/p&gt;
&lt;p&gt;官网：&lt;a </summary>
      
    
    
    
    <category term="Java2023" scheme="http://example.com/categories/Java2023/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第03章_流程控制语句</title>
    <link href="http://example.com/2023/02/18/java2023/%E7%AC%AC03%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"/>
    <id>http://example.com/2023/02/18/java2023/%E7%AC%AC03%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</id>
    <published>2023-02-18T12:37:01.000Z</published>
    <updated>2023-02-19T07:35:35.690Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第03章-流程控制语句"><a href="#第03章-流程控制语句" class="headerlink" title="第03章_流程控制语句"></a>第03章_流程控制语句</h1><p>讲师：尚硅谷-宋红康（江湖人称：康师傅）</p><p>官网：<a href="http://www.atguigu.com/">http://www.atguigu.com</a></p><hr><h2 id="本章专题与脉络"><a href="#本章专题与脉络" class="headerlink" title="本章专题与脉络"></a>本章专题与脉络</h2><p><img src="/2023/02/18/java2023/%E7%AC%AC03%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/第1阶段：Java基本语法-第03章.png" alt="第1阶段：Java基本语法-第03章" style="zoom:45%;"></p><hr><ul><li><p>流程控制语句是用来控制程序中各<code>语句执行顺序</code>的语句，可以把语句组合成能<code>完成一定功能</code>的小逻辑模块。</p></li><li><p>程序设计中规定的<code>三种</code>流程结构，即：</p><ul><li><strong>顺序结构</strong><ul><li>程序从上到下逐行地执行，中间没有任何判断和跳转。</li></ul></li><li><strong>分支结构</strong><ul><li>根据条件，选择性地执行某段代码。</li><li>有<code>if…else</code>和<code>switch-case</code>两种分支语句。</li></ul></li><li><strong>循环结构</strong><ul><li>根据循环条件，重复性的执行某段代码。</li><li>有<code>for</code>、<code>while</code>、<code>do-while</code>三种循环语句。</li><li>补充：JDK5.0 提供了<code>foreach</code>循环，方便的遍历集合、数组元素。（第12章集合中讲解）</li></ul></li></ul></li><li>生活中、工业生产中流程控制举例</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC03%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/洗衣流程.jpg" alt="洗衣流程" style="zoom:100%;"></p><h2 id="1-顺序结构"><a href="#1-顺序结构" class="headerlink" title="1. 顺序结构"></a>1. 顺序结构</h2><p>顺序结构就是程序<code>从上到下逐行</code>地执行。表达式语句都是顺序执行的。并且上一行对某个变量的修改对下一行会产生影响。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC03%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20211218093256771.png" alt="image-20211218093256771"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StatementTest</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;x = &quot;</span> + x);</span><br><span class="line">        System.out.println(<span class="string">&quot;y = &quot;</span> + y);</span><br><span class="line">        <span class="comment">//对x、y的值进行修改</span></span><br><span class="line">        x++;</span><br><span class="line">        y = <span class="number">2</span> * x + y;</span><br><span class="line">        x = x * <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;x = &quot;</span> + x);</span><br><span class="line">        System.out.println(<span class="string">&quot;y = &quot;</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java中定义变量时采用合法的<code>前向引用</code>。如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> num1 + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误形式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> num1 + <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-分支语句"><a href="#2-分支语句" class="headerlink" title="2. 分支语句"></a>2. 分支语句</h2><h3 id="2-1-if-else条件判断结构"><a href="#2-1-if-else条件判断结构" class="headerlink" title="2.1 if-else条件判断结构"></a>2.1 if-else条件判断结构</h3><h4 id="2-1-1-基本语法"><a href="#2-1-1-基本语法" class="headerlink" title="2.1.1 基本语法"></a>2.1.1 基本语法</h4><p><strong>结构1：单分支条件判断：if</strong></p><p><code>格式：</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)｛</span><br><span class="line">  语句块;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p><code>说明：</code>条件表达式必须是布尔表达式（关系表达式或逻辑表达式）或 布尔变量。</p><p><code>执行流程：</code></p><ol><li>首先判断条件表达式看其结果是true还是false</li><li>如果是true就执行语句块</li><li>如果是false就不执行语句块</li></ol><p><img src="/2023/02/18/java2023/%E7%AC%AC03%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20220514160139926.png" alt="image-20220514160139926"></p><p><strong>结构2：双分支条件判断：if…else</strong></p><p><code>格式：</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式) &#123; </span><br><span class="line">  语句块<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  语句块<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>执行流程：</code></p><ol><li>首先判断条件表达式看其结果是true还是false</li><li>如果是true就执行语句块1</li><li>如果是false就执行语句块2</li></ol><p><img src="/2023/02/18/java2023/%E7%AC%AC03%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20220514160243421.png" alt="image-20220514160243421"></p><p><strong>结构3：多分支条件判断：if…else if…else</strong></p><p><code>格式：</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件表达式<span class="number">1</span>) &#123;</span><br><span class="line">  语句块<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (条件表达式<span class="number">2</span>) &#123;</span><br><span class="line">  语句块<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (条件表达式n) &#123;</span><br><span class="line"> 语句块n;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  语句块n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>说明：</code>一旦条件表达式为true，则进入执行相应的语句块。执行完对应的语句块之后，就跳出当前结构。</p><p><code>执行流程：</code></p><ol><li>首先判断关系表达式1看其结果是true还是false</li><li>如果是true就执行语句块1，然后结束当前多分支</li><li>如果是false就继续判断关系表达式2看其结果是true还是false</li><li>如果是true就执行语句块2，然后结束当前多分支</li><li>如果是false就继续判断关系表达式…看其结果是true还是false</li></ol><p>​    …</p><p>   n.  如果没有任何关系表达式为true，就执行语句块n+1，然后结束当前多分支。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC03%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20220514160538651.png" alt="image-20220514160538651"></p><h4 id="2-1-2-应用举例"><a href="#2-1-2-应用举例" class="headerlink" title="2.1.2 应用举例"></a>2.1.2 应用举例</h4><p><strong>案例1：</strong>成年人心率的正常范围是每分钟60-100次。体检时，如果心率不在此范围内，则提示需要做进一步的检查。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IfElseTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">heartBeats</span> <span class="operator">=</span> <span class="number">89</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(heartBeats &lt; <span class="number">60</span> || heartBeats &gt; <span class="number">100</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你需要做进一步的检查&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;体检结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例2：</strong>定义一个整数，判定是偶数还是奇数    </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IfElseTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(a % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(a + <span class="string">&quot;是偶数&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(a + <span class="string">&quot;是奇数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">岳小鹏参加Java考试，他和父亲岳不群达成承诺：</span><br><span class="line">如果：</span><br><span class="line">成绩为100分时，奖励一辆跑车；</span><br><span class="line">成绩为(80，99]时，奖励一辆山地自行车；</span><br><span class="line">当成绩为[60,80]时，奖励环球影城一日游；</span><br><span class="line">其它时，胖揍一顿。</span><br><span class="line"></span><br><span class="line">说明：默认成绩是在[0,100]范围内</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IfElseTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">67</span>;<span class="comment">//岳小鹏的期末成绩</span></span><br><span class="line">        <span class="comment">//写法一：默认成绩范围为[0,100]</span></span><br><span class="line">        <span class="keyword">if</span>(score == <span class="number">100</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;奖励一辆跑车&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &gt; <span class="number">80</span> &amp;&amp; score &lt;= <span class="number">99</span>)&#123;    <span class="comment">//错误的写法：&#125;else if(80 &lt; score &lt;= 99)&#123;</span></span><br><span class="line">            System.out.println(<span class="string">&quot;奖励一辆山地自行车&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &gt;= <span class="number">60</span> &amp;&amp; score &lt;= <span class="number">80</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;奖励环球影城玩一日游&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//else&#123;</span></span><br><span class="line">        <span class="comment">//System.out.println(&quot;胖揍一顿&quot;);</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//写法二：</span></span><br><span class="line">        <span class="comment">// 默认成绩范围为[0,100]</span></span><br><span class="line">        <span class="keyword">if</span>(score == <span class="number">100</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;奖励一辆跑车&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &gt; <span class="number">80</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;奖励一辆山地自行车&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &gt;= <span class="number">60</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;奖励环球影城玩一日游&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;胖揍一顿&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC03%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221027185234087.png" alt="image-20221027185234087"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC03%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221027185500389.png" alt="image-20221027185500389"></p><blockquote><p>当条件表达式之间是“<code>互斥</code>”关系时（即彼此没有交集），条件判断语句及执行语句间顺序无所谓。</p><p>当条件表达式之间是“<code>包含</code>”关系时，“<code>小上大下 / 子上父下</code>”，否则范围小的条件表达式将不可能被执行。</p></blockquote><h4 id="2-1-3-if…else嵌套"><a href="#2-1-3-if…else嵌套" class="headerlink" title="2.1.3 if…else嵌套"></a>2.1.3 if…else嵌套</h4><p>在 if 的语句块中，或者是在else语句块中，又包含了另外一个条件判断（可以是单分支、双分支、多分支），就构成了<code>嵌套结构</code>。</p><p><strong>执行的特点：</strong><br>（1）如果是嵌套在if语句块中的，只有当外部的if条件满足，才会去判断内部的条件<br>（2）如果是嵌套在else语句块中的，只有当外部的if条件不满足，进入else后，才会去判断内部的条件</p><p><strong>案例4：</strong>由键盘输入三个整数分别存入变量num1、num2、num3，对它们进行排序(使用 if-else if-else)，并且从小到大输出。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IfElseTest4</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明num1,num2,num3三个变量并赋值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">23</span>,num2 = <span class="number">32</span>,num3 = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(num1 &gt;= num2)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(num3 &gt;= num1)</span><br><span class="line">System.out.println(num2 + <span class="string">&quot;-&quot;</span> + num1 + <span class="string">&quot;-&quot;</span> + num3);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(num3 &lt;= num2)</span><br><span class="line">System.out.println(num3 + <span class="string">&quot;-&quot;</span> + num2 + <span class="string">&quot;-&quot;</span> + num1);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">System.out.println(num2 + <span class="string">&quot;-&quot;</span> + num3 + <span class="string">&quot;-&quot;</span> + num1);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123; <span class="comment">//num1 &lt; num2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(num3 &gt;= num2)&#123;</span><br><span class="line">System.out.println(num1 + <span class="string">&quot;-&quot;</span> + num2 + <span class="string">&quot;-&quot;</span> + num3);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num3 &lt;= num1)&#123;</span><br><span class="line">System.out.println(num3 + <span class="string">&quot;-&quot;</span> + num1 + <span class="string">&quot;-&quot;</span> + num2);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(num1 + <span class="string">&quot;-&quot;</span> + num3 + <span class="string">&quot;-&quot;</span> + num2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-4-其它说明"><a href="#2-1-4-其它说明" class="headerlink" title="2.1.4 其它说明"></a>2.1.4 其它说明</h4><ul><li>语句块只有一条执行语句时，一对<code>&#123;&#125;可以省略</code>，但建议保留</li><li>当if-else结构是“多选一”时，最后的<code>else是可选的</code>，根据需要可以省略</li></ul><h4 id="2-1-5-练习"><a href="#2-1-5-练习" class="headerlink" title="2.1.5 练习"></a>2.1.5 练习</h4><p><strong>练习1：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1)对下列代码，若有输出，指出输出结果。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">2</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (y &gt; <span class="number">2</span>) </span><br><span class="line">            System.out.println(x + y);</span><br><span class="line">       System.out.println(<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">       System.out.println(<span class="string">&quot;x is &quot;</span> + x);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>练习2：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//如果写成if(b=false)能编译通过吗？如果能，结果是？</span></span><br><span class="line"><span class="keyword">if</span>(b == <span class="literal">false</span>)  <span class="comment">//建议：if(!b)</span></span><br><span class="line">System.out.println(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(b)</span><br><span class="line">System.out.println(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!b)</span><br><span class="line">System.out.println(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">System.out.println(<span class="string">&quot;d&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>练习3：</strong></p><p>定义两个整数，分别为small 和 big，如果第一个整数small大于第二个整数big，就交换。输出显示small和big变量的值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IfElseExer3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">big</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (small &gt; big) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> small;</span><br><span class="line">            small = big;</span><br><span class="line">            big = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;small=&quot;</span> + small + <span class="string">&quot;,big=&quot;</span> + big);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习4：</strong>小明参加期末Java考试，通过考试成绩，判断其Java等级，成绩范围[0,100]</p><ul><li>90-100      优秀</li><li>80-89        好</li><li>70-79        良</li><li>60-69        及格</li><li>60以下    不及格</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="comment">//写法一：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IfElseExer4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;小明的期末Java成绩是：[0,100]&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">89</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (score &lt; <span class="number">0</span> || score &gt; <span class="number">100</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你的成绩是错误的&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">90</span> &amp;&amp; score &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你的成绩属于优秀&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">80</span> &amp;&amp; score &lt; <span class="number">90</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你的成绩属于好&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">70</span> &amp;&amp; score &lt; <span class="number">80</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你的成绩属于良&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">60</span> &amp;&amp; score &lt; <span class="number">70</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你的成绩属于及格&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你的成绩属于不及格&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="comment">//写法二：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IfElseExer4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;小明的期末Java成绩是：[0,100]&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">89</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (score &lt; <span class="number">0</span> || score &gt; <span class="number">100</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你的成绩是错误的&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">90</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你的成绩属于优秀&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">80</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你的成绩属于好&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">70</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你的成绩属于良&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你的成绩属于及格&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你的成绩属于不及格&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>练习5：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">编写程序，声明2个int型变量并赋值。判断两数之和，如果大于等于50，打印“hello world!”</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IfElseExer5</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">12</span>, num2 = <span class="number">32</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (num1 + num2 &gt;= <span class="number">50</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习6：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">编写程序，声明2个double型变量并赋值。判断第一个数大于10.0，且第2个数小于20.0，打印两数之和。否则，打印两数的乘积。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IfElseExer6</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">21.2</span>,d2 = <span class="number">12.3</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(d1 &gt; <span class="number">10.0</span> &amp;&amp; d2 &lt; <span class="number">20.0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;两数之和为：&quot;</span> + (d1 + d2));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;两数乘积为：&quot;</span> + (d1 * d2));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习7：判断水的温度</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果大于95℃，则打印“开水”；</span><br><span class="line"></span><br><span class="line">如果大于70℃且小于等于95℃，则打印“热水”；</span><br><span class="line"></span><br><span class="line">如果大于40℃且小于等于70℃，则打印“温水”；</span><br><span class="line"></span><br><span class="line">如果小于等于40℃，则打印“凉水”。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IfElseExer7</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">waterTemperature</span> <span class="operator">=</span> <span class="number">85</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(waterTemperature &gt; <span class="number">95</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;开水&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(waterTemperature &gt; <span class="number">70</span> &amp;&amp; waterTemperature &lt;= <span class="number">95</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;热水&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(waterTemperature &gt; <span class="number">40</span> &amp;&amp; waterTemperature &lt;= <span class="number">70</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;温水&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;凉水&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-switch-case选择结构"><a href="#2-2-switch-case选择结构" class="headerlink" title="2.2 switch-case选择结构"></a>2.2 switch-case选择结构</h3><h4 id="2-2-1-基本语法"><a href="#2-2-1-基本语法" class="headerlink" title="2.2.1 基本语法"></a>2.2.1 基本语法</h4><p><strong>语法格式：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">    <span class="keyword">case</span> 常量值<span class="number">1</span>:</span><br><span class="line">        语句块<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//break;</span></span><br><span class="line">    <span class="keyword">case</span> 常量值<span class="number">2</span>:</span><br><span class="line">        语句块<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//break; </span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">   [<span class="keyword">default</span>:</span><br><span class="line">        语句块n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行流程图：</strong></p><p><img src="/2023/02/18/java2023/%E7%AC%AC03%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20220514101841710.png" alt="image-20220514101841710"></p><p><strong>执行过程：</strong></p><p>第1步：根据switch中表达式的值，依次匹配各个case。如果表达式的值等于某个case中的常量值，则执行对应case中的执行语句。</p><p>第2步：执行完此case的执行语句以后，<br>​              情况1：如果遇到break,则执行break并跳出当前的switch-case结构<br>​                情况2：如果没有遇到break，则会继续执行当前case之后的其它case中的执行语句。—-&gt;case穿透<br>​                 …<br>​                直到遇到break关键字或执行完所有的case及default的执行语句，跳出当前的switch-case结构</p><p><strong>使用注意点：</strong></p><ul><li><p>switch(表达式)中表达式的值必须是下述几种类型之一：byte，short，char，int，枚举 (jdk 5.0)，String (jdk 7.0)；</p></li><li><p>case子句中的值必须是常量，不能是变量名或不确定的表达式值或范围；</p></li><li><p>同一个switch语句，所有case子句中的常量值互不相同；</p></li><li><p>break语句用来在执行完一个case分支后使程序跳出switch语句块；</p><p>如果没有break，程序会顺序执行到switch结尾；</p></li><li><p>default子句是可选的。同时，位置也是灵活的。当没有匹配的case时，执行default语句。</p></li></ul><h4 id="2-2-2-应用举例"><a href="#2-2-2-应用举例" class="headerlink" title="2.2.2 应用举例"></a>2.2.2 应用举例</h4><p><strong>案例1：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwitchCaseTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span>(num)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;zero&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;one&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;two&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;three&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;other&quot;</span>);</span><br><span class="line"><span class="comment">//break;</span></span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例2：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwitchCaseTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">season</span> <span class="operator">=</span> <span class="string">&quot;summer&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (season) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;spring&quot;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;summer&quot;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;autumn&quot;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;winter&quot;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;冬雪皑皑&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;季节输入有误&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">switch</span>(key)&#123;</span><br><span class="line"><span class="keyword">case</span> key &gt; <span class="number">0</span> :</span><br><span class="line">        System.out.println(<span class="string">&quot;正数&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> key &lt; <span class="number">0</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;负数&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;零&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例3：</strong>使用switch-case实现：对学生成绩大于60分的，输出“合格”。低于60分的，输出“不合格”。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SwitchCaseTest3</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">67</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">写法1：极不推荐</span></span><br><span class="line"><span class="comment">switch(score)&#123;</span></span><br><span class="line"><span class="comment">case 0:</span></span><br><span class="line"><span class="comment">System.out.println(&quot;不及格&quot;);</span></span><br><span class="line"><span class="comment">break;</span></span><br><span class="line"><span class="comment">case 1:</span></span><br><span class="line"><span class="comment">System.out.println(&quot;不及格&quot;);</span></span><br><span class="line"><span class="comment">break;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">case 60:</span></span><br><span class="line"><span class="comment">System.out.println(&quot;及格&quot;);</span></span><br><span class="line"><span class="comment">break;</span></span><br><span class="line"><span class="comment">//...略...</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写法2：</span></span><br><span class="line"><span class="keyword">switch</span>(score / <span class="number">10</span>)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;输入的成绩有误&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写法3：</span></span><br><span class="line"><span class="keyword">switch</span>(score / <span class="number">60</span>)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;输入的成绩有误&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-3-利用case的穿透性"><a href="#2-2-3-利用case的穿透性" class="headerlink" title="2.2.3 利用case的穿透性"></a>2.2.3 利用case的穿透性</h4><p>在switch语句中，如果case的后面不写break，将出现穿透现象，也就是一旦匹配成功，不会在判断下一个case的值，直接向后运行，直到遇到break或者整个switch语句结束，执行终止。</p><p><strong>案例4：</strong>编写程序：从键盘上输入2023年的“month”和“day”，要求通过程序输出输入的日期为2023年的第几天。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SwitchCaseTest4</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;请输入2023年的month:&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;请输入2023年的day:&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里就不针对month和day进行合法性的判断了，以后可以使用正则表达式进行校验。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">sumDays</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录总天数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写法1 ：不推荐（存在冗余的数据）</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">switch(month)&#123;</span></span><br><span class="line"><span class="comment">case 1:</span></span><br><span class="line"><span class="comment">sumDays = day;</span></span><br><span class="line"><span class="comment">break;</span></span><br><span class="line"><span class="comment">case 2:</span></span><br><span class="line"><span class="comment">sumDays = 31 + day;</span></span><br><span class="line"><span class="comment">break;</span></span><br><span class="line"><span class="comment">case 3:</span></span><br><span class="line"><span class="comment">sumDays = 31 + 28 + day;</span></span><br><span class="line"><span class="comment">break;</span></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">case 12:</span></span><br><span class="line"><span class="comment">//sumDays = 31 + 28 + ... + 30 + day;</span></span><br><span class="line"><span class="comment">break;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写法2：推荐</span></span><br><span class="line"><span class="keyword">switch</span>(month)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">sumDays += <span class="number">30</span>;<span class="comment">//这个30是代表11月份的满月天数</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">sumDays += <span class="number">31</span>;<span class="comment">//这个31是代表10月份的满月天数</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">sumDays += <span class="number">30</span>;<span class="comment">//这个30是代表9月份的满月天数</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">sumDays += <span class="number">31</span>;<span class="comment">//这个31是代表8月份的满月天数</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">sumDays += <span class="number">31</span>;<span class="comment">//这个31是代表7月份的满月天数</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">sumDays += <span class="number">30</span>;<span class="comment">//这个30是代表6月份的满月天数</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">sumDays += <span class="number">31</span>;<span class="comment">//这个31是代表5月份的满月天数</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">sumDays += <span class="number">30</span>;<span class="comment">//这个30是代表4月份的满月天数</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">sumDays += <span class="number">31</span>;<span class="comment">//这个31是代表3月份的满月天数</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">sumDays += <span class="number">28</span>;<span class="comment">//这个28是代表2月份的满月天数</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">sumDays += <span class="number">31</span>;<span class="comment">//这个31是代表1月份的满月天数</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">sumDays += day;<span class="comment">//这个day是代表当月的第几天</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(month + <span class="string">&quot;月&quot;</span> + day + <span class="string">&quot;日是2023年的第&quot;</span> + sumDays + <span class="string">&quot;天&quot;</span>);</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">scan.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>拓展：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">从键盘分别输入年、月、日，判断这一天是当年的第几天</span><br><span class="line"> </span><br><span class="line">注：判断一年是否是闰年的标准：</span><br><span class="line">   1）可以被4整除，但不可被100整除</span><br><span class="line">  或</span><br><span class="line">   2）可以被400整除</span><br><span class="line">   </span><br><span class="line">例如：1900，2200等能被4整除，但同时能被100整除，但不能被400整除，不是闰年</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwitchCaseTest04</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入year:&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;请输入month:&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;请输入day:&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断这一天是当年的第几天==&gt;从1月1日开始，累加到xx月xx日这一天</span></span><br><span class="line">        <span class="comment">//(1)[1,month-1]个月满月天数</span></span><br><span class="line">        <span class="comment">//(2)单独考虑2月份是否是29天（依据是看year是否是闰年）</span></span><br><span class="line">        <span class="comment">//(3)第month个月的day天</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明一个变量days，用来存储总天数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sumDays</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//累加[1,month-1]个月满月天数</span></span><br><span class="line">        <span class="keyword">switch</span> (month) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">                <span class="comment">//累加的1-11月</span></span><br><span class="line">                sumDays += <span class="number">30</span>;<span class="comment">//这个30是代表11月份的满月天数</span></span><br><span class="line">                <span class="comment">//这里没有break，继续往下走</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">                <span class="comment">//累加的1-10月</span></span><br><span class="line">                sumDays += <span class="number">31</span>;<span class="comment">//这个31是代表10月的满月天数</span></span><br><span class="line">                <span class="comment">//这里没有break，继续往下走</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">                sumDays += <span class="number">30</span>;<span class="comment">//9月</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">                sumDays += <span class="number">31</span>;<span class="comment">//8月</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                sumDays += <span class="number">31</span>;<span class="comment">//7月</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                sumDays += <span class="number">30</span>;<span class="comment">//6月</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                sumDays += <span class="number">31</span>;<span class="comment">//5月</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                sumDays += <span class="number">30</span>;<span class="comment">//4月</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                sumDays += <span class="number">31</span>;<span class="comment">//3月</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                sumDays += <span class="number">28</span>;<span class="comment">//2月</span></span><br><span class="line">                <span class="comment">//在这里考虑是否可能是29天</span></span><br><span class="line">                <span class="keyword">if</span> (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span> || year % <span class="number">400</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    sumDays++;<span class="comment">//多加1天</span></span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                sumDays += <span class="number">31</span>;<span class="comment">//1月</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                sumDays += day;<span class="comment">//第month月的day天</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出结果</span></span><br><span class="line">        System.out.println(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + day + <span class="string">&quot;日是这一年的第&quot;</span> + sumDays + <span class="string">&quot;天&quot;</span>);</span><br><span class="line"></span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例5：</strong>根据指定的月份输出对应季节</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 需求：指定一个月份，输出该月份对应的季节。一年有四季:</span></span><br><span class="line"><span class="comment"> * 3,4,5春季</span></span><br><span class="line"><span class="comment"> * 6,7,8夏季</span></span><br><span class="line"><span class="comment"> * 9,10,11秋季</span></span><br><span class="line"><span class="comment"> * 12,1,2冬季</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwitchCaseTest5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入月份：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">switch(month) &#123;</span></span><br><span class="line"><span class="comment">            case 1:</span></span><br><span class="line"><span class="comment">                System.out.println(&quot;冬季&quot;);</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            case 2:</span></span><br><span class="line"><span class="comment">                System.out.println(&quot;冬季&quot;);</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            case 3:</span></span><br><span class="line"><span class="comment">                System.out.println(&quot;春季&quot;);</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            case 4:</span></span><br><span class="line"><span class="comment">                System.out.println(&quot;春季&quot;);</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            case 5:</span></span><br><span class="line"><span class="comment">                System.out.println(&quot;春季&quot;);</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            case 6:</span></span><br><span class="line"><span class="comment">                System.out.println(&quot;夏季&quot;);</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            case 7:</span></span><br><span class="line"><span class="comment">                System.out.println(&quot;夏季&quot;);</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            case 8:</span></span><br><span class="line"><span class="comment">                System.out.println(&quot;夏季&quot;);</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            case 9:</span></span><br><span class="line"><span class="comment">                System.out.println(&quot;秋季&quot;);</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            case 10:</span></span><br><span class="line"><span class="comment">                System.out.println(&quot;秋季&quot;);</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            case 11:</span></span><br><span class="line"><span class="comment">                System.out.println(&quot;秋季&quot;);</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            case 12:</span></span><br><span class="line"><span class="comment">                System.out.println(&quot;冬季&quot;);</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            default:</span></span><br><span class="line"><span class="comment">                System.out.println(&quot;你输入的月份有误&quot;);</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 改进版</span></span><br><span class="line">        <span class="keyword">switch</span>(month) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;冬季&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;春季&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;夏季&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;秋季&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;你输入的月份有误&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>常见错误实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(month)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>|<span class="number">4</span>|<span class="number">5</span>:<span class="comment">//3|4|5 用了位运算符，11 | 100 | 101结果是 111是7</span></span><br><span class="line">        System.out.println(<span class="string">&quot;春季&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>|<span class="number">7</span>|<span class="number">8</span>:<span class="comment">//6|7|8用了位运算符，110 | 111 | 1000结果是1111是15</span></span><br><span class="line">        System.out.println(<span class="string">&quot;夏季&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>|<span class="number">10</span>|<span class="number">11</span>:<span class="comment">//9|10|11用了位运算符，1001 | 1010 | 1011结果是1011是11</span></span><br><span class="line">        System.out.println(<span class="string">&quot;秋季&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>|<span class="number">1</span>|<span class="number">2</span>:<span class="comment">//12|1|2 用了位运算符，1100 | 1 | 10 结果是1111，是15</span></span><br><span class="line">        System.out.println(<span class="string">&quot;冬季&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;输入有误&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用if-else实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((month == <span class="number">1</span>) || (month == <span class="number">2</span>) || (month == <span class="number">12</span>)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;冬季&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((month == <span class="number">3</span>) || (month == <span class="number">4</span>) || (month == <span class="number">5</span>)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;春季&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((month == <span class="number">6</span>) || (month == <span class="number">7</span>) || (month == <span class="number">8</span>)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;夏季&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((month == <span class="number">9</span>) || (month == <span class="number">10</span>) || (month == <span class="number">11</span>)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;秋季&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;你输入的月份有误&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-4-if-else语句与switch-case语句比较"><a href="#2-2-4-if-else语句与switch-case语句比较" class="headerlink" title="2.2.4 if-else语句与switch-case语句比较"></a>2.2.4 if-else语句与switch-case语句比较</h4><ul><li>结论：凡是使用switch-case的结构都可以转换为if-else结构。反之，不成立。</li><li><p>开发经验：如果既可以使用switch-case，又可以使用if-else，建议使用switch-case。因为效率稍高。</p></li><li><p>细节对比：</p><ul><li>if-else语句优势<ul><li>if语句的条件是一个布尔类型值，if条件表达式为true则进入分支，可以用于范围的判断，也可以用于等值的判断，<code>使用范围更广</code>。</li><li>switch语句的条件是一个常量值（byte,short,int,char,枚举,String），只能判断某个变量或表达式的结果是否等于某个常量值，<code>使用场景较狭窄</code>。</li></ul></li><li>switch语句优势<ul><li>当条件是判断某个变量或表达式是否等于某个固定的常量值时，使用if和switch都可以，习惯上使用switch更多。因为<code>效率稍高</code>。当条件是区间范围的判断时，只能使用if语句。</li><li>使用switch可以利用<code>穿透性</code>，同时执行多个分支，而if…else没有穿透性。</li></ul></li></ul></li><li><p><strong>案例：只能使用 if-else</strong></p><p>从键盘输入一个整数，判断是正数、负数、还是零。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IfOrSwitchDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;请输入整数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(num + <span class="string">&quot;是正整数&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(num + <span class="string">&quot;是负整数&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(num + <span class="string">&quot;是零&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-5-练习"><a href="#2-2-5-练习" class="headerlink" title="2.2.5 练习"></a>2.2.5 练习</h4><p><strong>练习1：</strong>从键盘输入星期的整数值，输出星期的英文单词</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwitchCaseExer1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义指定的星期</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入星期值：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">weekday</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//switch语句实现选择</span></span><br><span class="line">        <span class="keyword">switch</span>(weekday) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Monday&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Tuesday&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Wednesday&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Thursday&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Friday&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Saturday&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Sunday&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;你输入的星期值有误！&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习2：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">使用 <span class="keyword">switch</span> 把小写类型的 <span class="type">char</span>型转为大写。只转换 a, b, c, d, e. 其它的输出 “other”。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwitchCaseExer2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> <span class="variable">word</span> <span class="operator">=</span> <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (word) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;E&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span> :</span><br><span class="line">                System.out.println(<span class="string">&quot;other&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">编写程序：从键盘上读入一个学生成绩，存放在变量score中，根据score的值输出其对应的成绩等级：</span><br><span class="line"></span><br><span class="line">score&gt;=90           等级:  A</span><br><span class="line">70&lt;=score&lt;90        等级:  B    </span><br><span class="line">60&lt;=score&lt;70        等级:  C</span><br><span class="line">score&lt;60            等级:  D</span><br><span class="line"></span><br><span class="line">方式一：使用if-else</span><br><span class="line">方式二：使用switch-case:  score / 10:   0 - 10</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwitchCaseExer3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入学生成绩：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> grade;<span class="comment">//记录学生等级</span></span><br><span class="line">        <span class="comment">//方式1：</span></span><br><span class="line"><span class="comment">//        if(score &gt;= 90)&#123;</span></span><br><span class="line"><span class="comment">//            grade = &#x27;A&#x27;;</span></span><br><span class="line"><span class="comment">//        &#125;else if(score &gt;= 70 &amp;&amp; score &lt; 90)&#123;</span></span><br><span class="line"><span class="comment">//            grade = &#x27;B&#x27;;</span></span><br><span class="line"><span class="comment">//        &#125;else if(score &gt;= 60 &amp;&amp; score &lt; 70)&#123;</span></span><br><span class="line"><span class="comment">//            grade = &#x27;C&#x27;;</span></span><br><span class="line"><span class="comment">//        &#125;else&#123;</span></span><br><span class="line"><span class="comment">//            grade = &#x27;D&#x27;;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式2：</span></span><br><span class="line">        <span class="keyword">switch</span>(score / <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">                grade = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                grade = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                grade = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span> :</span><br><span class="line">                grade = <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;学生成绩为&quot;</span> + score + <span class="string">&quot;,对应的等级为&quot;</span> + grade);</span><br><span class="line"></span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习4：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">编写一个程序，为一个给定的年份找出其对应的中国生肖。中国的生肖基于12年一个周期，每年用一个动物代表：rat、ox、tiger、rabbit、dragon、snake、horse、sheep、monkey、rooster、dog、pig。</span><br><span class="line"></span><br><span class="line">提示：2022年：虎   2022 % 12 == 6 </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC03%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20220314005350344.png" alt="image-20220314005350344"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 18:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwitchCaseExer4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//从键盘输入一个年份</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入年份：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">        input.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断</span></span><br><span class="line">        <span class="keyword">switch</span>(year % <span class="number">12</span>)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                System.out.println(year + <span class="string">&quot;是猴年&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                System.out.println(year + <span class="string">&quot;是鸡年&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                System.out.println(year + <span class="string">&quot;是狗年&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                System.out.println(year + <span class="string">&quot;是猪年&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                System.out.println(year + <span class="string">&quot;是鼠年&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                System.out.println(year + <span class="string">&quot;是牛年&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                System.out.println(year + <span class="string">&quot;是虎年&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                System.out.println(year + <span class="string">&quot;是兔年&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                System.out.println(year + <span class="string">&quot;是龙年&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">                System.out.println(year + <span class="string">&quot;是蛇年&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">                System.out.println(year + <span class="string">&quot;是马年&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">                System.out.println(year + <span class="string">&quot;是羊年&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(year + <span class="string">&quot;输入错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习5：押宝游戏</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">随机产生3个1-6的整数，如果三个数相等，那么称为“豹子”，如果三个数之和大于9，称为“大”，如果三个数之和小于等于9，称为“小”，用户从键盘输入押的是“豹子”、“大”、“小”，并判断是否猜对了</span><br><span class="line"></span><br><span class="line">提示：随机数  Math.random()产生 [0,1)范围内的小数</span><br><span class="line">     如何获取[a,b]范围内的随机整数呢？(int)(Math.random() * (b - a + 1)) + a</span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC03%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/1659112038716.png" alt="1659112038716"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwitchCaseExer5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1、随机产生3个1-6的整数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random()*<span class="number">6</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random()*<span class="number">6</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random()*<span class="number">6</span> + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、押宝</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;请押宝（豹子、大、小）：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">ya</span> <span class="operator">=</span> input.next();</span><br><span class="line">        input.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、判断结果</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//switch支持String类型</span></span><br><span class="line">        <span class="keyword">switch</span> (ya)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;豹子&quot;</span>: result = a == b &amp;&amp; b == c; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;大&quot;</span>: result = a + b + c &gt; <span class="number">9</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;小&quot;</span>: result = a + b + c &lt;= <span class="number">9</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:System.out.println(<span class="string">&quot;输入有误！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;a,b,c分别是：&quot;</span> + a +<span class="string">&quot;,&quot;</span> + b +<span class="string">&quot;,&quot;</span> + c );</span><br><span class="line">        System.out.println(result ? <span class="string">&quot;猜中了&quot;</span> : <span class="string">&quot;猜错了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习6：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">使用<span class="keyword">switch</span>语句改写下列<span class="keyword">if</span>语句：</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">1</span>)</span><br><span class="line">x+=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="number">2</span>)</span><br><span class="line">x+=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="number">3</span>)</span><br><span class="line">x+=<span class="number">16</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">x+=<span class="number">34</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(a)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        x += <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        x += <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        x += <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span> :</span><br><span class="line">        x += <span class="number">34</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-循环语句"><a href="#3-循环语句" class="headerlink" title="3. 循环语句"></a>3. 循环语句</h2><ul><li><p>理解：循环语句具有在<code>某些条件</code>满足的情况下，<code>反复执行</code>特定代码的功能。</p></li><li><p>循环结构分类：</p><ul><li>for 循环</li><li>while 循环</li><li>do-while 循环 </li></ul></li><li><p>循环结构<code>四要素</code>：</p><ul><li>初始化部分</li><li>循环条件部分</li><li>循环体部分</li><li>迭代部分</li></ul></li></ul><h3 id="3-1-for循环"><a href="#3-1-for循环" class="headerlink" title="3.1  for循环"></a>3.1  for循环</h3><h4 id="3-1-1-基本语法"><a href="#3-1-1-基本语法" class="headerlink" title="3.1.1 基本语法"></a>3.1.1 基本语法</h4><p><strong>语法格式：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (①初始化部分; ②循环条件部分; ④迭代部分)｛</span><br><span class="line">         ③循环体部分;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p><strong>执行过程：</strong>①-②-③-④-②-③-④-②-③-④-…..-②</p><p><strong>图示：</strong></p><p><img src="/2023/02/18/java2023/%E7%AC%AC03%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20220315013023236.png" alt="image-20220315013023236" style="zoom:80%;"></p><p><strong>说明：</strong></p><ul><li>for(;;)中的两个；不能多也不能少</li><li>①初始化部分可以声明多个变量，但必须是同一个类型，用逗号分隔</li><li>②循环条件部分为boolean类型表达式，当值为false时，退出循环</li><li>④可以有多个变量更新，用逗号分隔</li></ul><h4 id="3-1-2-应用举例"><a href="#3-1-2-应用举例" class="headerlink" title="3.1.2 应用举例"></a>3.1.2 应用举例</h4><p><strong>案例1：使用for循环重复执行某些语句</strong></p><p>题目：输出5行HelloWorld</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//需求1：控制台输出5行Hello World!</span></span><br><span class="line"><span class="comment">//写法1：</span></span><br><span class="line"><span class="comment">//System.out.println(&quot;Hello World!&quot;);</span></span><br><span class="line"><span class="comment">//System.out.println(&quot;Hello World!&quot;);</span></span><br><span class="line"><span class="comment">//System.out.println(&quot;Hello World!&quot;);</span></span><br><span class="line"><span class="comment">//System.out.println(&quot;Hello World!&quot;);</span></span><br><span class="line"><span class="comment">//System.out.println(&quot;Hello World!&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写法2：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">5</span>;i++)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例2：格式的多样性</strong></p><p>题目：写出输出的结果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForTest2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(System.out.print(<span class="string">&quot;a&quot;</span>);num &lt; <span class="number">3</span>;System.out.print(<span class="string">&quot;c&quot;</span>),num++)&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例3：累加的思想</strong></p><p>题目：遍历1-100以内的偶数，并获取偶数的个数，获取所有的偶数的和</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForTest3</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录偶数的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录偶数的和</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                count++;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//System.out.println(&quot;偶数的个数为：&quot; + count);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;偶数的个数为：&quot;</span> + count);</span><br><span class="line">        System.out.println(<span class="string">&quot;偶数的总和为：&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例4：结合分支结构使用</strong></p><p>题目：输出所有的水仙花数，所谓水仙花数是指一个3位数，其各个位上数字立方和等于其本身。例如： <code>153 = 1*1*1 + 3*3*3 + 5*5*5</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForTest4</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//定义统计变量，初始化值是0</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取三位数，用for循环实现</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">100</span>; x &lt; <span class="number">1000</span>; x++) &#123;</span><br><span class="line"><span class="comment">//获取三位数的个位，十位，百位</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ge</span> <span class="operator">=</span> x % <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">shi</span> <span class="operator">=</span> x / <span class="number">10</span> % <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">bai</span> <span class="operator">=</span> x / <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断这个三位数是否是水仙花数，如果是，统计变量++</span></span><br><span class="line"><span class="keyword">if</span>((ge*ge*ge+shi*shi*shi+bai*bai*bai) == x) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;水仙花数：&quot;</span> + x);</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出统计结果就可以了</span></span><br><span class="line">System.out.println(<span class="string">&quot;水仙花数共有&quot;</span>+count+<span class="string">&quot;个&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拓展：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">打印出四位数字中“个位+百位”等于“十位+千位”并且个位数为偶数，千位数为奇数的数字，并打印符合条件的数字的个数。</span><br></pre></td></tr></table></figure><p><strong>案例5：结合break的使用</strong></p><p>说明：输入两个正整数m和n，求其最大公约数和最小公倍数。</p><p>比如：12和20的最大公约数是4，最小公倍数是60。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 17:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForTest5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//需求1：最大公约数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">12</span>, n = <span class="number">20</span>;</span><br><span class="line">        <span class="comment">//取出两个数中的较小值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> (m &lt; n) ? m : n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> min; i &gt;= <span class="number">1</span>; i--) &#123;<span class="comment">//for(int i = 1;i &lt;= min;i++)&#123;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (m % i == <span class="number">0</span> &amp;&amp; n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;最大公约数是：&quot;</span> + i); <span class="comment">//公约数</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//跳出当前循环结构</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//需求2：最小公倍数</span></span><br><span class="line">        <span class="comment">//取出两个数中的较大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> (m &gt; n) ? m : n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> max; i &lt;= m * n; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i % m == <span class="number">0</span> &amp;&amp; i % n == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;最小公倍数是：&quot;</span> + i);<span class="comment">//公倍数</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：</p><p>1、我们可以在循环中使用break。一旦执行break，就跳出当前循环结构。</p><p>2、小结：如何结束一个循环结构？</p><p>​      结束情况1：循环结构中的循环条件部分返回false</p><p>​      结束情况2：循环结构中执行了break。</p><p>3、如果一个循环结构不能结束，那就是一个死循环！我们开发中要避免出现死循环。</p></blockquote><h4 id="3-1-3-练习"><a href="#3-1-3-练习" class="headerlink" title="3.1.3 练习"></a>3.1.3 练习</h4><p><strong>练习1：</strong>打印1~100之间所有奇数的和</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForExer1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录奇数的和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;奇数总和为：&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习2：</strong>打印1~100之间所有是7的倍数的整数的个数及总和（体会设置计数器的思想）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForExer2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录总和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">7</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                sum += i;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;1~100之间所有是7的倍数的整数的和为：&quot;</span> + sum);</span><br><span class="line">        System.out.println(<span class="string">&quot;1~100之间所有是7的倍数的整数的个数为：&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习3：</strong></p><p>编写程序从1循环到150，并在每行打印一个值，另外在每个3的倍数行上打印出“foo”,在每个5的倍数行上打印“biz”,在每个7的倍数行上打印输出“baz”。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC03%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20220315013722962.png" alt="image-20220315013722962" style="zoom:67%;"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForExer3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">150</span>; i++) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;foo\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">5</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;biz\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">7</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;baz\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-while循环"><a href="#3-2-while循环" class="headerlink" title="3.2 while循环"></a>3.2 while循环</h3><h4 id="3-2-1-基本语法"><a href="#3-2-1-基本语法" class="headerlink" title="3.2.1 基本语法"></a>3.2.1 基本语法</h4><p><strong>语法格式：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">①初始化部分</span><br><span class="line"><span class="keyword">while</span>(②循环条件部分)｛</span><br><span class="line">    ③循环体部分;</span><br><span class="line">    ④迭代部分;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行过程：</strong>①-②-③-④-②-③-④-②-③-④-…-②</p><p><strong>图示：</strong></p><p><img src="/2023/02/18/java2023/%E7%AC%AC03%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20220315013023236.png" alt="image-20220315013023236" style="zoom:80%;"></p><p><strong>说明：</strong></p><ul><li>while(循环条件)中循环条件必须是boolean类型。</li><li>注意不要忘记声明④迭代部分。否则，循环将不能结束，变成死循环。</li><li>for循环和while循环可以相互转换。二者没有性能上的差别。实际开发中，根据具体结构的情况，选择哪个格式更合适、美观。</li><li>for循环与while循环的区别：初始化条件部分的作用域不同。</li></ul><h4 id="3-2-2-应用举例"><a href="#3-2-2-应用举例" class="headerlink" title="3.2.2 应用举例"></a>3.2.2 应用举例</h4><p><strong>案例1：</strong>输出5行HelloWorld!</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WhileTest1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt;= <span class="number">5</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例2：</strong>遍历1-100的偶数，并计算所有偶数的和、偶数的个数（累加的思想）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WhileTest2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//遍历1-100的偶数，并计算所有偶数的和、偶数的个数（累加的思想）</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录1-100所有的偶数的和</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录1-100之间偶数的个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(num &lt;= <span class="number">100</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(num % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(num);</span><br><span class="line">sum += num;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代条件</span></span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;偶数的总和为：&quot;</span> + sum);</span><br><span class="line">System.out.println(<span class="string">&quot;偶数的个数为：&quot;</span> + count);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例3：</strong>猜数字游戏</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">随机生成一个100以内的数，猜这个随机数是多少？</span><br><span class="line"></span><br><span class="line">从键盘输入数，如果大了，提示大了；如果小了，提示小了；如果对了，就不再猜了，并统计一共猜了多少次。</span><br><span class="line"></span><br><span class="line">提示：生成一个[a,b] 范围的随机数的方式：(int)(Math.random() * (b - a + 1) + a)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 16:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuessNumber</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取一个随机数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">random</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * <span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录猜的次数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实例化Scanner</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个整数(1-100):&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">guess</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (guess != random) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (guess &gt; random) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;猜大了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (guess &lt; random) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;猜小了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;请输入一个整数(1-100):&quot;</span>);</span><br><span class="line">            guess = scan.nextInt();</span><br><span class="line"><span class="comment">//累加猜的次数</span></span><br><span class="line">            count++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;猜中了！&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;一共猜了&quot;</span> + count + <span class="string">&quot;次&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例4：折纸珠穆朗玛峰</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">世界最高山峰是珠穆朗玛峰，它的高度是8848.86米，假如我有一张足够大的纸，它的厚度是0.1毫米。</span><br><span class="line">请问，我折叠多少次，可以折成珠穆朗玛峰的高度?</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 19:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZFTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个计数器，初始值为0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义珠穆朗玛峰的高度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">zf</span> <span class="operator">=</span> <span class="number">8848860</span>;<span class="comment">//单位：毫米</span></span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">paper</span> <span class="operator">=</span> <span class="number">0.1</span>;<span class="comment">//单位：毫米</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(paper &lt; zf)&#123;</span><br><span class="line">            <span class="comment">//在循环中执行累加，对应折叠了多少次</span></span><br><span class="line">            count++;</span><br><span class="line">            paper *= <span class="number">2</span>;<span class="comment">//循环的执行过程中每次纸张折叠，纸张的厚度要加倍</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印计数器的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;需要折叠：&quot;</span> + count + <span class="string">&quot;次&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;折纸的高度为&quot;</span> + paper/<span class="number">1000</span> + <span class="string">&quot;米，超过了珠峰的高度&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-3-练习"><a href="#3-2-3-练习" class="headerlink" title="3.2.3 练习"></a>3.2.3 练习</h4><p><strong>练习：</strong>从键盘输入整数，输入0结束，统计输入的正数、负数的个数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test05While</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">positive</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//记录正数的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">negative</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">//记录负数的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">//初始化为特殊值，使得第一次循环条件成立</span></span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;请输入整数（0表示结束）：&quot;</span>);</span><br><span class="line">            num = input.nextInt();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                positive++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                negative++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;正数个数：&quot;</span> + positive);</span><br><span class="line">        System.out.println(<span class="string">&quot;负数个数：&quot;</span> + negative);</span><br><span class="line"></span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-3-do-while循环"><a href="#3-3-do-while循环" class="headerlink" title="3.3 do-while循环"></a>3.3 do-while循环</h3><h4 id="3-3-1-基本语法"><a href="#3-3-1-基本语法" class="headerlink" title="3.3.1 基本语法"></a>3.3.1 基本语法</h4><p><strong>语法格式：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">①初始化部分;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">③循环体部分</span><br><span class="line">④迭代部分</span><br><span class="line">&#125;<span class="keyword">while</span>(②循环条件部分); </span><br></pre></td></tr></table></figure><p><strong>执行过程：</strong>①-③-④-②-③-④-②-③-④-…-②</p><p><strong>图示：</strong></p><p><img src="/2023/02/18/java2023/%E7%AC%AC03%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20220512165558698.png" alt="image-20220512165558698" style="zoom:80%;"></p><p><strong>说明：</strong></p><ul><li>结尾while(循环条件)中循环条件必须是boolean类型</li><li>do{}while();最后有一个分号</li><li>do-while结构的循环体语句是至少会执行一次，这个和for和while是不一样的</li><li>循环的三个结构for、while、do-while三者是可以相互转换的。</li></ul><h4 id="3-3-2-应用举例"><a href="#3-3-2-应用举例" class="headerlink" title="3.3.2 应用举例"></a>3.3.2 应用举例</h4><p><strong>案例1：</strong>遍历1-100的偶数，并计算所有偶数的和、偶数的个数（累加的思想）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DoWhileTest1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历1-100的偶数，并计算所有偶数的和、偶数的个数（累加的思想）</span></span><br><span class="line"><span class="comment">//初始化部分</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录1-100所有的偶数的和</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录1-100之间偶数的个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"><span class="comment">//循环体部分</span></span><br><span class="line"><span class="keyword">if</span>(num % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(num);</span><br><span class="line">sum += num;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">num++;<span class="comment">//迭代部分</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">while</span>(num &lt;= <span class="number">100</span>); <span class="comment">//循环条件部分</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;偶数的总和为：&quot;</span> + sum);</span><br><span class="line">System.out.println(<span class="string">&quot;偶数的个数为：&quot;</span> + count);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>案例2：</strong>体会do-while至少会执行一次循环体</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DoWhileTest2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//while循环:</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span>(num1 &gt; <span class="number">10</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;hello:while&quot;</span>);</span><br><span class="line">num1--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//do-while循环:</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;hello:do-while&quot;</span>);</span><br><span class="line">num2--;</span><br><span class="line">&#125;<span class="keyword">while</span>(num2 &gt; <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例3：ATM取款</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">声明变量balance并初始化为0，用以表示银行账户的余额，下面通过ATM机程序实现存款，取款等功能。</span><br><span class="line"></span><br><span class="line">=========ATM========</span><br><span class="line">   1、存款</span><br><span class="line">   2、取款</span><br><span class="line">   3、显示余额</span><br><span class="line">   4、退出</span><br><span class="line">请选择(1-4)：</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 19:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ATM</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化条件</span></span><br><span class="line"><span class="type">double</span> <span class="variable">balance</span> <span class="operator">=</span> <span class="number">0.0</span>;<span class="comment">//表示银行账户的余额</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isFlag</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//用于控制循环的结束</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;=========ATM========&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;\t1、存款&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;\t2、取款&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;\t3、显示余额&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;\t4、退出&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;请选择(1-4)：&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">selection</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(selection)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">System.out.print(<span class="string">&quot;要存款的额度为：&quot;</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">addMoney</span> <span class="operator">=</span> scan.nextDouble();</span><br><span class="line"><span class="keyword">if</span>(addMoney &gt; <span class="number">0</span>)&#123;</span><br><span class="line">balance += addMoney;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">System.out.print(<span class="string">&quot;要取款的额度为：&quot;</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">minusMoney</span> <span class="operator">=</span> scan.nextDouble();</span><br><span class="line"><span class="keyword">if</span>(minusMoney &gt; <span class="number">0</span> &amp;&amp; balance &gt;= minusMoney)&#123;</span><br><span class="line">balance -= minusMoney;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;您输入的数据非法或余额不足&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;当前的余额为：&quot;</span> + balance);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;欢迎下次进入此系统。^_^&quot;</span>);</span><br><span class="line">isFlag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;请重新选择！&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">while</span>(isFlag);</span><br><span class="line"></span><br><span class="line"><span class="comment">//资源关闭</span></span><br><span class="line">scan.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-3-练习"><a href="#3-3-3-练习" class="headerlink" title="3.3.3 练习"></a>3.3.3 练习</h4><p><strong>练习1：</strong>随机生成一个100以内的数，猜这个随机数是多少？</p><p>从键盘输入数，如果大了提示，大了；如果小了，提示小了；如果对了，就不再猜了，并统计一共猜了多少次。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoWhileExer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//随机生成一个100以内的整数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Math.random() ==&gt; [0,1)的小数</span></span><br><span class="line"><span class="comment">Math.random()* 100 ==&gt; [0,100)的小数</span></span><br><span class="line"><span class="comment">(int)(Math.random()* 100) ==&gt; [0,100)的整数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random()* <span class="number">100</span>);</span><br><span class="line">        <span class="comment">//System.out.println(num);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明一个变量，用来存储猜的次数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> guess;<span class="comment">//提升作用域</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;请输入100以内的整数：&quot;</span>);</span><br><span class="line">            guess = input.nextInt();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//输入一次，就表示猜了一次</span></span><br><span class="line">            count++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(guess &gt; num)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;大了&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(guess &lt; num)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;小了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span>(num != guess);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;一共猜了：&quot;</span> + count+<span class="string">&quot;次&quot;</span>);</span><br><span class="line"></span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-对比三种循环结构"><a href="#3-4-对比三种循环结构" class="headerlink" title="3.4 对比三种循环结构"></a>3.4 对比三种循环结构</h3><ul><li><strong>三种循环结构都具有四个要素：</strong><ul><li>循环变量的初始化条件</li><li>循环条件</li><li>循环体语句块</li><li>循环变量的修改的迭代表达式</li></ul></li></ul><ul><li><strong>从循环次数角度分析</strong><ul><li>do-while循环至少执行一次循环体语句。</li><li>for和while循环先判断循环条件语句是否成立，然后决定是否执行循环体。</li></ul></li><li><strong>如何选择</strong><ul><li>遍历有明显的循环次数（范围）的需求，选择for循环</li><li>遍历没有明显的循环次数（范围）的需求，选择while循环</li><li>如果循环体语句块至少执行一次，可以考虑使用do-while循环</li><li>本质上：三种循环之间完全可以互相转换，都能实现循环的功能</li></ul></li></ul><h3 id="3-5-“无限”循环"><a href="#3-5-“无限”循环" class="headerlink" title="3.5 “无限”循环"></a>3.5 “无限”循环</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC03%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/类似：死循环.jpg" alt="类似：死循环"></p><h4 id="3-5-1-基本语法"><a href="#3-5-1-基本语法" class="headerlink" title="3.5.1 基本语法"></a>3.5.1 基本语法</h4><p><strong>语法格式：</strong></p><ul><li>最简单”无限”循环格式：<code>while(true)</code> , <code>for(;;)</code> </li></ul><p><strong>适用场景：</strong></p><ul><li>开发中，有时并不确定需要循环多少次，需要根据循环体内部某些条件，来控制循环的结束（使用break）。</li><li>如果此循环结构不能终止，则构成了死循环！开发中要避免出现死循环。</li></ul><h4 id="3-5-2-应用举例"><a href="#3-5-2-应用举例" class="headerlink" title="3.5.2 应用举例"></a>3.5.2 应用举例</h4><p><strong>案例1：</strong>实现爱你到永远…</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EndlessFor1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我爱你！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;end&quot;);//永远无法到达的语句，编译报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EndlessFor2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; <span class="literal">true</span>;)&#123; <span class="comment">//条件永远成立，死循环</span></span><br><span class="line">            System.out.println(<span class="string">&quot;我爱你！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EndlessFor3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">10</span>; )&#123; <span class="comment">//循环变量没有修改，条件永远成立，死循环</span></span><br><span class="line">            System.out.println(<span class="string">&quot;我爱你！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考：如下代码执行效果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EndlessFor4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&gt;=<span class="number">10</span>; )&#123; <span class="comment">//一次都不执行</span></span><br><span class="line">            System.out.println(<span class="string">&quot;我爱你！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例2：</strong>从键盘读入个数不确定的整数，并判断读入的正数和负数的个数，输入为0时结束程序。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PositiveNegative</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        </span><br><span class="line"><span class="type">int</span> <span class="variable">positiveNumber</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//统计正数的个数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">negativeNumber</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//统计负数的个数</span></span><br><span class="line"><span class="keyword">for</span>(;;)&#123;  <span class="comment">//while(true)&#123;</span></span><br><span class="line">System.out.println(<span class="string">&quot;请输入一个整数：(输入为0时结束程序)&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"><span class="keyword">if</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line"> positiveNumber++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &lt; <span class="number">0</span>)&#123;</span><br><span class="line"> negativeNumber++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;程序结束&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"> System.out.println(<span class="string">&quot;正数的个数为：&quot;</span>+ positiveNumber);</span><br><span class="line"> System.out.println(<span class="string">&quot;负数的个数为：&quot;</span>+ negativeNumber);  </span><br><span class="line">        </span><br><span class="line">         scanner.close();</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-6-嵌套循环（或多重循环）"><a href="#3-6-嵌套循环（或多重循环）" class="headerlink" title="3.6 嵌套循环（或多重循环）"></a>3.6 嵌套循环（或多重循环）</h3><h4 id="3-6-1-使用说明"><a href="#3-6-1-使用说明" class="headerlink" title="3.6.1 使用说明"></a>3.6.1 使用说明</h4><ul><li><strong>所谓嵌套循环</strong>，是指一个循环结构A的循环体是另一个循环结构B。比如，for循环里面还有一个for循环，就是嵌套循环。其中，for ,while ,do-while均可以作为外层循环或内层循环。<ul><li>外层循环：循环结构A</li><li>内层循环：循环结构B</li></ul></li><li>实质上，<code>嵌套循环就是把内层循环当成外层循环的循环体</code>。只有当内层循环的循环条件为false时，才会完全跳出内层循环，才可结束外层的当次循环，开始下一次的外层循环。</li><li>设外层循环次数为<code>m</code>次，内层为<code>n</code>次，则内层循环体实际上需要执行<code>m*n</code>次。</li><li><strong>技巧：</strong>从二维图形的角度看，外层循环控制<code>行数</code>，内层循环控制<code>列数</code>。</li><li><strong>开发经验：</strong>实际开发中，我们最多见到的嵌套循环是两层。一般不会出现超过三层的嵌套循环。如果将要出现，一定要停下来重新梳理业务逻辑，重新思考算法的实现，控制在三层以内。否则，可读性会很差。</li></ul><p>例如：两个for嵌套循环格式    </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化语句①; 循环条件语句②; 迭代语句⑦) &#123;</span><br><span class="line">    <span class="keyword">for</span>(初始化语句③; 循环条件语句④; 迭代语句⑥) &#123;</span><br><span class="line">      循环体语句⑤;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行过程：① - ② - ③ - ④ - ⑤ - ⑥ - ④ - ⑤ - ⑥ - ... - ④ - ⑦ - ② - ③ - ④ - ⑤ - ⑥ - ④..</span></span><br></pre></td></tr></table></figure><p><strong>执行特点：</strong>外层循环执行一次，内层循环执行一轮。</p><h4 id="3-6-2-应用举例"><a href="#3-6-2-应用举例" class="headerlink" title="3.6.2 应用举例"></a>3.6.2 应用举例</h4><p><strong>案例1：</strong>打印5行6个*</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ForForTest1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">******</span></span><br><span class="line"><span class="comment">******</span></span><br><span class="line"><span class="comment">******</span></span><br><span class="line"><span class="comment">******</span></span><br><span class="line"><span class="comment">******</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= <span class="number">5</span>;j++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">6</span>;i++)&#123;</span><br><span class="line">System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例2：</strong>打印5行直角三角形</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*</span><br><span class="line">**</span><br><span class="line">***</span><br><span class="line">****</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForForTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例3：</strong>打印5行倒直角三角形</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*****</span><br><span class="line">****</span><br><span class="line">***</span><br><span class="line">**</span><br><span class="line">*</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForForTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">5</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= <span class="number">6</span> - i;j++)&#123;</span><br><span class="line">System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例4：打印”菱形”形状的图案</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        * </span><br><span class="line">      * * * </span><br><span class="line">    * * * * * </span><br><span class="line">  * * * * * * * </span><br><span class="line">* * * * * * * * * </span><br><span class="line">  * * * * * * * </span><br><span class="line">    * * * * * </span><br><span class="line">      * * * </span><br><span class="line">        * </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForForTest4</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        上半部分im(表示-的个数)    n(表示*的个数)关系式：2*i + m = 10 --&gt; m = 10 - 2*i</span></span><br><span class="line"><span class="comment">    --------*   1   8   1n = 2 * i - 1</span></span><br><span class="line"><span class="comment">    ------* * *   2   6   3</span></span><br><span class="line"><span class="comment">    ----* * * * *   3   4   5</span></span><br><span class="line"><span class="comment">    --* * * * * * *   4   2       7</span></span><br><span class="line"><span class="comment">    * * * * * * * * *  5   0   9</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        下半部分         i      m                n              关系式： m = 2 * i</span></span><br><span class="line"><span class="comment">    --* * * * * * *    1       2                7                     n = 9 - 2 * i</span></span><br><span class="line"><span class="comment">    ----* * * * *      2       4                5</span></span><br><span class="line"><span class="comment">    ------* * *        3       6                3</span></span><br><span class="line"><span class="comment">    --------*          4       8                1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="comment">//上半部分</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//-</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">10</span> - <span class="number">2</span> * i; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//*</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= <span class="number">2</span> * i - <span class="number">1</span>; k++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;* &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//下半部分</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//-</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">2</span> * i; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//*</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= <span class="number">9</span> - <span class="number">2</span> * i; k++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;* &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例5：九九乘法表</strong></p><p><img src="/2023/02/18/java2023/%E7%AC%AC03%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221113193013204.png" alt="image-20221113193013204"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForForTest5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">&quot;*&quot;</span> + j + <span class="string">&quot;=&quot;</span> + (i * j) + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-6-3-练习"><a href="#3-6-3-练习" class="headerlink" title="3.6.3 练习"></a>3.6.3 练习</h4><p><strong>练习1：</strong>将一天中的时间打印到控制台</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForForDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">hour</span> <span class="operator">=</span> <span class="number">0</span>;hour &lt; <span class="number">24</span> ;hour++ ) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>; min &lt; <span class="number">60</span> ; min++) &#123;</span><br><span class="line">System.out.println(hour + <span class="string">&quot;时&quot;</span> + min +<span class="string">&quot;分&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-关键字break和continue的使用"><a href="#4-关键字break和continue的使用" class="headerlink" title="4. 关键字break和continue的使用"></a>4. 关键字break和continue的使用</h2><h3 id="4-1-break和continue的说明"><a href="#4-1-break和continue的说明" class="headerlink" title="4.1 break和continue的说明"></a>4.1 break和continue的说明</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">适用范围在循环结构中使用的作用相同点</span><br><span class="line"></span><br><span class="line">breakswitch-case</span><br><span class="line">循环结构一旦执行，就结束(或跳出)当前循环结构    此关键字的后面，不能声明语句</span><br><span class="line"></span><br><span class="line">continue循环结构一旦执行，就结束(或跳出)当次循环结构    此关键字的后面，不能声明语句</span><br></pre></td></tr></table></figure><p>此外，很多语言都有goto语句，goto语句可以随意将控制转移到程序中的任意一条语句上，然后执行它，但使程序容易出错。Java中的break和continue是不同于goto的。</p><h3 id="4-2-应用举例"><a href="#4-2-应用举例" class="headerlink" title="4.2 应用举例"></a>4.2 应用举例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BreakContinueTest1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">10</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i % <span class="number">4</span> == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//break;//123</span></span><br><span class="line"><span class="keyword">continue</span>;<span class="comment">//123567910</span></span><br><span class="line"><span class="comment">//如下的语句不可能被执行，编译不通过</span></span><br><span class="line"><span class="comment">//System.out.println(&quot;今晚迪丽热巴要约我吃饭&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.print(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;####&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//嵌套循环中的使用</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">4</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= <span class="number">10</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(j % <span class="number">4</span> == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//break; //结束的是包裹break关键字的最近的一层循环！</span></span><br><span class="line"><span class="keyword">continue</span>;<span class="comment">//结束的是包裹break关键字的最近的一层循环的当次！</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.print(j);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-带标签的使用"><a href="#4-3-带标签的使用" class="headerlink" title="4.3 带标签的使用"></a>4.3 带标签的使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">break</span>语句用于终止某个语句块的执行</span><br><span class="line">&#123;    …… </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"> ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的是哪一层语句块 </span><br><span class="line">label1: &#123;   ……        </span><br><span class="line">label2:     &#123;   ……</span><br><span class="line">label3: &#123;   ……</span><br><span class="line">           <span class="keyword">break</span> label2;</span><br><span class="line">           ……</span><br><span class="line"> &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>continue语句出现在多层嵌套的循环语句体中时，也可以通过标签指明要跳过的是哪一层循环。</li><li><p>标号语句必须紧接在循环的头部。标号语句不能用在非循环语句的前面。</p></li><li><p>举例：</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BreakContinueTest2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">l:<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">4</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= <span class="number">10</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(j % <span class="number">4</span> == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//break l;</span></span><br><span class="line"><span class="keyword">continue</span> l;</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(j);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-经典案例"><a href="#4-4-经典案例" class="headerlink" title="4.4 经典案例"></a>4.4 经典案例</h3><p><strong>题目：找出100以内所有的素数（质数）？100000以内的呢？</strong></p><p>目的：不同的代码的实现方式，可以效率差别很大。</p><p>分析：素数（质数）：只能被1和它本身整除的自然数。  —-&gt; 从2开始，到这个数-1为止，此范围内没有这个数的约数。则此数是一个质数。<br>比如：2、3、5、7、11、13、17、19、23、…</p><p><strong>实现方式1：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrimeNumberTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//boolean isFlag = true; //用于标识i是否被除尽过</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">//记录当前时间距离1970-1-1 00:00:00的毫秒数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录质数的个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt;= <span class="number">100000</span>;i++)&#123;  <span class="comment">//i</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isFlag</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">//用于标识i是否被除尽过</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>;j &lt;= i - <span class="number">1</span>;j++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i % j == <span class="number">0</span>)&#123; <span class="comment">//表明i有约数</span></span><br><span class="line">isFlag = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断i是否是质数</span></span><br><span class="line"><span class="keyword">if</span>(isFlag)&#123; <span class="comment">//如果isFlag变量没有给修改过值，就意味着i没有被j除尽过。则i是一个质数</span></span><br><span class="line"><span class="comment">//System.out.println(i);</span></span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重置isFlag</span></span><br><span class="line"><span class="comment">//isFlag = true;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;质数的个数为：&quot;</span> + count);</span><br><span class="line">System.out.println(<span class="string">&quot;执行此程序花费的毫秒数为：&quot;</span> + (end - start)); <span class="comment">//16628</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现方式2：</strong>针对实现方式1进行优化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrimeNumberTest1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">//记录当前时间距离1970-1-1 00:00:00的毫秒数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录质数的个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt;= <span class="number">100000</span>;i++)&#123;  <span class="comment">//i</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isFlag</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">//用于标识i是否被除尽过</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>;j &lt;= Math.sqrt(i);j++)&#123; <span class="comment">//优化2：将循环条件中的i改为Math.sqrt(i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i % j == <span class="number">0</span>)&#123; <span class="comment">//表明i有约数</span></span><br><span class="line">isFlag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//优化1：主要针对非质数起作用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断i是否是质数</span></span><br><span class="line"><span class="keyword">if</span>(isFlag)&#123; <span class="comment">//如果isFlag变量没有给修改过值，就意味着i没有被j除尽过。则i是一个质数</span></span><br><span class="line"><span class="comment">//System.out.println(i);</span></span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;质数的个数为：&quot;</span> + count);</span><br><span class="line">System.out.println(<span class="string">&quot;执行此程序花费的毫秒数为：&quot;</span> + (end - start));<span class="comment">//1062</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现方式3（选做）：</strong>使用continue + 标签</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrimeNumberTest2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">//记录当前时间距离1970-1-1 00:00:00的毫秒数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录质数的个数</span></span><br><span class="line"></span><br><span class="line">label:<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt;= <span class="number">100000</span>;i++)&#123;  <span class="comment">//i</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>;j &lt;= Math.sqrt(i);j++)&#123; <span class="comment">//优化2：将循环条件中的i改为Math.sqrt(i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i % j == <span class="number">0</span>)&#123; <span class="comment">//表明i有约数</span></span><br><span class="line"><span class="keyword">continue</span> label;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一旦程序能执行到此位置，说明i就是一个质数</span></span><br><span class="line">System.out.println(i);</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;质数的个数为：&quot;</span> + count);</span><br><span class="line">System.out.println(<span class="string">&quot;执行此程序花费的毫秒数为：&quot;</span> + (end - start));<span class="comment">//1062</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-练习"><a href="#4-5-练习" class="headerlink" title="4.5 练习"></a>4.5 练习</h3><p><strong>练习1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">生成 1-100 之间的随机数，直到生成了 97 这个数，看看一共用了几次？</span><br><span class="line"></span><br><span class="line">提示：使用 (int)(Math.random() * 100) + 1</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberGuessTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录循环的次数（或生成随机数进行比较的次数）</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">random</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random() * <span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(random == <span class="number">97</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;直到生成随机数97，一共比较了&quot;</span> + count + <span class="string">&quot;次&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-Scanner：键盘输入功能的实现"><a href="#5-Scanner：键盘输入功能的实现" class="headerlink" title="5. Scanner：键盘输入功能的实现"></a>5. Scanner：键盘输入功能的实现</h2><ul><li><p>如何从键盘获取不同类型（基本数据类型、String类型）的变量：使用Scanner类。</p></li><li><p>键盘输入代码的四个步骤：</p><ol><li>导包：<code>import java.util.Scanner;</code></li><li>创建Scanner类型的对象：<code>Scanner scan = new Scanner(System.in);</code></li><li>调用Scanner类的相关方法（<code>next() / nextXxx()</code>），来获取指定类型的变量</li><li>释放资源：<code>scan.close();</code></li></ol></li><li>注意：需要根据相应的方法，来输入指定类型的值。如果输入的数据类型与要求的类型不匹配时，会报异常 导致程序终止。</li></ul><h3 id="5-1-各种类型的数据输入"><a href="#5-1-各种类型的数据输入" class="headerlink" title="5.1 各种类型的数据输入"></a>5.1 各种类型的数据输入</h3><p><strong>案例：</strong>小明注册某交友网站，要求录入个人相关信息。如下：</p><p>请输入你的网名、你的年龄、你的体重、你是否单身、你的性别等情况。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//① 导包</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScannerTest1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//② 创建Scanner的对象</span></span><br><span class="line">        <span class="comment">//Scanner是一个引用数据类型，它的全名称是java.util.Scanner</span></span><br><span class="line">        <span class="comment">//scanner就是一个引用数据类型的变量了，赋给它的值是一个对象（对象的概念我们后面学习，暂时先这么叫）</span></span><br><span class="line">        <span class="comment">//new Scanner(System.in)是一个new表达式，该表达式的结果是一个对象</span></span><br><span class="line">        <span class="comment">//引用数据类型  变量 = 对象;</span></span><br><span class="line">        <span class="comment">//这个等式的意思可以理解为用一个引用数据类型的变量代表一个对象，所以这个变量的名称又称为对象名</span></span><br><span class="line">        <span class="comment">//我们也把scanner变量叫做scanner对象</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);<span class="comment">//System.in默认代表键盘输入</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//③根据提示，调用Scanner的方法，获取不同类型的变量</span></span><br><span class="line">        System.out.println(<span class="string">&quot;欢迎光临你好我好交友网站！&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入你的网名：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.next();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;请输入你的年龄：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;请输入你的体重：&quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">weight</span> <span class="operator">=</span> scanner.nextDouble();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;你是否单身（true/false)：&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isSingle</span> <span class="operator">=</span> scanner.nextBoolean();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;请输入你的性别：&quot;</span>);</span><br><span class="line">        <span class="type">char</span> <span class="variable">gender</span> <span class="operator">=</span> scanner.next().charAt(<span class="number">0</span>);<span class="comment">//先按照字符串接收，然后再取字符串的第一个字符（下标为0）</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;你的基本情况如下：&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;网名：&quot;</span> + name + <span class="string">&quot;\n年龄：&quot;</span> + age + <span class="string">&quot;\n体重：&quot;</span> + weight + </span><br><span class="line">                           <span class="string">&quot;\n单身：&quot;</span> + isSingle + <span class="string">&quot;\n性别：&quot;</span> + gender);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//④ 关闭资源</span></span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-练习"><a href="#5-2-练习" class="headerlink" title="5.2 练习"></a>5.2 练习</h3><p><strong>练习1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">大家都知道，男大当婚，女大当嫁。那么女方家长要嫁女儿，当然要提出一定的条件：高：180cm以上；富：财富1千万以上；帅：是。</span><br><span class="line"></span><br><span class="line">如果这三个条件同时满足，则：“我一定要嫁给他!!!”</span><br><span class="line">如果三个条件有为真的情况，则：“嫁吧，比上不足，比下有余。”</span><br><span class="line">如果三个条件都不满足，则：“不嫁！”</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">System.out.println(“身高: (cm));</span><br><span class="line">scanner.nextInt();</span><br><span class="line"></span><br><span class="line">System.out.println(“财富: (千万));</span><br><span class="line">scanner.nextDouble();</span><br><span class="line"></span><br><span class="line">System.out.println(“帅否: (true/false));   </span><br><span class="line">scanner.nextBoolean();  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(“帅否: (是/否));</span><br><span class="line">scanner.next();   &quot;是&quot;.equals(str)  </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScannerExer1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;请输入你的身高：(cm)&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;请输入你的财富：(以千万为单位)&quot;</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">wealth</span> <span class="operator">=</span> scan.nextDouble();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">方式1：关于是否帅问题，我们使用boolean类型接收</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">System.out.println(&quot;帅否？(true/false)&quot;);</span></span><br><span class="line"><span class="comment">boolean isHandsome = scan.nextBoolean();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//判断</span></span><br><span class="line"><span class="comment">if(height &gt;= 180 &amp;&amp; wealth &gt;= 1.0 &amp;&amp; isHandsome)&#123; //不建议isHandsome == true</span></span><br><span class="line"><span class="comment">System.out.println(&quot;我一定要嫁给他!!!&quot;);</span></span><br><span class="line"><span class="comment">&#125;else if(height &gt;= 180 || wealth &gt;= 1.0 || isHandsome)&#123;</span></span><br><span class="line"><span class="comment">System.out.println(&quot;嫁吧，比上不足，比下有余。&quot;);</span></span><br><span class="line"><span class="comment">&#125;else&#123;</span></span><br><span class="line"><span class="comment">System.out.println(&quot;不嫁&quot;);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2：关于是否帅问题，我们使用String类型接收</span></span><br><span class="line">System.out.println(<span class="string">&quot;帅否？(是/否)&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">isHandsome</span> <span class="operator">=</span> scan.next();</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断</span></span><br><span class="line"><span class="keyword">if</span>(height &gt;= <span class="number">180</span> &amp;&amp; wealth &gt;= <span class="number">1.0</span> &amp;&amp; isHandsome == <span class="string">&quot;是&quot;</span>)&#123;  <span class="comment">//知识点：判断两个字符串是否相等，使用String的equals()</span></span><br><span class="line">System.out.println(<span class="string">&quot;我一定要嫁给他!!!&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(height &gt;= <span class="number">180</span> || wealth &gt;= <span class="number">1.0</span> || isHandsome == <span class="string">&quot;是&quot;</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;嫁吧，比上不足，比下有余。&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;不嫁&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭资源</span></span><br><span class="line">scan.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我家的狗5岁了，5岁的狗相当于人类多大呢？其实，狗的前两年每一年相当于人类的10.5岁，之后每增加一年就增加四岁。那么5岁的狗相当于人类多少年龄呢？应该是：10.5 + 10.5 + 4 + 4 + 4 = 33岁。</span><br><span class="line"></span><br><span class="line">编写一个程序，获取用户输入的狗的年龄，通过程序显示其相当于人类的年龄。如果用户输入负数，请显示一个提示信息。</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScannerExer2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;请输入狗狗的年龄：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">dogAge</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过分支语句，判断狗狗相当于人的年龄</span></span><br><span class="line"><span class="keyword">if</span>(dogAge &lt; <span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;你输入的狗狗的年龄不合法&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(dogAge &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;相当于人的年龄：&quot;</span> + (dogAge * <span class="number">10.5</span>));</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;相当于人的年龄：&quot;</span> + (<span class="number">2</span> * <span class="number">10.5</span> + (dogAge - <span class="number">2</span>) * <span class="number">4</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭资源</span></span><br><span class="line">scan.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-如何获取一个随机数"><a href="#6-如何获取一个随机数" class="headerlink" title="6. 如何获取一个随机数"></a>6. 如何获取一个随机数</h2><p>如何产生一个指定范围的随机整数？</p><p>1、Math类的random()的调用，会返回一个[0,1)范围的一个double型值</p><p>2、Math.random() <em> 100  —-&gt;  [0,100)<br>      (int)(Math.random() </em> 100)    —-&gt; [0,99]<br>      (int)(Math.random() * 100) + 5  ——&gt; [5,104]</p><p>3、如何获取<code>[a,b]</code>范围内的随机整数呢？<code>(int)(Math.random() * (b - a + 1)) + a</code></p><p>4、举例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MathRandomTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">double</span> <span class="variable">value</span> <span class="operator">=</span> Math.random();</span><br><span class="line">System.out.println(value);</span><br><span class="line"></span><br><span class="line"><span class="comment">//[1,6]</span></span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random() * <span class="number">6</span>) + <span class="number">1</span>; <span class="comment">//</span></span><br><span class="line">System.out.println(number);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第03章-流程控制语句&quot;&gt;&lt;a href=&quot;#第03章-流程控制语句&quot; class=&quot;headerlink&quot; title=&quot;第03章_流程控制语句&quot;&gt;&lt;/a&gt;第03章_流程控制语句&lt;/h1&gt;&lt;p&gt;讲师：尚硅谷-宋红康（江湖人称：康师傅）&lt;/p&gt;
&lt;p&gt;官网：&lt;a </summary>
      
    
    
    
    <category term="Java2023" scheme="http://example.com/categories/Java2023/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第04章_IDEA的安装与使用（上）</title>
    <link href="http://example.com/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://example.com/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/</id>
    <published>2023-02-18T12:37:01.000Z</published>
    <updated>2023-02-19T07:38:43.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第04章-IDEA的安装与使用（上）"><a href="#第04章-IDEA的安装与使用（上）" class="headerlink" title="第04章_IDEA的安装与使用（上）"></a>第04章_IDEA的安装与使用（上）</h1><p>讲师：尚硅谷-宋红康（江湖人称：康师傅）</p><p>官网：<a href="http://www.atguigu.com/">http://www.atguigu.com</a></p><hr><h2 id="本章专题与脉络"><a href="#本章专题与脉络" class="headerlink" title="本章专题与脉络"></a>本章专题与脉络</h2><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/第1阶段：Java基本语法-第04章.png" alt="第1阶段：Java基本语法-第04章" style="zoom:50%;"></p><hr><p><strong>【Why IDEA ?】</strong></p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221018105217845.png" alt="image-20221018105217845"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/2022-10-18_11-00-29.jpg" alt="2022-10-18_11-00-29" style="zoom:80%;"></p><blockquote><p>【注】JetBrains官方说明：</p><p>尽管我们采取了多种措施确保受访者的代表性，但结果可能会略微偏向 JetBrains 产品的用户，因为这些用户更有可能参加调查。</p></blockquote><p>此外，2022年，某美国软件开发商在对近千名专业的Java开发者调研后，发布了《2022年Java开发者生产力报告》。报告提到：JetBrains 的 IntelliJ IDEA是最受欢迎的 Java IDE，占 <code>48%</code>，其次是 Eclipse，占 24%，Visual Studio Code 占 18%。</p><hr><p>本着”<code>工欲善其事必先利其器</code>“的精神，本章从IDEA的介绍、安装、设置入手，讲解IDEA中项目的创建、快捷键与模板的使用、断点调试、常用插件等。</p><h2 id="1-认识IntelliJ-IDEA"><a href="#1-认识IntelliJ-IDEA" class="headerlink" title="1. 认识IntelliJ IDEA"></a>1. 认识IntelliJ IDEA</h2><h3 id="1-1-JetBrains-公司介绍"><a href="#1-1-JetBrains-公司介绍" class="headerlink" title="1.1 JetBrains  公司介绍"></a>1.1 JetBrains  公司介绍</h3><p>IDEA，是 JetBrains (<a href="https://www.jetbrains.com/)公司的产品，该公司成立于2000年，总部位于捷克的布拉格，致力于为开发者打造最高效智能的开发工具。">https://www.jetbrains.com/)公司的产品，该公司成立于2000年，总部位于捷克的布拉格，致力于为开发者打造最高效智能的开发工具。</a></p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/1576217376761.png" alt="1576217376761" style="zoom:80%;"></p><p>公司旗下还有其它产品，比如：</p><ul><li>WebStorm：用于开发 JavaScript、HTML5、CSS3 等前端技术</li><li>PyCharm：用于开发 python</li><li>PhpStorm：用于开发 PHP</li><li>RubyMine：用于开发 Ruby/Rails</li><li>AppCode：用于开发 Objective - C/Swift</li><li>CLion：用于开发 C/C++</li><li>DataGrip：用于开发数据库和 SQL</li><li>Rider：用于开发.NET</li><li>GoLand：用于开发 Go</li></ul><p>用于开发 Android的Android Studio，也是Google 基于 IDEA 社区版进行迭代的。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/1593264471351.png" alt="1593264471351"></p><h3 id="1-2-IntelliJ-IDEA-介绍"><a href="#1-2-IntelliJ-IDEA-介绍" class="headerlink" title="1.2 IntelliJ IDEA  介绍"></a>1.2 IntelliJ IDEA  介绍</h3><p>IDEA，全称 <code>IntelliJ IDEA</code>，是 Java 语言的集成开发环境，目前已经（基本）<code>代替</code>了Eclipse的使用。IDEA 在业界被公认为是最好的 Java 开发工具（之一），因其<code>功能强悍</code>、<code>设置人性化</code>，而深受Java、大数据、移动端程序员的喜爱。</p><p>IntelliJ IDEA 在 2015 年的官网上这样介绍自己：</p><blockquote><p>Excel at enterprise, mobile and web development with Java, Scala and Groovy,with all the latest modern technologies and frameworks available out of thebox.</p></blockquote><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221018104714861.png" alt="image-20221018104714861"></p><h3 id="1-3-IDEA的主要优势：-vs-Eclipse"><a href="#1-3-IDEA的主要优势：-vs-Eclipse" class="headerlink" title="1.3 IDEA的主要优势：(vs Eclipse)"></a>1.3 IDEA的主要优势：(vs Eclipse)</h3><p><strong>功能强大：</strong></p><p>① 强大的整合能力。比如：Git、Maven、Spring等</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/内置的工具和支持的框架.png" alt="1576218068631" style="zoom: 67%;"></p><p>② 开箱即用的体验（集成版本控制系统、多语言支持的框架随时可用，无需额外安装插件）</p><p><strong>符合人体工程学：</strong></p><p>① 高度智能（快速的智能代码补全、实时代码分析、可靠的重构工具）</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221018104821144.png" alt="image-20221018104821144"></p><p>② 提示功能的快速、便捷、范围广</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/clip_imrage002.jpg" alt="img"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221018104942633.png" alt="image-20221018104942633"></p><p>③ 好用的快捷键和代码模板</p><p>④ 精准搜索</p><h3 id="1-4-IDEA-的下载"><a href="#1-4-IDEA-的下载" class="headerlink" title="1.4 IDEA  的下载"></a>1.4 IDEA  的下载</h3><ul><li>下载网址： <a href="https://www.jetbrains.com/idea/download/#section=windows">https://www.jetbrains.com/idea/download/#section=windows</a></li></ul><ul><li>IDEA 分为两个版本： <code>旗舰版(Ultimate)</code>和 <code>社区版(Community)</code>。</li></ul><ul><li>IDEA的大版本每年迭代一次，大版本下的小版本（如：2022.x）迭代时间不固定，一般每年3个小版本。</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220606191620253.png" alt="image-20220606191620253"></p><p>两个不同版本的详细对比，可以参照官网：<br><a href="https://www.jetbrains.com/idea/features/editions_comparison_matrix.html">https://www.jetbrains.com/idea/features/editions_comparison_matrix.html</a></p><p>官网提供的详细使用文档：<br><a href="https://www.jetbrains.com/help/idea/meet-intellij-idea.html">https://www.jetbrains.com/help/idea/meet-intellij-idea.html</a></p><h2 id="2-卸载与安装"><a href="#2-卸载与安装" class="headerlink" title="2. 卸载与安装"></a>2. 卸载与安装</h2><h3 id="2-1-卸载过程"><a href="#2-1-卸载过程" class="headerlink" title="2.1 卸载过程"></a>2.1 卸载过程</h3><p>这里以卸载2022.1.2版本为例说明。在【控制面板】找到【卸载程序】</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221019120032582.png" alt="image-20221019120032582" style="zoom: 80%;"></p><p>右键点击或左键双击IntelliJ IDEA 2022.1.2进行卸载：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221019121258294.png" alt="image-20221019121258294" style="zoom:80%;"></p><p>如果需要保留下述数据，就不要打√。如果想彻底删除IDEA所有数据，那就打上√。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221019122135368.png" alt="image-20221019122135368" style="zoom:80%;"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221019122323575.png" alt="image-20221019122323575" style="zoom:80%;"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221019122349195.png" alt="image-20221019122349195" style="zoom:80%;"></p><p>软件卸载完以后，还需要删除其它几个位置的残留：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221019161147552.png" alt="image-20221019161147552"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221019161226843.png" alt="image-20221019161226843"></p><h3 id="2-2-安装前的准备"><a href="#2-2-安装前的准备" class="headerlink" title="2.2 安装前的准备"></a>2.2 安装前的准备</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221018110944516.png" alt="image-20221018110944516"></p><ul><li>64 位 Microsoft Windows 11、10、8</li><li>最低 2 GB 可用 RAM，推荐 8 GB 系统总 RAM</li><li>2.5 GB 硬盘空间，推荐 SSD</li><li>最低屏幕分辨率 1024x768</li></ul><p>从安装上来看，IntelliJ IDEA 对硬件的要求<code>似乎不是很高</code>。可是在实际开发中并不是这样的，因为 IntelliJ IDEA 执行时会有大量的缓存、索引文件，所以如果你正在使用 Eclipse / MyEclipse，想通过 IntelliJ IDEA 来解决计算机的卡、慢等问题，这基本上是不可能的，本质上你应该对自己的硬件设备进行升级。</p><h3 id="2-3-安装过程"><a href="#2-3-安装过程" class="headerlink" title="2.3 安装过程"></a>2.3 安装过程</h3><p>1、下载完安装包，双击直接安装<img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220606191800719.png" alt="image-20220606191800719"></p><p>2、欢迎安装</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220606191825728.png" alt="image-20220606191825728"></p><p>3、是否删除电脑上低版本的IDEA（如果有，可以选择忽略）</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220606191838180.png" alt="image-20220606191838180"></p><ul><li><p>如果电脑上有低版本的IDEA，可以选择删除或保留。</p></li><li><p>这里没有卸载旧版本，如果需要卸载，记得勾选下面的保留旧的设置和配置。</p></li></ul><p>4、选择安装目录</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220606191942308.png" alt="image-20220606191942308"></p><p>选择安装目录，目录中要避免中文和空格。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220606192004081.png" alt="image-20220606192004081"></p><p>5、创建桌面快捷图标等</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220606192053432.png" alt="image-20220606192053432"></p><p>确认是否与.java、.groovy、.kt 格式文件进行关联。这里建议不关联。</p><p>6、在【开始】菜单新建一个文件夹（这里需要确认文件夹的名称），来管理IDEA的相关内容。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220606192126130.png" alt="image-20220606192126130"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220606192135684.png" alt="image-20220606192135684"></p><p>7、完成安装</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220606192148284.png" alt="image-20220606192148284"></p><p>重启以后，单击登录：<img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220615164056349.png" alt="image-20220615164056349"></p><h3 id="2-4-注册"><a href="#2-4-注册" class="headerlink" title="2.4 注册"></a>2.4 注册</h3><p>首先，需要通过用户协议：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221019170223226.png" alt="image-20221019170223226" style="zoom:80%;"></p><p>是否同意发送用户数据（特性、使用的插件、硬件与软件配置等），建议选择：不发送。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221019170301256.png" alt="image-20221019170301256" style="zoom:80%;"></p><p>接着，会提示我们进行注册。</p><ul><li><p>选择1：试用30天。在IDEA2022.1.2版本中，需要先登录，才能开启试用。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221019170638164.png" alt="image-20221019170638164" style="zoom:80%;"></p></li><li><p>选择2：付费购买旗舰版</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221019170740875.png" alt="image-20221019170740875" style="zoom:80%;"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221019170820975.png" alt="image-20221019170820975" style="zoom:50%;"></p></li><li><p>选择3：（推荐）</p><ul><li>大家参照《<code>.\03-资料\01-IDEA 2022.1 注册文档\IntelliJ IDEA2022.1注册文档.docx</code>》操作即可。</li><li>由于存在时效性，如果失效，大家可以自行搜索注册方式即可。</li></ul></li></ul><h3 id="2-5-闪退问题"><a href="#2-5-闪退问题" class="headerlink" title="2.5 闪退问题"></a>2.5 闪退问题</h3><p>问题描述：2022.1启动不了，双击桌面图标，没有响应。</p><p>解决办法：</p><p>打开<code>C:\Users\songhk\AppData\Roaming\JetBrains\IntelliJIdea2022.1\idea64.exe.vmoptions</code> 这个文件。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220606195927066.png" alt="image-20220606195927066"></p><p>内容如下所示：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220606195938517.png" alt="image-20220606195938517"></p><p>删除红框的数据以后，再登录即可正常进入。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220606200011927.png" alt="image-20220606200011927"></p><p>原因：之前使用过的比如2021.2.2版本，pojie了。新版IEDA太智能了，把现有的启运参数也都复制过去了。又因为最新的IDEA，不兼容pojie程序-javaagent:D:\develop_tools\IDEA\IntelliJ IDEA 2021.2.2\bin\jetbrains-agent.jar了，所以报错了，所以JVM结束了，所以没有启动画面，凉凉了。</p><h2 id="3-HelloWorld的实现"><a href="#3-HelloWorld的实现" class="headerlink" title="3. HelloWorld的实现"></a>3. HelloWorld的实现</h2><h3 id="3-1-新建Project-Class"><a href="#3-1-新建Project-Class" class="headerlink" title="3.1 新建Project - Class"></a>3.1 新建Project - Class</h3><p>选择”New Project”：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221019174051967.png" alt="image-20221019174051967" style="zoom:80%;"></p><p>指名工程名、使用的JDK版本等信息。如下所示：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221019174355370.png" alt="image-20221019174355370"></p><p>接着创建Java类：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221019174505876.png" alt="image-20221019174505876"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221019174551606.png" alt="image-20221019174551606"></p><h3 id="3-2-编写代码"><a href="#3-2-编写代码" class="headerlink" title="3.2 编写代码"></a>3.2 编写代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello,World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-运行"><a href="#3-3-运行" class="headerlink" title="3.3 运行"></a>3.3 运行</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221019174716442.png" alt="image-20221019174716442"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221019174801370.png" alt="image-20221019174801370"></p><h2 id="4-JDK相关设置"><a href="#4-JDK相关设置" class="headerlink" title="4. JDK相关设置"></a>4. JDK相关设置</h2><h3 id="4-1-项目的JDK设置"><a href="#4-1-项目的JDK设置" class="headerlink" title="4.1 项目的JDK设置"></a>4.1 项目的JDK设置</h3><p><code>File--&gt;Project Structure...--&gt;Platform Settings --&gt;SDKs</code></p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221019174847921.png" alt="image-20221019174847921"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221019175030852.png" alt="image-20221019175030852"></p><ul><li>注1：SDKs全称是Software Development Kit ，这里一定是选择JDK的安装根目录，不是JRE的目录。</li><li>注2：这里还可以从本地添加多个JDK。使用“+”即可实现。</li></ul><h3 id="4-2-out目录和编译版本"><a href="#4-2-out目录和编译版本" class="headerlink" title="4.2 out目录和编译版本"></a>4.2 out目录和编译版本</h3><p><code>File--&gt;Project Structure...--&gt;Project Settings --&gt;Project</code></p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221019175358200.png" alt="image-20221019175358200"></p><h2 id="5-详细设置"><a href="#5-详细设置" class="headerlink" title="5. 详细设置"></a>5. 详细设置</h2><h3 id="5-1-如何打开详细配置界面"><a href="#5-1-如何打开详细配置界面" class="headerlink" title="5.1 如何打开详细配置界面"></a>5.1 如何打开详细配置界面</h3><p>1、显示工具栏</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221019175536721.png" alt="image-20221019175536721"></p><p>2、选择详细配置菜单或按钮</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221019175620422.png" alt="image-20221019175620422"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221019175953767.png" alt="image-20221019175953767"></p><h3 id="5-2-系统设置"><a href="#5-2-系统设置" class="headerlink" title="5.2 系统设置"></a>5.2 系统设置</h3><h4 id="1、默认启动项目配置"><a href="#1、默认启动项目配置" class="headerlink" title="1、默认启动项目配置"></a>1、默认启动项目配置</h4><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221019180050832.png" alt="image-20221019180050832"></p><p>启动IDEA时，默认自动打开上次开发的项目？还是自己选择？</p><p>如果去掉Reopen projects on startup前面的对勾，每次启动IDEA就会出现如下界面：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221019180304644.png" alt="image-20221019180304644"></p><h4 id="2、取消自动更新"><a href="#2、取消自动更新" class="headerlink" title="2、取消自动更新"></a>2、取消自动更新</h4><p>Settings—&gt;Appearance &amp; Behavior-&gt;System Settings -&gt; Updates</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221019180428323.png" alt="image-20221019180428323"></p><p>默认都打√了，建议检查IDE更新的√去掉，检查插件更新的√选上。</p><h3 id="5-3-设置整体主题"><a href="#5-3-设置整体主题" class="headerlink" title="5.3 设置整体主题"></a>5.3 设置整体主题</h3><h4 id="1、选择主题"><a href="#1、选择主题" class="headerlink" title="1、选择主题"></a>1、选择主题</h4><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221019180637822.png" alt="image-20221019180637822"></p><h4 id="2、设置菜单和窗口字体和大小"><a href="#2、设置菜单和窗口字体和大小" class="headerlink" title="2、设置菜单和窗口字体和大小"></a>2、设置菜单和窗口字体和大小</h4><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/1655136527800.png" alt="1655136527800"></p><h4 id="3、设置IDEA背景图"><a href="#3、设置IDEA背景图" class="headerlink" title="3、设置IDEA背景图"></a>3、设置IDEA背景图</h4><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221018204241748.png" alt="image-20221018204241748"></p><p>选择一张合适的图片作为背景，即可。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221018204305159.png" alt="image-20221018204305159"></p><h3 id="5-4-设置编辑器主题样式"><a href="#5-4-设置编辑器主题样式" class="headerlink" title="5.4 设置编辑器主题样式"></a>5.4 设置编辑器主题样式</h3><h4 id="1、编辑器主题"><a href="#1、编辑器主题" class="headerlink" title="1、编辑器主题"></a>1、编辑器主题</h4><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/1655136655026.png" alt="1655136655026"></p><h4 id="2、字体大小"><a href="#2、字体大小" class="headerlink" title="2、字体大小"></a>2、字体大小</h4><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/1655136907073.png" alt="1655136907073"></p><p>更详细的字体与颜色如下：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221019182625234.png" alt="image-20221019182625234"></p><blockquote><p>温馨提示：如果选择某个font字体，中文乱码，可以在fallback font（备选字体）中选择一个支持中文的字体。</p></blockquote><h4 id="3、注释的字体颜色"><a href="#3、注释的字体颜色" class="headerlink" title="3、注释的字体颜色"></a>3、注释的字体颜色</h4><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220616121435182.png" alt="image-20220616121435182"></p><ul><li>Block comment：修改多行注释的字体颜色</li><li>Doc Comment –&gt; Text：修改文档注释的字体颜色</li><li>Line comment：修改单行注释的字体颜色</li></ul><h3 id="5-5-显示行号与方法分隔符"><a href="#5-5-显示行号与方法分隔符" class="headerlink" title="5.5 显示行号与方法分隔符"></a>5.5 显示行号与方法分隔符</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/1655137441471.png" alt="1655137441471"></p><h3 id="5-6-代码智能提示功能"><a href="#5-6-代码智能提示功能" class="headerlink" title="5.6 代码智能提示功能"></a>5.6 代码智能提示功能</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/1655137649491.png" alt="1655137649491"></p><p>IntelliJ IDEA 的代码提示和补充功能有一个特性：<code>区分大小写</code>。 如果想不区分大小写的话，就把这个对勾去掉。<code>建议去掉勾选</code>。</p><h3 id="5-7-自动导包配置"><a href="#5-7-自动导包配置" class="headerlink" title="5.7 自动导包配置"></a>5.7 自动导包配置</h3><ul><li>默认需要自己手动导包，Alt+Enter快捷键</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/1655138308426.png" alt="1655138308426"></p><ul><li>自动导包设置<ul><li>动态导入明确的包：Add unambiguous imports on the fly，该设置具有全局性；</li><li>优化动态导入的包：Optimize imports on the fly，该设置只对当前项目有效；</li></ul></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/1655138465774.png" alt="1655138465774"></p><h3 id="5-8-设置项目文件编码（一定要改）"><a href="#5-8-设置项目文件编码（一定要改）" class="headerlink" title="5.8 设置项目文件编码（一定要改）"></a>5.8 设置项目文件编码（一定要改）</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220615190832482.png" alt="image-20220615190832482"></p><p>说明： Transparent native-to-ascii conversion主要用于转换ascii，显式原生内容。一般都要勾选。</p><h3 id="5-9-设置控制台的字符编码"><a href="#5-9-设置控制台的字符编码" class="headerlink" title="5.9 设置控制台的字符编码"></a>5.9 设置控制台的字符编码</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221019003153265.png" alt="image-20221019003153265"></p><h3 id="5-10-修改类头的文档注释信息"><a href="#5-10-修改类头的文档注释信息" class="headerlink" title="5.10 修改类头的文档注释信息"></a>5.10 修改类头的文档注释信息</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221018114632127.png" alt="image-20221018114632127"></p><p>比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ClassName: $&#123;NAME&#125;</span></span><br><span class="line"><span class="comment">* Package: $&#123;PACKAGE_NAME&#125;</span></span><br><span class="line"><span class="comment">* Description: </span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Create</span> $&#123;DATE&#125; $&#123;TIME&#125; </span></span><br><span class="line"><span class="comment">* <span class="doctag">@Version</span> 1.0   </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>常用的预设的变量，这里直接贴出官网给的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$&#123;PACKAGE_NAME&#125; - the name of the target <span class="keyword">package</span> where the <span class="keyword">new</span> <span class="title class_">class</span> or <span class="keyword">interface</span> <span class="title class_">will</span> be created. </span><br><span class="line">$&#123;PROJECT_NAME&#125; - the name of the current project. </span><br><span class="line">$&#123;FILE_NAME&#125; - the name of the PHP file that will be created. </span><br><span class="line">$&#123;NAME&#125; - the name of the <span class="keyword">new</span> <span class="title class_">file</span> which you specify in the New File dialog box during the file creation. </span><br><span class="line">$&#123;USER&#125; - the login name of the current user. </span><br><span class="line">$&#123;DATE&#125; - the current system date. </span><br><span class="line">$&#123;TIME&#125; - the current system time. </span><br><span class="line">$&#123;YEAR&#125; - the current year. </span><br><span class="line">$&#123;MONTH&#125; - the current month. </span><br><span class="line">$&#123;DAY&#125; - the current day of the month. </span><br><span class="line">$&#123;HOUR&#125; - the current hour. </span><br><span class="line">$&#123;MINUTE&#125; - the current minute. </span><br><span class="line">$&#123;PRODUCT_NAME&#125; - the name of the IDE in which the file will be created. </span><br><span class="line">$&#123;MONTH_NAME_SHORT&#125; - the first <span class="number">3</span> letters of the month name. Example: Jan, Feb, etc. </span><br><span class="line">$&#123;MONTH_NAME_FULL&#125; - full name of a month. Example: January, February, etc.</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-11-设置自动编译"><a href="#5-11-设置自动编译" class="headerlink" title="5.11 设置自动编译"></a>5.11 设置自动编译</h3><p><code>Settings--&gt;Build,Execution,Deployment--&gt;Compiler</code></p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/1655109415450.png" alt="1655109415450" style="zoom: 67%;"></p><h3 id="5-12-设置为省电模式-可忽略"><a href="#5-12-设置为省电模式-可忽略" class="headerlink" title="5.12 设置为省电模式 (可忽略)"></a>5.12 设置为省电模式 (可忽略)</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220616121851207.png" alt="image-20220616121851207"></p><p>IntelliJ IDEA 有一种叫做<code>省电模式</code>的状态，开启这种模式之后 IntelliJ IDEA 会<code>关掉代码检查</code>和<code>代码提示</code>等功能。所以一般也可认为这是一种<code>阅读模式</code>，如果你在开发过程中遇到突然代码文件不能进行检查和提示，可以来看看这里是否有开启该功能。</p><h3 id="5-13-取消双击shift搜索"><a href="#5-13-取消双击shift搜索" class="headerlink" title="5.13 取消双击shift搜索"></a>5.13 取消双击shift搜索</h3><p>因为我们按shift切换中英文输入方式，经常被按到，总是弹出搜索框，太麻烦了。可以取消它。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/1659191272699.png" alt="1659191272699" style="zoom:80%;"></p><ul><li>方式1：适用于IDEA 2022.1.2版本</li></ul><p>在2022.1版本中，采用如下方式消双击shift出现搜索框：搜索double即可，勾选Disable double modifier key shortcuts，禁用这个选项。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/1659190132458.png" alt="1659190132458"></p><ul><li>方式2：适用于IDEA 2022.1.2之前版本</li></ul><p>双击shift 或 ctrl + shift + a，打开如下搜索窗口：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/1577243967254.png" alt="1577243967254"></p><p>选择registry…，找到”ide.suppress.double.click.handler”，把复选框打上勾就可以取消双击shift出现搜索框了。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/1577244045320.png" alt="1577244045320"></p><h2 id="6-工程与模块管理"><a href="#6-工程与模块管理" class="headerlink" title="6. 工程与模块管理"></a>6. 工程与模块管理</h2><h3 id="6-1-IDEA项目结构"><a href="#6-1-IDEA项目结构" class="headerlink" title="6.1 IDEA项目结构"></a>6.1 IDEA项目结构</h3><p><strong>层级关系：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">project(工程) - module(模块) - package(包) - class(类)</span><br></pre></td></tr></table></figure><p><strong>具体的：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个project中可以创建多个module</span><br><span class="line"></span><br><span class="line">一个module中可以创建多个package</span><br><span class="line"></span><br><span class="line">一个package中可以创建多个class</span><br></pre></td></tr></table></figure><blockquote><p>这些结构的划分，是为了方便管理功能代码。</p></blockquote><h3 id="6-2-Project和Module的概念"><a href="#6-2-Project和Module的概念" class="headerlink" title="6.2 Project和Module的概念"></a>6.2 Project和Module的概念</h3><p>在 IntelliJ IDEA 中，提出了Project和Module这两个概念。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220523014358169.png" alt="image-20220523014358169" style="zoom:80%;"></p><p>在 IntelliJ IDEA 中Project是<code>最顶级的结构单元</code>，然后就是Module。目前，主流的大型项目结构基本都是多Module的结构，这类项目一般是<code>按功能划分</code>的，比如：user-core-module、user-facade-module和user-hessian-module等等，模块之间彼此可以<code>相互依赖</code>，有着不可分割的业务关系。因此，对于一个Project来说：</p><ul><li>当为单Module项目的时候，这个单独的Module实际上就是一个Project。</li><li>当为多Module项目的时候，多个模块处于同一个Project之中，此时彼此之间具有<code>互相依赖</code>的关联关系。</li><li>当然多个模块没有建立依赖关系的话，也可以作为单独一个“小项目”运行。</li></ul><h3 id="6-3-Module和Package"><a href="#6-3-Module和Package" class="headerlink" title="6.3 Module和Package"></a>6.3 Module和Package</h3><p>在一个module下，可以声明多个包（package），一般命名规范如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.不要有中文</span><br><span class="line">2.不要以数字开头</span><br><span class="line">3.给包取名时一般都是公司域名倒着写,而且都是小写</span><br><span class="line">  比如：尚硅谷网址是www.atguigu.com</span><br><span class="line">  那么我们的package包名应该写成：com.atguigu.子名字。</span><br></pre></td></tr></table></figure><h3 id="6-4-创建Module"><a href="#6-4-创建Module" class="headerlink" title="6.4 创建Module"></a>6.4 创建Module</h3><p>建议创建“Empty空工程”，然后创建多模块，每一个模块可以独立运行，相当于一个小项目。JavaSE阶段不涉及到模块之间的依赖。后期再学习模块之间的依赖。</p><p>步骤：</p><p>（1）选择创建模块</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/1655167625885.png" alt="1655167625885"></p><p>（2）选择模块类型：这里选择创建Java模块，给模块命名，确定存放位置</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/1659191966074.png" alt="1659191966074"></p><p>（4）模块声明在工程下面</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/1659192028623.png" alt="1659192028623"></p><h3 id="6-5-删除模块"><a href="#6-5-删除模块" class="headerlink" title="6.5 删除模块"></a>6.5 删除模块</h3><p>（1）移除模块</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/1659192150052.png" alt="1659192150052"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/1659192180062.png" alt="1659192180062"></p><p>（2）彻底删除模块</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/1659192241224.png" alt="1659192241224"></p><h3 id="6-6-导入老师的模块"><a href="#6-6-导入老师的模块" class="headerlink" title="6.6 导入老师的模块"></a>6.6 导入老师的模块</h3><p>（1）将老师的模块<code>teacher_chapter04</code>整个的复制到自己IDEA项目的路径下</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/1659192514219.png" alt="1659192514219"></p><p>接着打开自己IDEA的项目，会在项目目录下看到拷贝过来的module，只不过不是以模块的方式呈现。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/1659192692658.png" alt="1659192692658"></p><p>（2）查看Project Structure，选择import module</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220615213827271.png" alt="image-20220615213827271"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220615214746952.png" alt="image-20220615214746952"></p><p>（3）选择要导入的module：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/1659192850055.png" alt="1659192850055"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220615214916374.png" alt="image-20220615214916374"></p><p>（4）接着可以一路Next下去，最后选择Overwrite</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/1659192928140.png" alt="1659192928140"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/1659192995900.png" alt="1659192995900"></p><p>最后点击OK即可了。</p><h3 id="6-7-同时打开两个IDEA项目工程"><a href="#6-7-同时打开两个IDEA项目工程" class="headerlink" title="6.7 同时打开两个IDEA项目工程"></a>6.7 同时打开两个IDEA项目工程</h3><h4 id="1、两个IDEA项目工程效果"><a href="#1、两个IDEA项目工程效果" class="headerlink" title="1、两个IDEA项目工程效果"></a>1、两个IDEA项目工程效果</h4><p>有些同学想要把上课练习代码和作业代码分开两个IDEA项目工程。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20211229111753237.png" alt="image-20211229111753237"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20211229111906342.png" alt="image-20211229111906342"></p><h4 id="2、新建一个IDEA项目"><a href="#2、新建一个IDEA项目" class="headerlink" title="2、新建一个IDEA项目"></a>2、新建一个IDEA项目</h4><p>注意：第一次需要新建，之后直接打开项目工程即可</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/1655170522054.png" alt="1655170522054"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/1655170341953.png" alt="1655170341953"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/1655170765902.png" alt="1655170765902"></p><h4 id="3、打开两个IDEA项目"><a href="#3、打开两个IDEA项目" class="headerlink" title="3、打开两个IDEA项目"></a>3、打开两个IDEA项目</h4><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20211229112314671.png" alt="image-20211229112314671"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20211229112343470.png" alt="image-20211229112343470"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/1655173351720.png" alt="1655173351720"></p><h3 id="6-8-导入前几章非IDEA工程代码"><a href="#6-8-导入前几章非IDEA工程代码" class="headerlink" title="6.8 导入前几章非IDEA工程代码"></a>6.8 导入前几章非IDEA工程代码</h3><p><strong>1、创建chapter01、chapter02、chapter03等章节的module</strong></p><p>将相应章节的源文件粘贴到module的src下。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220615220728669.png" alt="image-20220615220728669"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220615220755529.png" alt="image-20220615220755529"></p><p>打开其中各个源文件，会发现有乱码。比如：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220615220846097.png" alt="image-20220615220846097"></p><p><strong>2、设置编码</strong></p><p>当前项目是UTF-8。如果原来的.java文件都是GBK的（如果原来.java文件有的是GBK，有的是UTF-8就比较麻烦了）。</p><p>可以单独把这两个模块设置为GBK编码的。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220615220544760.png" alt="image-20220615220544760"></p><p>改为GBK，确认即可。如图：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220615220950214.png" alt="image-20220615220950214"></p><h2 id="7-代码模板的使用"><a href="#7-代码模板的使用" class="headerlink" title="7. 代码模板的使用"></a>7. 代码模板的使用</h2><h3 id="7-1-查看Postfix-Completion模板-后缀补全"><a href="#7-1-查看Postfix-Completion模板-后缀补全" class="headerlink" title="7.1 查看Postfix Completion模板(后缀补全)"></a>7.1 查看Postfix Completion模板(后缀补全)</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/1655173712802.png" alt="1655173712802"></p><h3 id="7-2-查看Live-Templates模板-实时模板"><a href="#7-2-查看Live-Templates模板-实时模板" class="headerlink" title="7.2 查看Live Templates模板(实时模板)"></a>7.2 查看Live Templates模板(实时模板)</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/wps2.jpg" alt="img"></p><h3 id="7-3-常用代码模板"><a href="#7-3-常用代码模板" class="headerlink" title="7.3 常用代码模板"></a>7.3 常用代码模板</h3><h4 id="1、非空判断"><a href="#1、非空判断" class="headerlink" title="1、非空判断"></a>1、非空判断</h4><ul><li>变量.null：if(变量 == null)</li><li>变量.nn：if(变量 != null) </li><li>变量.notnull：if(变量 != null) </li><li>ifn：if(xx  == null)</li><li>inn：if(xx  != null)</li></ul><h4 id="2、遍历数组和集合"><a href="#2、遍历数组和集合" class="headerlink" title="2、遍历数组和集合"></a>2、遍历数组和集合</h4><ul><li>数组或集合变量.fori：for循环</li><li>数组或集合变量.for：增强for循环</li><li>数组或集合变量.forr：反向for循环</li><li>数组或集合变量.iter：增强for循环遍历数组或集合</li></ul><h4 id="3、输出语句"><a href="#3、输出语句" class="headerlink" title="3、输出语句"></a>3、输出语句</h4><ul><li>sout：相当于System.out.println</li><li>soutm：打印当前方法的名称</li><li>soutp：打印当前方法的形参及形参对应的实参值</li><li>soutv：打印方法中声明的最近的变量的值</li><li>变量.sout：打印当前变量值</li><li>变量.soutv：打印当前变量名及变量值</li></ul><h4 id="4、对象操作"><a href="#4、对象操作" class="headerlink" title="4、对象操作"></a>4、对象操作</h4><ul><li>创建对象<ul><li>Xxx.new  .var ：创建Xxx类的对象，并赋给相应的变量</li><li>Xxx.new  .field：会将方法内刚创建的Xxx对象抽取为一个属性</li></ul></li><li>强转<ul><li>对象.cast：将对象进行强转</li><li>对象.castvar：将对象强转后，并赋给一个变量</li></ul></li></ul><h4 id="5、静态常量声明"><a href="#5、静态常量声明" class="headerlink" title="5、静态常量声明"></a>5、静态常量声明</h4><ul><li>psf：public static final</li><li>psfi：public static final int</li><li>psfs：public static final String</li><li>prsf：private static final</li></ul><h3 id="7-4-自定义代码模板"><a href="#7-4-自定义代码模板" class="headerlink" title="7.4 自定义代码模板"></a>7.4 自定义代码模板</h3><h4 id="7-4-1-自定义后缀补全模板"><a href="#7-4-1-自定义后缀补全模板" class="headerlink" title="7.4.1 自定义后缀补全模板"></a>7.4.1 自定义后缀补全模板</h4><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221018143204667.png" alt="image-20221018143204667"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20221018143606913.png" alt="image-20221018143606913"></p><h4 id="7-4-2-自定义Live-Templates"><a href="#7-4-2-自定义Live-Templates" class="headerlink" title="7.4.2 自定义Live Templates"></a>7.4.2 自定义Live Templates</h4><p>例如：定义sop代表System.out.print();语句</p><p>①在Live Templates中增加模板</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/1576467339631.png" alt="1576467339631"></p><p>②先定义一个模板的组，这样方便管理所有自定义的代码模板</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/1576467395084.png" alt="1576467395084"></p><p>③在模板组里新建模板</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/1576467478993.png" alt="1576467478993"></p><p>④定义模板（以输出语句为例）</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/1576467712251.png" alt="1576467712251"></p><ul><li>Abbreviation：模板的缩略名称</li><li>Description：模板的描述</li><li>Template text：模板的代码片段</li><li>模板应用范围。比如点击Define。选择如下：应用在java代码中。</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/1576467768103.png" alt="1576467768103"></p><p><strong>其它模板1：单元测试模板：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> test$var1$()&#123;</span><br><span class="line">    $var2$</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220612124137427.png" alt="image-20220612124137427"></p><p><strong>其它模板2：创建多线程</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        $<span class="keyword">var</span>$</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220612124221967.png" alt="image-20220612124221967"></p><p><strong>其它模板3：冒泡排序</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">$INDEX$</span> <span class="operator">=</span> <span class="number">1</span>; $INDEX$ &lt; $ARRAY$.length; $INDEX$++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">$INDEX2$</span> <span class="operator">=</span> <span class="number">0</span>; $INDEX2$ &lt; $ARRAY$.length-$INDEX$; $INDEX2$++) &#123;</span><br><span class="line">        <span class="keyword">if</span>($ARRAY$[$INDEX2$] &gt; $ARRAY$[$INDEX2$+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="type">$ELEMENT_TYPE$</span> <span class="variable">temp</span> <span class="operator">=</span> $ARRAY$[$INDEX2$];</span><br><span class="line">            $ARRAY$[$INDEX2$] = $ARRAY$[$INDEX2$+<span class="number">1</span>];</span><br><span class="line">            $ARRAY$[$INDEX2$+<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/image-20220612124541378.png" alt="image-20220612124541378"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第04章-IDEA的安装与使用（上）&quot;&gt;&lt;a href=&quot;#第04章-IDEA的安装与使用（上）&quot; class=&quot;headerlink&quot; title=&quot;第04章_IDEA的安装与使用（上）&quot;&gt;&lt;/a&gt;第04章_IDEA的安装与使用（上）&lt;/h1&gt;&lt;p&gt;讲师：尚硅谷</summary>
      
    
    
    
    <category term="Java2023" scheme="http://example.com/categories/Java2023/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第04章_IDEA的安装与使用（下）</title>
    <link href="http://example.com/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://example.com/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2023-02-18T12:37:01.000Z</published>
    <updated>2023-02-19T07:38:42.999Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第04章-IDEA的安装与使用（下）"><a href="#第04章-IDEA的安装与使用（下）" class="headerlink" title="第04章_IDEA的安装与使用（下）"></a>第04章_IDEA的安装与使用（下）</h1><p>讲师：尚硅谷-宋红康（江湖人称：康师傅）</p><p>官网：<a href="http://www.atguigu.com/">http://www.atguigu.com</a></p><hr><h2 id="8-快捷键的使用"><a href="#8-快捷键的使用" class="headerlink" title="8. 快捷键的使用"></a>8. 快捷键的使用</h2><h3 id="8-1-常用快捷键"><a href="#8-1-常用快捷键" class="headerlink" title="8.1 常用快捷键"></a>8.1 常用快捷键</h3><p>见《<code>尚硅谷_宋红康_IntelliJ IDEA 常用快捷键一览表.md</code>》</p><h3 id="8-2-查看快捷键"><a href="#8-2-查看快捷键" class="headerlink" title="8.2 查看快捷键"></a>8.2 查看快捷键</h3><h4 id="1、已知快捷键操作名，未知快捷键"><a href="#1、已知快捷键操作名，未知快捷键" class="headerlink" title="1、已知快捷键操作名，未知快捷键"></a>1、已知快捷键操作名，未知快捷键</h4><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/1577246789281.png" alt="1577246789281"></p><h4 id="2、已知快捷键，不知道对应的操作名"><a href="#2、已知快捷键，不知道对应的操作名" class="headerlink" title="2、已知快捷键，不知道对应的操作名"></a>2、已知快捷键，不知道对应的操作名</h4><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/1577246895469.png" alt="1577246895469"></p><h3 id="8-3-自定义快捷键"><a href="#8-3-自定义快捷键" class="headerlink" title="8.3 自定义快捷键"></a>8.3 自定义快捷键</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/1577247069135.png" alt="1577247069135"></p><h3 id="8-4-使用其它平台快捷键"><a href="#8-4-使用其它平台快捷键" class="headerlink" title="8.4 使用其它平台快捷键"></a>8.4 使用其它平台快捷键</h3><p>苹果电脑或者是用惯Eclipse快捷的，可以选择其他快捷键插件。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/image-20221019205934099.png" alt="image-20221019205934099"></p><h2 id="9-IDEA断点调试-Debug"><a href="#9-IDEA断点调试-Debug" class="headerlink" title="9. IDEA断点调试(Debug)"></a>9. IDEA断点调试(Debug)</h2><h3 id="9-1-为什么需要Debug"><a href="#9-1-为什么需要Debug" class="headerlink" title="9.1 为什么需要Debug"></a>9.1 为什么需要Debug</h3><p>编好的程序在执行过程中如果出现错误，该如何查找或定位错误呢？简单的代码直接就可以看出来，但如果代码比较复杂，就需要借助程序调试工具（Debug）来查找错误了。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运行编写好的程序时，可能出现的几种情况：</span><br><span class="line">&gt; 情况1：没有任何bug,程序执行正确！</span><br><span class="line"></span><br><span class="line">====================如果出现如下的三种情况，都又必要使用debug=============================</span><br><span class="line">&gt; 情况2：运行以后，出现了错误或异常信息。但是通过日志文件或控制台，显示了异常信息的位置。</span><br><span class="line">&gt; 情况3：运行以后，得到了结果，但是结果不是我们想要的。</span><br><span class="line">&gt; 情况4：运行以后，得到了结果，结果大概率是我们想要的。但是多次运行的话，可能会出现不是我们想要的情况。</span><br><span class="line">        比如：多线程情况下，处理线程安全问题。</span><br><span class="line">        </span><br></pre></td></tr></table></figure><h3 id="9-2-Debug的步骤"><a href="#9-2-Debug的步骤" class="headerlink" title="9.2 Debug的步骤"></a>9.2 Debug的步骤</h3><p>Debug(调试)程序步骤如下：</p><p>1、添加断点</p><p>2、启动调试</p><p>3、单步执行</p><p>4、观察变量和执行流程，找到并解决问题</p><h4 id="1、添加断点"><a href="#1、添加断点" class="headerlink" title="1、添加断点"></a>1、添加断点</h4><p>在源代码文件中，在想要设置断点的代码行的前面的标记行处，单击鼠标左键就可以设置断点，在相同位置再次单击即可取消断点。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/1576476225262.png" alt="1576476225262"></p><h4 id="2、启动调试"><a href="#2、启动调试" class="headerlink" title="2、启动调试"></a>2、启动调试</h4><p>IDEA提供多种方式来启动程序(Launch)的调试，分别是通过菜单(Run –&gt; Debug)、图标(“绿色臭虫”<img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/1576476267687.png" alt="1576476267687">等等</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/1576476841154.png" alt="1576476841154"></p><h4 id="3、单步调试工具介绍"><a href="#3、单步调试工具介绍" class="headerlink" title="3、单步调试工具介绍"></a>3、单步调试工具介绍</h4><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/1576477907469.png" alt="1576477907469"></p><p>或</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/1576477927994.png" alt="1576477927994"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/1576476917169.png" alt="1576476917169">：Step Over（F8）：进入下一步，如果当前行断点是调用一个方法，则不进入当前方法体内</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/1576476984903.png" alt="1576476984903">：Step Into（F7）：进入下一步，如果当前行断点是调用一个自定义方法，则进入该方法体内</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/1576477028289.png" alt="1576477028289">：Force Step Into（Alt +Shift  + F7）：进入下一步，如果当前行断点是调用一个核心类库方法，则进入该方法体内</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/1576477117156.png" alt="1576477117156">：Step Out（Shift  + F8）：跳出当前方法体</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/1576477204366.png" alt="1576477204366">：Run to Cursor（Alt + F9）：直接跳到光标处继续调试</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/1576477448969.png" alt="1576477448969">：Resume Program（F9）：恢复程序运行，但如果该断点下面代码还有断点则停在下一个断点上</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/1576477293031.png" alt="1576477293031">：Stop（Ctrl + F2）：结束调试</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/1576477330355.png" alt="1576477330355">：View Breakpoints（Ctrl + Shift  + F8）：查看所有断点</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/1576477381767.png" alt="1576477381767">：Mute Breakpoints：使得当前代码后面所有的断点失效， 一下执行到底 </p><blockquote><p>说明：在Debug过程中，可以动态的下断点。</p></blockquote><h3 id="9-3-多种Debug情况介绍"><a href="#9-3-多种Debug情况介绍" class="headerlink" title="9.3 多种Debug情况介绍"></a>9.3 多种Debug情况介绍</h3><h4 id="9-3-1-行断点"><a href="#9-3-1-行断点" class="headerlink" title="9.3.1 行断点"></a>9.3.1 行断点</h4><ul><li>断点打在代码所在的行上。执行到此行时，会停下来。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.debug;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName: Debug01</span></span><br><span class="line"><span class="comment"> * Package: com.atguigu.debug</span></span><br><span class="line"><span class="comment"> * Description: 演示1：行断点  &amp;  测试debug各个常见操作按钮</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Create</span>: 2022/10/20 18:44</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Debug01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;m = &quot;</span> + m + <span class="string">&quot;,n = &quot;</span> + n);</span><br><span class="line">        swap(m, n);</span><br><span class="line">        System.out.println(<span class="string">&quot;m = &quot;</span> + m + <span class="string">&quot;,n = &quot;</span> + n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(arr);<span class="comment">//地址值</span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">char</span>[] &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">        System.out.println(arr1);<span class="comment">//abc</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> m;</span><br><span class="line">        m = n;</span><br><span class="line">        n = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="9-3-2-方法断点"><a href="#9-3-2-方法断点" class="headerlink" title="9.3.2 方法断点"></a>9.3.2 方法断点</h4><ul><li>断点设置在方法的签名上，默认当进入时，断点可以被唤醒。</li><li>也可以设置在方法退出时，断点也被唤醒</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/image-20221020213250606.png" alt="image-20221020213250606"></p><ul><li>在多态的场景下，在父类或接口的方法上打断点，会自动调入到子类或实现类的方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.debug;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName: Debug02</span></span><br><span class="line"><span class="comment"> * Package: com.atguigu.debug</span></span><br><span class="line"><span class="comment"> * Description: 演示2： 方法断点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Create</span>: 2022/10/20 21:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Debug02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.</span></span><br><span class="line">        <span class="type">Son</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        instance.test();</span><br><span class="line">        <span class="comment">//2.</span></span><br><span class="line">        <span class="type">Father</span> <span class="variable">instance1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        instance1.test();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.</span></span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">con</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConsumerImpl</span>();</span><br><span class="line">        con.accept(<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.</span></span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Jerry&quot;</span>,<span class="number">11</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Tony&quot;</span>,<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father : test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son : test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Consumer</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String str)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConsumerImpl</span> <span class="keyword">implements</span> <span class="title class_">Consumer</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConsumerImple:&quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="9-3-3-字段断点"><a href="#9-3-3-字段断点" class="headerlink" title="9.3.3 字段断点"></a>9.3.3 字段断点</h4><ul><li>在类的属性声明上打断点，默认对属性的修改操作进行监控</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/image-20221020214905607.png" alt="image-20221020214905607"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.debug;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName: Debug03</span></span><br><span class="line"><span class="comment"> * Package: com.atguigu.debug</span></span><br><span class="line"><span class="comment"> * Description: 演示3：字段断点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Create</span>: 2022/10/20 21:34</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Debug03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        id = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> id, String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="9-3-4-条件断点"><a href="#9-3-4-条件断点" class="headerlink" title="9.3.4 条件断点"></a>9.3.4 条件断点</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.debug;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName: Debug04</span></span><br><span class="line"><span class="comment"> * Package: com.atguigu.debug</span></span><br><span class="line"><span class="comment"> * Description: 演示4：条件断点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Create</span>: 2022/10/20 21:49</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Debug04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            System.out.println(target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对上述代码，在满足arr[i] % 3 == 0的条件下，执行断点。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/image-20221020220043375.png" alt="image-20221020220043375"></p><h4 id="9-3-5-异常断点（暂略）"><a href="#9-3-5-异常断点（暂略）" class="headerlink" title="9.3.5 异常断点（暂略）"></a>9.3.5 异常断点（暂略）</h4><ul><li>对异常进行跟踪。如果程序出现指定异常，程序就会执行断点，自动停住。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.debug;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName: Debug05</span></span><br><span class="line"><span class="comment"> * Package: com.atguigu.debug</span></span><br><span class="line"><span class="comment"> * Description: 演示5：异常断点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Create</span>: 2022/10/20 22:01</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Debug05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> m / n;</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        Person p1 = new Person(1001);</span></span><br><span class="line"><span class="comment">//        System.out.println(p1.getName().toUpperCase());</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过下图的方式，对指定的异常进行监控：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/image-20221020220904864.png" alt="image-20221020220904864"></p><h4 id="9-3-6-线程调试（暂略）"><a href="#9-3-6-线程调试（暂略）" class="headerlink" title="9.3.6 线程调试（暂略）"></a>9.3.6 线程调试（暂略）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.debug;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName: Debug06</span></span><br><span class="line"><span class="comment"> * Package: com.atguigu.debug</span></span><br><span class="line"><span class="comment"> * Description: 演示6：线程调试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Create</span>: 2022/10/20 22:46</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Debug06</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        test(<span class="string">&quot;Thread1&quot;</span>);</span><br><span class="line">        test(<span class="string">&quot;Thread2&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String threadName)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(</span><br><span class="line">                () -&gt; System.out.println(Thread.currentThread().getName()),</span><br><span class="line">                threadName</span><br><span class="line">        ).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/image-20221020231542081.png" alt="image-20221020231542081"></p><h4 id="9-3-7-强制结束"><a href="#9-3-7-强制结束" class="headerlink" title="9.3.7 强制结束"></a>9.3.7 强制结束</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.debug;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName: Debug07</span></span><br><span class="line"><span class="comment"> * Package: com.atguigu.debug</span></span><br><span class="line"><span class="comment"> * Description: 演示7：强制结束</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Create</span>: 2022/10/20 23:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Debug07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;获取请求的数据&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;调用写入数据库的方法&quot;</span>);</span><br><span class="line">        insert();</span><br><span class="line">        System.out.println(<span class="string">&quot;程序结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入insert()方法&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;获取数据库连接&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;将数据写入数据表中&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;写出操作完成&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;断开连接&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/image-20221020232038387.png" alt="image-20221020232038387"></p><h3 id="9-4-自定义调试数据视图（暂略）"><a href="#9-4-自定义调试数据视图（暂略）" class="headerlink" title="9.4 自定义调试数据视图（暂略）"></a>9.4 自定义调试数据视图（暂略）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.debug;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName: Debug08</span></span><br><span class="line"><span class="comment"> * Package: com.atguigu.debug</span></span><br><span class="line"><span class="comment"> * Description: 演示8：用户自定义数据视图</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Create</span>: 2022/10/20 23:21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Debug08</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">1</span>,<span class="string">&quot;高铁&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>,<span class="string">&quot;网购&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>,<span class="string">&quot;支付宝&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>,<span class="string">&quot;共享单车&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>设置如下：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/1576478352757.png" alt="1576478352757"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/1576478431514.png" alt="1576478431514"></p><h3 id="9-5-常见问题"><a href="#9-5-常见问题" class="headerlink" title="9.5 常见问题"></a>9.5 常见问题</h3><p>问题：使用Step Into时，会出现无法进入源码的情况。如何解决？</p><p>方案1：使用 force step into 即可</p><p>方案2：点击Setting -&gt; Build,Execution,Deployment -&gt; Debugger -&gt; Stepping</p><p>把Do not step into the classess中的<code>java.*</code>、<code>javax.*</code> 取消勾选即可。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220516200427750.png" alt="image-20220516200427750" style="zoom:75%;"></p><p>小结：</p><blockquote><p>经验：初学者对于在哪里加断点，缺乏经验，这也是调试程序最麻烦的地方，需要一定的经验。</p><p>简单来说，在可能发生错误的代码的前面加断点。如果不会判断，就在程序执行的起点处加断点。</p></blockquote><h2 id="10-IDEA常用插件"><a href="#10-IDEA常用插件" class="headerlink" title="10. IDEA常用插件"></a>10. IDEA常用插件</h2><h3 id="推荐1：Alibaba-Java-Coding-Guidelines"><a href="#推荐1：Alibaba-Java-Coding-Guidelines" class="headerlink" title="推荐1：Alibaba Java Coding Guidelines"></a>推荐1：Alibaba Java Coding Guidelines</h3><p> <img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/image-20221023224455751.png" alt="image-20221023224455751"></p><p>阿里巴巴Java编码规范检查插件，检测代码是否存在问题，以及是否符合规范。</p><p>使用：在类中，右键，选择编码规约扫描，在下方显示扫描规约和提示。根据提示规范代码，提高代码质量。</p><h3 id="推荐2：jclasslib-bytecode-viewer"><a href="#推荐2：jclasslib-bytecode-viewer" class="headerlink" title="推荐2：jclasslib bytecode viewer"></a>推荐2：jclasslib bytecode viewer</h3><p> <img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/image-20221019223514412.png" alt="image-20221019223514412"></p><p>可视化的字节码查看器。</p><p>使用：</p><ol><li>在 IDEA 打开想研究的类。</li><li>编译该类或者直接编译整个项目（ 如果想研究的类在 jar 包中，此步可略过）。</li><li>打开“view” 菜单，选择“Show Bytecode With jclasslib” 选项。</li><li>选择上述菜单项后 IDEA 中会弹出 jclasslib 工具窗口。</li></ol><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/image-20221023225239838.png" alt="image-20221023225239838"></p><p>英文设置：</p><p>在 Help -&gt; Edit Custom VM Options …，加上</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Duser.language=en</span><br></pre></td></tr></table></figure><h3 id="推荐3：Translation"><a href="#推荐3：Translation" class="headerlink" title="推荐3：Translation"></a>推荐3：Translation</h3><p> <img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/image-20221019224727758.png" alt="image-20221019224727758"></p><p>注册翻译服务（有道智云、百度翻译开放平台、阿里云机器翻译）帐号，开通翻译服务并获取其应用ID和密钥<br>绑定应用ID和密钥：偏好设置（设置） &gt; 工具 &gt; 翻译 &gt; 常规 &gt; 翻译引擎 &gt; 配置…</p><p>使用：鼠标选中文本，点击右键即可自动翻译成多国语言。</p><p>注：请注意保管好你的应用密钥，防止其泄露。</p><h3 id="推荐4：GenerateAllSetter"><a href="#推荐4：GenerateAllSetter" class="headerlink" title="推荐4：GenerateAllSetter"></a>推荐4：GenerateAllSetter</h3><p> <img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/image-20221019223238560.png" alt="image-20221019223238560"></p><p>实际开发中还有一个非常常见的场景： 我们创建一个对象后，想依次调用 Setter 函数对属性赋值，如果属性较多很容易遗漏或者重复。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/image-20221023230812560.png" alt="image-20221023230812560" style="zoom:80%;"></p><p>可以使用这 GenerateAllSetter 提供的功能，快速生成对象的所有 Setter 函数（可填充默认值），然后自己再跟进实际需求设置属性值。</p><h3 id="插件5：Rainbow-Brackets"><a href="#插件5：Rainbow-Brackets" class="headerlink" title="插件5：Rainbow Brackets"></a>插件5：Rainbow Brackets</h3><p> <img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/image-20221019223340532.png" alt="image-20221019223340532"></p><p>给括号添加彩虹色，使开发者通过颜色区分括号嵌套层级，便于阅读</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/image-20221019222113604.png" alt="image-20221019222113604"></p><h3 id="推荐6：CodeGlance-Pro"><a href="#推荐6：CodeGlance-Pro" class="headerlink" title="推荐6：CodeGlance Pro"></a>推荐6：CodeGlance Pro</h3><p> <img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/image-20221019223219982.png" alt="image-20221019223219982"></p><p>在编辑器右侧生成代码小地图，可以拖拽小地图光标快速定位代码，阅读行数很多的代码文件时非常实用。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/image-20221023231842846.png" alt="image-20221023231842846" style="zoom:80%;"></p><h3 id="推荐7：Statistic"><a href="#推荐7：Statistic" class="headerlink" title="推荐7：Statistic"></a>推荐7：Statistic</h3><p> <img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/image-20221019234545641.png" alt="image-20221019234545641"></p><p>代码统计工具。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/image-20221023231801337.png" alt="image-20221023231801337"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/image-20221023231741671.png" alt="image-20221023231741671"></p><h3 id="推荐8：Presentation-Assistant"><a href="#推荐8：Presentation-Assistant" class="headerlink" title="推荐8：Presentation Assistant"></a>推荐8：Presentation Assistant</h3><p> <img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/image-20221019223426562.png" alt="image-20221019223426562"></p><p>显示快捷键操作的按键</p><h3 id="推荐9：Key-Promoter-X"><a href="#推荐9：Key-Promoter-X" class="headerlink" title="推荐9：Key Promoter X"></a>推荐9：Key Promoter X</h3><p> <img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/image-20221019223250943.png" alt="image-20221019223250943"></p><p>快捷键提示插件。当你执行鼠标操作时，如果该操作可被快捷键代替，会给出提示，帮助你自然形成使用快捷键的习惯，告别死记硬背。</p><h3 id="推荐10：JavaDoc"><a href="#推荐10：JavaDoc" class="headerlink" title="推荐10：JavaDoc"></a>推荐10：JavaDoc</h3><p> <img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/image-20221019224820244.png" alt="image-20221019224820244"></p><p>按<code>alt+insert</code>，执行操作：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/image-20221019225041655.png" alt="image-20221019225041655"></p><h3 id="推荐11：-LeetCode-Editor"><a href="#推荐11：-LeetCode-Editor" class="headerlink" title="推荐11： LeetCode Editor"></a>推荐11： LeetCode Editor</h3><p> <img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/image-20221019225142011.png" alt="image-20221019225142011"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/image-20221019225242331.png" alt="image-20221019225242331"></p><p>在 IDEA 里刷力扣算法题</p><h3 id="推荐12：GsonFormatPlus"><a href="#推荐12：GsonFormatPlus" class="headerlink" title="推荐12：GsonFormatPlus"></a>推荐12：GsonFormatPlus</h3><p> <img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/image-20221019233444272.png" alt="image-20221019233444272"></p><p>根据 json 生成对象。</p><p>使用：使用alt + s 或 alt + insert调取。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/image-20221023235416317.png" alt="image-20221023235416317"></p><p>举例：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tom&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="string">&quot;18&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;man&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hometown&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;province&quot;</span><span class="punctuation">:</span> <span class="string">&quot;河北省&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span> <span class="string">&quot;石家庄市&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;county&quot;</span><span class="punctuation">:</span> <span class="string">&quot;正定县&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="插件13：Material-Theme-UI"><a href="#插件13：Material-Theme-UI" class="headerlink" title="插件13：Material Theme UI"></a>插件13：Material Theme UI</h3><p> <img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/image-20221019223325480.png" alt="image-20221019223325480"></p><p>对于很多人而言，写代码时略显枯燥的，如果能够安装自己喜欢的主题将为开发工作带来些许乐趣。</p><p>IDEA 支持各种主题插件，其中最出名的当属 Material Theme UI。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/image-20220810011348421.png" alt="image-20220810011348421"></p><p>安装后，可以从该插件内置的各种风格个选择自己最喜欢的一种。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第04章-IDEA的安装与使用（下）&quot;&gt;&lt;a href=&quot;#第04章-IDEA的安装与使用（下）&quot; class=&quot;headerlink&quot; title=&quot;第04章_IDEA的安装与使用（下）&quot;&gt;&lt;/a&gt;第04章_IDEA的安装与使用（下）&lt;/h1&gt;&lt;p&gt;讲师：尚硅谷</summary>
      
    
    
    
    <category term="Java2023" scheme="http://example.com/categories/Java2023/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第05章_数组</title>
    <link href="http://example.com/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/"/>
    <id>http://example.com/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/</id>
    <published>2023-02-18T12:37:01.000Z</published>
    <updated>2023-02-19T07:38:42.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第05章-数组"><a href="#第05章-数组" class="headerlink" title="第05章_数组"></a>第05章_数组</h1><p>讲师：尚硅谷-宋红康（江湖人称：康师傅）</p><p>官网：<a href="http://www.atguigu.com/">http://www.atguigu.com</a></p><hr><h2 id="本章专题与脉络"><a href="#本章专题与脉络" class="headerlink" title="本章专题与脉络"></a>本章专题与脉络</h2><p><img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/第1阶段：Java基本语法-第05章.png" alt="第1阶段：Java基本语法-第05章" style="zoom:45%;"></p><h2 id="1-数组的概述"><a href="#1-数组的概述" class="headerlink" title="1. 数组的概述"></a>1. 数组的概述</h2><h3 id="1-1-为什么需要数组"><a href="#1-1-为什么需要数组" class="headerlink" title="1.1 为什么需要数组"></a>1.1 为什么需要数组</h3><p><strong>需求分析1：</strong></p><p>需要统计某公司50个员工的工资情况，例如计算平均工资、找到最高工资等。用之前知识，首先需要声明<code>50个变量</code>来分别记录每位员工的工资，这样会很麻烦。因此我们可以将所有的数据全部存储到一个容器中统一管理，并使用容器进行计算。</p><p><strong>需求分析2：</strong></p><p><img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/snipaste_20220317_000101.jpg" alt="snipaste_20220317_000101" style="zoom: 50%;"></p><p>容器的概念：</p><ul><li><strong>生活中的容器：</strong>水杯（装水等液体），衣柜（装衣服等物品），集装箱（装货物等）。</li><li><strong>程序中的容器：</strong>将多个数据存储到一起，每个数据称为该容器的元素。</li></ul><h3 id="1-2-数组的概念"><a href="#1-2-数组的概念" class="headerlink" title="1.2 数组的概念"></a>1.2 数组的概念</h3><ul><li><p>数组(Array)，是多个相同类型数据按一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。</p></li><li><p>数组中的概念</p><ul><li>数组名</li><li>下标（或索引）</li><li>元素</li><li>数组的长度</li></ul></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/image-20220317000952499.png" alt="image-20220317000952499"></p><p><strong>数组的特点：</strong></p><ul><li>数组本身是<code>引用数据类型</code>，而数组中的元素可以是<code>任何数据类型</code>，包括基本数据类型和引用数据类型。</li><li>创建数组对象会在内存中开辟一整块<code>连续的空间</code>。占据的空间的大小，取决于数组的长度和数组中元素的类型。</li><li>数组中的元素在内存中是依次紧密排列的，有序的。</li><li>数组，一旦初始化完成，其长度就是确定的。数组的<code>长度一旦确定，就不能修改</code>。</li><li>我们可以直接通过下标(或索引)的方式调用指定位置的元素，速度很快。</li><li>数组名中引用的是这块连续空间的首地址。</li></ul><h3 id="1-3-数组的分类"><a href="#1-3-数组的分类" class="headerlink" title="1.3 数组的分类"></a>1.3 数组的分类</h3><p><strong>1、按照元素类型分：</strong></p><ul><li>基本数据类型元素的数组：每个元素位置存储基本数据类型的值</li><li>引用数据类型元素的数组：每个元素位置存储对象（本质是存储对象的首地址）（在面向对象部分讲解）</li></ul><p><strong>2、按照维度分：</strong></p><ul><li>一维数组：存储一组数据</li><li>二维数组：存储多组数据，相当于二维表，一行代表一组数据，只是这里的二维表每一行长度不要求一样。</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/image-20211221164709624.png" alt="image-20211221164709624"></p><h2 id="2-一维数组的使用"><a href="#2-一维数组的使用" class="headerlink" title="2. 一维数组的使用"></a>2. 一维数组的使用</h2><h3 id="2-1-一维数组的声明"><a href="#2-1-一维数组的声明" class="headerlink" title="2.1 一维数组的声明"></a>2.1 一维数组的声明</h3><p><strong>格式：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//推荐</span></span><br><span class="line">元素的数据类型[] 一维数组的名称;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不推荐</span></span><br><span class="line">元素的数据类型  一维数组名[];</span><br></pre></td></tr></table></figure><p><strong>举例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr;</span><br><span class="line"><span class="type">int</span> arr1[];</span><br><span class="line"><span class="type">double</span>[] arr2;</span><br><span class="line">String[] arr3;  <span class="comment">//引用类型变量数组</span></span><br></pre></td></tr></table></figure><p><strong>数组的声明，需要明确：</strong></p><p>（1）数组的维度：在Java中数组的符号是[]，[]表示一维，[][]表示二维。</p><p>（2）数组的元素类型：即创建的数组容器可以存储什么数据类型的数据。元素的类型可以是任意的Java的数据类型。例如：int、String、Student等。</p><p>（3）数组名：就是代表某个数组的标识符，数组名其实也是变量名，按照变量的命名规范来命名。数组名是个引用数据类型的变量，因为它代表一组数据。</p><p><strong>举例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//比如，要存储一个小组的成绩</span></span><br><span class="line">        <span class="type">int</span>[] scores;</span><br><span class="line">        <span class="type">int</span> grades[];</span><br><span class="line"><span class="comment">//        System.out.println(scores);//未初始化不能使用</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//比如，要存储一组字母</span></span><br><span class="line">        <span class="type">char</span>[] letters;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比如，要存储一组姓名</span></span><br><span class="line">        String[] names;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比如，要存储一组价格</span></span><br><span class="line">        <span class="type">double</span>[] prices;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：Java语言中声明数组时不能指定其长度(数组中元素的个数)。 例如： int a[5]; //非法</p><h3 id="2-2-一维数组的初始化"><a href="#2-2-一维数组的初始化" class="headerlink" title="2.2 一维数组的初始化"></a>2.2 一维数组的初始化</h3><h4 id="2-2-1-静态初始化"><a href="#2-2-1-静态初始化" class="headerlink" title="2.2.1 静态初始化"></a>2.2.1 静态初始化</h4><ul><li><p>如果数组变量的初始化和数组元素的赋值操作同时进行，那就称为静态初始化。</p></li><li><p>静态初始化，本质是用静态数据（编译时已知）为数组初始化。此时数组的长度由静态数据的个数决定。</p></li><li><p><strong>一维数组声明和静态初始化格式1：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[] 数组名 = <span class="keyword">new</span> 数据类型[]&#123;元素<span class="number">1</span>,元素<span class="number">2</span>,元素<span class="number">3</span>,...&#125;;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line">    </span><br><span class="line">数据类型[] 数组名;</span><br><span class="line">数组名 = <span class="keyword">new</span> 数据类型[]&#123;元素<span class="number">1</span>,元素<span class="number">2</span>,元素<span class="number">3</span>,...&#125;;</span><br></pre></td></tr></table></figure><ul><li>new：关键字，创建数组使用的关键字。因为数组本身是引用数据类型，所以要用new创建数组实体。</li></ul></li></ul><p>例如，定义存储1，2，3，4，5整数的数组容器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//正确</span></span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"><span class="type">int</span>[] arr;</span><br><span class="line">arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//正确</span></span><br></pre></td></tr></table></figure><ul><li><strong>一维数组声明和静态初始化格式2：</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[] 数组名 = &#123;元素<span class="number">1</span>,元素<span class="number">2</span>,元素<span class="number">3.</span>..&#125;;<span class="comment">//必须在一个语句中完成，不能分成两个语句写</span></span><br></pre></td></tr></table></figure><p>例如，定义存储1，2，3，4，5整数的数组容器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] arr;</span><br><span class="line">arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure><p><strong>举例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//右边不需要写new int[]</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] nums;</span><br><span class="line">        nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;; <span class="comment">//声明和初始化在两个语句完成，就不能使用new int[]</span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] word = &#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        String[] heros = &#123;<span class="string">&quot;袁隆平&quot;</span>,<span class="string">&quot;邓稼先&quot;</span>,<span class="string">&quot;钱学森&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;arr数组：&quot;</span> + arr);<span class="comment">//arr数组：[I@1b6d3586</span></span><br><span class="line">        System.out.println(<span class="string">&quot;nums数组：&quot;</span> + nums);<span class="comment">//nums数组：[I@4554617c</span></span><br><span class="line">        System.out.println(<span class="string">&quot;word数组：&quot;</span> + word);<span class="comment">//word数组：[C@74a14482</span></span><br><span class="line">        System.out.println(<span class="string">&quot;heros数组：&quot;</span> + heros);<span class="comment">//heros数组：[Ljava.lang.String;@1540e19d</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-动态初始化"><a href="#2-2-2-动态初始化" class="headerlink" title="2.2.2 动态初始化"></a>2.2.2 动态初始化</h4><p>数组变量的初始化和数组元素的赋值操作分开进行，即为动态初始化。</p><p>动态初始化中，只确定了元素的个数（即数组的长度），而元素值此时只是默认值，还并未真正赋自己期望的值。真正期望的数据需要后续单独一个一个赋值。</p><p><strong>格式：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数组存储的元素的数据类型[] 数组名字 = <span class="keyword">new</span> 数组存储的元素的数据类型[长度];</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">数组存储的数据类型[] 数组名字;</span><br><span class="line">数组名字 = <span class="keyword">new</span> 数组存储的数据类型[长度];</span><br></pre></td></tr></table></figure><ul><li><p>[长度]：数组的长度，表示数组容器中可以最多存储多少个元素。</p></li><li><p><strong>注意：数组有定长特性，长度一旦指定，不可更改。</strong>和水杯道理相同，买了一个2升的水杯，总容量就是2升是固定的。</p></li></ul><p><strong>举例1：正确写法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] arr;</span><br><span class="line">arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>举例2：错误写法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//错误的，后面有&#123;&#125;指定元素列表，就不需要在[]中指定元素个数了。</span></span><br></pre></td></tr></table></figure><h3 id="2-3-一维数组的使用"><a href="#2-3-一维数组的使用" class="headerlink" title="2.3 一维数组的使用"></a>2.3 一维数组的使用</h3><h4 id="2-3-1-数组的长度"><a href="#2-3-1-数组的长度" class="headerlink" title="2.3.1  数组的长度"></a>2.3.1  数组的长度</h4><ul><li>数组的元素总个数，即数组的长度</li><li>每个数组都有一个属性length指明它的长度，例如：arr.length 指明数组arr的长度(即元素个数)</li><li>每个数组都具有长度，而且一旦初始化，其长度就是确定，且是不可变的。</li></ul><h4 id="2-3-2-数组元素的引用"><a href="#2-3-2-数组元素的引用" class="headerlink" title="2.3.2 数组元素的引用"></a>2.3.2 数组元素的引用</h4><p><strong>如何表示数组中的一个元素？</strong></p><p>每一个存储到数组的元素，都会自动的拥有一个编号，从0开始，这个自动编号称为<code>数组索引(index)或下标</code>，可以通过数组的索引/下标访问到数组中的元素。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数组名[索引/下标]</span><br></pre></td></tr></table></figure><p><strong>数组的下标范围？</strong></p><p>Java中数组的下标从[0]开始，下标范围是[0, 数组的长度-1]，即[0, 数组名.length-1]</p><p>数组元素下标可以是整型常量或整型表达式。如a[3] , b[i] , c[6*i];</p><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;arr数组的长度：&quot;</span> + arr.length);</span><br><span class="line">        System.out.println(<span class="string">&quot;arr数组的第1个元素：&quot;</span> + arr[<span class="number">0</span>]);<span class="comment">//下标从0开始</span></span><br><span class="line">        System.out.println(<span class="string">&quot;arr数组的第2个元素：&quot;</span> + arr[<span class="number">1</span>]);</span><br><span class="line">        System.out.println(<span class="string">&quot;arr数组的第3个元素：&quot;</span> + arr[<span class="number">2</span>]);</span><br><span class="line">        System.out.println(<span class="string">&quot;arr数组的第4个元素：&quot;</span> + arr[<span class="number">3</span>]);</span><br><span class="line">        System.out.println(<span class="string">&quot;arr数组的第5个元素：&quot;</span> + arr[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改第1个元素的值</span></span><br><span class="line">        <span class="comment">//此处arr[0]相当于一个int类型的变量</span></span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;arr数组的第1个元素：&quot;</span> + arr[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-一维数组的遍历"><a href="#2-4-一维数组的遍历" class="headerlink" title="2.4 一维数组的遍历"></a>2.4 一维数组的遍历</h3><p>将数组中的每个元素分别获取出来，就是<code>遍历</code>。for循环与数组的遍历是绝配。</p><p><strong>举例1</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTest4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="comment">//打印数组的属性，输出结果是5</span></span><br><span class="line">        System.out.println(<span class="string">&quot;数组的长度：&quot;</span> + arr.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历输出数组中的元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;数组的元素有：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>举例2</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTest5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;arr数组的长度：&quot;</span> + arr.length);</span><br><span class="line">        System.out.print(<span class="string">&quot;存储数据到arr数组之前：[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.print(arr[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;,&quot;</span> + arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;]&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line"> <span class="comment">/* </span></span><br><span class="line"><span class="comment"> arr[0] = 2;</span></span><br><span class="line"><span class="comment">        arr[1] = 4;</span></span><br><span class="line"><span class="comment">        arr[2] = 6;</span></span><br><span class="line"><span class="comment">        arr[3] = 8;</span></span><br><span class="line"><span class="comment">        arr[4] = 10;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = (i+<span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;存储数据到arr数组之后：[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.print(arr[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;,&quot;</span> + arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-数组元素的默认值"><a href="#2-5-数组元素的默认值" class="headerlink" title="2.5 数组元素的默认值"></a>2.5 数组元素的默认值</h3><p>数组是引用类型，当我们使用动态初始化方式创建数组时，元素值只是默认值。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTest6</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String argv[])</span>&#123;</span><br><span class="line"><span class="type">int</span> a[]= <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>]; </span><br><span class="line">System.out.println(a[<span class="number">3</span>]); <span class="comment">//a[3]的默认值为0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>对于基本数据类型而言，默认初始化值各有不同。</p><p>对于引用数据类型而言，默认初始化值为null（注意与0不同！)</p><p><img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/1561509460135.png" alt></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTest7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//存储26个字母</span></span><br><span class="line">        <span class="type">char</span>[] letters = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">26</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;letters数组的长度：&quot;</span> + letters.length);</span><br><span class="line">        System.out.print(<span class="string">&quot;存储字母到letters数组之前：[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; letters.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.print(letters[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;,&quot;</span> + letters[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;]&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//存储5个姓名</span></span><br><span class="line">        String[] names = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">5</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;names数组的长度：&quot;</span> + names.length);</span><br><span class="line">        System.out.print(<span class="string">&quot;存储姓名到names数组之前：[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; names.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.print(names[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;,&quot;</span> + names[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-一维数组内存分析"><a href="#3-一维数组内存分析" class="headerlink" title="3. 一维数组内存分析"></a>3. 一维数组内存分析</h2><h3 id="3-1-Java虚拟机的内存划分"><a href="#3-1-Java虚拟机的内存划分" class="headerlink" title="3.1 Java虚拟机的内存划分"></a>3.1 Java虚拟机的内存划分</h3><p>为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/JVM架构-简图.png" alt="JVM架构-简图"></p><div class="table-container"><table><thead><tr><th>区域名称</th><th>作用</th></tr></thead><tbody><tr><td><code>虚拟机栈</code></td><td>用于存储正在执行的每个Java方法的局部变量表等。局部变量表存放了编译期可知长度<br>的各种基本数据类型、对象引用，方法执行完，自动释放。</td></tr><tr><td><code>堆内存</code></td><td>存储对象（包括数组对象），new来创建的，都存储在堆内存。</td></tr><tr><td><code>方法区</code></td><td>存储已被虚拟机加载的类信息、常量、（静态变量）、即时编译器编译后的代码等数据。</td></tr><tr><td>本地方法栈</td><td>当程序中调用了native的本地方法时，本地方法执行期间的内存区域</td></tr><tr><td>程序计数器</td><td>程序计数器是CPU中的寄存器，它包含每一个线程下一条要执行的指令的地址</td></tr></tbody></table></div><h3 id="3-2-一维数组在内存中的存储"><a href="#3-2-一维数组在内存中的存储" class="headerlink" title="3.2 一维数组在内存中的存储"></a>3.2 一维数组在内存中的存储</h3><h4 id="1、一个一维数组内存图"><a href="#1、一个一维数组内存图" class="headerlink" title="1、一个一维数组内存图"></a>1、一个一维数组内存图</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">  System.out.println(arr);<span class="comment">//[I@5f150435</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/数组内存图1.jpg" alt></p><h4 id="2、数组下标为什么是0开始"><a href="#2、数组下标为什么是0开始" class="headerlink" title="2、数组下标为什么是0开始"></a>2、数组下标为什么是0开始</h4><p>因为第一个元素距离数组首地址间隔0个单元格。</p><h4 id="3、两个一维数组内存图"><a href="#3、两个一维数组内存图" class="headerlink" title="3、两个一维数组内存图"></a>3、两个一维数组内存图</h4><p>两个数组独立</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    System.out.println(arr);</span><br><span class="line">    System.out.println(arr2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/数组内存图2.jpg" style="zoom:67%;"></p><h4 id="4、两个变量指向一个一维数组"><a href="#4、两个变量指向一个一维数组" class="headerlink" title="4、两个变量指向一个一维数组"></a>4、两个变量指向一个一维数组</h4><p>两个数组变量本质上代表同一个数组。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 定义数组，存储3个元素</span></span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">    <span class="comment">//数组索引进行赋值</span></span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">6</span>;</span><br><span class="line">    arr[<span class="number">2</span>] = <span class="number">7</span>;</span><br><span class="line">    <span class="comment">//输出3个索引上的元素值</span></span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">//定义数组变量arr2，将arr的地址赋值给arr2</span></span><br><span class="line">    <span class="type">int</span>[] arr2 = arr;</span><br><span class="line">    arr2[<span class="number">1</span>] = <span class="number">9</span>;</span><br><span class="line">    System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/数组内存图3.jpg" style="zoom:67%;"></p><h2 id="4-一维数组的应用"><a href="#4-一维数组的应用" class="headerlink" title="4. 一维数组的应用"></a>4. 一维数组的应用</h2><p><strong>案例1：</strong>升景坊单间短期出租4个月，550元/月（水电煤公摊，网费35元/月），空调、卫生间、厨房齐全。屋内均是IT行业人士，喜欢安静。所以要求来租者最好是同行或者刚毕业的年轻人，爱干净、安静。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTest</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">8</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>&#125;;</span><br><span class="line">      <span class="type">int</span>[] index = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line">      <span class="type">String</span> <span class="variable">tel</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; index.length;i++)&#123;</span><br><span class="line">            tel += arr[index[i]];</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;联系方式：&quot;</span> + tel);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>案例2：输出英文星期几</p><p>用一个数组，保存星期一到星期天的7个英语单词，从键盘输入1-7，显示对应的单词<br>{“Monday”,”Tuesday”,”Wednesday”,”Thursday”,”Friday”,”Saturday”,”Sunday”}</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 14:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeekArrayTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 声明并初始化星期的数组</span></span><br><span class="line">        String[] weeks = &#123;<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;Tuesday&quot;</span>,<span class="string">&quot;Wednesday&quot;</span>,<span class="string">&quot;Thursday&quot;</span>,<span class="string">&quot;Friday&quot;</span>,<span class="string">&quot;Saturday&quot;</span>,<span class="string">&quot;Sunday&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 使用Scanner从键盘获取1-7范围的整数</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入[1-7]范围的整数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(number &lt; <span class="number">1</span> || number &gt; <span class="number">7</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你输入的输入非法&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3. 根据输入的整数，到数组中相应的索引位置获取指定的元素（即：星期几）</span></span><br><span class="line">            System.out.println(<span class="string">&quot;对应的星期为：&quot;</span> + weeks[number - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        scanner.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例3：</strong>从键盘读入学生成绩，找出最高分，并输出学生成绩等级。</p><ul><li><p>成绩&gt;=最高分-10  等级为’A’  </p></li><li><p>成绩&gt;=最高分-20  等级为’B’</p></li><li><p>成绩&gt;=最高分-30  等级为’C’  </p></li><li><p>其余            等级为’D’</p></li></ul><p>提示：先读入学生人数，根据人数创建int数组，存放学生成绩。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/image-20220317004637748.png" alt="image-20220317004637748" style="zoom:80%;"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 14:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScoreTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 根据提示，获取学生人数</span></span><br><span class="line">        System.out.print(<span class="string">&quot;请输入学生人数：&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 根据学生人数，创建指定长度的数组 (使用动态初始化)</span></span><br><span class="line">        <span class="type">int</span>[] scores = <span class="keyword">new</span> <span class="title class_">int</span>[count];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 使用循环，依次给数组的元素赋值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxScore</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//记录最高分</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入&quot;</span> + count + <span class="string">&quot;个成绩&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; scores.length; i++) &#123;</span><br><span class="line">            scores[i] = scanner.nextInt();</span><br><span class="line">            <span class="comment">//4. 获取数组中元素的最大值，即为最高分</span></span><br><span class="line">            <span class="keyword">if</span>(maxScore &lt; scores[i])&#123;</span><br><span class="line">                maxScore = scores[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;最高分是：&quot;</span> + maxScore);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 遍历数组元素，输出各自的分数，并根据其分数与最高分的差值，获取各自的等级</span></span><br><span class="line">        <span class="type">char</span> grade;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; scores.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(scores[i] &gt;= maxScore - <span class="number">10</span>)&#123;</span><br><span class="line">                grade = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(scores[i] &gt;= maxScore - <span class="number">20</span>)&#123;</span><br><span class="line">                grade = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(scores[i] &gt;= maxScore - <span class="number">30</span>)&#123;</span><br><span class="line">                grade = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                grade = <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;student &quot;</span> + i + <span class="string">&quot; socre is &quot;</span> + scores[i] + <span class="string">&quot;, grade is &quot;</span> + grade);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        scanner.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-多维数组的使用"><a href="#5-多维数组的使用" class="headerlink" title="5. 多维数组的使用"></a>5. 多维数组的使用</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><ul><li>Java 语言里提供了支持多维数组的语法。</li></ul><ul><li><p>如果说可以把一维数组当成几何中的<code>线性图形</code>，那么二维数组就相当于是<code>一个表格</code>，像Excel中的表格、围棋棋盘一样。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/image-20220317004810263.png" alt="image-20220317004810263" style="zoom:80%;"></p></li><li><p><strong>应用举例1：</strong></p><p>某公司2022年全年各个月份的销售额进行登记。按月份存储，可以使用一维数组。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] monthData = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">23</span>,<span class="number">43</span>,<span class="number">22</span>,<span class="number">34</span>,<span class="number">55</span>,<span class="number">65</span>,<span class="number">44</span>,<span class="number">67</span>,<span class="number">45</span>,<span class="number">78</span>,<span class="number">67</span>,<span class="number">66</span>&#125;;</span><br></pre></td></tr></table></figure><p>如果改写为按<code>季度</code>为单位存储怎么办呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] quarterData = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">23</span>,<span class="number">43</span>,<span class="number">22</span>&#125;,&#123;<span class="number">34</span>,<span class="number">55</span>,<span class="number">65</span>&#125;,&#123;<span class="number">44</span>,<span class="number">67</span>,<span class="number">45</span>&#125;,&#123;<span class="number">78</span>,<span class="number">67</span>,<span class="number">66</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>应用举例2：</strong></li></ul><p>高一年级三个班级均由多个学生姓名构成一个个数组。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] class1 = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;段誉&quot;</span>,<span class="string">&quot;令狐冲&quot;</span>,<span class="string">&quot;任我行&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">String[] class2 = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;张三丰&quot;</span>,<span class="string">&quot;周芷若&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">String[] class3 = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;赵敏&quot;</span>,<span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;韦小宝&quot;</span>,<span class="string">&quot;杨过&quot;</span>&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那从整个年级看，我们可以声明一个二维数组。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[][] grade = <span class="keyword">new</span> <span class="title class_">String</span>[][]&#123;&#123;<span class="string">&quot;段誉&quot;</span>,<span class="string">&quot;令狐冲&quot;</span>,<span class="string">&quot;任我行&quot;</span>&#125;,&#123;<span class="string">&quot;张三丰&quot;</span>,<span class="string">&quot;周芷若&quot;</span>&#125;,&#123;<span class="string">&quot;赵敏&quot;</span>,<span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;韦小宝&quot;</span>,<span class="string">&quot;杨过&quot;</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><strong>应用举例3：</strong></p><p><img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/image-20220516095701345.png" alt="image-20220516095701345"></p></li></ul><p>蓝框的几个元素，可以使用一维数组来存储。但现在发现每个元素下还有下拉框，其内部还有元素，那就需要使用二维数组来存储：</p><p>  <img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/image-20220516095829526.png" alt="image-20220516095829526"></p><ul><li><p>使用说明</p><p><img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/1561524724397-1647707344971.png" alt="1561524724397"></p></li></ul><blockquote><ul><li>对于二维数组的理解，可以看成是一维数组array1又作为另一个一维数组array2的元素而存在。</li><li>其实，从数组底层的运行机制来看，其实没有多维数组。</li></ul></blockquote><h3 id="5-2-声明与初始化"><a href="#5-2-声明与初始化" class="headerlink" title="5.2 声明与初始化"></a>5.2 声明与初始化</h3><h4 id="5-2-1-声明"><a href="#5-2-1-声明" class="headerlink" title="5.2.1 声明"></a>5.2.1 声明</h4><p>二维数组声明的语法格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//推荐</span></span><br><span class="line">元素的数据类型[][] 二维数组的名称;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不推荐</span></span><br><span class="line">元素的数据类型  二维数组名[][];</span><br><span class="line"><span class="comment">//不推荐</span></span><br><span class="line">元素的数据类型[]  二维数组名[];</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test20TwoDimensionalArrayDefine</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//存储多组成绩</span></span><br><span class="line">        <span class="type">int</span>[][] grades;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//存储多组姓名</span></span><br><span class="line">        String[][] names;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>面试：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int[] x, y[];</span><br><span class="line">//x是一维数组，y是二维数组</span><br></pre></td></tr></table></figure><h4 id="5-2-2-静态初始化"><a href="#5-2-2-静态初始化" class="headerlink" title="5.2.2 静态初始化"></a>5.2.2 静态初始化</h4><p><strong>格式：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">3</span>,<span class="number">8</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">7</span>&#125;,&#123;<span class="number">9</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>定义一个名称为arr的二维数组，二维数组中有三个一维数组</p><ul><li>每一个一维数组中具体元素也都已初始化<ul><li>第一个一维数组 arr[0] = {3,8,2};</li><li>第二个一维数组 arr[1] = {2,7};</li><li>第三个一维数组 arr[2] = {9,0,1,6};</li></ul></li><li>第三个一维数组的长度表示方式：arr[2].length;</li></ul><blockquote><ul><li>注意特殊写法情况：int[] x,y[]; x是一维数组，y是二维数组。</li></ul></blockquote><ul><li>举例1：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;&#125;;<span class="comment">//声明与初始化必须在一句完成</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[][] arr;</span><br><span class="line">arr = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">3</span>]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;&#125;;<span class="comment">//错误，静态初始化右边new 数据类型[][]中不能写数字</span></span><br></pre></td></tr></table></figure><ul><li>举例2：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwoDimensionalArrayInitialize</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//存储多组成绩</span></span><br><span class="line">        <span class="type">int</span>[][] grades = &#123;</span><br><span class="line">                    &#123;<span class="number">89</span>,<span class="number">75</span>,<span class="number">99</span>,<span class="number">100</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">88</span>,<span class="number">96</span>,<span class="number">78</span>,<span class="number">63</span>,<span class="number">100</span>,<span class="number">86</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">56</span>,<span class="number">63</span>,<span class="number">58</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">99</span>,<span class="number">66</span>,<span class="number">77</span>,<span class="number">88</span>&#125;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//存储多组姓名</span></span><br><span class="line">        String[][] names = &#123;</span><br><span class="line">            &#123;<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>, <span class="string">&quot;赵六&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;刘备&quot;</span>,<span class="string">&quot;关羽&quot;</span>,<span class="string">&quot;张飞&quot;</span>,<span class="string">&quot;诸葛亮&quot;</span>,<span class="string">&quot;赵云&quot;</span>,<span class="string">&quot;马超&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;曹丕&quot;</span>,<span class="string">&quot;曹植&quot;</span>,<span class="string">&quot;曹冲&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;孙权&quot;</span>,<span class="string">&quot;周瑜&quot;</span>,<span class="string">&quot;鲁肃&quot;</span>,<span class="string">&quot;黄盖&quot;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-3-动态初始化"><a href="#5-2-3-动态初始化" class="headerlink" title="5.2.3 动态初始化"></a>5.2.3 动态初始化</h4><p>如果二维数组的每一个数据，甚至是每一行的列数，需要后期单独确定，那么就只能使用动态初始化方式了。动态初始化方式分为两种格式：</p><p><strong>格式1：规则二维表：每一行的列数是相同的</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//（1）确定行数和列数</span></span><br><span class="line">元素的数据类型[][] 二维数组名 = <span class="keyword">new</span> 元素的数据类型[m][n];</span><br><span class="line"><span class="comment">//其中，m:表示这个二维数组有多少个一维数组。或者说一共二维表有几行</span></span><br><span class="line"><span class="comment">//其中，n:表示每一个一维数组的元素有多少个。或者说每一行共有一个单元格</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此时创建完数组，行数、列数确定，而且元素也都有默认值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）再为元素赋新值</span></span><br><span class="line">二维数组名[行下标][列下标] = 值;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">2</span>];</span><br></pre></td></tr></table></figure><ul><li><p>定义了名称为arr的二维数组</p></li><li><p>二维数组中有3个一维数组</p></li><li><p>每一个一维数组中有2个元素</p></li><li><p>一维数组的名称分别为arr[0], arr[1], arr[2]</p></li><li><p>给第一个一维数组1脚标位赋值为78写法是：<code>arr[0][1] = 78;</code></p></li></ul><p><strong>格式2：不规则：每一行的列数不一样</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//（1）先确定总行数</span></span><br><span class="line">元素的数据类型[][] 二维数组名 = <span class="keyword">new</span> 元素的数据类型[总行数][];</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时只是确定了总行数，每一行里面现在是null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）再确定每一行的列数，创建每一行的一维数组</span></span><br><span class="line">二维数组名[行下标] = <span class="keyword">new</span> 元素的数据类型[该行的总列数];</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时已经new完的行的元素就有默认值了，没有new的行还是null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)再为元素赋值</span></span><br><span class="line">二维数组名[行下标][列下标] = 值;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][];</span><br></pre></td></tr></table></figure><ul><li>二维数组中有3个一维数组。</li><li>每个一维数组都是默认初始化值null (注意：区别于格式1）</li><li>可以对这个三个一维数组分别进行初始化：arr[0] = new int[3];    arr[1] = new int[1];   arr[2] = new int[2];</li><li>注：<code>int[][]arr = new int[][3];</code> //非法</li></ul><p>练习：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 1</span></span><br><span class="line"><span class="comment"> 2 2</span></span><br><span class="line"><span class="comment"> 3 3 3</span></span><br><span class="line"><span class="comment"> 4 4 4 4</span></span><br><span class="line"><span class="comment"> 5 5 5 5 5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test25DifferentElementCount</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//1、声明一个二维数组，并且确定行数</span></span><br><span class="line">        <span class="comment">//因为每一行的列数不同，这里无法直接确定列数</span></span><br><span class="line">        <span class="type">int</span>[][]  arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>][];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、确定每一行的列数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">arr[0] 的列数是1</span></span><br><span class="line"><span class="comment">arr[1] 的列数是2</span></span><br><span class="line"><span class="comment">arr[2] 的列数是3</span></span><br><span class="line"><span class="comment">arr[3] 的列数是4</span></span><br><span class="line"><span class="comment">arr[4] 的列数是5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">            arr[i] = <span class="keyword">new</span> <span class="title class_">int</span>[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、确定元素的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;arr[i].length; j++)&#123;</span><br><span class="line">                arr[i][j] = i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、遍历显示</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;arr[i].length; j++)&#123;</span><br><span class="line">                System.out.print(arr[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-数组的长度和角标"><a href="#5-3-数组的长度和角标" class="headerlink" title="5.3 数组的长度和角标"></a>5.3 数组的长度和角标</h3><ul><li>二维数组的长度/行数：二维数组名.length</li><li>二维数组的某一行：二维数组名[行下标]，此时相当于获取其中一组数据。它本质上是一个一维数组。行下标的范围：[0, 二维数组名.length-1]。此时把二维数组看成一维数组的话，元素是行对象。</li><li>某一行的列数：二维数组名[行下标].length，因为二维数组的每一行是一个一维数组。</li><li>某一个元素：二维数组名[行下标][列下标]，即先确定行/组，再确定列。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test22TwoDimensionalArrayUse</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//存储3个小组的学员的成绩，分开存储，使用二维数组。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int[][] scores1;</span></span><br><span class="line"><span class="comment">int scores2[][];</span></span><br><span class="line"><span class="comment">int[] scores3[];*/</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] scores = &#123;</span><br><span class="line">                &#123;<span class="number">85</span>,<span class="number">96</span>,<span class="number">85</span>,<span class="number">75</span>&#125;,</span><br><span class="line">                &#123;<span class="number">99</span>,<span class="number">96</span>,<span class="number">74</span>,<span class="number">72</span>,<span class="number">75</span>&#125;,</span><br><span class="line">                &#123;<span class="number">52</span>,<span class="number">42</span>,<span class="number">56</span>,<span class="number">75</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(scores);<span class="comment">//[[I@15db9742</span></span><br><span class="line">        System.out.println(<span class="string">&quot;一共有&quot;</span> + scores.length +<span class="string">&quot;组成绩.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[[：代表二维数组，I代表元素类型是int</span></span><br><span class="line">        System.out.println(scores[<span class="number">0</span>]);<span class="comment">//[I@6d06d69c</span></span><br><span class="line">        <span class="comment">//[：代表一维数组，I代表元素类型是int</span></span><br><span class="line">        System.out.println(scores[<span class="number">1</span>]);<span class="comment">//[I@7852e922</span></span><br><span class="line">        System.out.println(scores[<span class="number">2</span>]);<span class="comment">//[I@4e25154f</span></span><br><span class="line">        <span class="comment">//System.out.println(scores[3]);//ArrayIndexOutOfBoundsException: 3</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;第1组有&quot;</span> + scores[<span class="number">0</span>].length +<span class="string">&quot;个学员.&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第2组有&quot;</span> + scores[<span class="number">1</span>].length +<span class="string">&quot;个学员.&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第3组有&quot;</span> + scores[<span class="number">2</span>].length +<span class="string">&quot;个学员.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;第1组的每一个学员成绩如下：&quot;</span>);</span><br><span class="line">        <span class="comment">//第一行的元素</span></span><br><span class="line">        System.out.println(scores[<span class="number">0</span>][<span class="number">0</span>]);<span class="comment">//85</span></span><br><span class="line">        System.out.println(scores[<span class="number">0</span>][<span class="number">1</span>]);<span class="comment">//96</span></span><br><span class="line">        System.out.println(scores[<span class="number">0</span>][<span class="number">2</span>]);<span class="comment">//85</span></span><br><span class="line">        System.out.println(scores[<span class="number">0</span>][<span class="number">3</span>]);<span class="comment">//75</span></span><br><span class="line">        <span class="comment">//System.out.println(scores[0][4]);//java.lang.ArrayIndexOutOfBoundsException: 4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-二维数组的遍历"><a href="#5-4-二维数组的遍历" class="headerlink" title="5.4 二维数组的遍历"></a>5.4 二维数组的遍历</h3><ul><li>格式：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;二维数组名.length; i++)&#123; <span class="comment">//二维数组对象.length</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;二维数组名[i].length; j++)&#123;<span class="comment">//二维数组行对象.length</span></span><br><span class="line">        System.out.print(二维数组名[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>举例：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test23TwoDimensionalArrayIterate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//存储3个小组的学员的成绩，分开存储，使用二维数组。</span></span><br><span class="line">        <span class="type">int</span>[][] scores = &#123;</span><br><span class="line">                &#123;<span class="number">85</span>,<span class="number">96</span>,<span class="number">85</span>,<span class="number">75</span>&#125;,</span><br><span class="line">                &#123;<span class="number">99</span>,<span class="number">96</span>,<span class="number">74</span>,<span class="number">72</span>,<span class="number">75</span>&#125;,</span><br><span class="line">                &#123;<span class="number">52</span>,<span class="number">42</span>,<span class="number">56</span>,<span class="number">75</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;一共有&quot;</span> + scores.length +<span class="string">&quot;组成绩.&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; scores.length; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;第&quot;</span> + (i+<span class="number">1</span>) +<span class="string">&quot;组有&quot;</span> + scores[i].length + <span class="string">&quot;个学员，成绩如下：&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; scores[i].length; j++) &#123;</span><br><span class="line">                System.out.print(scores[i][j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-内存解析"><a href="#5-5-内存解析" class="headerlink" title="5.5 内存解析"></a>5.5 内存解析</h3><p>二维数组本质上是元素类型是一维数组的一维数组。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>,<span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/1562112672215.png" alt="1562112672215"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、声明二维数组，并确定行数和列数</span></span><br><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、确定元素的值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">        arr[i][j] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/1562113179785.png" alt="1562113179785"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、声明一个二维数组，并且确定行数</span></span><br><span class="line"><span class="comment">//因为每一行的列数不同，这里无法直接确定列数</span></span><br><span class="line"><span class="type">int</span>[][]  arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>][];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、确定每一行的列数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">arr[0] 的列数是1</span></span><br><span class="line"><span class="comment">arr[1] 的列数是2</span></span><br><span class="line"><span class="comment">arr[2] 的列数是3</span></span><br><span class="line"><span class="comment">arr[3] 的列数是4</span></span><br><span class="line"><span class="comment">arr[4] 的列数是5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    arr[i] = <span class="keyword">new</span> <span class="title class_">int</span>[i+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、确定元素的值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;arr[i].length; j++)&#123;</span><br><span class="line">        arr[i][j] = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/1562113981079.png" alt="1562113981079"></p><h3 id="5-6-应用举例"><a href="#5-6-应用举例" class="headerlink" title="5.6 应用举例"></a>5.6 应用举例</h3><p><strong>案例1：</strong>获取arr数组中所有元素的和。</p><p>提示：使用for的嵌套循环即可。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/image-20220317005436209.png" alt="image-20220317005436209"></p><p><strong>案例2：</strong>声明：int[] x,y[]; 在给x,y变量赋值以后，以下选项允许通过编译的是： </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">声明：<span class="type">int</span>[] x,y[]; 在给x,y变量赋值以后，以下选项允许通过编译的是：</span><br><span class="line">a)    x[<span class="number">0</span>] = y;                 <span class="comment">//no</span></span><br><span class="line">b)    y[<span class="number">0</span>] = x;                 <span class="comment">//yes</span></span><br><span class="line">c)    y[<span class="number">0</span>][<span class="number">0</span>] = x;              <span class="comment">//no</span></span><br><span class="line">d)    x[<span class="number">0</span>][<span class="number">0</span>] = y;              <span class="comment">//no</span></span><br><span class="line">e)    y[<span class="number">0</span>][<span class="number">0</span>] = x[<span class="number">0</span>];           <span class="comment">//yes</span></span><br><span class="line">f)    x = y;                    <span class="comment">//no</span></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">一维数组：<span class="type">int</span>[] x  或者<span class="type">int</span> x[]   </span><br><span class="line">二维数组：<span class="type">int</span>[][] y 或者  <span class="type">int</span>[] y[]  或者 <span class="type">int</span>  y[][]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>案例3：</strong>使用二维数组打印一个 10 行杨辉三角。</p><p>提示：</p><ol><li><p>第一行有 1 个元素, 第 n 行有 n 个元素</p></li><li><p>每一行的第一个元素和最后一个元素都是 1</p></li><li><p>从第三行开始, 对于非第一个元素和最后一个元素的元素。即：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yanghui[i][j] = yanghui[i-1][j-1] + yanghui[i-1][j];</span><br></pre></td></tr></table></figure></li></ol><p><img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/image-20220317005549522.png" alt="image-20220317005549522"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 10:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YangHuiTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 动态初始化的方式创建二维数组</span></span><br><span class="line">        <span class="type">int</span>[][] yangHui = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; yangHui.length; i++) &#123;</span><br><span class="line">            yangHui[i] = <span class="keyword">new</span> <span class="title class_">int</span>[i + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2. 给数组元素赋值</span></span><br><span class="line">            <span class="comment">// 2.1 给外层数组元素中的首元素和末元素赋值</span></span><br><span class="line">            yangHui[i][<span class="number">0</span>] = yangHui[i][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.2 给外层数组元素中的非首元素和非末元素赋值（难）</span></span><br><span class="line">            <span class="comment">//if(i &gt; 1)&#123; //从 i == 2 开始执行</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt; yangHui[i].length - <span class="number">1</span>;j++)&#123; <span class="comment">//非首元素和非末元素的角标范围</span></span><br><span class="line">                    yangHui[i][j] = yangHui[i-<span class="number">1</span>][j-<span class="number">1</span>] + yangHui[i-<span class="number">1</span>][j];</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 遍历二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; yangHui.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; yangHui[i].length; j++) &#123;</span><br><span class="line">                System.out.print(yangHui[i][j] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-数组的常见算法"><a href="#6-数组的常见算法" class="headerlink" title="6. 数组的常见算法"></a>6. 数组的常见算法</h2><h3 id="6-1-数值型数组特征值统计"><a href="#6-1-数值型数组特征值统计" class="headerlink" title="6.1 数值型数组特征值统计"></a>6.1 数值型数组特征值统计</h3><ul><li>这里的特征值涉及到：平均值、最大值、最小值、总和等</li></ul><p><strong>举例1：</strong>数组统计：求总和、均值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestArrayElementSum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="comment">//求总和、均值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//因为0加上任何数都不影响结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            sum += arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">avg</span> <span class="operator">=</span> (<span class="type">double</span>)sum/arr.length;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;sum = &quot;</span> + sum);</span><br><span class="line">        System.out.println(<span class="string">&quot;avg = &quot;</span> + avg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>举例2：</strong>求数组元素的总乘积</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestArrayElementMul</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求总乘积</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//因为1乘以任何数都不影响结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            result *= arr[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>举例3：</strong>求数组元素中偶数的个数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestArrayElementEvenCount</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="comment">//统计偶数个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">evenCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                evenCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;evenCount = &quot;</span> + evenCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>举例4：</strong>求数组元素的最大值</p><p><img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/1574577970893.png" alt="1574577970893"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestArrayMax</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="comment">//找最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;<span class="comment">//此处i从1开始，是max不需要与arr[0]再比较一次了</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; max)&#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;max = &quot;</span> + max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>举例5：</strong>找最值及其第一次出现的下标</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMaxIndex</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="comment">//找最大值以及第一个最大值下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; max)&#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;max = &quot;</span> + max);</span><br><span class="line">        System.out.println(<span class="string">&quot;index = &quot;</span> + index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>举例6：</strong>找最值及其所有最值的下标</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test13AllMaxIndex</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="comment">//找最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; max)&#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;最大值是：&quot;</span> + max);</span><br><span class="line">        System.out.print(<span class="string">&quot;最大值的下标有：&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历数组，看哪些元素和最大值是一样的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(max == arr[i])&#123;</span><br><span class="line">                System.out.print(i+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test13AllMaxIndex2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="comment">//找最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">String</span> <span class="variable">index</span> <span class="operator">=</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; max)&#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">                index = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[i] == max)&#123;</span><br><span class="line">                index += <span class="string">&quot;,&quot;</span> + i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;最大值是&quot;</span> + max);</span><br><span class="line">        System.out.println(<span class="string">&quot;最大值的下标是[&quot;</span> + index+<span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>举例7(难)：</strong>输入一个整形数组，数组里有正数也有负数。数组中连续的一个或多个整数组成一个子数组，每个子数组都有一个和。求所有子数组的和的最大值。要求时间复杂度为O(n)。<br>例如：输入的数组为1, -2, 3, -10, -4, 7, 2, -5，和最大的子数组为3, 10, -4, 7, 2，因此输出为该子数组的和18。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test5</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, -<span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>, -<span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, -<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> getGreatestSum(arr);</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getGreatestSum</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">greatestSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> greatestSum;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">temp += arr[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(temp &lt; <span class="number">0</span>)&#123;</span><br><span class="line">temp = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(temp &gt; greatestSum)&#123;</span><br><span class="line">greatestSum = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(greatestSum == <span class="number">0</span>)&#123;</span><br><span class="line">greatestSum = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(greatestSum &lt; arr[i])&#123;</span><br><span class="line">greatestSum = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> greatestSum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>举例8：评委打分</strong></p><p>分析以下需求，并用代码实现：</p><p>（1）在编程竞赛中，有10位评委为参赛的选手打分，分数分别为：5，4，6，8，9，0，1，2，7，3</p><p>（2）求选手的最后得分（去掉一个最高分和一个最低分后其余8位评委打分的平均值）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 10:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayExer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] scores = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> scores[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> scores[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; scores.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(max &lt; scores[i])&#123;</span><br><span class="line">                max = scores[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(min &gt; scores[i])&#123;</span><br><span class="line">                min = scores[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sum += scores[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">avg</span> <span class="operator">=</span> (<span class="type">double</span>)(sum - max - min) / (scores.length - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;选手去掉最高分和最低分之后的平均分为：&quot;</span> + avg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-数组元素的赋值与数组复制"><a href="#6-2-数组元素的赋值与数组复制" class="headerlink" title="6.2 数组元素的赋值与数组复制"></a>6.2 数组元素的赋值与数组复制</h3><p><strong>举例1：</strong>杨辉三角（见二维数组课后案例）</p><p><strong>举例2：</strong>使用简单数组</p><p>(1)创建一个名为ArrayTest的类，在main()方法中声明array1和array2两个变量，他们是int[]类型的数组。</p><p>(2)使用大括号{}，把array1初始化为8个素数：2,3,5,7,11,13,17,19。</p><p>(3)显示array1的内容。</p><p>(4)赋值array2变量等于array1，修改array2中的偶索引元素，使其等于索引值(如array[0]=0,array[2]=2)。打印出array1。  array2 = array1;</p><blockquote><p><strong>思考：</strong>array1和array2是什么关系？</p><p><strong>拓展：</strong>修改题目，实现array2对array1数组的复制</p></blockquote><p><img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/snipaste_20220317_225346.jpg" alt="snipaste_20220317_225346" style="zoom:80%;"><img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/snipaste_20220317_225359.jpg" alt="snipaste_20220317_225359"></p><p><strong>举例3：</strong>一个数组，让数组的每个元素去除第一个元素，得到的商作为被除数所在位置的新值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">12</span>,<span class="number">43</span>,<span class="number">65</span>,<span class="number">3</span>,-<span class="number">8</span>,<span class="number">64</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for(int i = 0;i &lt; arr.length;i++)&#123;</span></span><br><span class="line"><span class="comment">//arr[i] = arr[i] / arr[0];</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length -<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">arr[i] = arr[i] / arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历arr</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>举例4：</strong>创建一个长度为6的int型数组，要求数组元素的值都在1-30之间，且是随机赋值。同时，要求元素的值各不相同。 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test4</span> &#123;</span><br><span class="line"><span class="comment">// 5-67 Math.random() * 63 + 5;</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;<span class="comment">// [0,1) [0,30) [1,31)</span></span><br><span class="line">arr[i] = (<span class="type">int</span>) (Math.random() * <span class="number">30</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] == arr[j]) &#123;</span><br><span class="line">flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">arr[i] = (<span class="type">int</span>) (Math.random() * <span class="number">30</span>) + <span class="number">1</span>;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更优的方法</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;<span class="comment">// [0,1) [0,30) [1,31)</span></span><br><span class="line">arr[i] = (<span class="type">int</span>) (Math.random() * <span class="number">30</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] == arr[j]) &#123;</span><br><span class="line">i--;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>举例5：</strong>扑克牌</p><p>案例：遍历扑克牌</p><p>遍历扑克牌，效果如图所示：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/1659199523932.png" alt="1659199523932"></p><p>提示：使用两个字符串数组，分别保存花色和点数，再用一个字符串数组保存最后的扑克牌。<br>String[] hua = {“黑桃”,”红桃”,”梅花”,”方片”};<br>String[] dian = {“A”,”2”,”3”,”4”,”5”,”6”,”7”,”8”,”9”,”10”,”J”,”Q”,”K”};</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu3.common_algorithm.exer5;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 17:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayExer05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] hua = &#123;<span class="string">&quot;黑桃&quot;</span>,<span class="string">&quot;红桃&quot;</span>,<span class="string">&quot;梅花&quot;</span>,<span class="string">&quot;方片&quot;</span>&#125;;</span><br><span class="line">        String[] dian = &#123;<span class="string">&quot;A&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;10&quot;</span>,<span class="string">&quot;J&quot;</span>,<span class="string">&quot;Q&quot;</span>,<span class="string">&quot;K&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String[] pai = <span class="keyword">new</span> <span class="title class_">String</span>[hua.length * dian.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; hua.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; dian.length;j++)&#123;</span><br><span class="line">                pai[k++] = hua[i] + dian[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pai.length; i++) &#123;</span><br><span class="line">            System.out.print(pai[i] + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">13</span> == <span class="number">12</span>)&#123;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>拓展：在上述基础上，增加大王、小王。</p><p><strong>举例6：</strong>回形数</p><p>从键盘输入一个整数（1~20） ，则以该数字为矩阵的大小，把1,2,3…n*n 的数字按照顺时针螺旋的形式填入其中。</p><p>例如： 输入数字2，则程序输出：<br>1 2<br>4 3 </p><p>输入数字3，则程序输出：<br>1 2 3<br>8 9 4<br>7 6 5<br>输入数字4， 则程序输出：<br>1    2    3    4<br>12  13  14  5<br>11  16  15  6<br>10   9   8    7</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RectangleTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;输入一个数字&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[len][len];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> len * len;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * k = 1:向右</span></span><br><span class="line"><span class="comment"> * k = 2:向下</span></span><br><span class="line"><span class="comment"> * k = 3:向左</span></span><br><span class="line"><span class="comment"> * k = 4:向上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span>;m &lt;= s;m++)&#123;</span><br><span class="line"><span class="keyword">if</span>(k == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(j &lt; len &amp;&amp; arr[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">arr[i][j++] = m;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">k = <span class="number">2</span>;</span><br><span class="line">i++;  </span><br><span class="line">j--;</span><br><span class="line">m--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(k == <span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(i &lt; len &amp;&amp; arr[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">arr[i++][j] = m;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">k = <span class="number">3</span>;</span><br><span class="line">i--;</span><br><span class="line">j--;</span><br><span class="line">m--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(k == <span class="number">3</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(j &gt;= <span class="number">0</span> &amp;&amp; arr[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">arr[i][j--] = m;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">k = <span class="number">4</span>;</span><br><span class="line">i--;</span><br><span class="line">j++;</span><br><span class="line">m--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(k == <span class="number">4</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; arr[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">arr[i--][j] = m;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">k = <span class="number">1</span>;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">m--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>;m &lt; arr.length;m++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;n &lt; arr[m].length;n++)&#123;</span><br><span class="line">System.out.print(arr[m][n] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">01 02 03 04 05 06 07 </span></span><br><span class="line"><span class="comment">24 25 26 27 28 29 08 </span></span><br><span class="line"><span class="comment">23 40 41 42 43 30 09 </span></span><br><span class="line"><span class="comment">22 39 48 49 44 31 10 </span></span><br><span class="line"><span class="comment">21 38 47 46 45 32 11 </span></span><br><span class="line"><span class="comment">20 37 36 35 34 33 12 </span></span><br><span class="line"><span class="comment">19 18 17 16 15 14 13 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RectangleTest1</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//要显示的数据</span></span><br><span class="line"><span class="type">int</span> <span class="variable">maxX</span> <span class="operator">=</span> n-<span class="number">1</span>; <span class="comment">//x轴的最大下标</span></span><br><span class="line"><span class="type">int</span> <span class="variable">maxY</span> <span class="operator">=</span> n-<span class="number">1</span>; <span class="comment">//Y轴的最大下标</span></span><br><span class="line"><span class="type">int</span> <span class="variable">minX</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//x轴的最小下标</span></span><br><span class="line"><span class="type">int</span> <span class="variable">minY</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//Y轴的最小下标</span></span><br><span class="line"><span class="keyword">while</span>(minX&lt;=maxX) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x=minX;x&lt;=maxX;x++) &#123;</span><br><span class="line">arr[minY][x] = ++count;</span><br><span class="line">&#125;</span><br><span class="line">minY++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> y=minY;y&lt;=maxY;y++) &#123;</span><br><span class="line">arr[y][maxX] = ++count;</span><br><span class="line">&#125;</span><br><span class="line">maxX--;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x=maxX;x&gt;=minX;x--) &#123;</span><br><span class="line">arr[maxY][x] = ++count;</span><br><span class="line">&#125;</span><br><span class="line">maxY--;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> y=maxY;y&gt;=minY;y--) &#123;</span><br><span class="line">arr[y][minX] = ++count;</span><br><span class="line">&#125;</span><br><span class="line">minX++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;arr.length;j++) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">space</span> <span class="operator">=</span> (arr[i][j]+<span class="string">&quot;&quot;</span>).length()==<span class="number">1</span> ? <span class="string">&quot;0&quot;</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line">System.out.print(space+arr[i][j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-数组元素的反转"><a href="#6-3-数组元素的反转" class="headerlink" title="6.3 数组元素的反转"></a>6.3 数组元素的反转</h3><p><strong>实现思想：</strong>数组对称位置的元素互换。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/image-20221117195931777.png" alt="image-20221117195931777" style="zoom:67%;"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestArrayReverse1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;反转之前：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反转</span></span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">        思路：首尾对应位置的元素交换</span></span><br><span class="line"><span class="comment">        （1）确定交换几次</span></span><br><span class="line"><span class="comment">           次数 = 数组.length / 2</span></span><br><span class="line"><span class="comment">        （2）谁和谁交换</span></span><br><span class="line"><span class="comment">        for(int i=0; i&lt;次数; i++)&#123;</span></span><br><span class="line"><span class="comment">             int temp = arr[i];</span></span><br><span class="line"><span class="comment">             arr[i] = arr[arr.length-1-i];</span></span><br><span class="line"><span class="comment">             arr[arr.length-1-i] = temp;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length/<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            arr[i] = arr[arr.length-<span class="number">1</span>-i];</span><br><span class="line">            arr[arr.length-<span class="number">1</span>-i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;反转之后：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><p><img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/1561469087319.png" alt="1561469087319"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestArrayReverse2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;反转之前：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反转</span></span><br><span class="line">        <span class="comment">//左右对称位置交换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> left=<span class="number">0</span>,right=arr.length-<span class="number">1</span>; left&lt;right; left++,right--)&#123;</span><br><span class="line">            <span class="comment">//首  与  尾交换</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[left];</span><br><span class="line">            arr[left] = arr[right];</span><br><span class="line">            arr[right] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;反转之后：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-4-数组的扩容与缩容"><a href="#6-4-数组的扩容与缩容" class="headerlink" title="6.4 数组的扩容与缩容"></a>6.4 数组的扩容与缩容</h3><p><strong>数组的扩容</strong></p><p>题目：现有数组 int[] arr = new int[]{1,2,3,4,5}; ，现将数组长度扩容1倍，并将10,20,30三个数据添加到arr数组中，如何操作？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] newArr = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">            newArr[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        newArr[arr.length] = <span class="number">10</span>;</span><br><span class="line">        newArr[arr.length + <span class="number">1</span>] = <span class="number">20</span>;</span><br><span class="line">        newArr[arr.length + <span class="number">2</span>] = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">        arr = newArr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历arr</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数组的缩容</strong></p><p>题目：现有数组 int[] arr={1,2,3,4,5,6,7}。现需删除数组中索引为4的元素。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        <span class="comment">//删除数组中索引为4的元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">delIndex</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        <span class="comment">//方案1：</span></span><br><span class="line">        <span class="comment">/*//创建新数组</span></span><br><span class="line"><span class="comment">        int[] newArr = new int[arr.length - 1];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; delIndex; i++) &#123;</span></span><br><span class="line"><span class="comment">            newArr[i] = arr[i];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        for (int i = delIndex + 1; i &lt; arr.length; i++) &#123;</span></span><br><span class="line"><span class="comment">            newArr[i - 1] = arr[i];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        arr = newArr;</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; arr.length; i++) &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(arr[i]);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方案2：</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> delIndex; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            arr[i] = arr[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[arr.length - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-5-数组的元素查找"><a href="#6-5-数组的元素查找" class="headerlink" title="6.5 数组的元素查找"></a>6.5 数组的元素查找</h3><p><strong>1、顺序查找</strong></p><p>顺序查找：挨个查看</p><p>要求：对数组元素的顺序没要求</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestArrayOrderSearch</span> &#123;</span><br><span class="line">    <span class="comment">//查找value第一次在数组中出现的index</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == value)&#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(index==-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(value + <span class="string">&quot;不存在&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(value + <span class="string">&quot;的下标是&quot;</span> + index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、二分查找</strong></p><p>举例：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/image-20220317230955644.png" alt="image-20220317230955644"></p><p>实现步骤：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/image-20220623210601915.png" alt="image-20220623210601915" style="zoom:67%;"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二分法查找：要求此数组必须是有序的。</span></span><br><span class="line"><span class="type">int</span>[] arr3 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">99</span>,-<span class="number">54</span>,-<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">33</span>,<span class="number">43</span>,<span class="number">256</span>,<span class="number">999</span>&#125;;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isFlag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">256</span>;</span><br><span class="line"><span class="comment">//int value = 25;</span></span><br><span class="line"><span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//首索引位置</span></span><br><span class="line"><span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> arr3.length - <span class="number">1</span>;<span class="comment">//尾索引位置</span></span><br><span class="line"><span class="keyword">while</span>(head &lt;= end)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (head + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(arr3[middle] == value)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;找到指定的元素，索引为：&quot;</span> + middle);</span><br><span class="line">        isFlag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr3[middle] &gt; value)&#123;</span><br><span class="line">        end = middle - <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//arr3[middle] &lt; value</span></span><br><span class="line">        head = middle + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(isFlag)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;未找打指定的元素&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-6-数组元素排序"><a href="#6-6-数组元素排序" class="headerlink" title="6.6 数组元素排序"></a>6.6 数组元素排序</h3><h4 id="6-6-1-算法概述"><a href="#6-6-1-算法概述" class="headerlink" title="6.6.1 算法概述"></a>6.6.1 算法概述</h4><ul><li><p><strong>定义</strong></p><ul><li>排序：假设含有n个记录的序列为{R1，R2，…,Rn},其相应的关键字序列为{K1，K2，…,Kn}。将这些记录重新排序为{Ri1,Ri2,…,Rin},使得相应的关键字值满足条Ki1&lt;=Ki2&lt;=…&lt;=Kin,这样的一种操作称为排序。</li><li>通常来说，排序的目的是快速查找。</li></ul></li><li><p><strong>衡量排序算法的优劣：</strong></p><ul><li><p><code>时间复杂度</code>：分析关键字的比较次数和记录的移动次数</p></li><li><p>常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n<sup>2</sup>)＜Ο(n<sup>3</sup>)＜…＜Ο(2<sup>n</sup>)＜Ο(n!)<O(n<sup>n&lt;/sup&gt;)</O(n<sup></p></li><li><p><code>空间复杂度</code>：分析排序算法中需要多少辅助内存</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个算法的空间复杂度S(n)定义为该算法所耗费的存储空间，它也是问题规模n的函数。</span><br></pre></td></tr></table></figure></li><li><p><code>稳定性</code>：若两个记录A和B的关键字值相等，但排序后A、B的先后次序保持不变，则称这种排序算法是稳定的。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/image-20211222113701365.png" alt="image-20211222113701365"></p></li></ul></li></ul><h4 id="6-6-2-排序算法概述"><a href="#6-6-2-排序算法概述" class="headerlink" title="6.6.2 排序算法概述"></a>6.6.2 排序算法概述</h4><ul><li><p><strong>排序算法分类：内部排序和外部排序</strong></p><ul><li><code>内部排序</code>：整个排序过程不需要借助于外部存储器（如磁盘等），所有排序操作都在内存中完成。</li><li><code>外部排序</code>：参与排序的数据非常多，数据量非常大，计算机无法把整个排序过程放在内存中完成，必须借助于外部存储器（如磁盘）。外部排序最常见的是多路归并排序。可以认为外部排序是由多次内部排序组成。</li></ul></li><li><p><strong>十大内部排序算法</strong></p></li></ul><p>​       数组的排序算法很多，实现方式各不相同，时间复杂度、空间复杂度、稳定性也各不相同：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/image-20211222111142684.png" alt="image-20211222111142684"></p><p>常见时间复杂度所消耗的时间从小到大排序：</p><p><strong>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)</strong></p><p>注意，经常将以2为底n的对数简写成logn。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/image-20220824003440106.png" alt="image-20220824003440106"></p><h4 id="6-6-3-冒泡排序（Bubble-Sort）"><a href="#6-6-3-冒泡排序（Bubble-Sort）" class="headerlink" title="6.6.3 冒泡排序（Bubble Sort）"></a>6.6.3 冒泡排序（Bubble Sort）</h4><p><img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/image-20220516094637228.png" alt="image-20220516094637228" style="zoom:67%;"></p><p><strong>排序思想：</strong></p><ol><li><p>比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。</p></li><li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p></li><li><p>针对所有的元素重复以上的步骤，除了最后一个。</p></li><li><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较为止。</p></li></ol><p><img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/BubbleSort.png" alt="BubbleSort"></p><p><strong>动态演示：</strong><a href="https://visualgo.net/zh/sorting">https://visualgo.net/zh/sorting</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、冒泡排序（最经典）</span></span><br><span class="line"><span class="comment">思想：每一次比较“相邻（位置相邻）”元素，如果它们不符合目标顺序（例如：从小到大），</span></span><br><span class="line"><span class="comment">     就交换它们，经过多轮比较，最终实现排序。</span></span><br><span class="line"><span class="comment"> （例如：从小到大） 每一轮可以把最大的沉底，或最小的冒顶。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">过程：arr&#123;6,9,2,9,1&#125;  目标：从小到大</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">第一轮：</span></span><br><span class="line"><span class="comment">第1次，arr[0]与arr[1]，6&gt;9不成立，满足目标要求，不交换</span></span><br><span class="line"><span class="comment">第2次，arr[1]与arr[2]，9&gt;2成立，不满足目标要求，交换arr[1]与arr[2] &#123;6,2,9,9,1&#125;</span></span><br><span class="line"><span class="comment">第3次，arr[2]与arr[3]，9&gt;9不成立，满足目标要求，不交换</span></span><br><span class="line"><span class="comment">第4次，arr[3]与arr[4]，9&gt;1成立，不满足目标要求，交换arr[3]与arr[4] &#123;6,2,9,1,9&#125;</span></span><br><span class="line"><span class="comment">第一轮所有元素&#123;6,9,2,9,1&#125;已经都参与了比较，结束。</span></span><br><span class="line"><span class="comment">第一轮的结果：第“一”最大值9沉底（本次是后面的9沉底），即到&#123;6,2,9,1,9&#125;元素的最右边</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">第二轮：</span></span><br><span class="line"><span class="comment">第1次，arr[0]与arr[1]，6&gt;2成立，不满足目标要求，交换arr[0]与arr[1] &#123;2,6,9,1,9&#125;</span></span><br><span class="line"><span class="comment">第2次，arr[1]与arr[2]，6&gt;9不成立，满足目标要求，不交换</span></span><br><span class="line"><span class="comment">第3次：arr[2]与arr[3]，9&gt;1成立，不满足目标要求，交换arr[2]与arr[3] &#123;2,6,1,9,9&#125;</span></span><br><span class="line"><span class="comment">第二轮未排序的所有元素 &#123;6,2,9,1&#125;已经都参与了比较，结束。</span></span><br><span class="line"><span class="comment">第二轮的结果：第“二”最大值9沉底（本次是前面的9沉底），即到&#123;2,6,1,9&#125;元素的最右边</span></span><br><span class="line"><span class="comment">第三轮：</span></span><br><span class="line"><span class="comment">第1次，arr[0]与arr[1]，2&gt;6不成立，满足目标要求，不交换</span></span><br><span class="line"><span class="comment">第2次，arr[1]与arr[2]，6&gt;1成立，不满足目标要求，交换arr[1]与arr[2] &#123;2,1,6,9,9&#125;</span></span><br><span class="line"><span class="comment">第三轮未排序的所有元素&#123;2,6,1&#125;已经都参与了比较，结束。</span></span><br><span class="line"><span class="comment">第三轮的结果：第三最大值6沉底，即到 &#123;2,1,6&#125;元素的最右边</span></span><br><span class="line"><span class="comment">第四轮：</span></span><br><span class="line"><span class="comment">第1次，arr[0]与arr[1]，2&gt;1成立，不满足目标要求，交换arr[0]与arr[1] &#123;1,2,6,9,9&#125;</span></span><br><span class="line"><span class="comment">第四轮未排序的所有元素&#123;2,1&#125;已经都参与了比较，结束。</span></span><br><span class="line"><span class="comment">第四轮的结果：第四最大值2沉底，即到&#123;1,2&#125;元素的最右边</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test19BubbleSort</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">6</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//目标：从小到大</span></span><br><span class="line">        <span class="comment">//冒泡排序的轮数 = 元素的总个数 - 1</span></span><br><span class="line">        <span class="comment">//轮数是多轮，每一轮比较的次数是多次，需要用到双重循环，即循环嵌套</span></span><br><span class="line">        <span class="comment">//外循环控制 轮数，内循环控制每一轮的比较次数和过程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123; <span class="comment">//循环次数是arr.length-1次/轮</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">假设arr.length=5</span></span><br><span class="line"><span class="comment">i=1,第1轮，比较4次</span></span><br><span class="line"><span class="comment">arr[0]与arr[1]</span></span><br><span class="line"><span class="comment">arr[1]与arr[2]</span></span><br><span class="line"><span class="comment">arr[2]与arr[3]</span></span><br><span class="line"><span class="comment">arr[3]与arr[4]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">arr[j]与arr[j+1]，int j=0;j&lt;4; j++</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">i=2,第2轮，比较3次</span></span><br><span class="line"><span class="comment">arr[0]与arr[1]</span></span><br><span class="line"><span class="comment">arr[1]与arr[2]</span></span><br><span class="line"><span class="comment">arr[2]与arr[3]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">arr[j]与arr[j+1]，int j=0;j&lt;3; j++</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">i=3,第3轮，比较2次</span></span><br><span class="line"><span class="comment">arr[0]与arr[1]</span></span><br><span class="line"><span class="comment">arr[1]与arr[2]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">arr[j]与arr[j+1]，int j=0;j&lt;2; j++</span></span><br><span class="line"><span class="comment">i=4,第4轮，比较1次</span></span><br><span class="line"><span class="comment">arr[0]与arr[1]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">arr[j]与arr[j+1]，int j=0;j&lt;1; j++</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int j=0; j&lt;arr.length-i; j++</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;arr.length-i; j++)&#123;</span><br><span class="line">                <span class="comment">//希望的是arr[j] &lt; arr[j+1]</span></span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="comment">//交换arr[j]与arr[j+1]</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                    arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//完成排序，遍历结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            System.out.print(arr[i]+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>冒泡排序优化（选讲）</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思考：冒泡排序是否可以优化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test19BubbleSort2</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从小到大排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//假设数组已经是有序的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="comment">//希望的是arr[j] &lt; arr[j+1]</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">//交换arr[j]与arr[j+1]</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line"></span><br><span class="line">                    flag = <span class="literal">false</span>;<span class="comment">//如果元素发生了交换，那么说明数组还没有排好序</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//完成排序，遍历结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-6-4-快速排序"><a href="#6-6-4-快速排序" class="headerlink" title="6.6.4 快速排序"></a>6.6.4 快速排序</h4><p>快速排序（Quick Sort）由<code>图灵奖</code>获得者<code>Tony Hoare</code>发明，被列为<code>20世纪十大算法之一</code>，是迄今为止所有内排序算法中速度最快的一种，快速排序的时间复杂度为O(nlog(n))。</p><p>快速排序通常明显比同为O(nlogn)的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。</p><p>排序思想：</p><ol><li><p>从数列中挑出一个元素，称为”基准”（pivot），</p></li><li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</p></li><li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p></li><li><p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p></li></ol><p><strong>动态演示：</strong><a href="https://visualgo.net/zh/sorting">https://visualgo.net/zh/sorting</a></p><p>图示1：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/image-20220317235922776.png" alt="image-20220317235922776"></p><p>图示2：</p><p>第一轮操作：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/image-20221117205612230.png" alt="image-20221117205612230"></p><p>第二轮操作：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/image-20221117205719427.png" alt="image-20221117205719427"></p><h4 id="6-6-5-内部排序性能比较与选择"><a href="#6-6-5-内部排序性能比较与选择" class="headerlink" title="6.6.5 内部排序性能比较与选择"></a>6.6.5 内部排序性能比较与选择</h4><ul><li><p>性能比较</p><ul><li><strong>从平均时间而言</strong>：快速排序最佳。但在最坏情况下时间性能不如堆排序和归并排序。</li><li><strong>从算法简单性看</strong>：由于直接选择排序、直接插入排序和冒泡排序的算法比较简单，将其认为是简单算法。对于Shell排序、堆排序、快速排序和归并排序算法，其算法比较复杂，认为是复杂排序。</li><li><strong>从稳定性看</strong>：直接插入排序、冒泡排序和归并排序时稳定的；而直接选择排序、快速排序、 Shell排序和堆排序是不稳定排序</li><li><strong>从待排序的记录数n的大小看</strong>，n较小时，宜采用简单排序；而n较大时宜采用改进排序。</li></ul></li><li><p>选择</p><ul><li>若n较小(如n≤50)，可采用直接插入或直接选择排序。<br>当记录规模较小时，直接插入排序较好；否则因为直接选择移动的记录数少于直接插入，应选直接选择排序为宜。</li><li>若文件初始状态基本有序(指正序)，则应选用直接插入、冒泡或随机的快速排序为宜；</li><li>若n较大，则应采用时间复杂度为O(nlgn)的排序方法：快速排序、堆排序或归并排序。</li></ul></li></ul><h2 id="7-Arrays工具类的使用"><a href="#7-Arrays工具类的使用" class="headerlink" title="7. Arrays工具类的使用"></a>7. Arrays工具类的使用</h2><p>java.util.Arrays类即为操作数组的工具类，包含了用来操作数组（比如排序和搜索）的各种方法。 比如：</p><ul><li><code>数组元素拼接</code><ul><li>static String toString(int[] a) ：字符串表示形式由数组的元素列表组成，括在方括号（”[]”）中。相邻元素用字符 “, “（逗号加空格）分隔。形式为：[元素1，元素2，元素3。。。]</li><li>static String toString(Object[] a) ：字符串表示形式由数组的元素列表组成，括在方括号（”[]”）中。相邻元素用字符 “, “（逗号加空格）分隔。元素将自动调用自己从Object继承的toString方法将对象转为字符串进行拼接，如果没有重写，则返回类型@hash值，如果重写则按重写返回的字符串进行拼接。</li></ul></li><li><code>数组排序</code><ul><li>static void sort(int[] a) ：将a数组按照从小到大进行排序</li><li>static void sort(int[] a, int fromIndex, int toIndex) ：将a数组的[fromIndex, toIndex)部分按照升序排列</li><li>static void sort(Object[] a) ：根据元素的自然顺序对指定对象数组按升序进行排序。</li><li>static <T> void sort(T[] a, Comparator&lt;? super T&gt; c) ：根据指定比较器产生的顺序对指定对象数组进行排序。</T></li></ul></li><li><code>数组元素的二分查找</code><ul><li>static int binarySearch(int[] a, int key)  、static int binarySearch(Object[] a, Object key) ：要求数组有序，在数组中查找key是否存在，如果存在返回第一次找到的下标，不存在返回负数。</li></ul></li><li><code>数组的复制</code><ul><li>static int[] copyOf(int[] original, int newLength)  ：根据original原数组复制一个长度为newLength的新数组，并返回新数组</li><li>static <T> T[] copyOf(T[] original,int newLength)：根据original原数组复制一个长度为newLength的新数组，并返回新数组</T></li><li>static int[] copyOfRange(int[] original, int from, int to) ：复制original原数组的[from,to)构成新数组，并返回新数组</li><li>static <T> T[] copyOfRange(T[] original,int from,int to)：复制original原数组的[from,to)构成新数组，并返回新数组</T></li></ul></li><li><code>比较两个数组是否相等</code><ul><li>static boolean equals(int[] a, int[] a2) ：比较两个数组的长度、元素是否完全相同</li><li>static boolean equals(Object[] a,Object[] a2)：比较两个数组的长度、元素是否完全相同</li></ul></li><li><code>填充数组</code><ul><li>static void fill(int[] a, int val) ：用val值填充整个a数组</li><li>static void fill(Object[] a,Object val)：用val对象填充整个a数组</li><li>static void fill(int[] a, int fromIndex, int toIndex, int val)：将a数组[fromIndex,toIndex)部分填充为val值</li><li>static void fill(Object[] a, int fromIndex, int toIndex, Object val) ：将a数组[fromIndex,toIndex)部分填充为val对象</li></ul></li></ul><p>举例：java.util.Arrays类的sort()方法提供了数组元素排序功能：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前&quot;</span> + Arrays.toString(arr));</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后&quot;</span> + Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="8-数组中的常见异常"><a href="#8-数组中的常见异常" class="headerlink" title="8. 数组中的常见异常"></a>8. 数组中的常见异常</h2><h3 id="8-1-数组角标越界异常"><a href="#8-1-数组角标越界异常" class="headerlink" title="8.1 数组角标越界异常"></a>8.1 数组角标越界异常</h3><p>当访问数组元素时，下标指定超出[0, 数组名.length-1]的范围时，就会报数组下标越界异常：ArrayIndexOutOfBoundsException。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestArrayIndexOutOfBoundsException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">       <span class="comment">// System.out.println(&quot;最后一个元素：&quot; + arr[3]);//错误，下标越界</span></span><br><span class="line">      <span class="comment">//  System.out.println(&quot;最后一个元素：&quot; + arr[arr.length]);//错误，下标越界</span></span><br><span class="line">        System.out.println(<span class="string">&quot;最后一个元素：&quot;</span> + arr[arr.length-<span class="number">1</span>]);<span class="comment">//对</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建数组，赋值3个元素，数组的索引就是0，1，2，没有3索引，因此我们不能访问数组中不存在的索引，程序运行后，将会抛出 <code>ArrayIndexOutOfBoundsException</code>  数组越界异常。在开发中，数组的越界异常是<strong>不能出现</strong>的，一旦出现了，就必须要修改我们编写的代码。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/数组越界异常.jpg" alt></p><h3 id="8-2-空指针异常"><a href="#8-2-空指针异常" class="headerlink" title="8.2 空指针异常"></a>8.2 空指针异常</h3><p>观察一下代码，运行后会出现什么结果。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNullPointerException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义数组</span></span><br><span class="line">        <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][];</span><br><span class="line"></span><br><span class="line">        System.out.println(arr[<span class="number">0</span>][<span class="number">0</span>]);<span class="comment">//NullPointerException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为此时数组的每一行还未分配具体存储元素的空间，此时arr[0]是null，此时访问arr[0][0]会抛出<code>NullPointerException</code> 空指针异常。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/空指针异常-1647708157677.jpg" alt></p><p><strong>空指针异常在内存图中的表现</strong></p><p><img src="/2023/02/18/java2023/%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/1572338767825-1647708157678.png" alt="1572338767825"></p><p><strong>小结：空指针异常情况</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//举例一：</span></span><br><span class="line"><span class="comment">//int[] arr1 = new int[10];</span></span><br><span class="line"><span class="comment">//arr1 = null;</span></span><br><span class="line"><span class="comment">//System.out.println(arr1[9]);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//举例二：</span></span><br><span class="line"><span class="comment">//int[][] arr2 = new int[5][];</span></span><br><span class="line"><span class="comment">////arr2[3] = new int[10];</span></span><br><span class="line"><span class="comment">//System.out.println(arr2[3][3]);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//举例三：</span></span><br><span class="line">String[] arr3 = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line">System.out.println(arr3[<span class="number">2</span>].toString());</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第05章-数组&quot;&gt;&lt;a href=&quot;#第05章-数组&quot; class=&quot;headerlink&quot; title=&quot;第05章_数组&quot;&gt;&lt;/a&gt;第05章_数组&lt;/h1&gt;&lt;p&gt;讲师：尚硅谷-宋红康（江湖人称：康师傅）&lt;/p&gt;
&lt;p&gt;官网：&lt;a href=&quot;http://www</summary>
      
    
    
    
    <category term="Java2023" scheme="http://example.com/categories/Java2023/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第06章_面向对象编程（基础）</title>
    <link href="http://example.com/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/"/>
    <id>http://example.com/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/</id>
    <published>2023-02-18T12:37:01.000Z</published>
    <updated>2023-02-19T07:38:42.827Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第06章-面向对象编程（基础）"><a href="#第06章-面向对象编程（基础）" class="headerlink" title="第06章_面向对象编程（基础）"></a>第06章_面向对象编程（基础）</h1><p>讲师：尚硅谷-宋红康（江湖人称：康师傅）</p><p>官网：<a href="http://www.atguigu.com/">http://www.atguigu.com</a></p><hr><h2 id="本章专题与脉络"><a href="#本章专题与脉络" class="headerlink" title="本章专题与脉络"></a>本章专题与脉络</h2><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/第2阶段：Java面向对象编程-第06章.png" alt="第2阶段：Java面向对象编程-第06章"></p><hr><p><strong>学习面向对象内容的三条主线</strong></p><ul><li>Java类及类的成员：（重点）属性、方法、构造器；（熟悉）代码块、内部类</li><li>面向对象的特征：封装、继承、多态、（抽象）</li><li>其他关键字的使用：this、super、package、import、static、final、interface、abstract等</li></ul><h2 id="1-面向对象编程概述-了解"><a href="#1-面向对象编程概述-了解" class="headerlink" title="1. 面向对象编程概述(了解)"></a>1. 面向对象编程概述(了解)</h2><h3 id="1-1-程序设计的思路"><a href="#1-1-程序设计的思路" class="headerlink" title="1.1 程序设计的思路"></a>1.1 程序设计的思路</h3><p>面向对象，是软件开发中的一类编程风格、开发范式。除了<code>面向对象</code>，还有<code>面向过程</code>、<code>指令式编程</code>和<code>函数式编程</code>。在所有的编程范式中，我们接触最多的还是面向过程和面向对象两种。</p><blockquote><p>类比：史书类型</p><ul><li>纪传体：以人物传记为中心，“本纪”叙述帝王，“世家”记叙王侯封国和特殊人物，“列传”记叙民间人物。</li><li>编年体：按年、月、日顺序编写。</li><li>国别体：是一部分国记事的历史散文，分载多国历史。</li></ul></blockquote><p>早期先有面向过程思想，随着软件规模的扩大，问题复杂性的提高，面向过程的<code>弊端</code>越来越明显，出现了面向对象思想并成为目前主流的方式。</p><p><strong>1. 面向过程的程序设计思想（Process-Oriented Programming）</strong>，简称<code>POP</code></p><ul><li>关注的焦点是<code>过程</code>：过程就是操作数据的步骤。如果某个过程的实现代码重复出现，那么就可以把这个过程抽取为一个<code>函数</code>。这样就可以大大简化冗余代码，便于维护。</li><li>典型的语言：C语言</li><li>代码结构：以<code>函数</code>为组织单位。</li><li>是一种“<code>执行者思维</code>”，适合解决简单问题。扩展能力差、后期维护难度较大。</li></ul><p><strong>2. 面向对象的程序设计思想（ Object Oriented Programming）</strong>，简称<code>OOP</code></p><ul><li>关注的焦点是<code>类</code>：在计算机程序设计过程中，参照现实中事物，将事物的属性特征、行为特征抽象出来，用类来表示。</li><li>典型的语言：Java、C#、C++、Python、Ruby和PHP等</li><li>代码结构：以<code>类</code>为组织单位。每种事物都具备自己的<code>属性</code>和<code>行为/功能</code>。</li><li>是一种“<code>设计者思维</code>”，适合解决复杂问题。代码扩展性强、可维护性高。</li></ul><h3 id="1-2-由实际问题考虑如何设计程序"><a href="#1-2-由实际问题考虑如何设计程序" class="headerlink" title="1.2 由实际问题考虑如何设计程序"></a>1.2 由实际问题考虑如何设计程序</h3><p><strong>思考1：如何开车？</strong></p><p>面向过程思想思考问题时，我们首先思考“<code>怎么按步骤实现？</code>”并将步骤对应成方法，一步一步，最终完成。 这个适合<code>简单任务</code>，不需要<code>过多协作</code>的情况。针对如何开车，可以列出步骤：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/面向过程的思考.png" alt="image-20220520154055429" style="zoom: 90%;"></p><p>面向过程适合简单、不需要协作的事务，重点关注如何执行。 </p><p><strong>思考2：如何造车？</strong></p><p>造车太复杂，需要<code>很多协作</code>才能完成。此时我们思考的是“<code>车怎么设计？</code>”，而不是“怎么按特定步骤造车的问题”。这就是思维方式的转变，前者就是面向对象思想。所以，面向对象(Oriented-Object)思想更契合人的思维模式。</p><p>用面向对象思想思考“如何设计车”：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/a49bd1fc8152291f0c5b43ee3322672d.png" alt="a49bd1fc8152291f0c5b43ee3322672d" style="zoom: 25%;"></p><p>自然地，我们就会从“车由什么组成”开始思考。发现，车由如下结构组成：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220520155357634.png" alt="image-20220520155357634" style="zoom: 67%;"></p><p>我们找轮胎厂完成制造轮胎的步骤，发动机厂完成制造发动机的步骤，…；这样，大家可以同时进行车的制造，最终进行组装，大大提高了效率。但是，具体到轮胎厂的一个流水线操作，仍然是有步骤的，还是离不开面向过程思维！</p><p>因此，<strong>面向对象可以帮助我们从宏观上把握、从整体上分析整个系统。</strong> 但是，具体到实现部分的微观操作（就是一个个方法），仍然需要面向过程的思路去处理。</p><blockquote><p>注意：</p><p>我们千万不要把面向过程和面向对象对立起来。他们是相辅相成的。面向对象离不开面向过程！</p></blockquote><p><strong>类比举例1：</strong></p><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/tuandui.jpg" alt="tuandui"></p><blockquote><p>当需求单一，或者简单时，我们一步步去操作没问题，并且效率也挺高。</p><p>可随着需求的更改，功能的增多，发现需要面对每一个步骤很麻烦了，这时就开始思索，<strong>能不能把这些步骤和功能进行封装，封装时根据不同的功能，进行不同的封装，功能类似的封装在一起。</strong>这样结构就清晰了很多。用的时候，找到对应的类就可以了。这就是面向对象的思想。</p></blockquote><p><strong>类比举例2：人把大象装进冰箱</strong></p><ul><li><p>面向过程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.打开冰箱</span><br><span class="line"></span><br><span class="line">2.把大象装进冰箱</span><br><span class="line"></span><br><span class="line">3.把冰箱门关住</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>面向对象</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">人&#123;</span><br><span class="line">    打开（冰箱）&#123;</span><br><span class="line">冰箱.开门();</span><br><span class="line">    &#125;</span><br><span class="line">    操作(大象)&#123;</span><br><span class="line">             大象.进入(冰箱);</span><br><span class="line">    &#125;</span><br><span class="line">    关闭(冰箱)&#123;   </span><br><span class="line">          冰箱.关门();     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">冰箱&#123;</span><br><span class="line">     开门()&#123; &#125;  </span><br><span class="line">     关门()&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">大象&#123;</span><br><span class="line">     进入(冰箱)&#123;  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p><strong>练习：</strong>抽象出下面系统中的“类”及其关系</p><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220319180839009.png" alt="image-20220319180839009" style="zoom:80%;"></p><h3 id="1-3-如何掌握这种思想？"><a href="#1-3-如何掌握这种思想？" class="headerlink" title="1.3 如何掌握这种思想？"></a>1.3 如何掌握这种思想？</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220319180301856.png" alt="image-20220319180301856" style="zoom: 67%;"></p><h2 id="2-Java语言的基本元素：类和对象"><a href="#2-Java语言的基本元素：类和对象" class="headerlink" title="2. Java语言的基本元素：类和对象"></a>2. Java语言的基本元素：类和对象</h2><h3 id="2-1-引入"><a href="#2-1-引入" class="headerlink" title="2.1 引入"></a>2.1 引入</h3><p>人认识世界，其实就是面向对象的。比如，我们认识一下美人鱼（都没见过）</p><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220520162643547.png" alt="image-20220520162643547" style="zoom:67%;"></p><p>经过“仔细学习”，发现美人鱼通常具备一些特征：</p><ul><li>女孩</li><li>有鱼尾</li><li>美丽</li></ul><p>这个总结的过程，其实是<code>抽象化</code>的过程。抽象出来的美人鱼的特征，可以归纳为一个<code>美人鱼类</code>。而图片中的都是这个类呈现出来的<code>具体的对象</code>。</p><h3 id="2-2-类和对象概述"><a href="#2-2-类和对象概述" class="headerlink" title="2.2 类和对象概述"></a>2.2 类和对象概述</h3><p><code>类(Class)</code>和<code>对象(Object)</code>是面向对象的核心概念。</p><p><strong>1、什么是类</strong></p><p><strong>类</strong>：具有相同特征的事物的抽象描述，是<code>抽象的</code>、概念上的定义。</p><p><strong>2、什么是对象</strong></p><p><strong>对象</strong>：实际存在的该类事物的<code>每个个体</code>，是<code>具体的</code>，因而也称为<code>实例(instance)</code>。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220319210405983.png" alt="image-20220319210405983"></p><p>可以理解为：<code>类 =&gt; 抽象概念的人</code>；<code>对象 =&gt; 实实在在的某个人</code></p><hr><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/iphone13promax.jpeg" style="zoom:85%;"></p><hr><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220503101940126.png" alt="image-20220503101940126" style="zoom:67%;"></p><h3 id><a href="#" class="headerlink" title=" "></a> </h3><p><strong>3、类与对象的关系错误理解</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">曰：“白马非马，可乎？”</span><br><span class="line">曰：“可。”</span><br><span class="line">曰：“何哉？”</span><br><span class="line">曰：“马者，所以命形也。白者，所以命色也。命色者，非命形也，故曰白马非马。”</span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220319214213898.png" alt="image-20220319214213898"></p><h3 id="2-3-类的成员概述"><a href="#2-3-类的成员概述" class="headerlink" title="2.3 类的成员概述"></a>2.3 类的成员概述</h3><blockquote><p>面向对象程序设计的重点是<code>类的设计</code></p><p>类的设计，其实就是<code>类的成员的设计</code></p></blockquote><ul><li><p>现实世界的生物体，大到鲸鱼，小到蚂蚁，都是由最基本的<code>细胞</code>构成的。同理，Java代码世界是由诸多个不同功能的<code>类</code>构成的。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220319211527249.png" alt="image-20220319211527249" style="zoom:67%;"></p></li><li><p>现实生物世界中的细胞又是由什么构成的呢？细胞核、细胞质、… </p><p>Java中用类class来描述事物也是如此。类，是一组相关<code>属性</code>和<code>行为</code>的集合，这也是类最基本的两个成员。</p><ul><li><strong>属性</strong>：该类事物的状态信息。对应类中的<code>成员变量</code><ul><li><strong>成员变量 &lt;=&gt; 属性 &lt;=&gt; Field</strong></li></ul></li><li><strong>行为</strong>：该类事物要做什么操作，或者基于事物的状态能做什么。对应类中的<code>成员方法</code><ul><li><strong>(成员)方法 &lt;=&gt; 函数 &lt;=&gt; Method</strong></li></ul></li></ul></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/20220319_211611.jpg" alt="20220319_211611" style="zoom: 67%;"></p><ul><li>举例：</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220319211859026.png" alt="image-20220319211859026"></p><h3 id="2-4-面向对象完成功能的三步骤（重要）"><a href="#2-4-面向对象完成功能的三步骤（重要）" class="headerlink" title="2.4 面向对象完成功能的三步骤（重要）"></a>2.4 面向对象完成功能的三步骤（重要）</h3><h4 id="步骤1：类的定义"><a href="#步骤1：类的定义" class="headerlink" title="步骤1：类的定义"></a>步骤1：类的定义</h4><p>类的定义使用关键字：class。格式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] class 类名&#123;</span><br><span class="line">属性声明;</span><br><span class="line">    方法声明;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="comment">//声明属性age</span></span><br><span class="line">    <span class="type">int</span> age ;                   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//声明方法showAge()</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;        </span><br><span class="line">    System.out.println(<span class="string">&quot;人吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>举例2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">    <span class="comment">//声明属性</span></span><br><span class="line">String type; <span class="comment">//种类</span></span><br><span class="line">String nickName; <span class="comment">//昵称</span></span><br><span class="line">String hostName; <span class="comment">//主人名称</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123; <span class="comment">//吃东西</span></span><br><span class="line">System.out.println(<span class="string">&quot;狗狗进食&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">char</span> gender;</span><br><span class="line">    Dog dog;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//喂宠物</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">()</span>&#123;</span><br><span class="line">        dog.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="步骤2：对象的创建"><a href="#步骤2：对象的创建" class="headerlink" title="步骤2：对象的创建"></a>步骤2：对象的创建</h4><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220319213201568.png" alt="image-20220319213201568" style="zoom: 50%;"></p><ul><li>创建对象，使用关键字：<strong>new</strong></li><li>创建对象语法： </li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式1：给创建的对象命名</span></span><br><span class="line"><span class="comment">//把创建的对象用一个引用数据类型的变量保存起来，这样就可以反复使用这个对象了</span></span><br><span class="line">类名 对象名 = <span class="keyword">new</span> 类名();</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2：</span></span><br><span class="line"><span class="keyword">new</span> 类名()<span class="comment">//也称为匿名对象</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>举例：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PersonTest</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="comment">//创建Person类的对象</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="comment">//创建Dog类的对象</span></span><br><span class="line"><span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="步骤3：对象调用属性或方法"><a href="#步骤3：对象调用属性或方法" class="headerlink" title="步骤3：对象调用属性或方法"></a>步骤3：对象调用属性或方法</h4><ul><li><p>对象是类的一个<strong>实例</strong>，必然具备该类事物的属性和行为（即方法）。</p></li><li><p>使用”<code>对象名.属性</code>“ 或 “<code>对象名.方法</code>“的方式访问对象成员（包括属性和方法）</p></li></ul><p>举例1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明Animal类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123; <span class="comment">//动物类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> legs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Eating.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Move.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnimalTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">xb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        xb.legs = <span class="number">4</span>;<span class="comment">//访问属性</span></span><br><span class="line">        System.out.println(xb.legs);</span><br><span class="line">        xb.eat();<span class="comment">//访问方法</span></span><br><span class="line">        xb.move();<span class="comment">//访问方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图示理解：<img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220319213753668.png" alt="image-20220319213753668"></p><p>举例2：针对前面步骤1的举例2：类的实例化（创建类的对象）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Game</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="comment">//通过Person对象调用属性</span></span><br><span class="line">        p.name = <span class="string">&quot;康师傅&quot;</span>;</span><br><span class="line">        p.gender = <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line">        p.dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(); <span class="comment">//给Person对象的dog属性赋值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//给Person对象的dog属性的type、nickname属性赋值</span></span><br><span class="line">        p.dog.type = <span class="string">&quot;柯基犬&quot;</span>;</span><br><span class="line">        p.dog.nickName = <span class="string">&quot;小白&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//通过Person对象调用方法</span></span><br><span class="line">        p.feed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-匿名对象-anonymous-object"><a href="#2-5-匿名对象-anonymous-object" class="headerlink" title="2.5 匿名对象 (anonymous object)"></a>2.5 匿名对象 (anonymous object)</h3><ul><li><p>我们也可以不定义对象的句柄，而直接调用这个对象的方法。这样的对象叫做匿名对象。</p><ul><li>如：new Person().shout(); </li></ul></li><li><p>使用情况</p><ul><li>如果一个对象只需要进行一次方法调用，那么就可以使用匿名对象。 </li><li>我们经常将匿名对象作为实参传递给一个方法调用。 </li></ul></li></ul><h2 id="3-对象的内存解析"><a href="#3-对象的内存解析" class="headerlink" title="3. 对象的内存解析"></a>3. 对象的内存解析</h2><h3 id="3-1-JVM内存结构划分"><a href="#3-1-JVM内存结构划分" class="headerlink" title="3.1 JVM内存结构划分"></a>3.1 JVM内存结构划分</h3><p>HotSpot Java虚拟机的架构图如下。其中我们主要关心的是运行时数据区部分（Runtime Data Area）。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/JVM架构-简图.png" alt="JVM架构-简图"></p><p>其中：</p><p><code>堆（Heap）</code>：此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。</p><p><code>栈（Stack）</code>：是指虚拟机栈。虚拟机栈用于存储局部变量等。局部变量表存放了编译期可知长度的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，是对象在堆内存的首地址）。 方法执行完，自动释放。</p><p><code>方法区（Method Area）</code>：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><h3 id="3-2-对象内存解析"><a href="#3-2-对象内存解析" class="headerlink" title="3.2 对象内存解析"></a>3.2 对象内存解析</h3><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; <span class="comment">//类：人</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">boolean</span> isMale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonTest</span> &#123; <span class="comment">//测试类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p1.name = <span class="string">&quot;赵同学&quot;</span>;</span><br><span class="line">        p1.age = <span class="number">20</span>;</span><br><span class="line">        p1.isMale = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p2.age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p3</span> <span class="operator">=</span> p1;</span><br><span class="line">        p3.name = <span class="string">&quot;郭同学&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存解析图：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220319215723183.png" alt="image-20220319215723183" style="zoom:67%;"></p><blockquote><p>说明：</p><ul><li>堆：凡是new出来的结构(对象、数组)都放在堆空间中。</li><li>对象的属性存放在堆空间中。</li><li>创建一个类的多个对象（比如p1、p2），则每个对象都拥有当前类的一套”副本”（即属性）。当通过一个对象修改其属性时，不会影响其它对象此属性的值。</li><li>当声明一个新的变量使用现有的对象进行赋值时（比如p3 = p1），此时并没有在堆空间中创建新的对象。而是两个变量共同指向了堆空间中同一个对象。当通过一个对象修改属性时，会影响另外一个对象对此属性的调用。</li></ul></blockquote><p><strong>面试题：对象名中存储的是什么呢？</strong></p><p>答：对象地址</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Student</span>());<span class="comment">//Student@7852e922</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        System.out.println(stu);<span class="comment">//Student@4e25154f</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">System.out.println(arr);<span class="comment">//[I@70dea4e</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接打印对象名和数组名都是显示“类型@对象的hashCode值”，所以说<strong>类、数组都是引用数据类型，引用数据类型的变量中存储的是对象的地址，或者说指向堆中对象的首地址。</strong></p><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/1561597909862.png" alt="1561597909862"></p><h3 id="3-3-练习"><a href="#3-3-练习" class="headerlink" title="3.3 练习"></a>3.3 练习</h3><p>根据代码，画出内存图</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">color</span> <span class="operator">=</span> <span class="string">&quot;red&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;color=&quot;</span> + color + <span class="string">&quot;,num=&quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Car</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();   <span class="comment">//建立对象c1</span></span><br><span class="line">        <span class="type">Car</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();   <span class="comment">//建立对象c2</span></span><br><span class="line">        c1.color = <span class="string">&quot;blue&quot;</span>;   <span class="comment">//对对象的属性进行修改</span></span><br><span class="line">        c1.show();   <span class="comment">//使用对象的方法</span></span><br><span class="line">        c2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-类的成员之一：成员变量-field"><a href="#4-类的成员之一：成员变量-field" class="headerlink" title="4. 类的成员之一：成员变量(field)"></a>4. 类的成员之一：成员变量(field)</h2><h3 id="4-1-如何声明成员变量"><a href="#4-1-如何声明成员变量" class="headerlink" title="4.1 如何声明成员变量"></a>4.1 如何声明成员变量</h3><ul><li>语法格式：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符<span class="number">1</span>] class 类名&#123;</span><br><span class="line">    [修饰符<span class="number">2</span>] 数据类型 成员变量名 [= 初始化值]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>说明：<ul><li>位置要求：必须在类中，方法外</li><li>修饰符2(暂不考虑)<ul><li>常用的权限修饰符有：private、缺省、protected、public</li><li>其他修饰符：static、final </li></ul></li><li>数据类型<ul><li>任何基本数据类型(如int、Boolean) 或 任何引用数据类型。</li></ul></li><li>成员变量名<ul><li>属于标识符，符合命名规则和规范即可。</li></ul></li><li>初始化值<ul><li>根据情况，可以显式赋值；也可以不赋值，使用默认值</li></ul></li></ul></li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;             <span class="comment">//声明private变量 age</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> “Lila”;    <span class="comment">//声明public变量 name</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-2-成员变量-vs-局部变量"><a href="#4-2-成员变量-vs-局部变量" class="headerlink" title="4.2 成员变量 vs 局部变量"></a>4.2 成员变量 vs 局部变量</h3><p><strong>1、变量的分类：成员变量与局部变量</strong></p><ul><li>在方法体外，类体内声明的变量称为成员变量。</li><li>在方法体内部等位置声明的变量称为局部变量。</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220511101608038.png" alt="image-20220511101608038" style="zoom:67%;"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220319230744617.png" alt="image-20220319230744617" style="zoom:80%;"></p><blockquote><p>其中，static可以将成员变量分为两大类，静态变量和非静态变量。其中静态变量又称为类变量，非静态变量又称为实例变量或者属性。接下来先学习实例变量。</p></blockquote><p><strong>2、成员变量 与 局部变量 的对比</strong></p><ul><li><p>相同点</p><ul><li>变量声明的格式相同： 数据类型  变量名 = 初始化值<ul><li>变量必须先声明、后初始化、再使用。</li></ul><ul><li>变量都有其对应的作用域。只在其作用域内是有效的</li></ul></li></ul></li><li><p>不同点</p></li></ul><p>1、声明位置和方式<br>（1）实例变量：在类中方法外<br>（2）局部变量：在方法体{}中或方法的形参列表、代码块中</p><p>2、在内存中存储的位置不同<br>（1）实例变量：堆<br>（2）局部变量：栈</p><p>3、生命周期<br>（1）实例变量：和对象的生命周期一样，随着对象的创建而存在，随着对象被GC回收而消亡，<br>            而且每一个对象的实例变量是独立的。<br>（2）局部变量：和方法调用的生命周期一样，每一次方法被调用而在存在，随着方法执行的结束而消亡，<br>            而且每一次方法调用都是独立。</p><p>4、作用域<br>（1）实例变量：通过对象就可以使用，本类中直接调用，其他类中“对象.实例变量”<br>（2）局部变量：出了作用域就不能使用</p><p>5、修饰符（后面来讲）<br>（1）实例变量：public,protected,private,final,volatile,transient等<br>（2）局部变量：final</p><p>6、默认值<br>（1）实例变量：有默认值<br>（2）局部变量：没有，必须手动初始化。其中的形参比较特殊，靠实参给它初始化。</p><p><strong>3、对象属性的默认初始化赋值</strong></p><p>当一个对象被创建时，会对其中各种类型的成员变量自动进行初始化赋值。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220319231821747.png" alt="image-20220319231821747" style="zoom:80%;"></p><p><strong>4、举例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;<span class="comment">//人类</span></span><br><span class="line">    <span class="comment">//1.属性</span></span><br><span class="line">    String name;<span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//年龄</span></span><br><span class="line">    <span class="type">boolean</span> isMale;<span class="comment">//是否是男性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String nation)</span> &#123;</span><br><span class="line">        <span class="comment">//nation:局部变量</span></span><br><span class="line">        String color;<span class="comment">//color:局部变量</span></span><br><span class="line">        color = <span class="string">&quot;yellow&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p.show(<span class="string">&quot;CHN&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220319231703240.png" alt="image-20220319231703240" style="zoom:80%;"></p><h2 id="5-类的成员之二：方法-method"><a href="#5-类的成员之二：方法-method" class="headerlink" title="5. 类的成员之二：方法(method)"></a>5. 类的成员之二：方法(method)</h2><h3 id="5-1-方法的引入"><a href="#5-1-方法的引入" class="headerlink" title="5.1 方法的引入"></a>5.1 方法的引入</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/街头霸王&超级玛丽.jpg"></p><p>《街霸》游戏中，每次人物出拳、出脚或跳跃等动作都需要编写50-80行的代码，在每次出拳、出脚或跳跃的地方都需要重复地编写这50-80行代码，这样程序会变得<code>很臃肿</code>，可读性也非常差。为了解决代码重复编写的问题，可以将出拳、出脚或跳跃的代码提取出来放在一个{}中，并为这段代码起个名字，这样在每次的出拳、出脚或跳跃的地方通过这个名字来调用这个{}的代码就可以了。</p><p>上述过程中，所提取出来的代码可以被看作是程序中定义的一个方法，程序在需要出拳、出脚或跳跃时调用该方法即可。</p><h3 id="5-2-方法-method、函数-的理解"><a href="#5-2-方法-method、函数-的理解" class="headerlink" title="5.2 方法(method、函数)的理解"></a>5.2 方法(method、函数)的理解</h3><ul><li><p><code>方法</code>是类或对象行为特征的抽象，用来完成某个功能操作。在某些语言中也称为<code>函数</code>或<code>过程</code>。 </p></li><li><p>将功能封装为方法的目的是，可以<code>实现代码重用，减少冗余，简化代码</code></p></li><li><p>Java里的方法<code>不能独立存在</code>，所有的方法必须定义在类里。</p></li><li><p>举例1：</p><ul><li>Math.random()的random()方法</li><li>Math.sqrt(x)的sqrt(x)方法</li><li>System.out.println(x)的println(x)方法</li><li>new Scanner(System.in).nextInt()的nextInt()方法</li><li>Arrays类中的binarySearch()方法、sort()方法、equals()方法</li></ul></li><li><p>举例2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>  &#123;  <span class="comment">//声明方法getAge()</span></span><br><span class="line"><span class="keyword">return</span> age; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> i)</span> &#123;  <span class="comment">//声明方法setAge</span></span><br><span class="line">age = i;        <span class="comment">//将参数i的值赋给类的成员变量age</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="5-3-如何声明方法"><a href="#5-3-如何声明方法" class="headerlink" title="5.3 如何声明方法"></a>5.3 如何声明方法</h3><p><strong>1、声明方法的语法格式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] 返回值类型 方法名([形参列表])[<span class="keyword">throws</span> 异常列表]&#123;</span><br><span class="line">        方法体的功能代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）一个完整的方法 = 方法头 + 方法体。</p><ul><li>方法头就是<code>[修饰符] 返回值类型 方法名([形参列表])[throws 异常列表]</code>，也称为<code>方法签名</code>。通常调用方法时只需要关注方法头就可以，从方法头可以看出这个方法的功能和调用格式。</li><li>方法体就是方法被调用后要执行的代码。对于调用者来说，不了解方法体如何实现的，并不影响方法的使用。</li></ul><p><strong>（2）方法头可能包含5个部分</strong></p><ul><li><p><strong>修饰符</strong>：可选的。方法的修饰符也有很多，例如：public、protected、private、static、abstract、native、final、synchronized等，后面会一一学习。</p><ul><li>其中，权限修饰符有public、protected、private。在讲封装性之前，我们先默认使用pulbic修饰方法。</li><li>其中，根据是否有static，可以将方法分为静态方法和非静态方法。其中静态方法又称为类方法，非静态方法又称为实例方法。咱们在讲static前先学习实例方法。</li></ul></li><li><p><strong>返回值类型</strong>： 表示方法运行的结果的数据类型，方法执行后将结果返回到调用者。</p><ul><li>无返回值，则声明：void</li><li>有返回值，则声明出返回值类型（可以是任意类型）。与方法体中“<code>return 返回值</code>”搭配使用</li></ul></li><li><p><strong>方法名</strong>：属于标识符，命名时遵循标识符命名规则和规范，“见名知意”</p></li><li><p><strong>形参列表</strong>：表示完成方法体功能时需要外部提供的数据列表。可以包含零个，一个或多个参数。</p><ul><li>无论是否有参数，()不能省略</li><li>如果有参数，每一个参数都要指定数据类型和参数名，多个参数之间使用逗号分隔，例如：<ul><li>一个参数： (数据类型  参数名)</li><li>二个参数： (数据类型1  参数1,  数据类型2  参数2) </li></ul></li><li>参数的类型可以是基本数据类型、引用数据类型</li></ul></li><li><p><strong>throws 异常列表</strong>：可选，在【第09章-异常处理】章节再讲</p></li></ul><p><strong>（3）方法体</strong>：方法体必须有{}括起来，在{}中编写完成方法功能的代码</p><p><strong>（4）关于方法体中return语句的说明：</strong></p><ul><li><p>return语句的作用是结束方法的执行，并将方法的结果返回去</p></li><li><p>如果返回值类型不是void，方法体中必须保证一定有 return 返回值; 语句，并且要求该返回值结果的类型与声明的返回值类型一致或兼容。</p></li><li>如果返回值类型为void时，方法体中可以没有return语句，如果要用return语句提前结束方法的执行，那么return后面不能跟返回值，直接写return ; 就可以。</li><li>return语句后面就不能再写其他代码了，否则会报错：Unreachable code</li></ul><p>补充：方法的分类：按照是否有形参及返回值</p><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220320000047155.png" alt="image-20220320000047155" style="zoom: 50%;"></p><p><strong>2、类比举例</strong></p><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220503102323689.png" alt="image-20220503102323689" style="zoom:67%;"></p><p><strong>3、代码示例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.test04.method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法定义案例演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDefineDemo</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无参无返回值方法的演示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有参无返回值方法的演示</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length int 第一个参数，表示矩形的长</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> width int 第二个参数，表示矩形的宽</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sign char 第三个参数，表示填充矩形图形的符号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printRectangle</span><span class="params">(<span class="type">int</span> length, <span class="type">int</span> width, <span class="type">char</span> sign)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= length ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j &lt;= width; j++)&#123;</span><br><span class="line">                System.out.print(sign);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无参有返回值方法的演示</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getIntBetweenOneToHundred</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(Math.random()*<span class="number">100</span>+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有参有返回值方法的演示</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a int 第一个参数，要比较大小的整数之一</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b int 第二个参数，要比较大小的整数之二</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int 比较大小的两个整数中较大者的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-4-如何调用实例方法"><a href="#5-4-如何调用实例方法" class="headerlink" title="5.4 如何调用实例方法"></a>5.4 如何调用实例方法</h3><p>方法通过方法名被调用，且只有被调用才会执行。</p><p><strong>1、方法调用语法格式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对象.方法名([实参列表])</span><br></pre></td></tr></table></figure><p><strong>2、示例</strong></p><p>举例1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.test04.method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法调用案例演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodInvokeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">MethodDefineDemo</span> <span class="variable">md</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodDefineDemo</span>();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------方法调用演示-------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用MethodDefineDemo类中无参无返回值的方法sayHello</span></span><br><span class="line">        md.sayHello();</span><br><span class="line">        md.sayHello();</span><br><span class="line">        md.sayHello();</span><br><span class="line">        <span class="comment">//调用一次，执行一次，不调用不执行</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//调用MethodDefineDemo类中有参无返回值的方法printRectangle</span></span><br><span class="line">        md.printRectangle(<span class="number">5</span>,<span class="number">10</span>,<span class="string">&#x27;@&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//调用MethodDefineDemo类中无参有返回值的方法getIntBetweenOneToHundred</span></span><br><span class="line">        md.getIntBetweenOneToHundred();<span class="comment">//语法没问题，就是结果丢失</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> md.getIntBetweenOneToHundred();</span><br><span class="line">        System.out.println(<span class="string">&quot;num = &quot;</span> + num);</span><br><span class="line"></span><br><span class="line">        System.out.println(md.getIntBetweenOneToHundred());</span><br><span class="line">        <span class="comment">//上面的代码调用了getIntBetweenOneToHundred三次，这个方法执行了三次</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//调用MethodDefineDemo类中有参有返回值的方法max</span></span><br><span class="line">        md.max(<span class="number">3</span>,<span class="number">6</span>);<span class="comment">//语法没问题，就是结果丢失</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">bigger</span> <span class="operator">=</span> md.max(<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;bigger = &quot;</span> + bigger);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;8,3中较大者是：&quot;</span> + md.max(<span class="number">8</span>,<span class="number">9</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>举例2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、创建Scanner的对象</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);<span class="comment">//System.in默认代表键盘输入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、提示输入xx</span></span><br><span class="line">System.out.print(<span class="string">&quot;请输入一个整数：&quot;</span>); <span class="comment">//对象.非静态方法(实参列表)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、接收输入内容</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> input.nextInt();  <span class="comment">//对象.非静态方法()</span></span><br></pre></td></tr></table></figure><h3 id="5-5-使用的注意点"><a href="#5-5-使用的注意点" class="headerlink" title="5.5  使用的注意点"></a>5.5  使用的注意点</h3><p>（1）必须先声明后使用，且方法必须定义在类的内部</p><p>（2）调用一次就执行一次，不调用不执行。</p><p>（3）方法中可以调用类中的方法或属性，不可以在方法内部定义方法。</p><p>正确示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类&#123;</span><br><span class="line">    方法<span class="number">1</span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    方法<span class="number">2</span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类&#123;</span><br><span class="line">    方法<span class="number">1</span>()&#123;</span><br><span class="line">        方法<span class="number">2</span>()&#123;  <span class="comment">//位置错误</span></span><br><span class="line">        </span><br><span class="line">   &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-6-关键字return的使用"><a href="#5-6-关键字return的使用" class="headerlink" title="5.6 关键字return的使用"></a>5.6 关键字return的使用</h3><ul><li>return在方法中的作用：<ul><li>作用1：结束一个方法</li><li>作用2：结束一个方法的同时，可以返回数据给方法的调用者 </li></ul></li><li>注意点：在return关键字的直接后面不能声明执行语句</li></ul><h3 id="5-7-方法调用内存分析"><a href="#5-7-方法调用内存分析" class="headerlink" title="5.7 方法调用内存分析"></a>5.7 方法调用内存分析</h3><ul><li>方法<code>没有被调用</code>的时候，都在<code>方法区</code>中的字节码文件(.class)中存储。</li><li>方法<code>被调用</code>的时候，需要进入到<code>栈内存</code>中运行。方法每调用一次就会在栈中有一个<code>入栈</code>动作，即给当前方法开辟一块独立的内存区域，用于存储当前方法的局部变量的值。</li><li><p>当方法执行结束后，会释放该内存，称为<code>出栈</code>，如果方法有返回值，就会把结果返回调用处，如果没有返回值，就直接结束，回到调用处继续执行下一条指令。</p></li><li><p>栈结构：先进后出，后进先出。</p></li></ul><p>举例分析：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 9:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p1.eat();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        sleep();</span><br><span class="line">        System.out.println(<span class="string">&quot;人：吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人：睡觉&quot;</span>);</span><br><span class="line">        doSport();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSport</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人：运动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存分析：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220524104951449.png" alt="image-20220524104951449"></p><h3 id="5-8-练习"><a href="#5-8-练习" class="headerlink" title="5.8 练习"></a>5.8 练习</h3><p><strong>练习1：</strong>创建一个Person类，其定义如下：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220320001337145.png" alt="image-20220320001337145" style="zoom:67%;"></p><p>要求：</p><p>(1)创建Person类的对象，设置该对象的name、age和sex属性，调用study方法，输出字符串“studying”，调用showAge()方法显示age值，调用addAge()方法给对象的age属性值增加2岁。<br>(2)创建第二个对象，执行上述操作，体会同一个类的不同对象之间的关系。</p><p><strong>练习2：</strong>利用面向对象的编程方法，设计圆类Circle，包含属性（半径）和计算圆面积的方法。定义测试类，创建该Circle类的对象，并进行测试。</p><p><strong>练习3：</strong></p><p>3.1 编写程序，声明一个method方法，在方法中打印一个<code>10*8的*型矩形</code>，在main方法中调用该方法。</p><p>3.2 修改上一个程序，在method方法中，除打印一个<code>10*8的*型矩形</code>外，再计算该矩形的面积，并将其作为方法返回值。在main方法中调用该方法，接收返回的面积值并打印。</p><p>3.3 修改上一个程序，在method方法提供m和n两个参数，方法中打印一个<code>m*n的*型矩形</code>，并计算该矩形的面积， 将其作为方法返回值。在main方法中调用该方法，接收返回的面积值并打印。</p><p><strong>练习4：</strong>声明一个日期类型MyDate：有属性：年year,月month，日day。创建2个日期对象，分别赋值为：你的出生日期，你对象的出生日期，并显示信息。</p><p><strong>练习5（课下练习）：</strong>用面向对象的方式编写用户登录程序。</p><p>用户类：</p><ul><li>属性：用户名，密码</li><li>方法：登录</li></ul><p>界面类：</p><ul><li>在界面类中添加main方法，接受用户输入，并调用用户类的登录方法进行验证。<ul><li>输出：<ul><li>登录失败：用户名或密码错误！</li><li>登录成功：欢迎你，用户名！</li></ul></li></ul></li></ul><p>参考代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    String password;<span class="comment">//密码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现用户登录的判断</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputName 输入的用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputPwd  输入的密码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String inputName,String inputPwd)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(name.equals(inputName) &amp;&amp; password.equals(inputPwd))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;登录成功：欢迎你，&quot;</span> + name);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;登录失败：用户名或密码错误！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  实现用户登录的判断</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputName 输入的用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputPwd 输入的密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true:登录成功  false:登录失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">login1</span><span class="params">(String inputName,String inputPwd)</span>&#123;</span><br><span class="line"><span class="comment">//        if(name.equals(inputName) &amp;&amp; password.equals(inputPwd))&#123;</span></span><br><span class="line"><span class="comment">//            return true;</span></span><br><span class="line"><span class="comment">//        &#125;else&#123;</span></span><br><span class="line"><span class="comment">//            return false;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//简化为：</span></span><br><span class="line">        <span class="keyword">return</span> name.equals(inputName) &amp;&amp; password.equals(inputPwd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 用户界面类UserInterface：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - 在用户界面类中添加main方法，接受用户输入，并调用用户类的登录方法进行验证。</span></span><br><span class="line"><span class="comment"> * - 输出：</span></span><br><span class="line"><span class="comment"> *     - 登录失败：用户名或密码错误！</span></span><br><span class="line"><span class="comment"> *     - 登录成功：欢迎你，用户名！</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 9:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        u1.name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">        u1.password = <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入用户名：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入密码：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> scanner.next();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//演示1：</span></span><br><span class="line"><span class="comment">//        u1.login(name,pwd);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//演示2：</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLogin</span> <span class="operator">=</span> u1.login1(name, pwd);</span><br><span class="line">        <span class="keyword">if</span>(isLogin)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;登录成功：欢迎你，&quot;</span> + u1.name);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;登录失败：用户名或密码错误！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-对象数组"><a href="#6-对象数组" class="headerlink" title="6. 对象数组"></a>6. 对象数组</h2><p>数组的元素可以是基本数据类型，也可以是引用数据类型。当元素是引用类型中的类时，我们称为对象数组。</p><p><strong>1、案例</strong></p><p>定义类Student，包含三个属性：学号number(int)，年级state(int)，成绩score(int)。 创建20个学生对象，学号为1到20，年级和成绩都由随机数确定。</p><p>问题一：打印出3年级(state值为3）的学生信息。</p><p>问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息</p><p>提示：</p><p>1) 生成随机数：Math.random()，返回值类型double; </p><p>2) 四舍五入取整：Math.round(double d)，返回值类型long。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义类Student，包含三个属性：学号number(int)，年级state(int)，成绩score(int)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> number;<span class="comment">//学号</span></span><br><span class="line"><span class="type">int</span> state;<span class="comment">//年级</span></span><br><span class="line"><span class="type">int</span> score;<span class="comment">//成绩</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;number : &quot;</span> + number </span><br><span class="line">+ <span class="string">&quot;,state : &quot;</span> + state + <span class="string">&quot;,score : &quot;</span> + score);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTest</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Student s1 = new Student();</span></span><br><span class="line"><span class="comment">// s1.number = 1;</span></span><br><span class="line"><span class="comment">// s1.state = (int)(Math.random() * 6 + 1);//[1,6]</span></span><br><span class="line"><span class="comment">// s1.score = (int)(Math.random() * 101);//[0,100]</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Student s2 = new Student();</span></span><br><span class="line"><span class="comment">// s2.number = 2;</span></span><br><span class="line"><span class="comment">// s2.state = (int)(Math.random() * 6 + 1);//[1,6]</span></span><br><span class="line"><span class="comment">// s2.score = (int)(Math.random() * 101);//[0,100]</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// //....</span></span><br><span class="line"><span class="comment">// 对象数组</span></span><br><span class="line"><span class="comment">// String[] arr = new String[10];</span></span><br><span class="line"><span class="comment">// 数组的创建</span></span><br><span class="line">Student[] students = <span class="keyword">new</span> <span class="title class_">Student</span>[<span class="number">20</span>];</span><br><span class="line"><span class="comment">// 通过循环结构给数组的属性赋值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; students.length; i++) &#123;</span><br><span class="line"><span class="comment">// 数组元素的赋值</span></span><br><span class="line">students[i] = <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="comment">// 数组元素是一个对象，给对象的各个属性赋值</span></span><br><span class="line">students[i].number = (i + <span class="number">1</span>);</span><br><span class="line">students[i].state = (<span class="type">int</span>) (Math.random() * <span class="number">6</span> + <span class="number">1</span>);<span class="comment">// [1,6]</span></span><br><span class="line">students[i].score = (<span class="type">int</span>) (Math.random() * <span class="number">101</span>);<span class="comment">// [0,100]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 问题一：打印出3年级(state值为3）的学生信息。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; students.length; i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (students[i].state == <span class="number">3</span>) &#123;</span><br><span class="line"><span class="comment">//System.out.println(</span></span><br><span class="line"><span class="comment">//&quot;number:&quot; + students[i].number + &quot;,state:&quot; + students[i].state + &quot;,score:&quot; + students[i].score);</span></span><br><span class="line">students[i].info();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;******************************&quot;</span>);</span><br><span class="line"><span class="comment">// 问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息</span></span><br><span class="line"><span class="comment">// 排序前</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; students.length; i++) &#123;</span><br><span class="line"><span class="comment">//System.out.println(</span></span><br><span class="line"><span class="comment">//&quot;number:&quot; + students[i].number + &quot;,state:&quot; + </span></span><br><span class="line"><span class="comment">//students[i].state + &quot;,score:&quot; + students[i].score);</span></span><br><span class="line"></span><br><span class="line">students[i].info();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">// 排序：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; students.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; students.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (students[j].score &gt; students[j + <span class="number">1</span>].score) &#123;</span><br><span class="line"><span class="type">Student</span> <span class="variable">temp</span> <span class="operator">=</span> students[j];</span><br><span class="line">students[j] = students[j + <span class="number">1</span>];</span><br><span class="line">students[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序后：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; students.length; i++) &#123;</span><br><span class="line"><span class="comment">//System.out.println(</span></span><br><span class="line"><span class="comment">//&quot;number:&quot; + students[i].number + &quot;,state:&quot; + </span></span><br><span class="line"><span class="comment">//students[i].state + &quot;,score:&quot; + students[i].score);</span></span><br><span class="line"></span><br><span class="line">students[i].info();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存解析：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220320001627445.png" alt="image-20220320001627445"></p><p><strong>2、注意点</strong></p><p>对象数组，首先要创建数组对象本身，即确定数组的长度，然后再创建每一个元素对象，如果不创建，数组的元素的默认值就是<code>null</code>，所以很容易出现<code>空指针异常NullPointerException</code>。</p><p><strong>3、练习</strong></p><p>（1）定义矩形类Rectangle，包含长、宽属性，area()返回矩形面积的方法，perimeter()返回矩形周长的方法，String getInfo()返回圆对象的详细信息（如：长、宽、面积、周长等数据）的方法</p><p>（2）在测试类中创建长度为3的Rectangle[]数组，用来装3个矩形对象，并给3个矩形对象的长分别赋值为10,20,30，宽分别赋值为5,15,25，遍历输出</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.test08.array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="type">double</span> length;</span><br><span class="line">    <span class="type">double</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">area</span><span class="params">()</span>&#123;<span class="comment">//面积</span></span><br><span class="line">        <span class="keyword">return</span> length * width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">perimeter</span><span class="params">()</span>&#123;<span class="comment">//周长</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * (length + width);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;长：&quot;</span> + length +</span><br><span class="line">                <span class="string">&quot;，宽：&quot;</span> + width +</span><br><span class="line">                <span class="string">&quot;，面积：&quot;</span> + area() +</span><br><span class="line">                <span class="string">&quot;，周长：&quot;</span> + perimeter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.test08.array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectArrayTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//声明并创建一个长度为3的矩形对象数组</span></span><br><span class="line">        Rectangle[] array = <span class="keyword">new</span> <span class="title class_">Rectangle</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建3个矩形对象，并为对象的实例变量赋值，</span></span><br><span class="line">        <span class="comment">//3个矩形对象的长分别是10,20,30</span></span><br><span class="line">        <span class="comment">//3个矩形对象的宽分别是5,15,25</span></span><br><span class="line">        <span class="comment">//调用矩形对象的getInfo()返回对象信息后输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="comment">//创建矩形对象</span></span><br><span class="line">            array[i] = <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//为矩形对象的成员变量赋值</span></span><br><span class="line">            array[i].length = (i+<span class="number">1</span>) * <span class="number">10</span>;</span><br><span class="line">            array[i].width = (<span class="number">2</span>*i+<span class="number">1</span>) * <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取并输出对象对象的信息</span></span><br><span class="line">            System.out.println(array[i].getInfo());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存解析：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20211228153827819.png" alt="image-20211228153827819"></p><h2 id="7-再谈方法"><a href="#7-再谈方法" class="headerlink" title="7. 再谈方法"></a>7. 再谈方法</h2><h3 id="7-1-方法的重载（overload）"><a href="#7-1-方法的重载（overload）" class="headerlink" title="7.1 方法的重载（overload）"></a>7.1 方法的重载（overload）</h3><h4 id="7-1-1-概念及特点"><a href="#7-1-1-概念及特点" class="headerlink" title="7.1.1 概念及特点"></a>7.1.1 概念及特点</h4><ul><li><strong>方法重载</strong>：在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可。<ul><li>参数列表不同，意味着参数个数或参数类型的不同</li></ul></li><li><strong>重载的特点</strong>：与修饰符、返回值类型无关，只看参数列表，且参数列表必须不同。(参数个数或参数类型)。调用时，根据方法参数列表的不同来区别。</li><li><strong>重载方法调用</strong>：JVM通过方法的参数列表，调用匹配的方法。<ul><li>先找个数、类型最匹配的</li><li>再找个数和类型可以兼容的，如果同时多个方法可以兼容将会报错</li></ul></li></ul><h4 id="7-1-2-示例"><a href="#7-1-2-示例" class="headerlink" title="7.1.2 示例"></a>7.1.2 示例</h4><p>举例1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//System.out.println()方法就是典型的重载方法，其内部的声明形式如下：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">byte</span> x)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">short</span> x)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">long</span> x)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">float</span> x)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">double</span> x)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">char</span> x)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">double</span> x)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="number">1.2f</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    举例2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回两个整数的和</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回三个整数的和</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y+z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回两个小数的和</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    举例3：方法的重载和返回值类型无关</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathTools</span> &#123;</span><br><span class="line">    <span class="comment">//以下方法不是重载，会报错</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOneToHundred</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)(Math.random()*<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getOneToHundred</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.random()*<span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="7-1-3-练习"><a href="#7-1-3-练习" class="headerlink" title="7.1.3 练习"></a>7.1.3 练习</h4><p><strong>练习1：</strong>判 断与<code>void show(int a,char b,double c)&#123;&#125;</code>构成重载的有：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a)<span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> x,<span class="type">char</span> y,<span class="type">double</span> z)</span>&#123;&#125;     <span class="comment">// no</span></span><br><span class="line"></span><br><span class="line">b)<span class="type">int</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> a,<span class="type">double</span> c,<span class="type">char</span> b)</span>&#123;&#125;      <span class="comment">// yes</span></span><br><span class="line"></span><br><span class="line">c) <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> a,<span class="type">double</span> c,<span class="type">char</span> b)</span>&#123;&#125;    <span class="comment">// yes</span></span><br><span class="line"></span><br><span class="line">d) <span class="type">boolean</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> c,<span class="type">char</span> b)</span>&#123;&#125;          <span class="comment">// yes</span></span><br><span class="line"></span><br><span class="line">e) <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">double</span> c)</span>&#123;&#125;                 <span class="comment">// yes</span></span><br><span class="line"></span><br><span class="line">f) <span class="type">double</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> x,<span class="type">char</span> y,<span class="type">double</span> z)</span>&#123;&#125;  <span class="comment">// no</span></span><br><span class="line"></span><br><span class="line">g) <span class="keyword">void</span> <span class="title function_">shows</span><span class="params">()</span>&#123;<span class="type">double</span> c&#125;                <span class="comment">// no</span></span><br></pre></td></tr></table></figure><p><strong>练习2</strong>：编写程序，定义三个重载方法并调用。</p><ul><li><p>方法名为mOL。</p></li><li><p>三个方法分别接收一个int参数、两个int参数、一个字符串参数。分别执行平方运算并输出结果，相乘并输出结果，输出字符串信息。</p></li><li><p>在主类的main ()方法中分别用参数区别调用三个方法。</p></li></ul><p><strong>练习3</strong>：定义三个重载方法max()，第一个方法求两个int值中的最大值，第二个方法求两个double值中的最大值，第三个方法求三个double值中的最大值，并分别调用三个方法。</p><h3 id="7-2-可变个数的形参"><a href="#7-2-可变个数的形参" class="headerlink" title="7.2 可变个数的形参"></a>7.2 可变个数的形参</h3><p>在<strong>JDK 5.0 </strong>中提供了<strong>Varargs(</strong>variable number of arguments<strong>)</strong>机制。即当定义一个方法时，形参的类型可以确定，但是形参的个数不确定，那么可以考虑使用可变个数的形参。</p><p><strong>格式：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法名(参数的类型名 ...参数名)</span><br></pre></td></tr></table></figure><p><strong>举例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JDK 5.0以前：采用数组形参来定义方法，传入多个同一类型变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a ,String[] books)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//JDK5.0：采用可变个数形参来定义方法，传入多个同一类型变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a ,String...books)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><ol><li><p>可变参数：方法参数部分指定类型的参数个数是可变多个：0个，1个或多个</p></li><li><p>可变个数形参的方法与同名的方法之间，彼此构成重载</p></li><li><p>可变参数方法的使用与方法参数部分使用数组是一致的，二者不能同时声明，否则报错。</p></li><li><p>方法的参数部分有可变形参，需要放在形参声明的最后</p></li><li><p>在一个方法的形参中，最多只能声明一个可变个数的形参</p></li></ol><p><strong>案例分析：</strong></p><p>案例1：n个字符串进行拼接，每一个字符串之间使用某字符进行分割，如果没有传入字符串，那么返回空字符串””</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTools</span> &#123;</span><br><span class="line">    String <span class="title function_">concat</span><span class="params">(<span class="type">char</span> seperator, String... args)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                str += args[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                str += seperator + args[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.test05.param;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringToolsTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringTools</span> <span class="variable">tools</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTools</span>();</span><br><span class="line"></span><br><span class="line">        System.out.println(tools.concat(<span class="string">&#x27;-&#x27;</span>));</span><br><span class="line">        System.out.println(tools.concat(<span class="string">&#x27;-&#x27;</span>,<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">        System.out.println(tools.concat(<span class="string">&#x27;-&#x27;</span>,<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>));</span><br><span class="line">        System.out.println(tools.concat(<span class="string">&#x27;-&#x27;</span>,<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>,<span class="string">&quot;java&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例2：求n个整数的和</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberTools</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">total</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>... nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestVarParam</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NumberTools</span> <span class="variable">tools</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumberTools</span>();</span><br><span class="line"></span><br><span class="line">        System.out.println(tools.sum());<span class="comment">//0个实参</span></span><br><span class="line">        System.out.println(tools.sum(<span class="number">5</span>));<span class="comment">//1个实参</span></span><br><span class="line">        System.out.println(tools.sum(<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>));<span class="comment">//4个实参</span></span><br><span class="line">        System.out.println(tools.sum(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>&#125;));<span class="comment">//传入数组实参</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">        System.out.println(tools.total(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;));<span class="comment">//0个元素的数组</span></span><br><span class="line">        System.out.println(tools.total(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">5</span>&#125;));<span class="comment">//1个元素的数组</span></span><br><span class="line">        System.out.println(tools.total(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>&#125;));<span class="comment">//传入数组实参</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例3：如下的方法彼此构成重载</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathTools</span> &#123;</span><br><span class="line">    <span class="comment">//求两个整数的最大值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求两个小数的最大值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">max</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求三个整数的最大值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> max(max(a,b),c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//求n个整数的最大值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span>... nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];<span class="comment">//如果没有传入整数，或者传入null，这句代码会报异常</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; max)&#123;</span><br><span class="line">                max = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*    //求n整数的最大值</span></span><br><span class="line"><span class="comment">    public int max(int[] nums)&#123;  //编译就报错，与(int... nums)无法区分</span></span><br><span class="line"><span class="comment">        int max = nums[0];//如果没有传入整数，或者传入null，这句代码会报异常</span></span><br><span class="line"><span class="comment">        for (int i = 1; i &lt; nums.length; i++) &#123;</span></span><br><span class="line"><span class="comment">            if(nums[i] &gt; max)&#123;</span></span><br><span class="line"><span class="comment">                max = nums[i];</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return max;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*    //求n整数的最大值</span></span><br><span class="line"><span class="comment">    public int max(int first, int... nums)&#123;  //当前类不报错，但是调用时会引起多个方法同时匹配</span></span><br><span class="line"><span class="comment">        int max = first;</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; nums.length; i++) &#123;</span></span><br><span class="line"><span class="comment">            if(nums[i] &gt; max)&#123;</span></span><br><span class="line"><span class="comment">                max = nums[i];</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return max;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-方法的参数传递机制"><a href="#7-3-方法的参数传递机制" class="headerlink" title="7.3 方法的参数传递机制"></a>7.3 方法的参数传递机制</h3><h4 id="7-3-1-形参和实参"><a href="#7-3-1-形参和实参" class="headerlink" title="7.3.1 形参和实参"></a>7.3.1 形参和实参</h4><ul><li>形参（formal parameter）：在定义方法时，方法名后面括号()中声明的变量称为形式参数，简称形参。</li><li>实参（actual parameter）：在调用方法时，方法名后面括号()中的使用的值/变量/表达式称为实际参数，简称实参。</li></ul><h4 id="7-3-2-参数传递机制：值传递"><a href="#7-3-2-参数传递机制：值传递" class="headerlink" title="7.3.2 参数传递机制：值传递"></a>7.3.2 参数传递机制：值传递</h4><p>Java里方法的参数传递方式只有一种：<code>值传递</code>。 即将实际参数值的副本（复制品）传入方法内，而参数本身不受影响。</p><ul><li><p>形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参</p></li><li><p>形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参</p></li></ul><h4 id="7-3-3-举例"><a href="#7-3-3-举例" class="headerlink" title="7.3.3 举例"></a>7.3.3 举例</h4><p><strong>1、形参是基本数据类型</strong></p><p>案例：编写方法，交换两个整型变量的值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;m = &quot;</span> + m + <span class="string">&quot;, n = &quot;</span> + n);</span><br><span class="line"><span class="comment">//交换m和n的值</span></span><br><span class="line"><span class="comment">//int temp = m;</span></span><br><span class="line"><span class="comment">//m = n;</span></span><br><span class="line"><span class="comment">//n = temp;</span></span><br><span class="line"></span><br><span class="line"><span class="type">ValueTransferTest1</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ValueTransferTest1</span>();</span><br><span class="line">test.swap(m, n);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;m = &quot;</span> + m + <span class="string">&quot;, n = &quot;</span> + n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> m;</span><br><span class="line">m = n;</span><br><span class="line">n = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存解析：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20221120153322455.png" alt="image-20221120153322455"></p><p><strong>2、形参是引用数据类型</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">Data</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>();</span><br><span class="line">d1.m = <span class="number">10</span>;</span><br><span class="line">d1.n = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;m = &quot;</span> + d1.m + <span class="string">&quot;, n = &quot;</span> + d1.n);</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现 换序</span></span><br><span class="line"></span><br><span class="line"><span class="type">ValueTransferTest2</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ValueTransferTest2</span>();</span><br><span class="line">test.swap(d1);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;m = &quot;</span> + d1.m + <span class="string">&quot;, n = &quot;</span> + d1.n);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Data data)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> data.m;</span><br><span class="line">data.m = data.n;</span><br><span class="line">data.n = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>&#123;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存解析：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20221120153442447.png" alt="image-20221120153442447"></p><h4 id="7-3-4-练习"><a href="#7-3-4-练习" class="headerlink" title="7.3.4 练习"></a>7.3.4 练习</h4><p>练习1：判断如下程序输出的结果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AssignNewObject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(MyData my)</span>&#123;</span><br><span class="line">        my = <span class="keyword">new</span> <span class="title class_">MyData</span>(); <span class="comment">//考虑堆空间此新创建的对象，和main中的data对象是否有关</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> my.x;</span><br><span class="line">        my.x = my.y;</span><br><span class="line">        my.y = temp;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AssignNewObject</span> <span class="variable">tools</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AssignNewObject</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">MyData</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyData</span>();</span><br><span class="line">        data.x = <span class="number">1</span>;</span><br><span class="line">        data.y = <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;交换之前：x = &quot;</span> + data.x +<span class="string">&quot;,y = &quot;</span> + data.y);<span class="comment">//</span></span><br><span class="line">        tools.swap(data);<span class="comment">//调用完之后，x与y的值交换？</span></span><br><span class="line">        System.out.println(<span class="string">&quot;交换之后：x = &quot;</span> + data.x +<span class="string">&quot;,y = &quot;</span> + data.y);<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span>&#123;</span><br><span class="line">    <span class="type">int</span> x ;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习2：如下操作是否可以实现数组排序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTypeParam</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//冒泡排序，实现数组从小到大排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                    arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印数组的元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayTypeParam</span> <span class="variable">tools</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayTypeParam</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序之前：&quot;</span>);</span><br><span class="line">        tools.print(nums);</span><br><span class="line"></span><br><span class="line">        tools.sort(nums);<span class="comment">//对nums数组进行排序</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序之后：&quot;</span>);</span><br><span class="line">        tools.print(nums);<span class="comment">//输出nums数组的元素</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习3：通过内存结构图，写出如下程序的输出结果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//栈：每个方法在调用时，都会有以栈帧的方法压入栈中。栈帧中保存了当前方法中声明的变量：方法内声明的，形参</span></span><br><span class="line"><span class="comment">//堆：存放new出来的&quot;东西&quot;：对象（成员变量在对象中）、数组实体（数组元素）。 </span></span><br><span class="line"><span class="comment">//注意：变量前如果声明有类型，那么这就是一个新的刚要定义的变量。如果变量前没有声明类型，那就说明此变量在之前已经声明过。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransferTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">TransferTest3</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransferTest3</span>();</span><br><span class="line">        test.first();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">first</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">Value</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Value</span>();</span><br><span class="line">        v.i = <span class="number">25</span>;</span><br><span class="line">        second(v, i);</span><br><span class="line">        System.out.println(v.i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">second</span><span class="params">(Value v, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        v.i = <span class="number">20</span>;</span><br><span class="line">        <span class="type">Value</span> <span class="variable">val</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Value</span>();</span><br><span class="line">        v = val;</span><br><span class="line">        System.out.println(v.i + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Value</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>内存解析：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/20220320_233145.jpg" alt="20220320_233145" style="zoom:80%;"></p><p>练习4：<code>貌似是</code>考查方法的参数传递</p><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220320233402122.png" alt="image-20220320233402122"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//法一：</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">       <span class="comment">// 在不改变原本题目的前提下，如何写这个函数才能在main函数中输出a=100，b=200？ </span></span><br><span class="line">       a = a * <span class="number">10</span>;</span><br><span class="line">       b = b * <span class="number">20</span>;</span><br><span class="line">       System.out.println(a);</span><br><span class="line">       System.out.println(b);</span><br><span class="line">       System.exit(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//法二：</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(System.out) &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(String x)</span> &#123;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (<span class="string">&quot;a=10&quot;</span>.equals(x)) &#123;</span><br><span class="line">                   x = <span class="string">&quot;a=100&quot;</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;b=10&quot;</span>.equals(x)) &#123;</span><br><span class="line">                   x = <span class="string">&quot;b=200&quot;</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="built_in">super</span>.println(x);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       System.setOut(ps);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>练习5：将对象作为参数传递给方法</p><p>（1）定义一个Circle类，包含一个double型的radius属性代表圆的半径，一个findArea()方法返回圆的面积。<br>（2）定义一个类PassObject，在类中定义一个方法printAreas()，该方法的定义如下：public void printAreas(Circle c, int time)，在printAreas方法中打印输出1到time之间的每个整数半径值，以及对应的面积。例如，times为5，则输出半径1，2，3，4，5，以及对应的圆面积。<br>（3）在main方法中调用printAreas()方法，调用完毕后输出当前半径值。程序运行结果如图所示。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220320233626003.png" alt="image-20220320233626003"></p><h3 id="7-4-递归-recursion-方法"><a href="#7-4-递归-recursion-方法" class="headerlink" title="7.4 递归(recursion)方法"></a>7.4 递归(recursion)方法</h3><p>举例1：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220521160246138.png" alt="image-20220521160246138" style="zoom: 67%;"></p><p>举例2：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">从前有座山,山上有座庙,庙里有个老和尚,老和尚在给小和尚讲故事,讲的啥?</span><br><span class="line">      从前有座山,山上有座庙,庙里有个老和尚,老和尚在给小和尚讲故事,讲的啥?</span><br><span class="line">          从前有座山,山上有座庙,庙里有个老和尚,老和尚在给小和尚讲故事,讲的啥?</span><br><span class="line">              从前有座山,山上有座庙,庙里有个老和尚,老和尚在给小和尚讲故事,讲的啥?...</span><br><span class="line">    ...</span><br><span class="line">老和尚没了,庙塌了,小和尚还俗结婚了。</span><br></pre></td></tr></table></figure><p><strong>递归方法调用</strong>：方法自己调用自己的现象就称为递归。</p><p><strong>递归的分类:</strong>直接递归、间接递归。</p><ul><li><p>直接递归：方法自身调用自己。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>&#123;</span><br><span class="line">methodA();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>间接递归：可以理解为A()方法调用B()方法，B()方法调用C()方法，C()方法调用A()方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">B();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">B</span><span class="params">()</span>&#123;</span><br><span class="line">C();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">C</span><span class="params">()</span>&#123;</span><br><span class="line">A();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>说明</strong>：</p><ul><li>递归方法包含了一种<code>隐式的循环</code>。</li><li>递归方法会<code>重复执行</code>某段代码，但这种重复执行无须循环控制。</li><li>递归一定要向<code>已知方向</code>递归，否则这种递归就变成了无穷递归，停不下来，类似于<code>死循环</code>。最终发生<code>栈内存溢出</code>。</li></ul><p><strong>举例：</strong></p><p>举例1：计算1 ~ n的和</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RecursionDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RecursionDemo</span>();</span><br><span class="line"><span class="comment">//计算1~num的和，使用递归完成</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">      <span class="comment">// 调用求和的方法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> demo.getSum(num);</span><br><span class="line">      <span class="comment">// 输出结果</span></span><br><span class="line">System.out.println(sum);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    通过递归算法实现.</span></span><br><span class="line"><span class="comment">    参数列表:int </span></span><br><span class="line"><span class="comment">    返回值类型: int </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">      <span class="comment">/* </span></span><br><span class="line"><span class="comment">         num为1时,方法返回1,</span></span><br><span class="line"><span class="comment">         相当于是方法的出口,num总有是1的情况</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"><span class="keyword">if</span>(num == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">          num不为1时,方法返回 num +(num-1)的累和</span></span><br><span class="line"><span class="comment">          递归调用getSum方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"><span class="keyword">return</span> num + getSum(num-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码执行图解：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/递归.png" alt></p><p>举例2：递归方法计算n!</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">multiply</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(num == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num * multiply(num - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220520150018655.png" alt="image-20220520150018655"></p><p>举例3：已知有一个数列：f(0) = 1，f(1) = 4，f(n+2)=2*f(n+1) + f(n)，其中n是大于0的整数，求f(10)的值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> * f(num - <span class="number">1</span>) + f(num - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例4：已知一个数列：f(20) = 1,f(21) = 4,f(n+2) = 2*f(n+1)+f(n)，其中n是大于0的整数，求f(10)的值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(num == <span class="number">20</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">21</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> func(num + <span class="number">2</span>) - <span class="number">2</span> * func(num + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例5：计算斐波那契数列（Fibonacci）的第n个值，斐波那契数列满足如下规律，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">34</span>,<span class="number">55</span>,....</span><br></pre></td></tr></table></figure><p>即从第三个数开始，一个数等于前两个数之和。假设f(n)代表斐波那契数列的第n个值，那么f(n)满足：<br>f(n) = f(n-2) + f(n-1); </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用递归的写法</span></span><br><span class="line">   <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> &#123;<span class="comment">//计算斐波那契数列第n个值是多少</span></span><br><span class="line">       <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;<span class="comment">//负数是返回特殊值1，表示不计算负数情况</span></span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> f(n - <span class="number">2</span>) + f(n - <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//不用递归</span></span><br><span class="line">   <span class="type">int</span> <span class="title function_">fValue</span><span class="params">(<span class="type">int</span> n)</span> &#123;<span class="comment">//计算斐波那契数列第n个值是多少</span></span><br><span class="line">       <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;<span class="comment">//负数是返回特殊值1，表示不计算负数情况</span></span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//从第三个数开始，  等于 前两个整数相加</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">beforeBefore</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">//相当于n=1时的值</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">before</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//相当于n=2时的值</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> beforeBefore + before; <span class="comment">//相当于n=3的值</span></span><br><span class="line">       <span class="comment">//再完后</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>; i &lt;= n; i++) &#123;</span><br><span class="line">           beforeBefore = before;</span><br><span class="line">           before = current;</span><br><span class="line">           current = beforeBefore + before;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">           假设i=4</span></span><br><span class="line"><span class="comment">               beforeBefore = before; //相当于n=2时的值</span></span><br><span class="line"><span class="comment">               before = current; //相当于n=3的值</span></span><br><span class="line"><span class="comment">               current = beforeBefore + before; //相当于n = 4的值</span></span><br><span class="line"><span class="comment">           假设i=5</span></span><br><span class="line"><span class="comment">               beforeBefore = before; //相当于n=3的值</span></span><br><span class="line"><span class="comment">               before = current; //相当于n = 4的值</span></span><br><span class="line"><span class="comment">               current = beforeBefore + before; //相当于n = 5的值</span></span><br><span class="line"><span class="comment">               ....</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> current;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>举例6：面试题</p><blockquote><p>宋老师，我今天去百度面试，遇到一个一个双重递归调用的问题，我琢磨了一下，完全不知道为什么。打断点了，也还是没看懂为什么程序会那样走。您有空可以看一下，求指教。</p></blockquote><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220320235105406.png" alt="image-20220320235105406"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">recursion</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">       count++;</span><br><span class="line">       System.out.println(<span class="string">&quot;count1:&quot;</span> + count + <span class="string">&quot;  k:&quot;</span> + k);</span><br><span class="line">       <span class="keyword">if</span> (k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> recursion(k - <span class="number">1</span>) + recursion(k - <span class="number">2</span>);<span class="comment">//287</span></span><br><span class="line">       <span class="comment">//return recursion(k - 1);//11</span></span><br><span class="line">       <span class="comment">//return recursion(k - 1) + recursion(k - 1);//2047</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>剖析：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220320235229941.png" alt="image-20220320235229941" style="zoom:67%;"></p><blockquote><p>最后说两句：</p><ol><li><p>递归调用会占用大量的系统堆栈，内存耗用多，在递归调用层次多时速度要比循环<code>慢的多</code>，所以在使用递归时要慎重。</p></li><li><p>在要求高性能的情况下尽量避免使用递归，递归调用既花时间又<code>耗内存</code>。考虑使用循环迭代</p></li></ol></blockquote><h2 id="8-关键字：package、import"><a href="#8-关键字：package、import" class="headerlink" title="8. 关键字：package、import"></a>8. 关键字：package、import</h2><h3 id="8-1-package-包"><a href="#8-1-package-包" class="headerlink" title="8.1 package(包)"></a>8.1 package(包)</h3><p>package，称为包，用于指明该文件中定义的类、接口等结构所在的包。</p><h4 id="8-1-1-语法格式"><a href="#8-1-1-语法格式" class="headerlink" title="8.1.1 语法格式"></a>8.1.1 语法格式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 顶层包名.子包名 ;</span><br></pre></td></tr></table></figure><p>举例：pack1\pack2\PackageTest.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pack1.pack2;    <span class="comment">//指定类PackageTest属于包pack1.pack2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PackageTest</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;in  method display()&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>一个源文件只能有一个声明包的package语句</li><li>package语句作为Java源文件的第一条语句出现。若缺省该语句，则指定为无名包。</li><li>包名，属于标识符，满足标识符命名的规则和规范（全部小写）、见名知意<ul><li>包通常使用所在公司域名的倒置：com.atguigu.xxx。</li><li>大家取包名时不要使用”<code>java.xx</code>“包</li></ul></li><li>包对应于文件系统的目录，package语句中用 “.” 来指明包(目录)的层次，每.一次就表示一层文件目录。</li><li>同一个包下可以声明多个结构（类、接口），但是不能定义同名的结构（类、接口）。不同的包下可以定义同名的结构（类、接口）</li></ul><h4 id="8-1-2-包的作用"><a href="#8-1-2-包的作用" class="headerlink" title="8.1.2 包的作用"></a>8.1.2 包的作用</h4><ul><li>包可以包含类和子包，划分<code>项目层次</code>，便于管理</li><li>帮助<code>管理大型软件</code>系统：将功能相近的类划分到同一个包中。比如：MVC的设计模式</li><li>解决<code>类命名冲突</code>的问题</li><li>控制<code>访问权限</code></li></ul><h4 id="8-1-3-应用举例"><a href="#8-1-3-应用举例" class="headerlink" title="8.1.3 应用举例"></a>8.1.3 应用举例</h4><p>举例1：某航运软件系统包括：一组域对象、GUI和reports子系统</p><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220321233025157.png" alt="image-20220321233025157"></p><p><strong>举例2：MVC设计模式</strong></p><p>MVC是一种软件构件模式，目的是为了降低程序开发中代码业务的耦合度。</p><p>MVC设计模式将整个程序分为三个层次：<code>视图模型(Viewer)层</code>，<code>控制器(Controller)层</code>，与<code>数据模型(Model)层</code>。这种将程序输入输出、数据处理，以及数据的展示分离开来的设计模式使程序结构变的灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程序的耦合性。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">视图层viewer：显示数据,为用户提供使用界面，与用户直接进行交互。</span><br><span class="line"> &gt;相关工具类   view.utils</span><br><span class="line"> &gt;自定义view  view.ui</span><br><span class="line"></span><br><span class="line">控制层controller：解析用户请求，处理业务逻辑，给予用户响应</span><br><span class="line"> &gt;应用界面相关    controller.activity</span><br><span class="line"> &gt;存放fragment   controller.fragment</span><br><span class="line"> &gt;显示列表的适配器 controller.adapter</span><br><span class="line"> &gt;服务相关的        controller.service</span><br><span class="line"> &gt;抽取的基类        controller.base</span><br><span class="line">    </span><br><span class="line">模型层model：主要承载数据、处理数据</span><br><span class="line"> &gt;数据对象封装 model.bean/domain</span><br><span class="line"> &gt;数据库操作类 model.dao</span><br><span class="line"> &gt;数据库      model.db</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220321233153448.png" alt="image-20220321233153448"></p><h4 id="8-1-4-JDK中主要的包介绍"><a href="#8-1-4-JDK中主要的包介绍" class="headerlink" title="8.1.4 JDK中主要的包介绍"></a>8.1.4 JDK中主要的包介绍</h4><p><code>java.lang</code>——包含一些Java语言的核心类，如String、Math、Integer、 System和Thread，提供常用功能<br><code>java.net</code>——包含执行与网络相关的操作的类和接口。<br><code>java.io</code>   ——包含能提供多种输入/输出功能的类。<br><code>java.util</code>——包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。<br><code>java.text</code>——包含了一些java格式化相关的类<br><code>java.sql</code>——包含了java进行JDBC数据库编程的相关类/接口<br><code>java.awt</code>——包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。  </p><h3 id="8-2-import-导入"><a href="#8-2-import-导入" class="headerlink" title="8.2 import(导入)"></a>8.2 import(导入)</h3><p>为了使用定义在其它包中的Java类，需用import语句来显式引入指定包下所需要的类。相当于<code>import语句告诉编译器到哪里去寻找这个类</code>。</p><h4 id="8-2-1-语法格式"><a href="#8-2-1-语法格式" class="headerlink" title="8.2.1 语法格式"></a>8.2.1 语法格式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import 包名.类名;</span><br></pre></td></tr></table></figure><h4 id="8-2-2-应用举例"><a href="#8-2-2-应用举例" class="headerlink" title="8.2.2 应用举例"></a>8.2.2 应用举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pack1.pack2.Test;   <span class="comment">//import pack1.pack2.*;表示引入pack1.pack2包中的所有结构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PackTest</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line"><span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();          <span class="comment">//Test类在pack1.pack2包中定义</span></span><br><span class="line">t.display();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2-3-注意事项"><a href="#8-2-3-注意事项" class="headerlink" title="8.2.3 注意事项"></a>8.2.3 注意事项</h4><ul><li><p>import语句，声明在包的声明和类的声明之间。</p></li><li><p>如果需要导入多个类或接口，那么就并列显式多个import语句即可</p></li><li><p>如果使用<code>a.*</code>导入结构，表示可以导入a包下的所有的结构。举例：可以使用java.util.*的方式，一次性导入util包下所有的类或接口。</p></li><li><p>如果导入的类或接口是java.lang包下的，或者是当前包下的，则可以省略此import语句。</p></li><li><p>如果已经导入java.a包下的类，那么如果需要使用a包的子包下的类的话，仍然需要导入。</p></li><li><p>如果在代码中使用不同包下的同名的类，那么就需要使用类的全类名的方式指明调用的是哪个类。</p></li><li><p>（了解）<code>import static</code>组合的使用：调用指定类或接口下的静态的属性或方法</p></li></ul><h2 id="9-面向对象特征一：封装性-encapsulation"><a href="#9-面向对象特征一：封装性-encapsulation" class="headerlink" title="9. 面向对象特征一：封装性(encapsulation)"></a>9. 面向对象特征一：封装性(encapsulation)</h2><h3 id="9-1-为什么需要封装？"><a href="#9-1-为什么需要封装？" class="headerlink" title="9.1 为什么需要封装？"></a>9.1 为什么需要封装？</h3><ul><li>我要用洗衣机，只需要按一下开关和洗涤模式就可以了。有必要了解洗衣机内部的结构吗？有必要碰电动机吗？</li><li>我要开车，我不需要懂离合、油门、制动等原理和维修也可以驾驶。</li></ul><ul><li>客观世界里每一个事物的内部信息都隐藏在其内部，外界无法直接操作和修改，只能通过指定的方式进行访问和修改。</li></ul><p>随着我们系统越来越复杂，类会越来越多，那么类之间的访问边界必须把握好，面向对象的开发原则要遵循“<code>高内聚、低耦合</code>”。</p><blockquote><p>高内聚、低耦合是软件工程中的概念，也是UNIX 操作系统设计的经典原则。</p><p>内聚，指一个模块内各个元素彼此结合的紧密程度；耦合指一个软件结构内不同模块之间互连程度的度量。内聚意味着重用和独立，耦合意味着多米诺效应牵一发动全身。</p></blockquote><p>而“高内聚，低耦合”的体现之一：</p><ul><li><code>高内聚</code>：类的内部数据操作细节自己完成，不允许外部干涉；</li><li><code>低耦合</code>：仅暴露少量的方法给外部使用，尽量方便外部调用。</li></ul><h3 id="9-2-何为封装性？"><a href="#9-2-何为封装性？" class="headerlink" title="9.2 何为封装性？"></a>9.2 何为封装性？</h3><p>所谓封装，就是把客观事物封装成抽象概念的类，并且类可以把自己的数据和方法只向可信的类或者对象开放，向没必要开放的类或者对象隐藏信息。</p><p><strong>通俗的讲，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。</strong></p><h3 id="9-3-Java如何实现数据封装"><a href="#9-3-Java如何实现数据封装" class="headerlink" title="9.3 Java如何实现数据封装"></a>9.3 Java如何实现数据封装</h3><ul><li>实现封装就是控制类或成员的可见性范围。这就需要依赖访问控制修饰符，也称为权限修饰符来控制。</li></ul><ul><li>权限修饰符：<code>public</code>、<code>protected</code>、<code>缺省</code>、<code>private</code>。具体访问范围如下：</li></ul><div class="table-container"><table><thead><tr><th>修饰符</th><th>本类内部</th><th>本包内</th><th>其他包的子类</th><th>其他包非子类</th></tr></thead><tbody><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr><tr><td>缺省</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table></div><ul><li>具体修饰的结构：<ul><li>外部类：public、缺省</li><li>成员变量、成员方法、构造器、成员内部类：public、protected、缺省、private</li></ul></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220321222327616.png" alt="image-20220321222327616" style="zoom:67%;"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220617164042390.png" alt="image-20220617164042390" style="zoom:80%;"></p><h3 id="9-4-封装性的体现"><a href="#9-4-封装性的体现" class="headerlink" title="9.4 封装性的体现"></a>9.4 封装性的体现</h3><h4 id="9-4-1-成员变量-属性私有化"><a href="#9-4-1-成员变量-属性私有化" class="headerlink" title="9.4.1 成员变量/属性私有化"></a>9.4.1 成员变量/属性私有化</h4><p><strong>概述：私有化类的成员变量，提供公共的get和set方法，对外暴露获取和修改属性的功能。</strong></p><p>实现步骤：</p><p><strong>①</strong> 使用 <code>private</code> 修饰成员变量</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> 数据类型 变量名 ；</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> marry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>②</strong> 提供 <code>getXxx</code>方法 / <code>setXxx</code> 方法，可以访问成员变量，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> marry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String n)</span> &#123;</span><br><span class="line">name = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMarry</span><span class="params">(<span class="type">boolean</span> m)</span>&#123;</span><br><span class="line">        marry = m;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMarry</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> marry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>③</strong> 测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实例变量私有化，跨类是无法直接使用的</span></span><br><span class="line"><span class="comment">/* p.name = &quot;张三&quot;;</span></span><br><span class="line"><span class="comment">        p.age = 23;</span></span><br><span class="line"><span class="comment">        p.marry = true;*/</span></span><br><span class="line"></span><br><span class="line">        p.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;p.name = &quot;</span> + p.getName());</span><br><span class="line"></span><br><span class="line">        p.setAge(<span class="number">23</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;p.age = &quot;</span> + p.getAge());</span><br><span class="line"></span><br><span class="line">        p.setMarry(<span class="literal">true</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;p.marry = &quot;</span> + p.isMarry());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>成员变量封装的好处：</strong></p><ul><li>让使用者只能通过事先预定的方法来<code>访问数据</code>，从而可以在该方法里面加入控制逻辑，限制对成员变量的不合理访问。还可以进行数据检查，从而有利于保证对象信息的完整性。</li><li><code>便于修改</code>，提高代码的可维护性。主要说的是隐藏的部分，在内部修改了，如果其对外可以的访问方式不变的话，外部根本感觉不到它的修改。例如：Java8-&gt;Java9，String从char[]转为byte[]内部实现，而对外的方法不变，我们使用者根本感觉不到它内部的修改。</li></ul><p><strong>开心一笑：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A man and woman are in a computer programming lecture. The man touches the woman&#x27;s breasts.</span><br><span class="line"></span><br><span class="line">&quot;Hey!&quot; she says. &quot;Those are private!&quot;</span><br><span class="line"></span><br><span class="line">The man says, &quot;But we&#x27;re in the same class!&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="9-4-2-私有化方法"><a href="#9-4-2-私有化方法" class="headerlink" title="9.4.2 私有化方法"></a>9.4.2 私有化方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 自定义的操作数组的工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康 Email:shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayUtil</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 求int型数组的最大值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(maxValue &lt; arr[i])&#123;</span><br><span class="line">maxValue = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 求int型数组的最小值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">minValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(minValue &gt; arr[i])&#123;</span><br><span class="line">minValue = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> minValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 求int型数组的总和</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">sum += arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 求int型数组的元素的平均值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">avg</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">sumValue</span> <span class="operator">=</span> sum(arr);</span><br><span class="line"><span class="keyword">return</span> sumValue / arr.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一系列重载的上述方法</span></span><br><span class="line"><span class="comment">// public double max(double[] arr)&#123;&#125;</span></span><br><span class="line"><span class="comment">// public float max(float[] arr)&#123;&#125;</span></span><br><span class="line"><span class="comment">// public byte max(byte[] arr)&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 遍历数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">System.out.print(arr[i] + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 复制数组arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] copy(<span class="type">int</span>[] arr) &#123;</span><br><span class="line"><span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">arr1[i] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 反转数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j = arr.length - <span class="number">1</span>;i &lt; j;i++,j--)&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 数组的排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> desc 指明排序的方式。 ascend:升序    descend:降序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr,String desc)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;ascend&quot;</span>.equals(desc))&#123;<span class="comment">//if(desc.equals(&quot;ascend&quot;))&#123;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="comment">//int temp = arr[j];</span></span><br><span class="line"><span class="comment">//arr[j] = arr[j + 1];</span></span><br><span class="line"><span class="comment">//arr[j + 1] = temp;</span></span><br><span class="line">swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;descend&quot;</span>.equals(desc))&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &lt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="comment">//int temp = arr[j];</span></span><br><span class="line"><span class="comment">//arr[j] = arr[j + 1];</span></span><br><span class="line"><span class="comment">//arr[j + 1] = temp;</span></span><br><span class="line">swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;您输入的排序方式有误！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 查找指定的value值在arr数组中出现的位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回value值出现的位置 或 -1：未找到</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> value)</span> &#123;</span><br><span class="line"><span class="comment">//方法：线性查找</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(value == arr[i])&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>开发中，一般成员实例变量都习惯使用private修饰，再提供相应的public权限的get/set方法访问。</p><p>对于final的实例变量，不提供set()方法。（后面final关键字的时候讲）</p><p>对于static final的成员变量，习惯上使用public修饰。</p></blockquote><h3 id="9-5-练习"><a href="#9-5-练习" class="headerlink" title="9.5 练习"></a>9.5 练习</h3><p>练习1：</p><p>创建程序：在其中定义两个类：Person和PersonTest类。定义如下：</p><p>用setAge()设置人的合法年龄(0~130)，用getAge()返回人的年龄。在PersonTest类中实例化Person类的对象b，调用setAge()和getAge()方法，体会Java的封装性。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220321223633916.png" alt="image-20220321223633916" style="zoom:80%;"></p><p>练习2：</p><p>自定义图书类。设定属性包括：书名bookName，作者author，出版社名publisher，价格price；方法包括：相应属性的get/set方法，图书信息介绍等。</p><h2 id="10-类的成员之三：构造器-Constructor"><a href="#10-类的成员之三：构造器-Constructor" class="headerlink" title="10. 类的成员之三：构造器(Constructor)"></a>10. 类的成员之三：构造器(Constructor)</h2><p>我们new完对象时，所有成员变量都是默认值，如果我们需要赋别的值，需要挨个为它们再赋值，太麻烦了。我们能不能在new对象时，直接为当前对象的某个或所有成员变量直接赋值呢？</p><p>可以，Java给我们提供了<code>构造器（Constructor)</code>，也称为<code>构造方法</code>。</p><h3 id="10-1-构造器的作用"><a href="#10-1-构造器的作用" class="headerlink" title="10.1 构造器的作用"></a>10.1 构造器的作用</h3><p>new对象，并在new对象的时候为实例变量赋值。</p><p>举例：Person p = new <code>Person(“Peter”,15)</code>;</p><p>解释：如同我们规定每个“人”一出生就必须先洗澡，我们就可以在“人”的构造器中加入完成“洗澡”的程序代码，于是每个“人”一出生就会自动完成“洗澡”，程序就不必再在每个人刚出生时一个一个地告诉他们要“洗澡”了。</p><h3 id="10-2-构造器的语法格式"><a href="#10-2-构造器的语法格式" class="headerlink" title="10.2 构造器的语法格式"></a>10.2 构造器的语法格式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] class 类名&#123;</span><br><span class="line">    [修饰符] 构造器名()&#123;</span><br><span class="line">    <span class="comment">// 实例初始化代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    [修饰符] 构造器名(参数列表)&#123;</span><br><span class="line">        <span class="comment">// 实例初始化代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>构造器名必须与它所在的类名必须相同。</li><li>它没有返回值，所以不需要返回值类型，也不需要void。</li><li>构造器的修饰符只能是权限修饰符，不能被其他任何修饰。比如，不能被static、final、synchronized、abstract、native修饰，不能有return语句返回值。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String n,<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        name = n;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String n)</span> &#123;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;姓名：&quot;</span> + name +<span class="string">&quot;，年龄：&quot;</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStudent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//调用无参构造创建学生对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用有参构造创建学生对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(s1.getInfo());</span><br><span class="line">        System.out.println(s2.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-3-使用说明"><a href="#10-3-使用说明" class="headerlink" title="10.3 使用说明"></a>10.3 使用说明</h3><ol><li><p>当我们没有显式的声明类中的构造器时，系统会默认提供一个无参的构造器并且该构造器的修饰符默认与类的修饰符相同</p><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220524143937454.png" alt="image-20220524143937454"></p></li><li><p>当我们显式的定义类的构造器以后，系统就不再提供默认的无参的构造器了。</p></li><li><p>在类中，至少会存在一个构造器。</p></li><li><p>构造器是可以重载的。</p></li></ol><h3 id="10-4-练习"><a href="#10-4-练习" class="headerlink" title="10.4 练习"></a>10.4 练习</h3><p><strong>练习1：</strong>编写两个类，TriAngle和TriAngleTest，其中TriAngle类中声明私有的底边长base和高height，同时声明公共方法访问私有变量。此外，提供类必要的构造器。另一个类中使用这些公共方法，计算三角形的面积。</p><p><strong>练习2：</strong></p><p>(1)定义Student类,有4个属性：<br>  String name;<br>  int age;<br>  String school;<br>  String major;</p><p>(2)定义Student类的3个构造器:</p><ul><li>第一个构造器Student(String n, int a)设置类的name和age属性；</li><li>第二个构造器Student(String n, int a, String s)设置类的name, age 和school属性；</li><li>第三个构造器Student(String n, int a, String s, String m)设置类的name, age ,school和major属性；</li></ul><p>(3)在main方法中分别调用不同的构造器创建的对象，并输出其属性值。</p><p><strong>练习3：</strong></p><p>1、写一个名为Account的类模拟账户。该类的属性和方法如下图所示。</p><p>该类包括的属性：账号id，余额balance，年利率annualInterestRate；</p><p>包含的方法：访问器方法（getter和setter方法），取款方法withdraw()，存款方法deposit()。</p><p> <img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220321235241752.png" alt="image-20220321235241752"></p><p><strong>提示：</strong>在提款方法withdraw中，需要判断用户余额是否能够满足提款数额的要求，如果不能，应给出提示。</p><ol><li><p>创建Customer类。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220321235324156.png" alt="image-20220321235324156"></p></li></ol><p>a. 声明三个私有对象属性：firstName、lastName和account。<br>b. 声明一个公有构造器，这个构造器带有两个代表对象属性的参数（f和l）<br>c. 声明两个公有存取器来访问该对象属性，方法getFirstName和getLastName返回相应的属性。<br>d. 声明setAccount 方法来对account属性赋值。<br>e. 声明getAccount 方法以获取account属性。</p><p>3.写一个测试程序。</p><p>（1）创建一个Customer ，名字叫 Jane Smith, 他有一个账号为1000，余额为2000元，年利率为 1.23％ 的账户。<br>（2）对Jane Smith操作。<br>存入 100 元，再取出960元。再取出2000元。<br>打印出Jane Smith 的基本信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">成功存入 ：100.0</span><br><span class="line">成功取出：960.0</span><br><span class="line">余额不足，取款失败</span><br><span class="line">Customer [Smith, Jane] has a account: id is 1000, annualInterestRate is 1.23％, balance is 1140.0</span><br></pre></td></tr></table></figure><h2 id="11-阶段性知识补充"><a href="#11-阶段性知识补充" class="headerlink" title="11. 阶段性知识补充"></a>11. 阶段性知识补充</h2><h3 id="11-1-类中属性赋值过程"><a href="#11-1-类中属性赋值过程" class="headerlink" title="11.1 类中属性赋值过程"></a>11.1 类中属性赋值过程</h3><p><strong>1、在类的属性中，可以有哪些位置给属性赋值？</strong></p><p>① 默认初始化</p><p>② 显式初始化</p><p>③ 构造器中初始化</p><p>④ 通过”对象.属性”或”对象.方法”的方式，给属性赋值</p><p><strong>2、这些位置执行的先后顺序是怎样？</strong></p><p>顺序：① - ② - ③ - ④</p><p>3、说明：</p><ul><li><p>上述中的①、②、③在对象创建过程中，只执行一次。</p><ul><li>④ 是在对象创建后执行的，可以根据需求多次执行。</li></ul></li></ul><h3 id="11-2-JavaBean"><a href="#11-2-JavaBean" class="headerlink" title="11.2 JavaBean"></a>11.2 JavaBean</h3><ul><li><p>JavaBean是一种Java语言写成的可重用组件。</p><ul><li>好比你做了一个扳手，这个扳手会在很多地方被拿去用。这个扳手也提供多种功能(你可以拿这个扳手扳、锤、撬等等)，而这个扳手就是一个组件。</li></ul></li><li><p>所谓JavaBean，是指符合如下标准的Java类：</p><ul><li>类是公共的</li><li>有一个无参的公共的构造器</li><li>有属性，且有对应的get、set方法</li></ul></li><li><p>用户可以使用JavaBean将功能、处理、值、数据库访问和其他任何可以用Java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP页面、Servlet、其他JavaBean、applet程序或者应用来使用这些对象。用户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能，而不用关心任何改变。</p></li><li><p>《Think in Java》中提到，JavaBean最初是为Java GUI的可视化编程实现的。你拖动IDE构建工具创建一个GUI 组件（如多选框），其实是工具给你创建Java类，并提供将类的属性暴露出来给你修改调整，将事件监听器暴露出来。</p></li><li><p>示例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaBean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 属性一般定义为private</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JavaBean</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String n)</span> &#123;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="11-3-UML类图"><a href="#11-3-UML类图" class="headerlink" title="11.3 UML类图"></a>11.3 UML类图</h3><ul><li><p>UML（Unified Modeling Language，统一建模语言），用来描述<code>软件模型</code>和<code>架构</code>的图形化语言。</p></li><li><p>常用的UML工具软件有<code>PowerDesinger</code>、<code>Rose</code>和<code>Enterprise Architect</code>。</p></li><li><p>UML工具软件不仅可以绘制软件开发中所需的各种图表，还可以生成对应的源代码。</p></li><li><p>在软件开发中，使用<code>UML类图</code>可以更加直观地描述类内部结构（类的属性和操作）以及类之间的关系（如关联、依赖、聚合等）。</p><ul><li>+表示 public 类型， - 表示 private 类型，#表示protected类型</li><li>方法的写法:<br>方法的类型(+、-)  方法名(参数名： 参数类型)：返回值类型</li><li>斜体表示抽象方法或类。</li></ul></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220321232230831.png" alt="image-20220321232230831" style="zoom:80%;"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/image-20220503111301602.png" alt="image-20220503111301602"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第06章-面向对象编程（基础）&quot;&gt;&lt;a href=&quot;#第06章-面向对象编程（基础）&quot; class=&quot;headerlink&quot; title=&quot;第06章_面向对象编程（基础）&quot;&gt;&lt;/a&gt;第06章_面向对象编程（基础）&lt;/h1&gt;&lt;p&gt;讲师：尚硅谷-宋红康（江湖人称：康师</summary>
      
    
    
    
    <category term="Java2023" scheme="http://example.com/categories/Java2023/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第07章_面向对象编程(进阶)</title>
    <link href="http://example.com/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/"/>
    <id>http://example.com/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/</id>
    <published>2023-02-18T12:37:01.000Z</published>
    <updated>2023-02-19T07:38:43.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第07章-面向对象编程-进阶"><a href="#第07章-面向对象编程-进阶" class="headerlink" title="第07章_面向对象编程(进阶)"></a>第07章_面向对象编程(进阶)</h1><p>讲师：尚硅谷-宋红康（江湖人称：康师傅）</p><p>官网：<a href="http://www.atguigu.com/">http://www.atguigu.com</a></p><hr><h2 id="本章专题与脉络"><a href="#本章专题与脉络" class="headerlink" title="本章专题与脉络"></a>本章专题与脉络</h2><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/第2阶段：Java面向对象编程-第07章.png" alt="第2阶段：Java面向对象编程-第07章" style="zoom: 67%;"></p><h2 id="1-关键字：this"><a href="#1-关键字：this" class="headerlink" title="1. 关键字：this"></a>1. 关键字：this</h2><h3 id="1-1-this是什么？"><a href="#1-1-this是什么？" class="headerlink" title="1.1 this是什么？"></a>1.1 this是什么？</h3><ul><li><p>在Java中，this关键字不算难理解，它的作用和其词义很接近。</p><ul><li>它在方法（准确的说是实例方法或非static的方法）内部使用，表示调用该方法的对象</li><li>它在构造器内部使用，表示该构造器正在初始化的对象。</li></ul></li><li><p>this可以调用的结构：成员变量、方法和构造器</p></li></ul><h3 id="1-2-什么时候使用this"><a href="#1-2-什么时候使用this" class="headerlink" title="1.2 什么时候使用this"></a>1.2 什么时候使用this</h3><h4 id="1-2-1-实例方法或构造器中使用当前对象的成员"><a href="#1-2-1-实例方法或构造器中使用当前对象的成员" class="headerlink" title="1.2.1 实例方法或构造器中使用当前对象的成员"></a>1.2.1 实例方法或构造器中使用当前对象的成员</h4><p>在实例方法或构造器中，如果使用当前类的成员变量或成员方法可以在其前面添加this，增强程序的可读性。不过，通常我们都习惯省略this。</p><p>但是，当形参与成员变量同名时，如果在方法内或构造器内需要使用成员变量，必须添加this来表明该变量是类的成员变量。即：我们可以用this来区分<code>成员变量</code>和<code>局部变量</code>。比如：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20220503102947013.png" alt="image-20220503102947013" style="zoom:67%;"></p><p>另外，使用this访问属性和方法时，如果在本类中未找到，会从父类中查找。这个在继承中会讲到。</p><p>举例1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;<span class="comment">// 定义Person类</span></span><br><span class="line"><span class="keyword">private</span> String name ;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age ;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = name ;   </span><br><span class="line"><span class="built_in">this</span>.age = age ;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getInfo</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;姓名：&quot;</span> + name) ;</span><br><span class="line"><span class="built_in">this</span>.speak();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(“年龄：” + <span class="built_in">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>举例2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">area</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.length * <span class="built_in">this</span>.width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">perimeter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * (<span class="built_in">this</span>.length + <span class="built_in">this</span>.width);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">char</span> sign)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="built_in">this</span>.width; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="built_in">this</span>.length; j++) &#123;</span><br><span class="line">                System.out.print(sign);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;长：&quot;</span> + <span class="built_in">this</span>.length + <span class="string">&quot;，宽：&quot;</span> + <span class="built_in">this</span>.width +<span class="string">&quot;，面积：&quot;</span> + <span class="built_in">this</span>.area() +<span class="string">&quot;，周长：&quot;</span> + <span class="built_in">this</span>.perimeter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRectangle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Rectangle</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">        <span class="type">Rectangle</span> <span class="variable">r2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;r1对象：&quot;</span> + r1.getInfo());</span><br><span class="line">        System.out.println(<span class="string">&quot;r2对象：&quot;</span> + r2.getInfo());</span><br><span class="line"></span><br><span class="line">        r1.length = <span class="number">10</span>;</span><br><span class="line">        r1.width = <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;r1对象：&quot;</span> + r1.getInfo());</span><br><span class="line">        System.out.println(<span class="string">&quot;r2对象：&quot;</span> + r2.getInfo());</span><br><span class="line"></span><br><span class="line">        r1.print(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">        r1.print(<span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">        r2.print(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">        r2.print(<span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-2-同一个类中构造器互相调用"><a href="#1-2-2-同一个类中构造器互相调用" class="headerlink" title="1.2.2 同一个类中构造器互相调用"></a>1.2.2 同一个类中构造器互相调用</h4><p>this可以作为一个类中构造器相互调用的特殊格式。</p><ul><li>this()：调用本类的无参构造器</li><li>this(实参列表)：调用本类的有参构造器</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//        this(&quot;&quot;,18);//调用本类有参构造器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>();<span class="comment">//调用本类无参构造器</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>(name);<span class="comment">//调用本类中有一个String参数的构造器</span></span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;姓名：&quot;</span> + name +<span class="string">&quot;，年龄：&quot;</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>不能出现递归调用。比如，调用自身构造器。<ul><li>推论：如果一个类中声明了n个构造器，则最多有 n - 1个构造器中使用了”this(形参列表)”</li></ul></li><li>this()和this(实参列表)只能声明在构造器首行。<ul><li>推论：在类的一个构造器中，最多只能声明一个”this(参数列表)”</li></ul></li></ul><h3 id="1-3-练习"><a href="#1-3-练习" class="headerlink" title="1.3 练习"></a>1.3 练习</h3><p><strong>练习1：</strong>添加必要的构造器，综合应用构造器的重载，this关键字。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20220808191154534.png" alt="image-20220808191154534"></p><p><strong>练习2：</strong></p><p>（1）按照如下的UML类图，创建相应的类，提供必要的结构：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20220323211412409.png" alt="image-20220323211412409" style="zoom:50%;"></p><p>在提款方法withdraw()中，需要判断用户余额是否能够满足提款数额的要求，如果不能，应给出提示。deposit()方法表示存款。</p><p>（2）按照如下的UML类图，创建相应的类，提供必要的结构</p><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20220323211454372.png" alt="image-20220323211454372" style="zoom:50%;"></p><p>（3）按照如下的UML类图，创建相应的类，提供必要的结构</p><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20220323211521808.png" alt="image-20220323211521808" style="zoom:50%;"></p><ul><li><p>addCustomer 方法必须依照参数（姓，名）构造一个新的 Customer对象，然后把它放到 customer 数组中。还必须把 numberOfCustomer 属性的值加 1。</p></li><li><p>getNumOfCustomers 方法返回 numberofCustomers 属性值。</p></li><li><p>getCustomer方法返回与给出的index参数相关的客户。</p></li></ul><p>（4）创建BankTest类，进行测试。</p><p>内存解析图：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20220323211653907.png" alt="image-20220323211653907" style="zoom:80%;"></p><h2 id="2-面向对象特征二：继承-Inheritance"><a href="#2-面向对象特征二：继承-Inheritance" class="headerlink" title="2. 面向对象特征二：继承(Inheritance)"></a>2. 面向对象特征二：继承(Inheritance)</h2><h3 id="2-1-继承的概述"><a href="#2-1-继承的概述" class="headerlink" title="2.1 继承的概述"></a>2.1 继承的概述</h3><h4 id="2-1-1-生活中的继承"><a href="#2-1-1-生活中的继承" class="headerlink" title="2.1.1 生活中的继承"></a>2.1.1 生活中的继承</h4><ul><li>财产继承：</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20220323215921441.png" alt="image-20220323215921441" style="zoom: 50%;"></p><ul><li>绿化：前人栽树，后人乘凉</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20220520171727778.png" alt="image-20220520171727778" style="zoom: 50%;"></p><p>“绿水青山，就是金山银山”</p><ul><li><p>样貌：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20220323220246746.png" alt="image-20220323220246746" style="zoom: 50%;"></p></li><li><p>继承之外，是不是还可以”<code>进化</code>“：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20220323220537644.png" alt="image-20220323220537644" style="zoom: 50%;"></p></li></ul><blockquote><p>继承有延续（下一代延续上一代的基因、财富）、扩展（下一代和上一代又有所不同）的意思。</p></blockquote><h4 id="2-1-2-Java中的继承"><a href="#2-1-2-Java中的继承" class="headerlink" title="2.1.2 Java中的继承"></a>2.1.2 Java中的继承</h4><p><strong>角度一：从上而下</strong></p><p>为描述和处理<strong>个人</strong>信息，定义类Person：</p><p> <img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20220323220923386.png" alt="image-20220323220923386" style="zoom:67%;"></p><p>为描述和处理<strong>学生</strong>信息，定义类Student：</p><p> <img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20220323221001495.png" alt="image-20220323221001495" style="zoom:67%;"></p><p>通过继承，简化Student类的定义：</p><p> <img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20220323221050791.png" alt="image-20220323221050791" style="zoom:67%;"></p><blockquote><p>说明：Student类继承了父类Person的所有属性和方法，并增加了一个属性school。Person中的属性和方法，Student都可以使用。</p></blockquote><p><strong>角度二：从下而上</strong></p><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/猫狗继承1.jpg" alt></p><p>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类中无需再定义这些属性和行为，只需要和抽取出来的类构成<code>继承关系</code>。如图所示：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/猫狗继承2.jpg" style="zoom: 67%;"></p><p>再举例：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20220323221436571.png" alt="image-20220323221436571" style="zoom:67%;"></p><h4 id="2-1-3-继承的好处"><a href="#2-1-3-继承的好处" class="headerlink" title="2.1.3 继承的好处"></a>2.1.3 继承的好处</h4><ul><li><p>继承的出现减少了代码冗余，提高了代码的复用性。</p></li><li><p>继承的出现，更有利于功能的扩展。</p></li><li><p>继承的出现让类与类之间产生了<code>is-a</code>的关系，为多态的使用提供了前提。</p><ul><li>继承描述事物之间的所属关系，这种关系是：<code>is-a</code> 的关系。可见，父类更通用、更一般，子类更具体。</li></ul></li></ul><blockquote><p>注意：不要仅为了获取其他类中某个功能而去继承！</p></blockquote><h3 id="2-2-继承的语法"><a href="#2-2-继承的语法" class="headerlink" title="2.2 继承的语法"></a>2.2 继承的语法</h3><h4 id="2-2-1-继承中的语法格式"><a href="#2-2-1-继承中的语法格式" class="headerlink" title="2.2.1 继承中的语法格式"></a>2.2.1 继承中的语法格式</h4><p>通过 <code>extends</code> 关键字，可以声明一个类B继承另外一个类A，定义格式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] class 类A &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[修饰符] class 类B extends 类A &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-2-2-继承中的基本概念"><a href="#2-2-2-继承中的基本概念" class="headerlink" title="2.2.2 继承中的基本概念"></a>2.2.2 继承中的基本概念</h4><p>类B，称为子类、派生类(derived class)、SubClass</p><p>类A，称为父类、超类、基类(base class)、SuperClass</p><h3 id="2-3-代码举例"><a href="#2-3-代码举例" class="headerlink" title="2.3 代码举例"></a>2.3 代码举例</h3><p><strong>1、父类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.inherited.grammar;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义动物类Animal，做为父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 定义name属性</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">// 定义age属性</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义动物的吃东西方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(age + <span class="string">&quot;岁的&quot;</span></span><br><span class="line">                + name + <span class="string">&quot;在吃东西&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2、子类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.inherited.grammar;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义猫类Cat 继承 动物类Animal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">int</span> count;<span class="comment">//记录每只猫抓的老鼠数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个猫抓老鼠的方法catchMouse</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catchMouse</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(<span class="string">&quot;抓老鼠，已经抓了&quot;</span></span><br><span class="line">                + count + <span class="string">&quot;只老鼠&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、测试类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.inherited.grammar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个猫类对象</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="comment">// 为该猫类对象的name属性进行赋值</span></span><br><span class="line">        cat.name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">        <span class="comment">// 为该猫类对象的age属性进行赋值</span></span><br><span class="line">        cat.age = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 调用该猫继承来的eat()方法</span></span><br><span class="line">        cat.eat();</span><br><span class="line">        <span class="comment">// 调用该猫的catchMouse()方法</span></span><br><span class="line">        cat.catchMouse();</span><br><span class="line">        cat.catchMouse();</span><br><span class="line">        cat.catchMouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-继承性的细节说明"><a href="#2-4-继承性的细节说明" class="headerlink" title="2.4 继承性的细节说明"></a>2.4 继承性的细节说明</h3><p><strong>1、子类会继承父类所有的实例变量和实例方法</strong></p><p>从类的定义来看，类是一类具有相同特性的事物的抽象描述。父类是所有子类共同特征的抽象描述。而实例变量和实例方法就是事物的特征，那么父类中声明的实例变量和实例方法代表子类事物也有这个特征。</p><ul><li>当子类对象被创建时，在堆中给对象申请内存时，就要看子类和父类都声明了什么实例变量，这些实例变量都要分配内存。</li><li>当子类对象调用方法时，编译器会先在子类模板中看该类是否有这个方法，如果没找到，会看它的父类甚至父类的父类是否声明了这个方法，遵循<code>从下往上</code>找的顺序，找到了就停止，一直到根父类都没有找到，就会报编译错误。</li></ul><p>所以继承意味着子类的对象除了看子类的类模板还要看父类的类模板。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20211230090255997.png" alt="image-20211230090255997"></p><p><strong>2、子类不能直接访问父类中私有的(private)的成员变量和方法</strong></p><p>子类虽会继承父类私有(private)的成员变量，但子类不能对继承的私有成员变量直接进行访问，可通过继承的get/set方法进行访问。如图所示：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20220323224757212.png" alt="image-20220323224757212"></p><p><strong>3、在Java 中，继承的关键字用的是“extends”，即子类不是父类的子集，而是对父类的“扩展”</strong></p><p>子类在继承父类以后，还可以定义自己特有的方法，这就可以看做是对父类功能上的扩展。</p><p><strong>4、Java支持多层继承(继承体系)</strong></p><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20220323225441417.png" alt="image-20220323225441417" style="zoom:67%;"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：</p><ul><li><p>子类和父类是一种相对的概念</p></li><li><p>顶层父类是Object类。所有的类默认继承Object，作为父类。</p></li></ul></blockquote><p><strong>5、一个父类可以同时拥有多个子类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>6、Java只支持单继承，不支持多重继承</strong></p><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20220514162507692.png" alt="image-20220514162507692" style="zoom:67%;"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20220523201405061.png" alt="image-20220523201405061" style="zoom:67%;"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个类只能有一个父类，不可以有多个直接父类。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;&#125; <span class="comment">//ok</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span>,B...<span class="comment">//error</span></span><br></pre></td></tr></table></figure><h3 id="2-5-练习"><a href="#2-5-练习" class="headerlink" title="2.5 练习"></a>2.5 练习</h3><p><strong>练习1：</strong>定义一个学生类Student，它继承自Person类</p><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20220323231804928.png" alt="image-20220323231804928" style="zoom:67%;"></p><p><strong>练习2：</strong></p><p>(1)定义一个ManKind类，包括</p><ul><li>成员变量int sex和int salary；</li><li><p>方法void manOrWoman()：根据sex的值显示“man”(sex==1)或者“woman”(sex==0)；</p></li><li><p>方法void employeed()：根据salary的值显示“no job”(salary==0)或者“ job”(salary!=0)。</p></li></ul><p>(2)定义类Kids继承ManKind，并包括</p><ul><li>成员变量int yearsOld；</li><li>方法printAge()打印yearsOld的值。</li></ul><p>(3)定义类KidsTest，在类的main方法中实例化Kids的对象someKid，用该对象访问其父类的成员变量及方法。</p><p><strong>练习3：</strong>根据下图实现类。在CylinderTest类中创建Cylinder类的对象，设置圆柱的底面半径和高，并输出圆柱的体积。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20220323231942361.png" alt="image-20220323231942361" style="zoom:67%;"></p><h2 id="3-方法的重写（override-overwrite）"><a href="#3-方法的重写（override-overwrite）" class="headerlink" title="3. 方法的重写（override/overwrite）"></a>3. 方法的重写（override/overwrite）</h2><p>父类的所有方法子类都会继承，但是当某个方法被继承到子类之后，子类觉得父类原来的实现不适合于自己当前的类，该怎么办呢？子类可以对从父类中继承来的方法进行改造，我们称为方法的<code>重写 (override、overwrite)</code>。也称为方法的<code>重置</code>、<code>覆盖</code>。</p><p>在程序执行时，子类的方法将覆盖父类的方法。</p><h3 id="3-1-方法重写举例"><a href="#3-1-方法重写举例" class="headerlink" title="3.1 方法重写举例"></a>3.1 方法重写举例</h3><p>比如新的手机增加来电显示头像的功能，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.inherited.method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showNum</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;来电显示号码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.inherited.method;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SmartPhone：智能手机</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmartPhone</span> <span class="keyword">extends</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">    <span class="comment">//重写父类的来电显示功能的方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showNum</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//来电显示姓名和图片功能</span></span><br><span class="line">        System.out.println(<span class="string">&quot;显示来电姓名&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;显示头像&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写父类的通话功能的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;语音通话 或 视频通话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.inherited.method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestOverride</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建子类对象</span></span><br><span class="line">        <span class="type">SmartPhone</span> <span class="variable">sp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmartPhone</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用父类继承而来的方法</span></span><br><span class="line">        sp.call();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用子类重写的方法</span></span><br><span class="line">        sp.showNum();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@Override使用说明：</p><p>写在方法上面，用来检测是不是满足重写方法的要求。这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。建议保留，这样编译器可以帮助我们检查格式，另外也可以让阅读源代码的程序员清晰的知道这是一个重写的方法。</p></blockquote><h3 id="3-2-方法重写的要求"><a href="#3-2-方法重写的要求" class="headerlink" title="3.2 方法重写的要求"></a>3.2 方法重写的要求</h3><ol><li><p>子类重写的方法<code>必须</code>和父类被重写的方法具有相同的<code>方法名称</code>、<code>参数列表</code>。</p></li><li><p>子类重写的方法的返回值类型<code>不能大于</code>父类被重写的方法的返回值类型。（例如：Student &lt; Person）。</p></li></ol><blockquote><p>注意：如果返回值类型是基本数据类型和void，那么必须是相同</p></blockquote><ol><li>子类重写的方法使用的访问权限<code>不能小于</code>父类被重写的方法的访问权限。（public &gt; protected &gt; 缺省 &gt; private）</li></ol><blockquote><p>注意：① 父类私有方法不能重写   ② 跨包的父类缺省的方法也不能重写</p></blockquote><ol><li>子类方法抛出的异常不能大于父类被重写方法的异常</li></ol><p>此外，子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为static的（不是重写）。因为static方法是属于类的，子类无法覆盖父类的方法。</p><h3 id="3-3-小结：方法的重载与重写"><a href="#3-3-小结：方法的重载与重写" class="headerlink" title="3.3 小结：方法的重载与重写"></a>3.3 小结：方法的重载与重写</h3><p>方法的重载：方法名相同，形参列表不同。不看返回值类型。</p><p>方法的重写：见上面。</p><p>（1）同一个类中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.inherited.method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestOverload</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">max</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b,<span class="type">int</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> max(max(a,b),c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）父子类中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.inherited.method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestOverloadOverride</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        s.method(<span class="number">1</span>);<span class="comment">//只有一个形式的method方法</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Daughter</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Daughter</span>();</span><br><span class="line">        d.method(<span class="number">1</span>);</span><br><span class="line">        d.method(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//有两个形式的method方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father.method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> i)</span>&#123;<span class="comment">//重写</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Son.method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Daughter</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;<span class="comment">//重载</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Daughter.method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-练习"><a href="#3-4-练习" class="headerlink" title="3.4 练习"></a>3.4 练习</h3><p><strong>练习1：</strong>如果现在父类的一个方法定义成private访问权限，在子类中将此方法声明为default访问权限，那么这样还叫重写吗？ (NO)</p><p><strong>练习2：</strong>修改继承内容的练习2中定义的类Kids，在Kids中重新定义employeed()方法，覆盖父类ManKind中定义的employeed()方法，输出“Kids should study and no job.”</p><h2 id="4-再谈封装性中的4种权限修饰"><a href="#4-再谈封装性中的4种权限修饰" class="headerlink" title="4. 再谈封装性中的4种权限修饰"></a>4. 再谈封装性中的4种权限修饰</h2><p>权限修饰符：public,protected,缺省,private</p><div class="table-container"><table><thead><tr><th>修饰符</th><th>本类</th><th>本包</th><th>其他包子类</th><th>其他包非子类</th></tr></thead><tbody><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr><tr><td>缺省</td><td>√</td><td>√（本包子类非子类都可见）</td><td>×</td><td>×</td></tr><tr><td>protected</td><td>√</td><td>√（本包子类非子类都可见）</td><td>√（其他包仅限于子类中可见）</td><td>×</td></tr><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table></div><p>外部类：public和缺省</p><p>成员变量、成员方法等：public,protected,缺省,private</p><p><strong>1、外部类要跨包使用必须是public，否则仅限于本包使用</strong></p><p>（1）外部类的权限修饰符如果缺省，本包使用没问题</p><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20211230093627763.png" alt="image-20211230093627763"></p><p>（2）外部类的权限修饰符如果缺省，跨包使用有问题</p><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20211230094236974.png" alt="image-20211230094236974"></p><p><strong>2、成员的权限修饰符问题</strong></p><p>（1）本包下使用：成员的权限修饰符可以是public、protected、缺省</p><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20211230095320646.png" alt="image-20211230095320646"></p><p>（2）跨包下使用：要求严格</p><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20211230095817784.png" alt="image-20211230095817784"></p><p>（3）跨包使用时，如果类的权限修饰符缺省，成员权限修饰符&gt;类的权限修饰符也没有意义</p><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20211230100219840.png" alt="image-20211230100219840"></p><h2 id="5-关键字：super"><a href="#5-关键字：super" class="headerlink" title="5. 关键字：super"></a>5. 关键字：super</h2><h3 id="5-1-super的理解"><a href="#5-1-super的理解" class="headerlink" title="5.1 super的理解"></a>5.1 super的理解</h3><p>在Java类中使用super来调用父类中的指定操作：</p><ul><li>super可用于访问父类中定义的属性</li><li>super可用于调用父类中定义的成员方法</li><li>super可用于在子类构造器中调用父类的构造器</li></ul><p>注意：</p><ul><li>尤其当子父类出现同名成员时，可以用super表明调用的是父类中的成员</li><li>super的追溯不仅限于直接父类</li><li>super和this的用法相像，this代表本类对象的引用，super代表父类的内存空间的标识</li></ul><h3 id="5-2-super的使用场景"><a href="#5-2-super的使用场景" class="headerlink" title="5.2 super的使用场景"></a>5.2 super的使用场景</h3><h4 id="5-2-1-子类中调用父类被重写的方法"><a href="#5-2-1-子类中调用父类被重写的方法" class="headerlink" title="5.2.1 子类中调用父类被重写的方法"></a>5.2.1 子类中调用父类被重写的方法</h4><ul><li>如果子类没有重写父类的方法，只要权限修饰符允许，在子类中完全可以直接调用父类的方法；</li><li>如果子类重写了父类的方法，在子类中需要通过<code>super.</code>才能调用父类被重写的方法，否则默认调用的子类重写的方法</li></ul><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.inherited.method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showNum</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;来电显示号码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//smartphone：智能手机</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmartPhone</span> <span class="keyword">extends</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">    <span class="comment">//重写父类的来电显示功能的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showNum</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//来电显示姓名和图片功能</span></span><br><span class="line">        System.out.println(<span class="string">&quot;显示来电姓名&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;显示头像&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保留父类来电显示号码的功能</span></span><br><span class="line">        <span class="built_in">super</span>.showNum();<span class="comment">//此处必须加super.，否则就是无限递归，那么就会栈内存溢出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li><p><strong>方法前面没有super.和this.</strong></p><ul><li>先从子类找匹配方法，如果没有，再从直接父类找，再没有，继续往上追溯</li></ul></li><li><p><strong>方法前面有this.</strong></p><ul><li>先从子类找匹配方法，如果没有，再从直接父类找，再没有，继续往上追溯</li></ul></li><li><p><strong>方法前面有super.</strong></p><ul><li>从当前子类的直接父类找，如果没有，继续往上追溯</li></ul></li></ul><h4 id="5-2-2-子类中调用父类中同名的成员变量"><a href="#5-2-2-子类中调用父类中同名的成员变量" class="headerlink" title="5.2.2 子类中调用父类中同名的成员变量"></a>5.2.2 子类中调用父类中同名的成员变量</h4><ul><li>如果实例变量与局部变量重名，可以在实例变量前面加this.进行区别</li><li>如果子类实例变量和父类实例变量重名，并且父类的该实例变量在子类仍然可见，在子类中要访问父类声明的实例变量需要在父类实例变量前加super.，否则默认访问的是子类自己声明的实例变量</li><li>如果父子类实例变量没有重名，只要权限修饰符允许，在子类中完全可以直接访问父类中声明的实例变量，也可以用this.实例访问，也可以用super.实例变量访问</li></ul><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//子类与父类的属性同名，子类对象中就有两个a</span></span><br><span class="line">System.out.println(<span class="string">&quot;子类的a：&quot;</span> + a);<span class="comment">//20  先找局部变量找，没有再从本类成员变量找</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类的a：&quot;</span> + <span class="built_in">this</span>.a);<span class="comment">//20   先从本类成员变量找</span></span><br><span class="line">        System.out.println(<span class="string">&quot;父类的a：&quot;</span> + <span class="built_in">super</span>.a);<span class="comment">//10    直接从父类成员变量找</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//子类与父类的属性不同名，是同一个b</span></span><br><span class="line">System.out.println(<span class="string">&quot;b = &quot;</span> + b);<span class="comment">//11  先找局部变量找，没有再从本类成员变量找，没有再从父类找</span></span><br><span class="line">System.out.println(<span class="string">&quot;b = &quot;</span> + <span class="built_in">this</span>.b);<span class="comment">//11   先从本类成员变量找，没有再从父类找</span></span><br><span class="line">System.out.println(<span class="string">&quot;b = &quot;</span> + <span class="built_in">super</span>.b);<span class="comment">//11  直接从父类局部变量找</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line"><span class="comment">//子类与父类的属性同名，子类对象中就有两个成员变量a，此时方法中还有一个局部变量a</span></span><br><span class="line">System.out.println(<span class="string">&quot;局部变量的a：&quot;</span> + a);<span class="comment">//30  先找局部变量</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类的a：&quot;</span> + <span class="built_in">this</span>.a);<span class="comment">//20  先从本类成员变量找</span></span><br><span class="line">        System.out.println(<span class="string">&quot;父类的a：&quot;</span> + <span class="built_in">super</span>.a);<span class="comment">//10  直接从父类成员变量找</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;b = &quot;</span> + b);<span class="comment">//13  先找局部变量</span></span><br><span class="line">System.out.println(<span class="string">&quot;b = &quot;</span> + <span class="built_in">this</span>.b);<span class="comment">//11  先从本类成员变量找</span></span><br><span class="line">System.out.println(<span class="string">&quot;b = &quot;</span> + <span class="built_in">super</span>.b);<span class="comment">//11  直接从父类局部变量找</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">son.test();</span><br><span class="line">son.method(<span class="number">30</span>,<span class="number">13</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：起点不同（就近原则）</p><ul><li><p><strong>变量前面没有super.和this.</strong></p><ul><li>在构造器、代码块、方法中如果出现使用某个变量，先查看是否是当前块声明的<code>局部变量</code>，</li><li>如果不是局部变量，先从当前执行代码的<code>本类去找成员变量</code></li><li>如果从当前执行代码的本类中没有找到，会往上找<code>父类声明的成员变量</code>（权限修饰符允许在子类中访问的）</li></ul></li><li><p><strong>变量前面有this.</strong> </p><ul><li>通过this找成员变量时，先从当前执行代码的==本类去找成员变量==</li><li>如果从当前执行代码的本类中没有找到，会往上找==父类声明的成员变量（==权限修饰符允许在子类中访问的）</li></ul></li><li><p><strong>变量前面super.</strong> </p><ul><li>通过super找成员变量，直接从当前执行代码的直接父类去找成员变量（权限修饰符允许在子类中访问的）</li><li>如果直接父类没有，就去父类的父类中找（权限修饰符允许在子类中访问的）</li></ul></li></ul><p><strong><font color="red">特别说明：应该避免子类声明和父类重名的成员变量</font></strong></p><p>在阿里的开发规范等文档中都做出明确说明：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20211230110411580.png" alt="image-20211230110411580"></p><h4 id="5-2-3-子类构造器中调用父类构造器"><a href="#5-2-3-子类构造器中调用父类构造器" class="headerlink" title="5.2.3 子类构造器中调用父类构造器"></a>5.2.3 子类构造器中调用父类构造器</h4><p>① 子类继承父类时，不会继承父类的构造器。只能通过“super(形参列表)”的方式调用父类指定的构造器。</p><p>② 规定：“super(形参列表)”，必须声明在构造器的首行。</p><p>③ 我们前面讲过，在构造器的首行可以使用”this(形参列表)”，调用本类中重载的构造器，<br>     结合②，结论：在构造器的首行，”this(形参列表)” 和 “super(形参列表)”只能二选一。</p><p>④ 如果在子类构造器的首行既没有显示调用”this(形参列表)”，也没有显式调用”super(形参列表)”，<br>​     则子类此构造器默认调用”super()”，即调用父类中空参的构造器。</p><p>⑤ 由③和④得到结论：子类的任何一个构造器中，要么会调用本类中重载的构造器，要么会调用父类的构造器。<br>     只能是这两种情况之一。</p><p>⑥ 由⑤得到：一个类中声明有n个构造器，最多有n-1个构造器中使用了”this(形参列表)”，则剩下的那个一定使用”super(形参列表)”。</p><blockquote><p>开发中常见错误：</p><p>如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有空参的构造器，则<code>编译出错</code>。</p></blockquote><p>情景举例1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        <span class="comment">//A类和B类都是默认有一个无参构造，B类的默认无参构造中还会默认调用A类的默认无参构造</span></span><br><span class="line">        <span class="comment">//但是因为都是默认的，没有打印语句，看不出来</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情景举例2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">A()&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;A类无参构造器&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        <span class="comment">//A类显示声明一个无参构造，</span></span><br><span class="line"><span class="comment">//B类默认有一个无参构造，</span></span><br><span class="line"><span class="comment">//B类的默认无参构造中会默认调用A类的无参构造</span></span><br><span class="line">        <span class="comment">//可以看到会输出“A类无参构造器&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情景举例3：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">A()&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;A类无参构造器&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">B()&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;B类无参构造器&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        <span class="comment">//A类显示声明一个无参构造，</span></span><br><span class="line"><span class="comment">//B类显示声明一个无参构造，        </span></span><br><span class="line"><span class="comment">//B类的无参构造中虽然没有写super()，但是仍然会默认调用A类的无参构造</span></span><br><span class="line">        <span class="comment">//可以看到会输出“A类无参构造器&quot;和&quot;B类无参构造器&quot;)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情景举例4：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">A()&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;A类无参构造器&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">B()&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;B类无参构造器&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        <span class="comment">//A类显示声明一个无参构造，</span></span><br><span class="line"><span class="comment">//B类显示声明一个无参构造，        </span></span><br><span class="line"><span class="comment">//B类的无参构造中明确写了super()，表示调用A类的无参构造</span></span><br><span class="line">        <span class="comment">//可以看到会输出“A类无参构造器&quot;和&quot;B类无参构造器&quot;)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情景举例5：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">A(<span class="type">int</span> a)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;A类有参构造器&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">B()&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;B类无参构造器&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test05</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        <span class="comment">//A类显示声明一个有参构造，没有写无参构造，那么A类就没有无参构造了</span></span><br><span class="line"><span class="comment">//B类显示声明一个无参构造，        </span></span><br><span class="line"><span class="comment">//B类的无参构造没有写super(...)，表示默认调用A类的无参构造</span></span><br><span class="line">        <span class="comment">//编译报错，因为A类没有无参构造</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20200227141228450.png" alt="image-20200227141228450"></p><p>情景举例6：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">A(<span class="type">int</span> a)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;A类有参构造器&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">B()&#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;B类无参构造器&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test06</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        <span class="comment">//A类显示声明一个有参构造，没有写无参构造，那么A类就没有无参构造了</span></span><br><span class="line"><span class="comment">//B类显示声明一个无参构造，        </span></span><br><span class="line"><span class="comment">//B类的无参构造明确写super()，表示调用A类的无参构造</span></span><br><span class="line">        <span class="comment">//编译报错，因为A类没有无参构造</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20200303183542807.png" alt="image-20200303183542807"></p><p>情景举例7：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">A(<span class="type">int</span> a)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;A类有参构造器&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">B(<span class="type">int</span> a)&#123;</span><br><span class="line"><span class="built_in">super</span>(a);</span><br><span class="line">System.out.println(<span class="string">&quot;B类有参构造器&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test07</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//A类显示声明一个有参构造，没有写无参构造，那么A类就没有无参构造了</span></span><br><span class="line"><span class="comment">//B类显示声明一个有参构造，        </span></span><br><span class="line"><span class="comment">//B类的有参构造明确写super(a)，表示调用A类的有参构造</span></span><br><span class="line">        <span class="comment">//会打印“A类有参构造器&quot;和&quot;B类有参构造器&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情景举例8：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    A()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A类无参构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">A(<span class="type">int</span> a)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;A类有参构造器&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    B()&#123;</span><br><span class="line">        <span class="built_in">super</span>();<span class="comment">//可以省略，调用父类的无参构造</span></span><br><span class="line">        System.out.println(<span class="string">&quot;B类无参构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">B(<span class="type">int</span> a)&#123;</span><br><span class="line"><span class="built_in">super</span>(a);<span class="comment">//调用父类有参构造</span></span><br><span class="line">System.out.println(<span class="string">&quot;B类有参构造器&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test8</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        <span class="type">B</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-小结：this与super"><a href="#5-3-小结：this与super" class="headerlink" title="5.3 小结：this与super"></a>5.3 小结：this与super</h3><p><strong>1、this和super的意义</strong></p><p>this：当前对象</p><ul><li>在构造器和非静态代码块中，表示正在new的对象</li><li>在实例方法中，表示调用当前方法的对象</li></ul><p>super：引用父类声明的成员</p><p><strong>2、this和super的使用格式</strong></p><ul><li>this<ul><li>this.成员变量：表示当前对象的某个成员变量，而不是局部变量</li><li>this.成员方法：表示当前对象的某个成员方法，完全可以省略this.</li><li>this()或this(实参列表)：调用另一个构造器协助当前对象的实例化，只能在构造器首行，只会找本类的构造器，找不到就报错</li></ul></li><li>super<ul><li>super.成员变量：表示当前对象的某个成员变量，该成员变量在父类中声明的</li><li>super.成员方法：表示当前对象的某个成员方法，该成员方法在父类中声明的</li><li>super()或super(实参列表)：调用父类的构造器协助当前对象的实例化，只能在构造器首行，只会找直接父类的对应构造器，找不到就报错</li></ul></li></ul><h3 id="5-4-练习"><a href="#5-4-练习" class="headerlink" title="5.4 练习"></a>5.4 练习</h3><p><strong>练习1：</strong>修改方法重写的练习2中定义的类Kids中employeed()方法，在该方法中调用父类ManKind的employeed()方法，然后再输出“but Kids should study and no job.”</p><p><strong>练习2：</strong>修改继承中的练习3中定义的Cylinder类，在Cylinder类中覆盖findArea()方法，计算圆柱的表面积。考虑：findVolume方法怎样做相应的修改？</p><p>在CylinderTest类中创建Cylinder类的对象，设置圆柱的底面半径和高，并输出圆柱的表面积和体积。</p><p>附加题：在CylinderTest类中创建一个Circle类的对象，设置圆的半径，计算输出圆的面积。体会父类和子类成员的分别调用。</p><p><strong>练习3：</strong></p><p>1、写一个名为Account的类模拟账户。该类的属性和方法如下图所示。该类包括的属性：账号id，余额balance，年利率annualInterestRate；包含的方法：访问器方法（getter和setter方法），返回月利率的方法getMonthlyInterest()，取款方法withdraw()，存款方法deposit()。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20220324003430464.png" alt="image-20220324003430464"></p><p>写一个用户程序测试Account类。在用户程序中，创建一个账号为1122、余额为20000、年利率4.5%的Account对象。使用withdraw方法提款30000元，并打印余额。<br>再使用withdraw方法提款2500元，使用deposit方法存款3000元，然后打印余额和月利率。</p><p>提示：在提款方法withdraw中，需要判断用户余额是否能够满足提款数额的要求，如果不能，应给出提示。<br>运行结果如图所示：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20220324003447242.png" alt="image-20220324003447242"></p><p>2、创建Account类的一个子类CheckAccount代表可透支的账户，该账户中定义一个属性overdraft代表可透支限额。在CheckAccount类中重写withdraw方法，其算法如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果（取款金额&lt;账户余额），</span><br><span class="line">可直接取款</span><br><span class="line">如果（取款金额&gt;账户余额），</span><br><span class="line">计算需要透支的额度</span><br><span class="line">判断可透支额overdraft是否足够支付本次透支需要，如果可以</span><br><span class="line">将账户余额修改为0，冲减可透支金额</span><br><span class="line">如果不可以</span><br><span class="line">提示用户超过可透支额的限额</span><br></pre></td></tr></table></figure><p>要求：写一个用户程序测试CheckAccount类。在用户程序中，创建一个账号为1122、余额为20000、年利率4.5%，可透支限额为5000元的CheckAccount对象。</p><p>使用withdraw方法提款5000元，并打印账户余额和可透支额。</p><p>再使用withdraw方法提款18000元，并打印账户余额和可透支额。</p><p>再使用withdraw方法提款3000元，并打印账户余额和可透支额。</p><p>提示：</p><p>（1）子类CheckAccount的构造方法需要将从父类继承的3个属性和子类自己的属性全部初始化。</p><p>（2）父类Account的属性balance被设置为private，但在子类CheckAccount的withdraw方法中需要修改它的值，因此应修改父类的balance属性，定义其为protected。</p><p>运行结果如下图所示：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20220324003616767.png" alt="image-20220324003616767"></p><h2 id="6-子类对象实例化全过程"><a href="#6-子类对象实例化全过程" class="headerlink" title="6. 子类对象实例化全过程"></a>6. 子类对象实例化全过程</h2><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20220324003713230.png" alt="image-20220324003713230"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;小花&quot;</span>,<span class="string">&quot;小红&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20220324003735416.png" alt="image-20220324003735416" style="zoom:80%;"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20220324003813163.png" alt="image-20220324003813163" style="zoom:67%;"></p><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Creature</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Creature</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creature无参数的构造器&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> <span class="keyword">extends</span> <span class="title class_">Creature</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal带一个参数的构造器，该动物的name为&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(name);</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal带两个参数的构造器，其age为&quot;</span> + age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;汪汪队阿奇&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog无参数的构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7-面向对象特征三：多态性"><a href="#7-面向对象特征三：多态性" class="headerlink" title="7. 面向对象特征三：多态性"></a>7. 面向对象特征三：多态性</h2><blockquote><p>一千个读者眼中有一千个哈姆雷特。</p></blockquote><h3 id="7-1-多态的形式和体现"><a href="#7-1-多态的形式和体现" class="headerlink" title="7.1 多态的形式和体现"></a>7.1 多态的形式和体现</h3><h4 id="7-1-1-对象的多态性"><a href="#7-1-1-对象的多态性" class="headerlink" title="7.1.1 对象的多态性"></a>7.1.1 对象的多态性</h4><p>多态性，是面向对象中最重要的概念，在Java中的体现：<strong>对象的多态性：父类的引用指向子类的对象</strong></p><p>格式：（父类类型：指子类继承的父类类型，或者实现的接口类型）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类类型 变量名 = 子类对象；</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();<span class="comment">//Object类型的变量o，指向Person类型的对象</span></span><br><span class="line"></span><br><span class="line">o = <span class="keyword">new</span> <span class="title class_">Student</span>(); <span class="comment">//Object类型的变量o，指向Student类型的对象</span></span><br></pre></td></tr></table></figure><p>对象的多态：在Java中，子类的对象可以替代父类的对象使用。所以，一个引用类型变量可能指向(引用)多种不同类型的对象</p><h4 id="7-1-2-多态的理解"><a href="#7-1-2-多态的理解" class="headerlink" title="7.1.2 多态的理解"></a>7.1.2 多态的理解</h4><p>Java引用变量有两个类型：<code>编译时类型</code>和<code>运行时类型</code>。编译时类型由<code>声明</code>该变量时使用的类型决定，运行时类型由<code>实际赋给该变量的对象</code>决定。简称：<strong>编译时，看左边；运行时，看右边。</strong></p><ul><li>若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism)</li><li>多态情况下，“看左边”：看的是父类的引用（父类中不具备子类特有的方法）<pre><code>                    “看右边”：看的是子类的对象（实际运行的是子类重写父类的方法）</code></pre></li></ul><p>多态的使用前提：① 类的继承关系  ② 方法的重写</p><h4 id="7-1-3-举例"><a href="#7-1-3-举例" class="headerlink" title="7.1.3 举例"></a>7.1.3 举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.polymorphism.grammar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String nickname; <span class="comment">//昵称</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getNickname</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNickname</span><span class="params">(String nickname)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(nickname + <span class="string">&quot;吃东西&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.polymorphism.grammar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">    <span class="comment">//子类重写父类的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫咪&quot;</span> + getNickname() + <span class="string">&quot;吃鱼仔&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子类扩展的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catchMouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抓老鼠&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.polymorphism.grammar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">    <span class="comment">//子类重写父类的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗子&quot;</span> + getNickname() + <span class="string">&quot;啃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子类扩展的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">watchHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;看家&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1、方法内局部变量的赋值体现多态</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.polymorphism.grammar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//多态引用</span></span><br><span class="line">        <span class="type">Pet</span> <span class="variable">pet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        pet.setNickname(<span class="string">&quot;小白&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//多态的表现形式</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        编译时看父类：只能调用父类声明的方法，不能调用子类扩展的方法；</span></span><br><span class="line"><span class="comment">        运行时，看“子类”，如果子类重写了方法，一定是执行子类重写的方法体；</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        pet.eat();<span class="comment">//运行时执行子类Dog重写的方法</span></span><br><span class="line"><span class="comment">//      pet.watchHouse();//不能调用Dog子类扩展的方法</span></span><br><span class="line"></span><br><span class="line">        pet = <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        pet.setNickname(<span class="string">&quot;雪球&quot;</span>);</span><br><span class="line">        pet.eat();<span class="comment">//运行时执行子类Cat重写的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、方法的形参声明体现多态</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.polymorphism.grammar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Pet pet;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">adopt</span><span class="params">(Pet pet)</span> &#123;<span class="comment">//形参是父类类型，实参是子类对象</span></span><br><span class="line">        <span class="built_in">this</span>.pet = pet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">()</span>&#123;</span><br><span class="line">        pet.eat();<span class="comment">//pet实际引用的对象类型不同，执行的eat方法也不同</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.polymorphism.grammar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPerson</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        dog.setNickname(<span class="string">&quot;小白&quot;</span>);</span><br><span class="line">        person.adopt(dog);<span class="comment">//实参是dog子类对象，形参是父类Pet类型</span></span><br><span class="line">        person.feed();</span><br><span class="line"></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        cat.setNickname(<span class="string">&quot;雪球&quot;</span>);</span><br><span class="line">        person.adopt(cat);<span class="comment">//实参是cat子类对象，形参是父类Pet类型</span></span><br><span class="line">        person.feed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、方法返回值类型体现多态</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.polymorphism.grammar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PetShop</span> &#123;</span><br><span class="line">    <span class="comment">//返回值类型是父类类型，实际返回的是子类对象</span></span><br><span class="line">    <span class="keyword">public</span> Pet <span class="title function_">sale</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Dog&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Cat&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.polymorphism.grammar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPetShop</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PetShop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PetShop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Pet</span> <span class="variable">dog</span> <span class="operator">=</span> shop.sale(<span class="string">&quot;Dog&quot;</span>);</span><br><span class="line">        dog.setNickname(<span class="string">&quot;小白&quot;</span>);</span><br><span class="line">        dog.eat();</span><br><span class="line"></span><br><span class="line">        <span class="type">Pet</span> <span class="variable">cat</span> <span class="operator">=</span> shop.sale(<span class="string">&quot;Cat&quot;</span>);</span><br><span class="line">        cat.setNickname(<span class="string">&quot;雪球&quot;</span>);</span><br><span class="line">        cat.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-为什么需要多态性-polymorphism-？"><a href="#7-2-为什么需要多态性-polymorphism-？" class="headerlink" title="7.2 为什么需要多态性(polymorphism)？"></a>7.2 为什么需要多态性(polymorphism)？</h3><p>开发中，有时我们在设计一个数组、或一个成员变量、或一个方法的形参、返回值类型时，无法确定它具体的类型，只能确定它是某个系列的类型。</p><p>案例：</p><p>（1）声明一个Dog类，包含public void eat()方法，输出“狗啃骨头”</p><p>（2）声明一个Cat类，包含public void eat()方法，输出“猫吃鱼仔”</p><p>（3）声明一个Person类，功能如下：</p><ul><li>包含宠物属性</li><li>包含领养宠物方法 public void adopt(宠物类型Pet)</li><li>包含喂宠物吃东西的方法 public void feed()，实现为调用宠物对象.eat()方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗啃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃鱼仔&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//adopt：领养</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">adopt</span><span class="params">(Dog dog)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.dog = dog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//feed：喂食</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dog != <span class="literal">null</span>)&#123;</span><br><span class="line">            dog.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    问题：</span></span><br><span class="line"><span class="comment">    1、从养狗切换到养猫怎么办？   </span></span><br><span class="line"><span class="comment">    修改代码把Dog修改为养猫？</span></span><br><span class="line"><span class="comment">    2、或者有的人养狗，有的人养猫怎么办？  </span></span><br><span class="line"><span class="comment">    3、要是还有更多其他宠物类型怎么办？</span></span><br><span class="line"><span class="comment">    如果Java不支持多态，那么上面的问题将会非常麻烦，代码维护起来很难，扩展性很差。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-多态的好处和弊端"><a href="#7-3-多态的好处和弊端" class="headerlink" title="7.3 多态的好处和弊端"></a>7.3 多态的好处和弊端</h3><p><strong>好处</strong>：变量引用的子类对象不同，执行的方法就不同，实现动态绑定。代码编写更灵活、功能更强大，可维护性和扩展性更好了。</p><p><strong>弊端</strong>：一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">m.school = <span class="string">&quot;pku&quot;</span>; <span class="comment">//合法,Student类有school成员变量</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(); </span><br><span class="line">e.school = <span class="string">&quot;pku&quot;</span>;<span class="comment">//非法,Person类没有school成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性是在编译时确定的，编译时e为Person类型，没有school成员变量，因而编译错误。</span></span><br></pre></td></tr></table></figure><blockquote><p>开发中：</p><p>使用父类做方法的形参，是多态使用最多的场合。即使增加了新的子类，方法也无需改变，提高了扩展性，符合开闭原则。</p><p>【开闭原则OCP】</p><ul><li>对扩展开放，对修改关闭</li><li>通俗解释：软件系统中的各种组件，如模块（Modules）、类（Classes）以及功能（Functions）等，应该在不修改现有代码的基础上，引入新功能</li></ul></blockquote><h3 id="7-4-虚方法调用-Virtual-Method-Invocation"><a href="#7-4-虚方法调用-Virtual-Method-Invocation" class="headerlink" title="7.4 虚方法调用(Virtual Method Invocation)"></a>7.4 虚方法调用(Virtual Method Invocation)</h3><p>在Java中虚方法是指在编译阶段不能确定方法的调用入口地址，在运行阶段才能确定的方法，即可能被重写的方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">e.getInfo();<span class="comment">//调用Student类的getInfo()方法</span></span><br></pre></td></tr></table></figure><p>子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。</p><p>举例：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20220324234208997.png" alt="image-20220324234208997"></p><p>前提：Person类中定义了welcome()方法，各个子类重写了welcome()。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20220324234214932.png" alt="image-20220324234214932"></p><p>执行：多态的情况下，调用对象的welcome()方法，实际执行的是子类重写的方法。</p><blockquote><p>拓展：</p><p><code>静态链接（或早起绑定）</code>：当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。那么调用这样的方法，就称为非虚方法调用。比如调用静态方法、私有方法、final方法、父类构造器、本类重载构造器等。</p><p><code>动态链接（或晚期绑定）</code>：如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。调用这样的方法，就称为虚方法调用。比如调用重写的方法（针对父类）、实现的方法（针对接口）。</p></blockquote><h3 id="7-5-成员变量没有多态性"><a href="#7-5-成员变量没有多态性" class="headerlink" title="7.5 成员变量没有多态性"></a>7.5 成员变量没有多态性</h3><ul><li><p>若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中。</p></li><li><p>对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.polymorphism.grammar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestVariable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Base</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">        System.out.println(b.a);</span><br><span class="line">        System.out.println(((Sub)b).a);</span><br><span class="line"></span><br><span class="line">        <span class="type">Sub</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">        System.out.println(s.a);</span><br><span class="line">        System.out.println(((Base)s).a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-6-向上转型与向下转型"><a href="#7-6-向上转型与向下转型" class="headerlink" title="7.6 向上转型与向下转型"></a>7.6 向上转型与向下转型</h3><p>首先，一个对象在new的时候创建是哪个类型的对象，它从头至尾都不会变。即这个对象的运行时类型，本质的类型用于不会变。但是，把这个对象赋值给不同类型的变量时，这些变量的编译时类型却不同。</p><h4 id="7-6-1-为什么要类型转换"><a href="#7-6-1-为什么要类型转换" class="headerlink" title="7.6.1 为什么要类型转换"></a>7.6.1 为什么要类型转换</h4><p>因为多态，就一定会有把子类对象赋值给父类变量的时候，这个时候，在<code>编译期间</code>，就会出现类型转换的现象。</p><p>但是，使用父类变量接收了子类对象之后，我们就<code>不能调用</code>子类拥有，而父类没有的方法了。这也是多态给我们带来的一点”小麻烦”。所以，想要调用子类特有的方法，必须做类型转换，使得<code>编译通过</code>。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20220324235337563.png" alt="image-20220324235337563" style="zoom:80%;"></p><ul><li><p><strong>向上转型</strong>：当左边的变量的类型（父类） &gt; 右边对象/变量的类型（子类），我们就称为向上转型</p><ul><li>此时，编译时按照左边变量的类型处理，就只能调用父类中有的变量和方法，不能调用子类特有的变量和方法了</li><li>但是，<strong>运行时，仍然是对象本身的类型</strong>，所以执行的方法是子类重写的方法体。</li><li>此时，一定是安全的，而且也是自动完成的</li></ul></li><li><p><strong>向下转型</strong>：当左边的变量的类型（子类）&lt;右边对象/变量的编译时类型（父类），我们就称为向下转型</p><ul><li>此时，编译时按照左边变量的类型处理，就可以调用子类特有的变量和方法了</li><li>但是，<strong>运行时，仍然是对象本身的类型</strong></li><li>不是所有通过编译的向下转型都是正确的，可能会发生ClassCastException，为了安全，可以通过isInstanceof关键字进行判断</li></ul></li></ul><h4 id="7-6-2-如何向上或向下转型"><a href="#7-6-2-如何向上或向下转型" class="headerlink" title="7.6.2 如何向上或向下转型"></a>7.6.2 如何向上或向下转型</h4><p>向上转型：自动完成</p><p>向下转型：（子类类型）父类变量</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.polymorphism.grammar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassCastTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//没有类型转换</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();<span class="comment">//dog的编译时类型和运行时类型都是Dog</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//向上转型</span></span><br><span class="line">        <span class="type">Pet</span> <span class="variable">pet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();<span class="comment">//pet的编译时类型是Pet，运行时类型是Dog</span></span><br><span class="line">        pet.setNickname(<span class="string">&quot;小白&quot;</span>);</span><br><span class="line">        pet.eat();<span class="comment">//可以调用父类Pet有声明的方法eat，但执行的是子类重写的eat方法体</span></span><br><span class="line"><span class="comment">//        pet.watchHouse();//不能调用父类没有的方法watchHouse</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> (Dog) pet;</span><br><span class="line">        System.out.println(<span class="string">&quot;d.nickname = &quot;</span> + d.getNickname());</span><br><span class="line">        d.eat();<span class="comment">//可以调用eat方法</span></span><br><span class="line">        d.watchHouse();<span class="comment">//可以调用子类扩展的方法watchHouse</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> (Cat) pet;<span class="comment">//编译通过，因为从语法检查来说，pet的编译时类型是Pet，Cat是Pet的子类，所以向下转型语法正确</span></span><br><span class="line">        <span class="comment">//这句代码运行报错ClassCastException，因为pet变量的运行时类型是Dog，Dog和Cat之间是没有继承关系的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-6-3-instanceof关键字"><a href="#7-6-3-instanceof关键字" class="headerlink" title="7.6.3 instanceof关键字"></a>7.6.3 instanceof关键字</h4><p>为了避免ClassCastException的发生，Java提供了 <code>instanceof</code> 关键字，给引用变量做类型的校验。如下代码格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//检验对象a是否是数据类型A的对象，返回值为boolean型</span></span><br><span class="line">对象a <span class="keyword">instanceof</span> 数据类型A </span><br></pre></td></tr></table></figure><ul><li>说明：<ul><li>只要用instanceof判断返回true的，那么强转为该类型就一定是安全的，不会报ClassCastException异常。</li><li>如果对象a属于类A的子类B，a instanceof A值也为true。</li><li>要求对象a所属的类与类A必须是子类和父类的关系，否则编译错误。</li></ul></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.polymorphism.grammar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInstanceof</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Pet[] pets = <span class="keyword">new</span> <span class="title class_">Pet</span>[<span class="number">2</span>];</span><br><span class="line">        pets[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Dog</span>();<span class="comment">//多态引用</span></span><br><span class="line">        pets[<span class="number">0</span>].setNickname(<span class="string">&quot;小白&quot;</span>);</span><br><span class="line">        pets[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Cat</span>();<span class="comment">//多态引用</span></span><br><span class="line">        pets[<span class="number">1</span>].setNickname(<span class="string">&quot;雪球&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pets.length; i++) &#123;</span><br><span class="line">            pets[i].eat();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(pets[i] <span class="keyword">instanceof</span> Dog)&#123;</span><br><span class="line">                <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) pets[i];</span><br><span class="line">                dog.watchHouse();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pets[i] <span class="keyword">instanceof</span> Cat)&#123;</span><br><span class="line">                <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat) pets[i];</span><br><span class="line">                cat.catchMouse();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-7-练习"><a href="#7-7-练习" class="headerlink" title="7.7 练习"></a>7.7 练习</h3><p><strong>练习1：笔试&amp;面试</strong></p><p>题目1：继承成员变量和继承方法的区别</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FieldMethodTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Sub</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">        System.out.println(s.count);</span><br><span class="line">        s.display();</span><br><span class="line">        <span class="type">Base</span> <span class="variable">b</span> <span class="operator">=</span> s;</span><br><span class="line">        System.out.println(b == s);</span><br><span class="line">        System.out.println(b.count);</span><br><span class="line">        b.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>题目2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//考查多态的笔试题目：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterviewTest1</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Base</span> <span class="variable">base</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">base.add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Sub s = (Sub)base;</span></span><br><span class="line"><span class="comment">//s.add(1,2,3);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>... arr)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;base&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;sub_1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//public void add(int a, int b, int c) &#123;</span></span><br><span class="line"><span class="comment">//System.out.println(&quot;sub_2&quot;);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>题目3：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//getXxx()和setXxx()声明在哪个类中，内部操作的属性就是哪个类里的。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterviewTest2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Father</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line"><span class="type">Son</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">System.out.println(f.getInfo());<span class="comment">//atguigu</span></span><br><span class="line">System.out.println(s.getInfo());<span class="comment">//尚硅谷</span></span><br><span class="line">s.test();<span class="comment">//尚硅谷  atguigu</span></span><br><span class="line">System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">s.setInfo(<span class="string">&quot;大硅谷&quot;</span>);</span><br><span class="line">System.out.println(f.getInfo());<span class="comment">//atguigu</span></span><br><span class="line">System.out.println(s.getInfo());<span class="comment">//大硅谷</span></span><br><span class="line">s.test();<span class="comment">//大硅谷  atguigu</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> <span class="string">&quot;atguigu&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setInfo</span><span class="params">(String info)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.info = info;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> <span class="string">&quot;尚硅谷&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setInfo</span><span class="params">(String info)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.info = info;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="built_in">this</span>.getInfo());</span><br><span class="line">System.out.println(<span class="built_in">super</span>.getInfo());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目4：多态是编译时行为还是运行时行为？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//证明如下：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>  &#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;animal eat food&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>  <span class="keyword">extends</span> <span class="title class_">Animal</span>  &#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;cat eat fish&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>  <span class="keyword">extends</span> <span class="title class_">Animal</span>  &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Dog eat bone&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span>  <span class="keyword">extends</span> <span class="title class_">Animal</span>  &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Sheep eat grass&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterviewTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Animal  <span class="title function_">getInstance</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> (key) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cat</span> ();</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dog</span> ();</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Sheep</span> ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">3</span>);</span><br><span class="line">System.out.println(key);</span><br><span class="line"></span><br><span class="line"><span class="type">Animal</span>  <span class="variable">animal</span> <span class="operator">=</span> getInstance(key);</span><br><span class="line">animal.eat(); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习2：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">protected</span> String name=<span class="string">&quot;person&quot;</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> age=<span class="number">50</span>;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;Name: &quot;</span>+ name + <span class="string">&quot;\n&quot;</span> +<span class="string">&quot;age: &quot;</span>+ age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">protected</span> String school=<span class="string">&quot;pku&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="string">&quot;Name: &quot;</span>+ name + <span class="string">&quot;\nage: &quot;</span>+ age </span><br><span class="line">          + <span class="string">&quot;\nschool: &quot;</span>+ school;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graduate</span> <span class="keyword">extends</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span> String major=<span class="string">&quot;IT&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>  <span class="string">&quot;Name: &quot;</span>+ name + <span class="string">&quot;\nage: &quot;</span>+ age </span><br><span class="line">          + <span class="string">&quot;\nschool: &quot;</span>+ school+<span class="string">&quot;\nmajor:&quot;</span>+major;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>建立InstanceTest 类，在类中定义方法method(Person e);<br>在method中:<br>(1)根据e的类型调用相应类的getInfo()方法。<br>(2)根据e的类型执行：<br>如果e为Person类的对象，输出：<br>“a person”;<br>如果e为Student类的对象，输出：<br>“a student”<br>“a person ”<br>如果e为Graduate类的对象，输出：<br>“a graduated student”<br>“a student”<br>“a person”</p><p><strong>练习3</strong>：定义三个类，父类GeometricObject代表几何形状，子类Circle代表圆形，MyRectangle代表矩形。定义一个测试类GeometricTest，编写equalsArea方法测试两个对象的面积是否相等（注意方法的参数类型，利用动态绑定技术），编写displayGeometricObject方法显示对象的面积（注意方法的参数类型，利用动态绑定技术）。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20220325000034619.png" alt="image-20220325000034619" style="zoom:67%;"></p><h2 id="8-Object-类的使用"><a href="#8-Object-类的使用" class="headerlink" title="8. Object 类的使用"></a>8. Object 类的使用</h2><h3 id="8-1-如何理解根父类"><a href="#8-1-如何理解根父类" class="headerlink" title="8.1 如何理解根父类"></a>8.1 如何理解根父类</h3><p>类 <code>java.lang.Object</code>是类层次结构的根类，即所有其它类的父类。每个类都使用 <code>Object</code> 作为超类。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20220503104750655.png" alt="image-20220503104750655" style="zoom:67%;"></p><ul><li><p>Object类型的变量与除Object以外的任意引用数据类型的对象都存在多态引用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">method(Object obj)&#123;…&#125; <span class="comment">//可以接收任何类作为其参数</span></span><br><span class="line"></span><br><span class="line"><span class="type">Person</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();  </span><br><span class="line">method(o);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>所有对象（包括数组）都实现这个类的方法。</p></li><li><p>如果一个类没有特别指定父类，那么默认则继承自Object类。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">Object</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-2-Object类的方法"><a href="#8-2-Object类的方法" class="headerlink" title="8.2 Object类的方法"></a>8.2 Object类的方法</h3><p>根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。这里我们主要关注其中的6个：</p><h4 id="1、-重点-equals"><a href="#1、-重点-equals" class="headerlink" title="1、(重点)equals()"></a>1、(重点)equals()</h4><p><strong>= =：</strong> </p><ul><li><p>基本类型比较值:只要两个变量的值相等，即为true。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">5</span>; </span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">6</span>)&#123;…&#125;</span><br></pre></td></tr></table></figure></li><li><p>引用类型比较引用(是否指向同一个对象)：只有指向同一个对象时，==才返回true。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p1=<span class="keyword">new</span> <span class="title class_">Person</span>();      </span><br><span class="line">Person p2=<span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">if</span> (p1==p2)&#123;…&#125;</span><br></pre></td></tr></table></figure><ul><li>用“==”进行比较时，符号两边的<code>数据类型必须兼容</code>(可自动转换的基本数据类型除外)，否则编译出错</li></ul></li></ul><p><strong>equals()：</strong>所有类都继承了Object，也就获得了equals()方法。还可以重写。</p><ul><li><p>只能比较引用类型，Object类源码中equals()的作用与“==”相同：比较是否指向同一个对象。     </p><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20220226101655293.png" alt="image-20220503104750655" style="zoom:67%;"></p></li><li><p>格式:obj1.equals(obj2)</p></li><li><p>特例：当用equals()方法进行比较时，对类File、String、Date及包装类（Wrapper Class）来说，是比较类型及内容而不考虑引用的是否是同一个对象；</p><ul><li>原因：在这些类中重写了Object类的equals()方法。</li></ul></li><li><p>当自定义使用equals()时，可以重写。用于比较两个对象的“内容”是否都相等</p></li><li><p>重写equals()方法的原则</p><ul><li><p><code>对称性</code>：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。</p></li><li><p><code>自反性</code>：x.equals(x)必须返回是“true”。</p></li><li><p><code>传递性</code>：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。</p></li><li><p><code>一致性</code>：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。</p></li><li><p>任何情况下，x.equals(null)，永远返回是“false”；</p><p>​    x.equals(和x不同类型的对象)永远返回是“false”。</p></li></ul></li><li><p>重写举例：</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line"><span class="keyword">private</span> String host;</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String host, String username, String password)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.host = host;</span><br><span class="line"><span class="built_in">this</span>.username = username;</span><br><span class="line"><span class="built_in">this</span>.password = password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getHost</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> host;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHost</span><span class="params">(String host)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.host = host;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> username;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.username = username;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.password = password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;User [host=&quot;</span> + host + <span class="string">&quot;, username=&quot;</span> + username + <span class="string">&quot;, password=&quot;</span> + password + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> == obj)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">User</span> <span class="variable">other</span> <span class="operator">=</span> (User) obj;</span><br><span class="line"><span class="keyword">if</span> (host == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (other.host != <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!host.equals(other.host))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (password == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (other.password != <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!password.equals(other.password))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (username == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (other.username != <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!username.equals(other.username))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>面试题：</strong>==和equals的区别</p><blockquote><p>从我面试的反馈，85%的求职者“理直气壮”的回答错误…</p></blockquote><ul><li><p>== 既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型就是比较内存地址</p></li><li><p>equals的话，它是属于java.lang.Object类里面的方法，如果该方法没有被重写过默认也是==;我们可以看到String等类的equals方法是被重写过的，而且String类在日常开发中用的比较多，久而久之，形成了equals是比较值的错误观点。</p></li><li><p>具体要看自定义类里有没有重写Object的equals方法来判断。</p></li><li><p>通常情况下，重写equals方法，会比较类中的相应属性是否都相等。</p></li></ul><p><strong>练习1：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">it</span> <span class="operator">=</span> <span class="number">65</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">fl</span> <span class="operator">=</span> <span class="number">65.0f</span>;</span><br><span class="line">System.out.println(“<span class="number">65</span>和<span class="number">65.0f</span>是否相等？” + (it == fl)); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="variable">ch1</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>; <span class="type">char</span> <span class="variable">ch2</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;65和&#x27;A&#x27;是否相等？&quot;</span> + (it == ch1));<span class="comment">//</span></span><br><span class="line">System.out.println(<span class="string">&quot;12和ch2是否相等？&quot;</span> + (<span class="number">12</span> == ch2));<span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;str1和str2是否相等？&quot;</span>+ (str1 == str2));<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;str1是否equals str2？&quot;</span>+(str1.equals(str2)));<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">System.out.println(“hello” == <span class="keyword">new</span> <span class="title class_">java</span>.util.Date()); <span class="comment">//</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>练习2：</strong></p><p>编写Order类，有int型的orderId，String型的orderName，相应的getter()和setter()方法，两个参数的构造器，重写父类的equals()方法：public boolean equals(Object obj)，并判断测试类中创建的两个对象是否相等。</p><p><strong>练习3：</strong></p><p>请根据以下代码自行定义能满足需要的MyDate类,在MyDate类中覆盖equals方法，使其判断当两个MyDate类型对象的年月日都相同时，结果为true，否则为false。  public boolean equals(Object o)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EqualsTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyDate</span> <span class="variable">m1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyDate</span>(<span class="number">14</span>, <span class="number">3</span>, <span class="number">1976</span>);</span><br><span class="line">        <span class="type">MyDate</span> <span class="variable">m2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyDate</span>(<span class="number">14</span>, <span class="number">3</span>, <span class="number">1976</span>);</span><br><span class="line">        <span class="keyword">if</span> (m1 == m2) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;m1==m2&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;m1!=m2&quot;</span>); <span class="comment">// m1 != m2</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m1.equals(m2)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;m1 is equal to m2&quot;</span>);<span class="comment">// m1 is equal to m2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;m1 is not equal to m2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2、-重点-toString"><a href="#2、-重点-toString" class="headerlink" title="2、(重点)toString()"></a>2、(重点)toString()</h4><p>方法签名：public String toString()</p><p>① 默认情况下，toString()返回的是“对象的运行时类型 @ 对象的hashCode值的十六进制形式”</p><p>② 在进行String与其它类型数据的连接操作时，自动调用toString()方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date now=<span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">System.out.println(“now=”+now);  <span class="comment">//相当于</span></span><br><span class="line">System.out.println(“now=”+now.toString()); </span><br></pre></td></tr></table></figure><p>③ 如果我们直接System.out.println(对象)，默认会自动调用这个对象的toString()</p><blockquote><p>因为Java的引用数据类型的变量中存储的实际上时对象的内存地址，但是Java对程序员隐藏内存地址信息，所以不能直接将内存地址显示出来，所以当你打印对象时，JVM帮你调用了对象的toString()。</p></blockquote><p>④ 可以根据需要在用户自定义类型中重写toString()方法<br>    如String 类重写了toString()方法，返回字符串的值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s1=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(s1);<span class="comment">//相当于System.out.println(s1.toString());</span></span><br></pre></td></tr></table></figure><p>例如自定义的Person类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> + <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习</strong>：定义两个类，父类GeometricObject代表几何形状，子类Circle代表圆形。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20220325002959156.png" alt="image-20220325002959156" style="zoom:67%;"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image-20220325002932102.png" alt="image-20220325002932102" style="zoom:67%;"></p><h4 id="3、clone"><a href="#3、clone" class="headerlink" title="3、clone()"></a>3、clone()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Object类的clone()的使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloneTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Animal</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;花花&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Animal</span> <span class="variable">a2</span> <span class="operator">=</span> (Animal) a1.clone();</span><br><span class="line">System.out.println(<span class="string">&quot;原始对象：&quot;</span> + a1);</span><br><span class="line">a2.setName(<span class="string">&quot;毛毛&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;clone之后的对象：&quot;</span> + a2);</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Animal [name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、finalize"><a href="#4、finalize" class="headerlink" title="4、finalize()"></a>4、finalize()</h4><ul><li>当对象被回收时，系统自动调用该对象的 finalize() 方法。（不是垃圾回收器调用的，是本类对象调用的）<ul><li>永远不要主动调用某个对象的finalize方法，应该交给垃圾回收机制调用。</li></ul></li><li>什么时候被回收：当某个对象没有任何引用时，JVM就认为这个对象是垃圾对象，就会在之后不确定的时间使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用 finalize()方法。 </li><li>子类可以重写该方法，目的是在对象被清理之前执行必要的清理操作。比如，在方法内断开相关连接资源。<ul><li>如果重写该方法，让一个新的引用变量重新引用该对象，则会重新激活对象。</li></ul></li><li>在JDK 9中此方法已经被<code>标记为过时</code>的。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalizeTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Peter&quot;</span>, <span class="number">12</span>);</span><br><span class="line">System.out.println(p);</span><br><span class="line">p = <span class="literal">null</span>;<span class="comment">//此时对象实体就是垃圾对象，等待被回收。但时间不确定。</span></span><br><span class="line">System.gc();<span class="comment">//强制性释放空间</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类重写此方法，可在释放对象前进行某些操作</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;对象被释放---&gt;&quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Person [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、getClass"><a href="#5、getClass" class="headerlink" title="5、getClass()"></a>5、getClass()</h4><p>public final Class&lt;?&gt; getClass()：获取对象的运行时类型</p><blockquote><p>因为Java有多态现象，所以一个引用数据类型的变量的编译时类型与运行时类型可能不一致，因此如果需要查看这个变量实际指向的对象的类型，需要用getClass()方法</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">System.out.println(obj.getClass());<span class="comment">//运行时类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">com</span>.atguigu.java.Person</span><br></pre></td></tr></table></figure><h4 id="6、hashCode"><a href="#6、hashCode" class="headerlink" title="6、hashCode()"></a>6、hashCode()</h4><p>public int hashCode()：返回每个对象的hash值。(后续在集合框架章节重点讲解)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;AA&quot;</span>.hashCode());<span class="comment">//2080</span></span><br><span class="line">    System.out.println(<span class="string">&quot;BB&quot;</span>.hashCode());<span class="comment">//2112</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-native关键字的理解"><a href="#8-3-native关键字的理解" class="headerlink" title="8.3 native关键字的理解"></a>8.3 native关键字的理解</h3><p>使用native关键字说明这个方法是原生函数，也就是这个方法是用<code>C/C++</code>等非Java语言实现的，并且<code>被编译成了DLL</code>，由Java去调用。</p><ul><li><p>本地方法是有方法体的，用c语言编写。由于本地方法的方法体源码没有对我们开源，所以我们看不到方法体</p></li><li><p>在Java中定义一个native方法时，并不提供实现体。</p></li></ul><p><strong>1. 为什么要用native方法</strong></p><p>Java使用起来非常方便，然而有些层次的任务用java实现起来不容易，或者我们对程序的效率很在意时，例如：Java需要与一些底层操作系统或某些硬件交换信息时的情况。native方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</p><p><strong>2. native声明的方法，对于调用者，可以当做和其他Java方法一样使用</strong></p><p>native method的存在并不会对其他类调用这些本地方法产生任何影响，实际上调用这些方法的其他类甚至不知道它所调用的是一个本地方法。JVM将控制调用本地方法的所有细节。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第07章-面向对象编程-进阶&quot;&gt;&lt;a href=&quot;#第07章-面向对象编程-进阶&quot; class=&quot;headerlink&quot; title=&quot;第07章_面向对象编程(进阶)&quot;&gt;&lt;/a&gt;第07章_面向对象编程(进阶)&lt;/h1&gt;&lt;p&gt;讲师：尚硅谷-宋红康（江湖人称：康师傅）</summary>
      
    
    
    
    <category term="Java2023" scheme="http://example.com/categories/Java2023/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第09章_异常处理</title>
    <link href="http://example.com/2023/02/18/java2023/%E7%AC%AC09%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://example.com/2023/02/18/java2023/%E7%AC%AC09%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</id>
    <published>2023-02-18T12:37:01.000Z</published>
    <updated>2023-02-19T07:38:42.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第09章-异常处理"><a href="#第09章-异常处理" class="headerlink" title="第09章_异常处理"></a>第09章_异常处理</h1><p>讲师：尚硅谷-宋红康（江湖人称：康师傅）</p><p>官网：<a href="http://www.atguigu.com/">http://www.atguigu.com</a></p><hr><h2 id="本章专题与脉络"><a href="#本章专题与脉络" class="headerlink" title="本章专题与脉络"></a>本章专题与脉络</h2><p><img src="/2023/02/18/java2023/%E7%AC%AC09%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/第3阶段：Java高级应用-第09章.png" alt="第3阶段：Java高级应用-第09章" style="zoom: 50%;"></p><h2 id="1-异常概述"><a href="#1-异常概述" class="headerlink" title="1. 异常概述"></a>1. 异常概述</h2><h3 id="1-1-什么是生活的异常"><a href="#1-1-什么是生活的异常" class="headerlink" title="1.1 什么是生活的异常"></a>1.1 什么是生活的异常</h3><p>男主角小明每天开车上班，正常车程1小时。但是，不出意外的话，可能会出现意外。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC09%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20220814203918560.png" alt="image-20220814203918560"></p><p>出现意外，即为异常情况。我们会做相应的处理。如果不处理，到不了公司。处理完了，就可以正常开车去公司。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC09%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20220520210320301.png" alt="image-20220520210320301" style="zoom:70%;"></p><h3 id="1-2-什么是程序的异常"><a href="#1-2-什么是程序的异常" class="headerlink" title="1.2 什么是程序的异常"></a>1.2 什么是程序的异常</h3><p>在使用计算机语言进行项目开发的过程中，即使程序员把代码写得<code>尽善尽美</code>，在系统的运行过程中仍然会遇到一些问题，因为很多问题不是靠代码能够避免的，比如：<code>客户输入数据的格式问题</code>，<code>读取文件是否存在</code>，<code>网络是否始终保持通畅</code>等等。</p><ul><li><strong>异常</strong> ：指的是程序在执行过程中，出现的非正常情况，如果不处理最终会导致JVM的非正常停止。</li></ul><blockquote><p>异常指的并不是语法错误和逻辑错误。语法错了，编译不通过，不会产生字节码文件，根本不能运行。</p><p>代码逻辑错误，只是没有得到想要的结果，例如：求a与b的和，你写成了a-b</p></blockquote><h3 id="1-3-异常的抛出机制"><a href="#1-3-异常的抛出机制" class="headerlink" title="1.3 异常的抛出机制"></a>1.3 异常的抛出机制</h3><p>Java中是如何表示不同的异常情况，又是如何让程序员得知，并处理异常的呢？</p><p>Java中把不同的异常用不同的类表示，一旦发生某种异常，就<code>创建该异常类型的对象</code>，并且抛出（throw）。然后程序员可以捕获(catch)到这个异常对象，并处理；如果没有捕获(catch)这个异常对象，那么这个异常对象将会导致程序终止。</p><p>举例：</p><p>运行下面的程序，程序会产生一个数组角标越界异常<code>ArrayIndexOfBoundsException</code>。我们通过图解来解析下异常产生和抛出的过程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTools</span> &#123;</span><br><span class="line">    <span class="comment">// 对给定的数组通过给定的角标获取元素。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getElement</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">element</span> <span class="operator">=</span> arr[index];</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123; <span class="number">34</span>, <span class="number">12</span>, <span class="number">67</span> &#125;;</span><br><span class="line">        intnum = ArrayTools.getElement(arr, <span class="number">4</span>)</span><br><span class="line">        System.out.println(<span class="string">&quot;num=&quot;</span> + num);</span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序执行过程图解：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC09%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/异常产生过程.png" alt></p><h3 id="1-4-如何对待异常"><a href="#1-4-如何对待异常" class="headerlink" title="1.4 如何对待异常"></a>1.4 如何对待异常</h3><p> 对于程序出现的异常，一般有两种解决方法：一是遇到错误就终止程序的运行。另一种方法是程序员在编写程序时，就充分考虑到各种可能发生的异常和错误，极力预防和避免。实在无法避免的，要编写相应的代码进行异常的检测、以及<code>异常的处理</code>，保证代码的<code>健壮性</code>。</p><h2 id="2-Java异常体系"><a href="#2-Java异常体系" class="headerlink" title="2. Java异常体系"></a>2. Java异常体系</h2><h3 id="2-1-Throwable"><a href="#2-1-Throwable" class="headerlink" title="2.1 Throwable"></a>2.1 Throwable</h3><p><code>java.lang.Throwable</code> 类是Java程序执行过程中发生的异常事件对应的类的根父类。</p><p><strong>Throwable中的常用方法：</strong></p><ul><li><p><code>public void printStackTrace()</code>：打印异常的详细信息。</p><p>包含了异常的类型、异常的原因、异常出现的位置、在开发和调试阶段都得使用printStackTrace。</p></li><li><p><code>public String getMessage()</code>：获取发生异常的原因。</p></li></ul><h3 id="2-2-Error-和-Exception"><a href="#2-2-Error-和-Exception" class="headerlink" title="2.2 Error 和 Exception"></a>2.2 Error 和 Exception</h3><p>Throwable可分为两类：Error和Exception。分别对应着<code>java.lang.Error</code>与<code>java.lang.Exception</code>两个类。</p><p><strong>Error：</strong>Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。一般不编写针对性的代码进行处理。</p><ul><li>例如：StackOverflowError（栈内存溢出）和OutOfMemoryError（堆内存溢出，简称OOM）。</li></ul><p><strong>Exception:</strong> 其它因编程错误或偶然的外在因素导致的一般性问题，需要使用针对性的代码进行处理，使程序继续运行。否则一旦发生异常，程序也会挂掉。例如：</p><ul><li>空指针访问</li><li>试图读取不存在的文件</li><li>网络连接中断</li><li>数组角标越界</li></ul><blockquote><p>说明：</p><ol><li>无论是Error还是Exception，还有很多子类，异常的类型非常丰富。当代码运行出现异常时，特别是我们不熟悉的异常时，不要紧张，把异常的简单类名，拷贝到API中去查去认识它即可。</li><li>我们本章讲的异常处理，其实针对的就是Exception。</li></ol></blockquote><p><img src="/2023/02/18/java2023/%E7%AC%AC09%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20220511161910951.png" alt="image-20220511161910951" style="zoom:67%;"></p><h3 id="2-3-编译时异常和运行时异常"><a href="#2-3-编译时异常和运行时异常" class="headerlink" title="2.3 编译时异常和运行时异常"></a>2.3 编译时异常和运行时异常</h3><p>Java程序的执行分为编译时过程和运行时过程。有的错误只有在<code>运行时</code>才会发生。比如：除数为0，数组下标越界等。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC09%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20220330002449526.png" alt="image-20220330002449526" style="zoom:80%;"></p><p>因此，根据异常可能出现的阶段，可以将异常分为：</p><ul><li><strong>编译时期异常</strong>（即checked异常、受检异常）：在代码编译阶段，编译器就能明确<code>警示</code>当前代码<code>可能发生（不是一定发生）</code>xx异常，并<code>明确督促</code>程序员提前编写处理它的代码。如果程序员<code>没有编写</code>对应的异常处理代码，则编译器就会直接判定编译失败，从而不能生成字节码文件。通常，这类异常的发生不是由程序员的代码引起的，或者不是靠加简单判断就可以避免的，例如：FileNotFoundException（文件找不到异常）。</li><li><strong>运行时期异常</strong>（即runtime异常、unchecked异常、非受检异常）：在代码编译阶段，编译器完全不做任何检查，无论该异常是否会发生，编译器都不给出任何提示。只有等代码运行起来并确实发生了xx异常，它才能被发现。通常，这类异常是由程序员的代码编写不当引起的，只要稍加判断，或者细心检查就可以避免。<ul><li><strong>java.lang.RuntimeException</strong>类及它的子类都是运行时异常。比如：ArrayIndexOutOfBoundsException数组下标越界异常，ClassCastException类型转换异常。</li></ul></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC09%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/1562771528807.png" alt="1562771528807"></p><h2 id="3-常见的错误和异常"><a href="#3-常见的错误和异常" class="headerlink" title="3. 常见的错误和异常"></a>3. 常见的错误和异常</h2><h3 id="3-1-Error"><a href="#3-1-Error" class="headerlink" title="3.1 Error"></a>3.1 Error</h3><p>最常见的就是VirtualMachineError，它有两个经典的子类：StackOverflowError、OutOfMemoryError。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStackOverflowError</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//StackOverflowError</span></span><br><span class="line">        recursion();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recursion</span><span class="params">()</span>&#123; <span class="comment">//递归方法</span></span><br><span class="line">        recursion(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestOutOfMemoryError</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//OutOfMemoryError</span></span><br><span class="line">        <span class="comment">//方式一：</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[Integer.MAX_VALUE];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//OutOfMemoryError</span></span><br><span class="line">        <span class="comment">//方式二：</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            s.append(<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-运行时异常"><a href="#3-2-运行时异常" class="headerlink" title="3.2 运行时异常"></a>3.2 运行时异常</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRuntimeException</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//NullPointerException</span></span><br><span class="line">        <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][];</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>].length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//ClassCastException</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//ArrayIndexOutOfBoundsException</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//InputMismatchException</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入一个整数：&quot;</span>);<span class="comment">//输入非整数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//ArithmeticException</span></span><br><span class="line">        System.out.println(a/b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-3-编译时异常"><a href="#3-3-编译时异常" class="headerlink" title="3.3 编译时异常"></a>3.3 编译时异常</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCheckedException</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test06</span><span class="params">()</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);<span class="comment">//休眠1秒  InterruptedException</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test07</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);<span class="comment">//ClassNotFoundException</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test08</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;....&quot;</span>);  <span class="comment">//SQLException</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test09</span><span class="params">()</span>  &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;尚硅谷Java秘籍.txt&quot;</span>); <span class="comment">//FileNotFoundException</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test10</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;尚硅谷Java秘籍.txt&quot;</span>);</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);<span class="comment">//FileNotFoundException</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> fis.read();<span class="comment">//IOException</span></span><br><span class="line"><span class="keyword">while</span>(b != -<span class="number">1</span>)&#123;</span><br><span class="line">System.out.print((<span class="type">char</span>)b);</span><br><span class="line">b = fis.read();<span class="comment">//IOException</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fis.close();<span class="comment">//IOException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-异常的处理"><a href="#4-异常的处理" class="headerlink" title="4. 异常的处理"></a>4. 异常的处理</h2><h3 id="4-1-异常处理概述"><a href="#4-1-异常处理概述" class="headerlink" title="4.1 异常处理概述"></a>4.1 异常处理概述</h3><p>在编写程序时，经常要在可能出现错误的地方加上检测的代码，如进行x/y运算时，要<code>检测分母为0</code>，<code>数据为空</code>，<code>输入的不是数据而是字符</code>等。过多的if-else分支会导致程序的<code>代码加长</code>、<code>臃肿</code>，<code>可读性差</code>，程序员需要花很大的精力“<code>堵漏洞</code>”。因此采用异常处理机制。</p><p><strong>Java异常处理</strong></p><p>Java采用的异常处理机制，是<code>将异常处理的程序代码集中在一起</code>，与正常的程序代码分开，使得程序简洁、优雅，并易于维护。</p><p><strong>Java异常处理的方式：</strong></p><p>方式一：try-catch-finally</p><p>方式二：throws + 异常类型</p><p><img src="/2023/02/18/java2023/%E7%AC%AC09%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20220331111051496.png" alt="image-20220331111051496"></p><h3 id="4-2-方式1：捕获异常（try-catch-finally）"><a href="#4-2-方式1：捕获异常（try-catch-finally）" class="headerlink" title="4.2 方式1：捕获异常（try-catch-finally）"></a>4.2 方式1：捕获异常（try-catch-finally）</h3><p>Java提供了异常处理的<strong>抓抛模型</strong>。</p><ul><li>前面提到，Java程序的执行过程中如出现异常，会生成一个异常类对象，该异常对象将被提交给Java运行时系统，这个过程称为<code>抛出(throw)异常</code>。</li><li>如果一个方法内抛出异常，该异常对象会被抛给调用者方法中处理。如果异常没有在调用者方法中处理，它继续被抛给这个调用方法的上层方法。这个过程将一直继续下去，直到异常被处理。这一过程称为<code>捕获(catch)异常</code>。</li><li>如果一个异常回到main()方法，并且main()也不处理，则程序运行终止。</li></ul><h4 id="4-2-1-try-catch-finally基本格式"><a href="#4-2-1-try-catch-finally基本格式" class="headerlink" title="4.2.1 try-catch-finally基本格式"></a>4.2.1 try-catch-finally基本格式</h4><p>捕获异常语法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">......<span class="comment">//可能产生异常的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>( 异常类型<span class="number">1</span> e )&#123;</span><br><span class="line">......<span class="comment">//当产生异常类型1型异常时的处置措施</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>( 异常类型<span class="number">2</span> e )&#123;</span><br><span class="line">...... <span class="comment">//当产生异常类型2型异常时的处置措施</span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">...... <span class="comment">//无论是否发生异常，都无条件执行的语句</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>1、整体执行过程：</strong></p><p>当某段代码可能发生异常，不管这个异常是编译时异常（受检异常）还是运行时异常（非受检异常），我们都可以使用try块将它括起来，并在try块下面编写catch分支尝试捕获对应的异常对象。</p><ul><li>如果在程序运行时，try块中的代码没有发生异常，那么catch所有的分支都不执行。</li><li>如果在程序运行时，try块中的代码发生了异常，根据异常对象的类型，将从上到下选择第一个匹配的catch分支执行。此时try中发生异常的语句下面的代码将不执行，而整个try…catch之后的代码可以继续运行。</li><li>如果在程序运行时，try块中的代码发生了异常，但是所有catch分支都无法匹配（捕获）这个异常，那么JVM将会终止当前方法的执行，并把异常对象“抛”给调用者。如果调用者不处理，程序就挂了。</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC09%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20220503122722605.png" alt="image-20220503122722605" style="zoom:67%;"></p><p><strong>2、try</strong></p><ul><li>捕获异常的第一步是用<code>try&#123;…&#125;语句块</code>选定捕获异常的范围，将可能出现异常的业务逻辑代码放在try语句块中。</li></ul><p><strong>3、catch (Exceptiontype e)</strong></p><ul><li><p>catch分支，分为两个部分，catch()中编写异常类型和异常参数名，{}中编写如果发生了这个异常，要做什么处理的代码。</p></li><li><p>如果明确知道产生的是何种异常，可以用该异常类作为catch的参数；也可以用其父类作为catch的参数。</p><p>比如：可以用ArithmeticException类作为参数的地方，就可以用RuntimeException类作为参数，或者用所有异常的父类Exception类作为参数。但不能是与ArithmeticException类无关的异常，如NullPointerException（catch中的语句将不会执行）。</p></li><li><p>每个try语句块可以伴随一个或多个catch语句，用于处理可能产生的不同类型的异常对象。</p></li><li><p>如果有多个catch分支，并且多个异常类型有父子类关系，必须保证小的子异常类型在上，大的父异常类型在下。否则，报错。</p></li><li><p>catch中常用异常处理的方式</p><ul><li><p><code>public String getMessage()</code>：获取异常的描述信息，返回字符串</p></li><li><p><code>public void printStackTrace()</code>：打印异常的跟踪栈信息并输出到控制台。包含了异常的类型、异常的原因、还包括异常出现的位置，在开发和调试阶段，都得使用printStackTrace()。</p></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC09%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20220331180736381.png" alt="image-20220331180736381" style="zoom:80%;"></p></li></ul><h4 id="4-2-2-使用举例"><a href="#4-2-2-使用举例" class="headerlink" title="4.2.2 使用举例"></a>4.2.2 使用举例</h4><p>举例1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexOutExp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String friends[] = &#123; <span class="string">&quot;lisa&quot;</span>, <span class="string">&quot;bily&quot;</span>, <span class="string">&quot;kessy&quot;</span> &#125;;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(friends[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;index err&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;\nthis is the end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>举例2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DivideZero1</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        <span class="type">DivideZero1</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DivideZero1</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            y = <span class="number">3</span> / c.x;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;divide by zero error!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;program ends ok!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>举例3：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;atguigu.com&quot;</span>;</span><br><span class="line">str1 = <span class="literal">null</span>;</span><br><span class="line">System.out.println(str1.charAt(<span class="number">0</span>));</span><br><span class="line">&#125;<span class="keyword">catch</span>(NullPointerException e)&#123;</span><br><span class="line"><span class="comment">//异常的处理方式1</span></span><br><span class="line">System.out.println(<span class="string">&quot;不好意思，亲~出现了小问题，正在加紧解决...&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(ClassCastException e)&#123;</span><br><span class="line"><span class="comment">//异常的处理方式2</span></span><br><span class="line">System.out.println(<span class="string">&quot;出现了类型转换的异常&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(RuntimeException e)&#123;</span><br><span class="line"><span class="comment">//异常的处理方式3</span></span><br><span class="line">System.out.println(<span class="string">&quot;出现了运行时异常&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此处的代码，在异常被处理了以后，是可以正常执行的</span></span><br><span class="line">System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例4：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-2-3-finally使用及举例"><a href="#4-2-3-finally使用及举例" class="headerlink" title="4.2.3 finally使用及举例"></a>4.2.3 finally使用及举例</h4><p><img src="/2023/02/18/java2023/%E7%AC%AC09%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20220331215517077.png" alt="image-20220331215517077" style="zoom: 80%;"></p><ul><li><p>因为异常会引发程序跳转，从而会导致有些语句执行不到。而程序中有一些特定的代码无论异常是否发生，都<code>需要执行</code>。例如，数据库连接、输入流输出流、Socket连接、Lock锁的关闭等，这样的代码通常就会放到finally块中。所以，我们通常将一定要被执行的代码声明在finally中。</p><ul><li>唯一的例外，使用 System.exit(0) 来终止当前正在运行的 Java 虚拟机。</li></ul></li><li><p>不论在try代码块中是否发生了异常事件，catch语句是否执行，catch语句是否有异常，catch语句中是否有return，finally块中的语句都会被执行。</p></li><li><p>finally语句和catch语句是可选的，但finally不能单独使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">     </span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ul><p>举例1：确保资源关闭</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.keyword;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.InputMismatchException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFinally</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;请输入第一个整数：&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">            System.out.print(<span class="string">&quot;请输入第二个整数：&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> a/b;</span><br><span class="line">            System.out.println(a + <span class="string">&quot;/&quot;</span> + b +<span class="string">&quot;=&quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InputMismatchException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数字格式不正确，请输入两个整数&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ArithmeticException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第二个整数不能为0&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;程序结束，释放资源&quot;</span>);</span><br><span class="line">            input.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello1.txt&quot;</span>);</span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);<span class="comment">//FileNotFoundException</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> fis.read();<span class="comment">//IOException</span></span><br><span class="line">            <span class="keyword">while</span>(b != -<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.print((<span class="type">char</span>)b);</span><br><span class="line">                b = fis.read();<span class="comment">//IOException</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(fis != <span class="literal">null</span>)</span><br><span class="line">                    fis.close();<span class="comment">//IOException</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例2：从try回来</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinallyTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> test(<span class="string">&quot;12&quot;</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Integer.parseInt(str);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(NumberFormatException e)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;test结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例3：从catch回来</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinallyTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> test(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer.parseInt(str);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;test结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例4：从finally回来</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinallyTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> test(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer.parseInt(str);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;test结束&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>笔试题：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> test();</span><br><span class="line">        System.out.println(result); <span class="comment">//100</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>笔试题：final、finally、finalize有什么区别？</p></blockquote><h4 id="4-2-4-练习"><a href="#4-2-4-练习" class="headerlink" title="4.2.4 练习"></a>4.2.4 练习</h4><p>编写一个类ExceptionTest，在main方法中使用try、catch、finally，要求：</p><ul><li><p>在try块中，编写被零除的代码。</p></li><li><p>在catch块中，捕获被零除所产生的异常，并且打印异常信息</p></li><li><p>在finally块中，打印一条语句。</p></li></ul><h4 id="4-2-5-异常处理的体会"><a href="#4-2-5-异常处理的体会" class="headerlink" title="4.2.5 异常处理的体会"></a>4.2.5 异常处理的体会</h4><ul><li><p>前面使用的异常都是<code>RuntimeException类</code>或是它的<code>子类</code>，这些类的异常的特点是：即使没有使用try和catch捕获，Java自己也能捕获，并且编译通过 ( 但运行时会发生异常使得程序运行终止 )。所以，对于这类异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。</p></li><li><p>如果抛出的异常是IOException等类型的<code>非运行时异常</code>，则必须捕获，否则<code>编译错误</code>。也就是说，我们必须处理编译时异常，将异常进行捕捉，转化为运行时异常。</p></li></ul><h3 id="4-3-方式2：声明抛出异常类型（throws）"><a href="#4-3-方式2：声明抛出异常类型（throws）" class="headerlink" title="4.3 方式2：声明抛出异常类型（throws）"></a>4.3 方式2：声明抛出异常类型（throws）</h3><ul><li><p>如果在编写方法体的代码时，某句代码可能发生某个<code>编译时异常</code>，不处理编译不通过，但是在当前方法体中可能<code>不适合处理</code>或<code>无法给出合理的处理方式</code>，则此方法应<code>显示地</code>声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC09%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20220331112000671.png" alt="image-20220331112000671" style="zoom:67%;"></p></li><li><p>具体方式：在方法声明中用<code>throws语句</code>可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。</p></li></ul><h4 id="4-3-1-throws基本格式"><a href="#4-3-1-throws基本格式" class="headerlink" title="4.3.1 throws基本格式"></a>4.3.1 throws基本格式</h4><p><strong>声明异常格式：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123;   &#125;</span><br></pre></td></tr></table></figure><p>在throws后面可以写多个异常类型，用逗号隔开。</p><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(String file)</span>  <span class="keyword">throws</span> FileNotFoundException,IOException &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 读文件的操作可能产生FileNotFoundException或IOException类型的异常</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-3-2-throws-使用举例"><a href="#4-3-2-throws-使用举例" class="headerlink" title="4.3.2 throws 使用举例"></a>4.3.2 throws 使用举例</h4><p><strong>举例：针对于编译时异常</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.keyword;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThrowsCheckedException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;上课.....&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            afterClass();<span class="comment">//换到这里处理异常</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;准备提前上课&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;上课.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">afterClass</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">10</span>; i&gt;=<span class="number">1</span>; i--)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);<span class="comment">//本来应该在这里处理异常</span></span><br><span class="line">            System.out.println(<span class="string">&quot;距离上课还有：&quot;</span> + i + <span class="string">&quot;分钟&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>举例：针对于运行时异常：</strong></p><p>throws后面也可以写运行时异常类型，只是运行时异常类型，写或不写对于编译器和程序执行来说都没有任何区别。如果写了，唯一的区别就是调用者调用该方法后，使用try…catch结构时，IDEA可以获得更多的信息，需要添加哪种catch分支。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.keyword;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.InputMismatchException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThrowsRuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;请输入第一个整数：&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">            System.out.print(<span class="string">&quot;请输入第二个整数：&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> divide(a,b);</span><br><span class="line">            System.out.println(a + <span class="string">&quot;/&quot;</span> + b +<span class="string">&quot;=&quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException | InputMismatchException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            input.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span><span class="keyword">throws</span> ArithmeticException&#123;</span><br><span class="line">        <span class="keyword">return</span> a/b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-3-3-方法重写中throws的要求"><a href="#4-3-3-方法重写中throws的要求" class="headerlink" title="4.3.3 方法重写中throws的要求"></a>4.3.3 方法重写中throws的要求</h4><p>方法重写时，对于方法签名是有严格要求的。复习：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）方法名必须相同</span><br><span class="line">（2）形参列表必须相同</span><br><span class="line">（3）返回值类型</span><br><span class="line">- 基本数据类型和void：必须相同</span><br><span class="line">- 引用数据类型：&lt;=</span><br><span class="line">（4）权限修饰符：&gt;=，而且要求父类被重写方法在子类中是可见的</span><br><span class="line">（5）不能是static，final修饰的方法</span><br></pre></td></tr></table></figure><p>此外，对于throws异常列表要求：</p><ul><li>如果父类被重写方法的方法签名后面没有 “throws  编译时异常类型”，那么重写方法时，方法签名后面也不能出现“throws  编译时异常类型”。</li><li>如果父类被重写方法的方法签名后面有 “<code>throws  编译时异常类型</code>”，那么重写方法时，throws的编译时异常类型必须 &lt;= 被重写方法throws的编译时异常类型，或者不throws编译时异常。</li><li>方法重写，对于“<code>throws 运行时异常类型</code>”没有要求。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.keyword;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father.method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="keyword">throws</span> IOException,ClassCastException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son.method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-两种异常处理方式的选择"><a href="#4-4-两种异常处理方式的选择" class="headerlink" title="4.4 两种异常处理方式的选择"></a>4.4 两种异常处理方式的选择</h3><p>前提：对于异常，使用相应的处理方式。此时的异常，主要指的是编译时异常。</p><ul><li>如果程序代码中，涉及到资源的调用（流、数据库连接、网络连接等），则必须考虑使用try-catch-finally来处理，保证不出现内存泄漏。</li><li>如果父类被重写的方法没有throws异常类型，则子类重写的方法中如果出现异常，只能考虑使用try-catch-finally进行处理，不能throws。</li><li>开发中，方法a中依次调用了方法b,c,d等方法，方法b,c,d之间是递进关系。此时，如果方法b,c,d中有异常，我们通常选择使用throws，而方法a中通常选择使用try-catch-finally。</li></ul><h2 id="5-手动抛出异常对象：throw"><a href="#5-手动抛出异常对象：throw" class="headerlink" title="5. 手动抛出异常对象：throw"></a>5. 手动抛出异常对象：throw</h2><p>Java 中异常对象的生成有两种方式：</p><ul><li><p>由虚拟机<strong>自动生成</strong>：程序运行过程中，虚拟机检测到程序发生了问题，那么针对当前代码，就会在后台自动创建一个对应异常类的实例对象并抛出。</p></li><li><p>由开发人员<strong>手动创建</strong>：<code>new 异常类型([实参列表]);</code>，如果创建好的异常对象不抛出对程序没有任何影响，和创建一个普通对象一样，但是一旦throw抛出，就会对程序运行产生影响了。</p></li></ul><h3 id="5-1-使用格式"><a href="#5-1-使用格式" class="headerlink" title="5.1 使用格式"></a>5.1 使用格式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> 异常类名(参数);</span><br></pre></td></tr></table></figure><p>throw语句抛出的异常对象，和JVM自动创建和抛出的异常对象一样。</p><ul><li><p>如果是编译时异常类型的对象，同样需要使用throws或者try…catch处理，否则编译不通过。</p></li><li><p>如果是运行时异常类型的对象，编译器不提示。</p></li><li><p>可以抛出的异常必须是Throwable或其子类的实例。下面的语句在编译时将会产生语法错误：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;want to throw&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-2-使用注意点："><a href="#5-2-使用注意点：" class="headerlink" title="5.2 使用注意点："></a>5.2 使用注意点：</h3><p>无论是编译时异常类型的对象，还是运行时异常类型的对象，如果没有被try..catch合理的处理，都会导致程序崩溃。</p><p>throw语句会导致程序执行流程被改变，throw语句是明确抛出一个异常对象，因此它<code>下面的代码将不会执行</code>。</p><p>如果当前方法没有try…catch处理这个异常对象，throw语句就会<code>代替return语句</code>提前终止当前方法的执行，并返回一个异常对象给调用者。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.keyword;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThrow</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(max(<span class="number">4</span>,<span class="number">2</span>,<span class="number">31</span>,<span class="number">1</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(max(<span class="number">4</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(max());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span>... nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;没有传入任何整数，无法获取最大值&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; max)&#123;</span><br><span class="line">                max = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-自定义异常"><a href="#6-自定义异常" class="headerlink" title="6. 自定义异常"></a>6. 自定义异常</h2><h3 id="6-1-为什么需要自定义异常类"><a href="#6-1-为什么需要自定义异常类" class="headerlink" title="6.1 为什么需要自定义异常类"></a>6.1 为什么需要自定义异常类</h3><p>Java中不同的异常类，分别表示着某一种具体的异常情况。那么在开发中总是有些异常情况是核心类库中没有定义好的，此时我们需要根据自己业务的异常情况来定义异常类。例如年龄负数问题，考试成绩负数问题，某员工已在团队中等。</p><h3 id="6-2-如何自定义异常类"><a href="#6-2-如何自定义异常类" class="headerlink" title="6.2 如何自定义异常类"></a>6.2 如何自定义异常类</h3><p>（1）要继承一个异常类型</p><p>​            自定义一个编译时异常类型：自定义类继承<code>java.lang.Exception</code>。</p><p>​            自定义一个运行时异常类型：自定义类继承<code>java.lang.RuntimeException</code>。</p><p>（2）建议大家提供至少两个构造器，一个是无参构造，一个是(String message)构造器。</p><p>（3）自定义异常需要提供<code>serialVersionUID</code></p><h3 id="6-3-注意点"><a href="#6-3-注意点" class="headerlink" title="6.3 注意点"></a>6.3 注意点</h3><ol><li>自定义的异常只能通过throw抛出。</li><li><p>自定义异常最重要的是异常类的名字和message属性。当异常出现时，可以根据名字判断异常类型。比如：<code>TeamException(&quot;成员已满，无法添加&quot;);</code>、 <code>TeamException(&quot;该员工已是某团队成员&quot;);</code></p></li><li><p>自定义异常对象只能手动抛出。抛出后由try..catch处理，也可以甩锅throws给调用者处理。</p></li></ol><h3 id="6-4-举例"><a href="#6-4-举例" class="headerlink" title="6.4 举例"></a>6.4 举例</h3><p>举例1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">23423423435L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> idnumber;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String message, <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">        <span class="built_in">this</span>.idnumber = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> idnumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyExpTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">regist</span><span class="params">(<span class="type">int</span> num)</span> <span class="keyword">throws</span> MyException &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;人数为负值，不合理&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">&quot;登记人数&quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">manager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            regist(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;登记失败，出错种类&quot;</span> + e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;本次登记操作结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">MyExpTest</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyExpTest</span>();</span><br><span class="line">        t.manager();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>举例2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.define;</span><br><span class="line"><span class="comment">//自定义异常：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotTriangleException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">13465653435L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NotTriangleException</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NotTriangleException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.define;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Triangle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> b;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Triangle</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b, <span class="type">double</span> c)</span> <span class="keyword">throws</span> NotTriangleException &#123;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;=<span class="number">0</span> || b&lt;=<span class="number">0</span> || c&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotTriangleException</span>(<span class="string">&quot;三角形的边长必须是正数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a+b&lt;=c || b+c&lt;=a || a+c&lt;=b)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotTriangleException</span>(a+<span class="string">&quot;,&quot;</span> + b +<span class="string">&quot;,&quot;</span> + c +<span class="string">&quot;不能构造三角形，三角形任意两边之后必须大于第三边&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setA</span><span class="params">(<span class="type">double</span> a)</span> <span class="keyword">throws</span> NotTriangleException&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotTriangleException</span>(<span class="string">&quot;三角形的边长必须是正数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a+b&lt;=c || b+c&lt;=a || a+c&lt;=b)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotTriangleException</span>(a+<span class="string">&quot;,&quot;</span> + b +<span class="string">&quot;,&quot;</span> + c +<span class="string">&quot;不能构造三角形，三角形任意两边之后必须大于第三边&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setB</span><span class="params">(<span class="type">double</span> b)</span> <span class="keyword">throws</span> NotTriangleException &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotTriangleException</span>(<span class="string">&quot;三角形的边长必须是正数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a+b&lt;=c || b+c&lt;=a || a+c&lt;=b)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotTriangleException</span>(a+<span class="string">&quot;,&quot;</span> + b +<span class="string">&quot;,&quot;</span> + c +<span class="string">&quot;不能构造三角形，三角形任意两边之后必须大于第三边&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getC</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setC</span><span class="params">(<span class="type">double</span> c)</span> <span class="keyword">throws</span> NotTriangleException &#123;</span><br><span class="line">        <span class="keyword">if</span>(c&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotTriangleException</span>(<span class="string">&quot;三角形的边长必须是正数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a+b&lt;=c || b+c&lt;=a || a+c&lt;=b)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotTriangleException</span>(a+<span class="string">&quot;,&quot;</span> + b +<span class="string">&quot;,&quot;</span> + c +<span class="string">&quot;不能构造三角形，三角形任意两边之后必须大于第三边&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Triangle&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;a=&quot;</span> + a +</span><br><span class="line">                <span class="string">&quot;, b=&quot;</span> + b +</span><br><span class="line">                <span class="string">&quot;, c=&quot;</span> + c +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.define;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTriangle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Triangle</span> <span class="variable">t</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t = <span class="keyword">new</span> <span class="title class_">Triangle</span>(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;三角形创建成功：&quot;</span>);</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NotTriangleException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;三角形创建失败&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(t != <span class="literal">null</span>) &#123;</span><br><span class="line">                t.setA(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;三角形边长修改成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NotTriangleException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;三角形边长修改失败&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-练习"><a href="#7-练习" class="headerlink" title="7. 练习"></a>7. 练习</h2><p><strong>练习1：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReturnExceptionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;进入方法A&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;制造异常&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;用A方法的finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;进入方法B&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;调用B方法的finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        methodA();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      System.out.println(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    methodB();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>练习2：</strong></p><p>从键盘接收学生成绩，成绩必须在0~100之间。</p><p>自定义成绩无效异常。</p><p>编写方法接收成绩并返回该成绩，如果输入无效，则抛出自定义异常。</p><p><strong>练习3：</strong></p><p>编写应用程序EcmDef.java，接收命令行的两个参数，要求不能输入负数，计算两数相除。<br>对数据类型不一致(NumberFormatException)、缺少命令行参数(ArrayIndexOutOfBoundsException、<br>除0(ArithmeticException)及输入负数(EcDef 自定义的异常)进行异常处理。</p><p>提示：<br>(1)在主类(EcmDef)中定义异常方法(ecm)完成两数相除功能。</p><p>(2)在main()方法中使用异常处理语句进行异常处理。</p><p>(3)在程序中，自定义对应输入负数的异常类(EcDef)。</p><p>(4)运行时接受参数 java EcmDef 20 10   //args[0]=“20” args[1]=“10”</p><p>(5)Interger类的static方法parseInt(String s)将s转换成对应的int值。<br>     如：int a=Interger.parseInt(“314”);    //a=314;</p><h2 id="8-小结与小悟"><a href="#8-小结与小悟" class="headerlink" title="8. 小结与小悟"></a>8. 小结与小悟</h2><h3 id="8-1-小结：异常处理5个关键字"><a href="#8-1-小结：异常处理5个关键字" class="headerlink" title="8.1 小结：异常处理5个关键字"></a>8.1 小结：异常处理5个关键字</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC09%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20220330003738109.png" alt="image-20220330003738109" style="zoom: 67%;"></p><blockquote><p>类比：上游排污，下游治污</p></blockquote><h3 id="8-2-感悟"><a href="#8-2-感悟" class="headerlink" title="8.2 感悟"></a>8.2 感悟</h3><p><strong>小哲理：</strong></p><p>世界上最遥远的<code>距离</code>，是我在<code>if</code>里你在<code>else</code>里，似乎一直相伴又永远分离；</p><p>世界上最痴心的<code>等待</code>，是我当<code>case</code>你是<code>switch</code>，或许永远都选不上自己；</p><p>世界上最真情的<code>相依</code>，是你在<code>try</code>我在<code>catch</code>。无论你发神马脾气，我都默默承受，静静处理。到那时，再来期待我们的<code>finally</code>。</p><p><strong>歌词：</strong></p><p><img src="/2023/02/18/java2023/%E7%AC%AC09%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20220511163035280.png" alt="image-20220511163035280" style="zoom:67%;"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC09%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/try.png" alt="try"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第09章-异常处理&quot;&gt;&lt;a href=&quot;#第09章-异常处理&quot; class=&quot;headerlink&quot; title=&quot;第09章_异常处理&quot;&gt;&lt;/a&gt;第09章_异常处理&lt;/h1&gt;&lt;p&gt;讲师：尚硅谷-宋红康（江湖人称：康师傅）&lt;/p&gt;
&lt;p&gt;官网：&lt;a href=&quot;ht</summary>
      
    
    
    
    <category term="Java2023" scheme="http://example.com/categories/Java2023/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第08章_面向对象编程(高级)</title>
    <link href="http://example.com/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/"/>
    <id>http://example.com/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/</id>
    <published>2023-02-18T12:37:01.000Z</published>
    <updated>2023-03-14T06:16:10.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第08章-面向对象编程-高级"><a href="#第08章-面向对象编程-高级" class="headerlink" title="第08章_面向对象编程(高级)"></a>第08章_面向对象编程(高级)</h1><p>讲师：尚硅谷-宋红康（江湖人称：康师傅）</p><p>官网：<a href="http://www.atguigu.com/">http://www.atguigu.com</a></p><hr><h2 id="本章专题与脉络"><a href="#本章专题与脉络" class="headerlink" title="本章专题与脉络"></a>本章专题与脉络</h2><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/第2阶段：Java面向对象编程-第08章.png" alt="第2阶段：Java面向对象编程-第08章" style="zoom: 40%;"></p><h2 id="1-关键字：static"><a href="#1-关键字：static" class="headerlink" title="1. 关键字：static"></a>1. 关键字：static</h2><p><strong>回顾类中的实例变量（即非static的成员变量）</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">double</span> radius)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.radius=radius;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findArea</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI*radius*radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建两个Circle对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Circle c1=<span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">2.0</span>);<span class="comment">//c1.radius=2.0</span></span><br><span class="line">Circle c2=<span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">3.0</span>);<span class="comment">//c2.radius=3.0</span></span><br></pre></td></tr></table></figure><p>Circle类中的变量radius是一个实例变量(instance variable)，它属于类的每一个对象，c1中的radius变化不会影响c2的radius，反之亦然。</p><p><strong>如果想让一个成员变量被类的所有实例所共享，就用static修饰即可，称为类变量（或类属性）！</strong></p><h3 id="1-1-类属性、类方法的设计思想"><a href="#1-1-类属性、类方法的设计思想" class="headerlink" title="1.1 类属性、类方法的设计思想"></a>1.1 类属性、类方法的设计思想</h3><p>当我们编写一个类时，其实就是在描述其对象的属性和行为，而并没有产生实质上的对象，只有通过new关键字才会产出对象，这时系统才会分配内存空间给对象，其方法才可以供外部调用。我们有时候希望无论是否产生了对象或无论产生了多少对象的情况下，<code>某些特定的数据在内存空间里只有一份</code>。例如，所有的中国人都有个国家名称，每一个中国人都共享这个国家名称，不必在每一个中国人的实例对象中都单独分配一个用于代表国家名称的变量。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220325213629311.png" alt="image-20220325213629311"></p><p>此外，在类中声明的实例方法，在类的外面必须要先创建对象，才能调用。但是有些方法的调用者和当前类的对象无关，这样的方法通常被声明为<code>类方法</code>，由于不需要创建对象就可以调用类方法，从而简化了方法的调用。</p><p>这里的类变量、类方法，只需要使用<code>static</code>修饰即可。所以也称为静态变量、静态方法。</p><h3 id="1-2-static关键字"><a href="#1-2-static关键字" class="headerlink" title="1.2 static关键字"></a>1.2 static关键字</h3><ul><li><p>使用范围：</p><ul><li>在Java类中，可用static修饰属性、方法、代码块、内部类</li></ul></li><li><p>被修饰后的成员具备以下特点：</p><ul><li>随着类的加载而加载</li><li>优先于对象存在</li><li>修饰的成员，被所有对象所共享</li><li>访问权限允许时，可不创建对象，直接被类调用</li></ul></li></ul><h3 id="1-3-静态变量"><a href="#1-3-静态变量" class="headerlink" title="1.3 静态变量"></a>1.3 静态变量</h3><h4 id="1-3-1-语法格式"><a href="#1-3-1-语法格式" class="headerlink" title="1.3.1 语法格式"></a>1.3.1 语法格式</h4><p>使用static修饰的成员变量就是静态变量（或类变量、类属性）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] class 类&#123;</span><br><span class="line">[其他修饰符] <span class="keyword">static</span> 数据类型 变量名;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-2-静态变量的特点"><a href="#1-3-2-静态变量的特点" class="headerlink" title="1.3.2 静态变量的特点"></a>1.3.2 静态变量的特点</h4><ul><li>静态变量的默认值规则和实例变量一样。</li><li><p>静态变量值是所有对象共享。</p></li><li><p>静态变量在本类中，可以在任意方法、代码块、构造器中直接使用。</p></li><li>如果权限修饰符允许，在其他类中可以通过“<code>类名.静态变量</code>”直接访问，也可以通过“<code>对象.静态变量</code>”的方式访问（但是更推荐使用类名.静态变量的方式）。</li><li>静态变量的get/set方法也静态的，当局部变量与静态变量<code>重名时</code>，使用“<code>类名.静态变量</code>”进行区分。</li></ul><h4 id="1-3-3-举例"><a href="#1-3-3-举例" class="headerlink" title="1.3.3 举例"></a>1.3.3 举例</h4><p>举例1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span>&#123;</span><br><span class="line">    <span class="comment">//实例变量</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//类变量</span></span><br><span class="line">    <span class="keyword">static</span> String nation;<span class="comment">//国籍</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chinese</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chinese</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Chinese&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, nation=&#x27;&quot;</span> + nation + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Chinese</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chinese</span>(<span class="string">&quot;康师傅&quot;</span>,<span class="number">36</span>);</span><br><span class="line">        c1.nation = <span class="string">&quot;中华人民共和国&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Chinese</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chinese</span>(<span class="string">&quot;老干妈&quot;</span>,<span class="number">66</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(c1);</span><br><span class="line">        System.out.println(c2);</span><br><span class="line"></span><br><span class="line">        System.out.println(Chinese.nation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的内存结构：（以经典的JDK6内存解析为例，此时静态变量存储在方法区）</p><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220514183814514.png" alt="image-20220514183814514" style="zoom:67%;"></p><p>举例2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.keyword;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> total;<span class="comment">//这里私有化，在类的外面必须使用get/set方法的方式来访问静态变量</span></span><br><span class="line">    <span class="keyword">static</span> String company; <span class="comment">//这里缺省权限修饰符，是为了方便类外以“类名.静态变量”的方式访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span> &#123;</span><br><span class="line">        total++;</span><br><span class="line">        id = total;<span class="comment">//这里使用total静态变量的值为id属性赋值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getTotal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setTotal</span><span class="params">(<span class="type">int</span> total)</span> &#123;</span><br><span class="line">        Employee.total = total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Employee&#123;company = &quot;</span> + company + <span class="string">&quot;,id = &quot;</span> + id + <span class="string">&quot; ,name=&quot;</span> + name +<span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.keyword;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStaticVariable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//静态变量total的默认值是0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Employee.total = &quot;</span> + Employee.getTotal());</span><br><span class="line"></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        System.out.println(e1);<span class="comment">//静态变量company的默认值是null</span></span><br><span class="line">        System.out.println(e2);<span class="comment">//静态变量company的默认值是null</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Employee.total = &quot;</span> + Employee.getTotal());<span class="comment">//静态变量total值是2</span></span><br><span class="line"></span><br><span class="line">        Employee.company = <span class="string">&quot;尚硅谷&quot;</span>;</span><br><span class="line">        System.out.println(e1);<span class="comment">//静态变量company的值是尚硅谷</span></span><br><span class="line">        System.out.println(e2);<span class="comment">//静态变量company的值是尚硅谷</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//只要权限修饰符允许,虽然不推荐，但是也可以通过“对象.静态变量”的形式来访问</span></span><br><span class="line">        e1.company = <span class="string">&quot;超级尚硅谷&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(e1);<span class="comment">//静态变量company的值是超级尚硅谷</span></span><br><span class="line">        System.out.println(e2);<span class="comment">//静态变量company的值是超级尚硅谷</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-4-内存解析"><a href="#1-3-4-内存解析" class="headerlink" title="1.3.4 内存解析"></a>1.3.4 内存解析</h4><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220104100145059.png" alt="image-20220104100145059"></p><h3 id="1-4-静态方法"><a href="#1-4-静态方法" class="headerlink" title="1.4 静态方法"></a>1.4 静态方法</h3><h4 id="1-4-1-语法格式"><a href="#1-4-1-语法格式" class="headerlink" title="1.4.1 语法格式"></a>1.4.1 语法格式</h4><p>用static修饰的成员方法就是静态方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] class 类&#123;</span><br><span class="line">[其他修饰符] <span class="keyword">static</span> 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">        方法体</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-2-静态方法的特点"><a href="#1-4-2-静态方法的特点" class="headerlink" title="1.4.2 静态方法的特点"></a>1.4.2 静态方法的特点</h4><ul><li>静态方法在本类的任意方法、代码块、构造器中都可以直接被调用。</li><li>只要权限修饰符允许，静态方法在其他类中可以通过“类名.静态方法“的方式调用。也可以通过”对象.静态方法“的方式调用（但是更推荐使用类名.静态方法的方式）。</li><li>在static方法内部只能访问类的static修饰的属性或方法，不能访问类的非static的结构。</li><li>静态方法可以被子类继承，但不能被子类重写。</li><li>静态方法的调用都只看编译时类型。</li><li>因为不需要实例就可以访问static方法，因此static方法内部不能有this，也不能有super。如果有重名问题，使用“类名.”进行区别。</li></ul><h4 id="1-4-3-举例"><a href="#1-4-3-举例" class="headerlink" title="1.4.3 举例"></a>1.4.3 举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.keyword;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father.method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father.fun&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.keyword;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"><span class="comment">//    @Override //尝试重写静态方法，加上@Override编译报错，去掉Override不报错，但是也不是重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son.fun&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.keyword;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStaticMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Father.method();</span><br><span class="line">        Son.method();<span class="comment">//继承静态方法</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Father</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        f.method();<span class="comment">//执行Father类中的method</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-练习"><a href="#1-5-练习" class="headerlink" title="1.5 练习"></a>1.5 练习</h3><p>笔试题：如下程序执行会不会报错</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 14:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo</span> <span class="variable">test</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        test.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习：</p><p>编写一个类实现银行账户的概念，包含的属性有“帐号”、“密码”、“存款余额”、“利率”、“最小余额”，定义封装这些属性的方法。<code>账号要自动生成。</code></p><p>编写主类，使用银行账户类，输入、输出3个储户的上述信息。</p><p>考虑：哪些属性可以设计成static属性。</p><h2 id="2-单例-Singleton-设计模式"><a href="#2-单例-Singleton-设计模式" class="headerlink" title="2. 单例(Singleton)设计模式"></a>2. 单例(Singleton)设计模式</h2><h3 id="2-1-设计模式概述"><a href="#2-1-设计模式概述" class="headerlink" title="2.1 设计模式概述"></a>2.1 设计模式概述</h3><p><strong>设计模式</strong>是在大量的<code>实践中总结</code>和<code>理论化</code>之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式免去我们自己再思考和摸索。就像是经典的棋谱，不同的棋局，我们用不同的棋谱。”套路”</p><p>经典的设计模式共有23种。每个设计模式均是特定环境下特定问题的处理方法。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220520174508815.png" alt="image-20220520174508815" style="zoom: 80%;"></p><blockquote><p>简单工厂模式并不是23中经典模式的一种，是其中工厂方法模式的简化版</p><p>对软件设计模式的研究造就了一本可能是面向对象设计方面最有影响的书籍：《设计模式》：《Design Patterns: Elements of Reusable Object-Oriented Software》（即后述《设计模式》一书），由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合著（Addison-Wesley，1995）。这几位作者常被称为”四人组（Gang of Four）”，而这本书也就被称为”四人组（或 GoF）”书。</p></blockquote><h3 id="2-2-何为单例模式"><a href="#2-2-何为单例模式" class="headerlink" title="2.2 何为单例模式"></a>2.2 何为单例模式</h3><p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类<strong>只能存在一个对象实例</strong>，并且该类只提供一个取得其对象实例的方法。</p><h3 id="2-3-实现思路"><a href="#2-3-实现思路" class="headerlink" title="2.3 实现思路"></a>2.3 实现思路</h3><p>如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将<code>类的构造器的访问权限设置为private</code>，这样，就不能用new操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，<code>只能调用该类的某个静态方法</code>以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的<code>该类对象的变量也必须定义成静态的</code>。</p><h3 id="2-4-单例模式的两种实现方式"><a href="#2-4-单例模式的两种实现方式" class="headerlink" title="2.4 单例模式的两种实现方式"></a>2.4 单例模式的两种实现方式</h3><h4 id="2-4-1-饿汉式"><a href="#2-4-1-饿汉式" class="headerlink" title="2.4.1 饿汉式"></a>2.4.1 饿汉式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1.私有化构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.内部提供一个当前类的实例</span></span><br><span class="line">    <span class="comment">// 4.此实例也必须静态化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">single</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.提供公共的静态的方法，返回当前类的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-4-2-懒汉式"><a href="#2-4-2-懒汉式" class="headerlink" title="2.4.2 懒汉式"></a>2.4.2 懒汉式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1.私有化构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.内部提供一个当前类的实例</span></span><br><span class="line">    <span class="comment">// 4.此实例也必须静态化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton single;</span><br><span class="line">    <span class="comment">// 3.提供公共的静态的方法，返回当前类的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(single == <span class="literal">null</span>) &#123;</span><br><span class="line">            single = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-4-3-饿汉式-vs-懒汉式"><a href="#2-4-3-饿汉式-vs-懒汉式" class="headerlink" title="2.4.3 饿汉式 vs 懒汉式"></a>2.4.3 饿汉式 vs 懒汉式</h4><p>饿汉式：</p><ul><li>特点：<code>立即加载</code>，即在使用类的时候已经将对象创建完毕。</li><li>优点：实现起来<code>简单</code>；没有多线程安全问题。</li><li>缺点：当类被加载的时候，会初始化static的实例，静态变量被创建并分配内存空间，从这以后，这个static的实例便一直占着这块内存，直到类被卸载时，静态变量被摧毁，并释放所占有的内存。因此在某些特定条件下会<code>耗费内存</code>。</li></ul><p>懒汉式：</p><ul><li>特点：<code>延迟加载</code>，即在调用静态方法时实例才被创建。</li><li>优点：实现起来比较简单；当类被加载的时候，static的实例未被创建并分配内存空间，当静态方法第一次被调用时，初始化实例变量，并分配内存，因此在某些特定条件下会<code>节约内存</code>。</li><li>缺点：在多线程环境中，这种实现方法是完全错误的，<code>线程不安全</code>，根本不能保证单例的唯一性。<ul><li>说明：在多线程章节，会将懒汉式改造成线程安全的模式。</li></ul></li></ul><h3 id="2-5-单例模式的优点及应用场景"><a href="#2-5-单例模式的优点及应用场景" class="headerlink" title="2.5 单例模式的优点及应用场景"></a>2.5 单例模式的优点及应用场景</h3><p>由于单例模式只生成一个实例，减少了<code>系统性能开销</code>，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。</p><p>举例：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220325222541203.png" alt="image-20220325222541203" style="zoom:67%;"></p><p><strong>应用场景</strong></p><ul><li>Windows的Task Manager (任务管理器)就是很典型的单例模式</li><li>Windows的Recycle Bin (回收站)也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。</li><li><p>Application 也是单例的典型应用</p></li><li><p>应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只</p><p>能有一个实例去操作，否则内容不好追加。</p></li><li>数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。</li></ul><h2 id="3-理解main方法的语法"><a href="#3-理解main方法的语法" class="headerlink" title="3. 理解main方法的语法"></a>3. 理解main方法的语法</h2><p>由于JVM需要调用类的main()方法，所以该方法的访问权限必须是public，又因为JVM在执行main()方法时不必创建对象，所以该方法必须是static的，该方法接收一个String类型的数组参数，该数组中保存执行Java命令时传递给所运行的类的参数。 </p><p>又因为main() 方法是静态的，我们不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员，这种情况，我们在之前的例子中多次碰到。</p><p><strong>命令行参数用法举例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommandPara</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;args[&quot;</span> + i + <span class="string">&quot;] = &quot;</span> + args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//运行程序CommandPara.java</span></span><br><span class="line">java CommandPara <span class="string">&quot;Tom&quot;</span> <span class="string">&quot;Jerry&quot;</span> <span class="string">&quot;Shkstart&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">args[<span class="number">0</span>] = Tom</span><br><span class="line">args[<span class="number">1</span>] = Jerry</span><br><span class="line">args[<span class="number">2</span>] = Shkstart</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220325223215924.png" alt="image-20220325223215924"></p><p>IDEA工具：</p><p>（1）配置运行参数</p><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20211228101828718.png" alt="image-20211228101828718" style="zoom: 80%;"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20211228102022216.png" alt="image-20211228102022216" style="zoom:67%;"></p><p>（2）运行程序</p><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20211228102059327.png" alt="image-20211228102059327" style="zoom: 80%;"></p><p>笔试题：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此处，Something类的文件名叫OtherThing.java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Something</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] something_to_do)</span> &#123;        </span><br><span class="line">        System.out.println(<span class="string">&quot;Do something ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//上述程序是否可以正常编译、运行？ </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-类的成员之四：代码块"><a href="#4-类的成员之四：代码块" class="headerlink" title="4. 类的成员之四：代码块"></a>4. 类的成员之四：代码块</h2><p>如果成员变量想要初始化的值不是一个硬编码的常量值，而是需要通过复杂的计算或读取文件、或读取运行环境信息等方式才能获取的一些值，该怎么办呢？此时，可以考虑代码块（或初始化块）。</p><ul><li><p>代码块(或初始化块)的<code>作用</code>：</p><ul><li>对Java类或对象进行初始化</li></ul></li><li><p>代码块(或初始化块)的<code>分类</code>：</p><ul><li><p>一个类中代码块若有修饰符，则只能被static修饰，称为静态代码块(static block)</p></li><li><p>没有使用static修饰的，为非静态代码块。</p></li></ul></li></ul><h3 id="4-1-静态代码块"><a href="#4-1-静态代码块" class="headerlink" title="4.1 静态代码块"></a>4.1 静态代码块</h3><p>如果想要为静态变量初始化，可以直接在静态变量的声明后面直接赋值，也可以使用静态代码块。</p><h4 id="4-1-1-语法格式"><a href="#4-1-1-语法格式" class="headerlink" title="4.1.1 语法格式"></a>4.1.1 语法格式</h4><p>在代码块的前面加static，就是静态代码块。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 class 类&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">        静态代码块</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-2-静态代码块的特点"><a href="#4-1-2-静态代码块的特点" class="headerlink" title="4.1.2 静态代码块的特点"></a>4.1.2 静态代码块的特点</h4><ol><li><p>可以有输出语句。</p><ol><li><p>可以对类的属性、类的声明进行初始化操作。</p></li><li><p>不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法。</p></li><li><p>若有多个静态的代码块，那么按照从上到下的顺序依次执行。</p></li><li><p>静态代码块的执行要先于非静态代码块。</p></li><li><p>静态代码块随着类的加载而加载，且只执行一次。</p></li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.keyword;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chinese</span> &#123;</span><br><span class="line"><span class="comment">//    private static String country = &quot;中国&quot;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String country;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;非静态代码块，country = &quot;</span> + country);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        country = <span class="string">&quot;中国&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chinese</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.keyword;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStaticBlock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Chinese</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chinese</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="type">Chinese</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chinese</span>(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-2-非静态代码块"><a href="#4-2-非静态代码块" class="headerlink" title="4.2 非静态代码块"></a>4.2 非静态代码块</h3><h4 id="4-2-1-语法格式"><a href="#4-2-1-语法格式" class="headerlink" title="4.2.1 语法格式"></a>4.2.1 语法格式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 class 类&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        非静态代码块</span><br><span class="line">    &#125;</span><br><span class="line">    【修饰符】 构造器名()&#123;</span><br><span class="line">    <span class="comment">// 实例初始化代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    【修饰符】 构造器名(参数列表)&#123;</span><br><span class="line">        <span class="comment">// 实例初始化代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-2-非静态代码块的作用"><a href="#4-2-2-非静态代码块的作用" class="headerlink" title="4.2.2 非静态代码块的作用"></a>4.2.2 非静态代码块的作用</h4><p>和构造器一样，也是用于实例变量的初始化等操作。</p><h4 id="4-2-3-非静态代码块的意义"><a href="#4-2-3-非静态代码块的意义" class="headerlink" title="4.2.3 非静态代码块的意义"></a>4.2.3 非静态代码块的意义</h4><p>如果多个重载的构造器有公共代码，并且这些代码都是先于构造器其他代码执行的，那么可以将这部分代码抽取到非静态代码块中，减少冗余代码。</p><h4 id="4-2-4-非静态代码块的执行特点"><a href="#4-2-4-非静态代码块的执行特点" class="headerlink" title="4.2.4 非静态代码块的执行特点"></a>4.2.4 非静态代码块的执行特点</h4><ol><li><p>可以有输出语句。</p><ol><li><p>可以对类的属性、类的声明进行初始化操作。</p></li><li><p>除了调用非静态的结构外，还可以调用静态的变量或方法。</p></li><li><p>若有多个非静态的代码块，那么按照从上到下的顺序依次执行。</p></li><li><p>每次创建对象的时候，都会执行一次。且先于构造器执行。</p></li></ol></li></ol><h3 id="4-3-举例"><a href="#4-3-举例" class="headerlink" title="4.3 举例"></a>4.3 举例</h3><p><strong>举例1：</strong></p><p>（1）声明User类，</p><ul><li><p>包含属性：username（String类型），password（String类型），registrationTime（long类型），私有化</p></li><li><p>包含get/set方法，其中registrationTime没有set方法</p></li><li><p>包含无参构造，</p><ul><li>输出“新用户注册”，</li><li>registrationTime赋值为当前系统时间，</li><li>username就默认为当前系统时间值，</li><li>password默认为“123456”</li></ul></li><li><p>包含有参构造(String username, String password)，</p><ul><li>输出“新用户注册”，</li><li>registrationTime赋值为当前系统时间，</li><li>username和password由参数赋值</li></ul></li><li><p>包含public String getInfo()方法，返回：“用户名：xx，密码：xx，注册时间：xx”</p></li></ul><p>（2）编写测试类，测试类main方法的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    System.out.println(u1.getInfo());</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;song&quot;</span>,<span class="string">&quot;8888&quot;</span>);</span><br><span class="line">    System.out.println(u2.getInfo());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不用非静态代码块，User类是这样的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.block.no;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> registrationTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;新用户注册&quot;</span>);</span><br><span class="line">        registrationTime = System.currentTimeMillis();</span><br><span class="line">        username = registrationTime+<span class="string">&quot;&quot;</span>;</span><br><span class="line">        password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String username,String password)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;新用户注册&quot;</span>);</span><br><span class="line">        registrationTime = System.currentTimeMillis();</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getRegistrationTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> registrationTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;用户名：&quot;</span> + username + <span class="string">&quot;，密码：&quot;</span> + password + <span class="string">&quot;，注册时间：&quot;</span> + registrationTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果提取构造器公共代码到非静态代码块，User类是这样的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.block.use;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> registrationTime;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;新用户注册&quot;</span>);</span><br><span class="line">        registrationTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">        username = registrationTime+<span class="string">&quot;&quot;</span>;</span><br><span class="line">        password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getRegistrationTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> registrationTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;用户名：&quot;</span> + username + <span class="string">&quot;，密码：&quot;</span> + password + <span class="string">&quot;，注册时间：&quot;</span> + registrationTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>举例2：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">is = DBCPTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;dbcp.properties&quot;</span>);</span><br><span class="line"><span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">pros.load(is);</span><br><span class="line"><span class="comment">//调用BasicDataSourceFactory的静态方法，获取数据源。</span></span><br><span class="line">dataSource = BasicDataSourceFactory.createDataSource(pros);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(is != <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">is.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-小结：实例变量赋值顺序"><a href="#4-4-小结：实例变量赋值顺序" class="headerlink" title="4.4 小结：实例变量赋值顺序"></a>4.4 小结：实例变量赋值顺序</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220325230208941.png" alt="image-20220325230208941" style="zoom:67%;"></p><h3 id="4-5-练习"><a href="#4-5-练习" class="headerlink" title="4.5 练习"></a>4.5 练习</h3><p>练习1：分析加载顺序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Root</span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Root的静态初始化块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Root的普通初始化块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Root</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Root的无参数的构造器&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mid</span> <span class="keyword">extends</span> <span class="title class_">Root</span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Mid的静态初始化块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Mid的普通初始化块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Mid</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Mid的无参数的构造器&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Mid</span><span class="params">(String msg)</span>&#123;</span><br><span class="line"><span class="comment">//通过this调用同一类中重载的构造器</span></span><br><span class="line"><span class="built_in">this</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;Mid的带参数构造器，其参数值：&quot;</span></span><br><span class="line">+ msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Leaf</span> <span class="keyword">extends</span> <span class="title class_">Mid</span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Leaf的静态初始化块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Leaf的普通初始化块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Leaf</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//通过super调用父类中有一个字符串参数的构造器</span></span><br><span class="line"><span class="built_in">super</span>(<span class="string">&quot;尚硅谷&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Leaf的构造器&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeafTest</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Leaf</span>(); </span><br><span class="line"><span class="comment">//new Leaf();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习2：分析加载顺序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;11111111111&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;22222222222&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;33333333333&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;44444444444&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;55555555555&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;66666666666&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">System.out.println(<span class="string">&quot;77777777777&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>练习3：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu05.field.interview;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 16:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Zi</span> <span class="variable">zi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> getNum(<span class="string">&quot;（1）i&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> getNum(<span class="string">&quot;（2）j&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        print(<span class="string">&quot;（3）父类静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        print(<span class="string">&quot;（4）父类非静态代码块，又称为构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Fu()&#123;</span><br><span class="line">        print(<span class="string">&quot;（5）父类构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        System.out.println(str + <span class="string">&quot;-&gt;&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        print(str);</span><br><span class="line">        <span class="keyword">return</span> ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> getNum(<span class="string">&quot;（6）k&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> getNum(<span class="string">&quot;（7）h&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        print(<span class="string">&quot;（8）子类静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        print(<span class="string">&quot;（9）子类非静态代码块，又称为构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Zi()&#123;</span><br><span class="line">        print(<span class="string">&quot;（10）子类构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        System.out.println(str + <span class="string">&quot;-&gt;&quot;</span> + k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        print(str);</span><br><span class="line">        <span class="keyword">return</span> ++k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-final关键字"><a href="#5-final关键字" class="headerlink" title="5. final关键字"></a>5. final关键字</h2><h3 id="5-1-final的意义"><a href="#5-1-final的意义" class="headerlink" title="5.1 final的意义"></a>5.1 final的意义</h3><p>final：最终的，不可更改的</p><h3 id="5-2-final的使用"><a href="#5-2-final的使用" class="headerlink" title="5.2 final的使用"></a>5.2 final的使用</h3><h4 id="5-2-1-final修饰类"><a href="#5-2-1-final修饰类" class="headerlink" title="5.2.1 final修饰类"></a>5.2.1 final修饰类</h4><p>表示这个类不能被继承，没有子类。提高安全性，提高程序的可读性。</p><p>例如：String类、System类、StringBuffer类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Eunuch</span>&#123;<span class="comment">//太监类</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Eunuch</span>&#123;<span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-2-final修饰方法"><a href="#5-2-2-final修饰方法" class="headerlink" title="5.2.2 final修饰方法"></a>5.2.2 final修饰方法</h4><p>表示这个方法不能被子类重写。</p><p>例如：Object类中的getClass()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;father&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;<span class="comment">//错误</span></span><br><span class="line">System.out.println(<span class="string">&quot;son&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-3-final修饰变量"><a href="#5-2-3-final修饰变量" class="headerlink" title="5.2.3 final修饰变量"></a>5.2.3 final修饰变量</h4><p>final修饰某个变量（成员变量或局部变量），一旦赋值，它的值就不能被修改，即常量，常量名建议使用大写字母。</p><p>例如：final double MY_PI = 3.14;</p><blockquote><p>如果某个成员变量用final修饰后，没有set方法，并且必须初始化（可以显式赋值、或在初始化块赋值、实例变量还可以在构造器中赋值）</p></blockquote><ul><li>修饰成员变量</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">totalNumber</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> ID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line">        ID = ++totalNumber; <span class="comment">// 可在构造器中给final修饰的“变量”赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        System.out.println(t.ID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>修饰局部变量：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFinal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> MIN_SCORE ;</span><br><span class="line">        MIN_SCORE = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SCORE</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        MAX_SCORE = <span class="number">200</span>; <span class="comment">//非法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>错误演示：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">INFO</span> <span class="operator">=</span> <span class="string">&quot;atguigu&quot;</span>;  <span class="comment">//声明常量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//The final field A.INFO cannot be  assigned</span></span><br><span class="line">        <span class="comment">//INFO = &quot;尚硅谷&quot;; </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-3-笔试题"><a href="#5-3-笔试题" class="headerlink" title="5.3 笔试题"></a>5.3 笔试题</h3><p>题1：排错</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Something</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addOne</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ++x;</span><br><span class="line">        <span class="comment">// return x + 1;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题2：排错</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Something</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Other</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Other</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Something</span>().addOne(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addOne</span><span class="params">(<span class="keyword">final</span> Other o)</span> &#123;</span><br><span class="line">        <span class="comment">// o = new Other();</span></span><br><span class="line">        o.i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Other</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-抽象类与抽象方法-或abstract关键字"><a href="#6-抽象类与抽象方法-或abstract关键字" class="headerlink" title="6. 抽象类与抽象方法(或abstract关键字)"></a>6. 抽象类与抽象方法(或abstract关键字)</h2><h3 id="6-1-由来"><a href="#6-1-由来" class="headerlink" title="6.1 由来"></a>6.1 由来</h3><p>举例1：</p><p>随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220325231608838.png" alt="image-20220325231608838"></p><p>举例2：</p><p>我们声明一些几何图形类：圆、矩形、三角形类等，发现这些类都有共同特征：求面积、求周长。那么这些共同特征应该抽取到一个共同父类：几何图形类中。但是这些方法在父类中又<code>无法给出具体的实现</code>，而是应该交给子类各自具体实现。那么父类在声明这些方法时，<code>就只有方法签名，没有方法体</code>，我们把没有方法体的方法称为<strong>抽象方法</strong>。Java语法规定，包含抽象方法的类必须是<strong>抽象类</strong>。</p><h3 id="6-2-语法格式"><a href="#6-2-语法格式" class="headerlink" title="6.2 语法格式"></a>6.2 语法格式</h3><ul><li><strong>抽象类</strong>：被abstract修饰的类。</li><li><strong>抽象方法</strong>：被abstract修饰没有方法体的方法。</li></ul><p>抽象类的语法格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[权限修饰符] <span class="keyword">abstract</span> class 类名&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">[权限修饰符] <span class="keyword">abstract</span> class 类名 extends 父类&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象方法的语法格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[其他修饰符] <span class="keyword">abstract</span> 返回值类型 方法名([形参列表]);</span><br></pre></td></tr></table></figure><blockquote><p>注意：抽象方法没有方法体</p></blockquote><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220517204707255.png" alt="image-20220517204707255"></p><p>代码举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span> <span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;小猫吃鱼和猫粮&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CatTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建子类对象</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(); </span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 调用eat方法</span></span><br><span class="line">        c.eat();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做<strong>实现方法</strong>。</p><h3 id="6-3-使用说明"><a href="#6-3-使用说明" class="headerlink" title="6.3 使用说明"></a>6.3 使用说明</h3><ol><li><p>抽象类<strong>不能创建对象</strong>，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。</p><blockquote><p>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</p><p>抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。若没有重写全部的抽象方法，仍为抽象类。</p></blockquote></li><li><p>抽象类中，也有构造方法，是供子类创建对象时，初始化父类成员变量使用的。</p><blockquote><p>理解：子类的构造方法中，有默认的super()或手动的super(实参列表)，需要访问父类构造方法。</p></blockquote></li><li><p>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p><blockquote><p>理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。</p></blockquote></li><li><p>抽象类的子类，必须重写抽象父类中<strong>所有的</strong>抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。 </p><blockquote><p>理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</p></blockquote></li></ol><h3 id="6-4-注意事项"><a href="#6-4-注意事项" class="headerlink" title="6.4 注意事项"></a>6.4 注意事项</h3><ul><li><p>不能用abstract修饰变量、代码块、构造器；</p></li><li><p>不能用abstract修饰私有方法、静态方法、final的方法、final的类。</p></li></ul><h3 id="6-5-应用举例1"><a href="#6-5-应用举例1" class="headerlink" title="6.5 应用举例1"></a>6.5 应用举例1</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220325232847872.png" alt="image-20220325232847872"></p><p>在航运公司系统中，Vehicle类需要定义两个方法分别<code>计算运输工具的燃料效率</code>和<code>行驶距离</code>。</p><p><strong>问题：</strong>卡车(Truck)和驳船(RiverBarge)的燃料效率和行驶距离的计算方法完全不同。Vehicle类不能提供计算方法，但子类可以。</p><p><strong>解决方案：</strong>Java允许类设计者指定：超类声明一个方法但不提供实现，该方法的实现由子类提供。这样的方法称为抽象方法。有一个或更多抽象方法的类称为抽象类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Vehicle是一个抽象类，有两个抽象方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Vehicle</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">calcFuelEfficiency</span><span class="params">()</span>;<span class="comment">//计算燃料效率的抽象方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">calcTripDistance</span><span class="params">()</span>;<span class="comment">//计算行驶距离的抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Truck</span> <span class="keyword">extends</span> <span class="title class_">Vehicle</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcFuelEfficiency</span><span class="params">( )</span>   &#123; <span class="comment">//写出计算卡车的燃料效率的具体方法   &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcTripDistance</span><span class="params">( )</span>    &#123;  <span class="comment">//写出计算卡车行驶距离的具体方法   &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RiverBarge</span> <span class="keyword">extends</span> <span class="title class_">Vehicle</span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcFuelEfficiency</span><span class="params">( )</span> &#123; <span class="comment">//写出计算驳船的燃料效率的具体方法  &#125;</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcTripDistance</span><span class="params">( )</span>  &#123;  <span class="comment">//写出计算驳船行驶距离的具体方法&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-6-应用举例2：模板方法设计模式-TemplateMethod"><a href="#6-6-应用举例2：模板方法设计模式-TemplateMethod" class="headerlink" title="6.6 应用举例2：模板方法设计模式(TemplateMethod)"></a>6.6 应用举例2：模板方法设计模式(TemplateMethod)</h3><p>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。</p><p><strong>解决的问题</strong>：</p><ul><li><p>当功能内部一部分实现是确定的，另一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。</p></li><li><p>换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。</p></li></ul><p><strong>类比举例：</strong>英语六级模板</p><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220503145003315.png" alt="image-20220503145003315" style="zoom: 80%;"></p><p>制作月饼的模板：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220517205013997.png" alt="image-20220517205013997" style="zoom: 50%;"></p><p>举例1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Template</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">getTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        code();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行时间是：&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubTemplate</span> <span class="keyword">extends</span> <span class="title class_">Template</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>举例2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.java;</span><br><span class="line"><span class="comment">//抽象类的应用：模板方法的设计模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TemplateMethodTest</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">BankTemplateMethod</span> <span class="variable">btm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DrawMoney</span>();</span><br><span class="line">btm.process();</span><br><span class="line"></span><br><span class="line"><span class="type">BankTemplateMethod</span> <span class="variable">btm2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ManageMoney</span>();</span><br><span class="line">btm2.process();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BankTemplateMethod</span> &#123;</span><br><span class="line"><span class="comment">// 具体方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">takeNumber</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;取号排队&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">transact</span><span class="params">()</span>; <span class="comment">// 办理具体的业务 //钩子方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">evaluate</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;反馈评分&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板方法，把基本操作组合到一起，子类一般不能重写</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.takeNumber();</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.transact();<span class="comment">// 像个钩子，具体执行时，挂哪个子类，就执行哪个子类的实现代码</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.evaluate();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DrawMoney</span> <span class="keyword">extends</span> <span class="title class_">BankTemplateMethod</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transact</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;我要取款！！！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ManageMoney</span> <span class="keyword">extends</span> <span class="title class_">BankTemplateMethod</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transact</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;我要理财！我这里有2000万美元!!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>模板方法设计模式是编程中经常用得到的模式。各个框架、类库中都有他的影子，比如常见的有：</p><ul><li><p>数据库访问的封装</p></li><li><p>Junit单元测试</p></li><li><p>JavaWeb的Servlet中关于doGet/doPost方法调用</p></li><li><p>Hibernate中模板程序</p></li><li><p>Spring中JDBCTemlate、HibernateTemplate等</p></li></ul><h3 id="6-7-思考与练习"><a href="#6-7-思考与练习" class="headerlink" title="6.7 思考与练习"></a>6.7 思考与练习</h3><p><strong>思考：</strong></p><p>问题1：为什么抽象类不可以使用final关键字声明？</p><p>问题2：一个抽象类中可以定义构造器吗？</p><p>问题3：是否可以这样理解：抽象类就是比普通类多定义了抽象方法，除了不能直接进行类的实例化操作之外，并没有任何的不同？</p><p><strong>练习1：</strong></p><p>编写一个Employee类，声明为抽象类，包含如下三个属性：name，id，salary。提供必要的构造器和抽象方法：work()。</p><p>对于Manager类来说，他既是员工，还具有奖金(bonus)的属性。</p><p>请使用继承的思想，设计CommonEmployee类和Manager类，要求类中提供必要的方法进行属性访问。</p><p><strong>练习2：软件外包公司外派管理</strong></p><p>有一家软件外包公司，可以外派开发人员，该公司有两个角色：普通开发人员Developer和项目经理Manager。他们的关系如下图：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220504164925878.png" alt="image-20220504164925878"></p><p>普通开发人员的工作内容是“开发项目”，项目经理的工作内容是“项目管理”。对外的报价是普通开发人员每天500,元，超过60天每天400元。项目经理每天800元，超过60天每天700元。</p><p>有一家银行需要1名项目经理、2名开发人员，现场开发90天，计算银行需要付给软件公司的总金额。</p><p>提示：创建数组 Employee[] emps = new Employee[3]。其中存储驻场的3名员工。</p><p><strong>练习3：</strong></p><p>创建父类Shape，包含绘制形状的抽象方法draw()。</p><p>创建Shape的子类Circle和Rectangle，重写draw()方法，绘制圆形和矩形。</p><p>绘制多个圆形和矩形。</p><p><strong>练习4：</strong></p><p>1、声明抽象父类Person，包含抽象方法public abstract void eat();<br>2、声明子类中国人Chinese，重写抽象方法，打印用筷子吃饭<br>3、声明子类美国人American，重写抽象方法，打印用刀叉吃饭<br>4、声明子类印度人Indian，重写抽象方法，打印用手抓饭<br>5、声明测试类PersonTest，创建Person数组，存储各国人对象，并遍历数组，调用eat()方法</p><p><strong>练习5：工资系统设计</strong></p><p>编写工资系统，实现不同类型员工(多态)的按月发放工资。如果当月出现某个Employee对象的生日，则将该雇员的工资增加100元。</p><p>实验说明：</p><p>（1）定义一个Employee类，该类包含：</p><p>private成员变量name,number,birthday，其中birthday 为MyDate类的对象；</p><p>abstract方法earnings()；</p><p>toString()方法输出对象的name,number和birthday。</p><p>（2）MyDate类包含:</p><p>private成员变量year,month,day ；</p><p>toDateString()方法返回日期对应的字符串：xxxx年xx月xx日</p><p>（3）定义SalariedEmployee类继承Employee类，实现按月计算工资的员工处理。该类包括：private成员变量monthlySalary；</p><p>实现父类的抽象方法earnings(),该方法返回monthlySalary值；toString()方法输出员工类型信息及员工的name，number,birthday。</p><p>（4）参照SalariedEmployee类定义HourlyEmployee类，实现按小时计算工资的员工处理。该类包括：</p><p>private成员变量wage和hour；</p><p>实现父类的抽象方法earnings(),该方法返回wage*hour值；</p><p>toString()方法输出员工类型信息及员工的name，number,birthday。</p><p>（5）定义PayrollSystem类，创建Employee变量数组并初始化，该数组存放各类雇员对象的引用。利用循环结构遍历数组元素，输出各个对象的类型,name,number,birthday,以及该对象生日。当键盘输入本月月份值时，如果本月是某个Employee对象的生日，还要输出增加工资信息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//提示：</span></span><br><span class="line"><span class="comment">//定义People类型的数组People c1[]=new People[10];</span></span><br><span class="line"><span class="comment">//数组元素赋值</span></span><br><span class="line">c1[<span class="number">0</span>]=<span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&quot;John&quot;</span>,<span class="string">&quot;0001&quot;</span>,<span class="number">20</span>);</span><br><span class="line">c1[<span class="number">1</span>]=<span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&quot;Bob&quot;</span>,<span class="string">&quot;0002&quot;</span>,<span class="number">19</span>);</span><br><span class="line"><span class="comment">//若People有两个子类Student和Officer，则数组元素赋值时，可以使父类类型的数组元素指向子类。</span></span><br><span class="line">c1[<span class="number">0</span>]=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;John&quot;</span>,<span class="string">&quot;0001&quot;</span>,<span class="number">20</span>,<span class="number">85.0</span>);</span><br><span class="line">c1[<span class="number">1</span>]=<span class="keyword">new</span> <span class="title class_">Officer</span>(<span class="string">&quot;Bob&quot;</span>,<span class="string">&quot;0002&quot;</span>,<span class="number">19</span>,<span class="number">90.5</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7-接口-interface"><a href="#7-接口-interface" class="headerlink" title="7. 接口(interface)"></a>7. 接口(interface)</h2><h3 id="7-1-类比"><a href="#7-1-类比" class="headerlink" title="7.1 类比"></a>7.1 类比</h3><p>生活中大家每天都在用USB接口，那么USB接口与我们今天要学习的接口有什么相同点呢？</p><pre><code> USB，（Universal Serial Bus，通用串行总线）是Intel公司开发的总线架构，使得在计算机上添加串行设备（鼠标、键盘、打印机、扫描仪、摄像头、充电器、MP3机、手机、数码相机、移动硬盘等）非常容易。</code></pre><p>其实，不管是电脑上的USB插口，还是其他设备上的USB插口都只是<code>遵循了USB规范</code>的一种具体设备而已。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/bbcc80f541000c71b81650cfaa770c86.png" alt="bbcc80f541000c71b81650cfaa770c86"></p><p>只要设备遵循USB规范的，那么就可以与电脑互联，并正常通信。至于这个设备、电脑是哪个厂家制造的，内部是如何实现的，我们都无需关心。</p><p>Java的软件系统会有很多模块组成，那么各个模块之间也应该采用这种<code>面向接口</code>的<code>低耦合</code>，为系统提供更好的可扩展性和可维护性。</p><h3 id="7-2-概述"><a href="#7-2-概述" class="headerlink" title="7.2 概述"></a>7.2 概述</h3><p>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要…则必须能…”的思想。继承是一个”是不是”的is-a关系，而接口实现则是 “能不能”的<code>has-a</code>关系。</p><ul><li>例如：电脑都预留了可以插入USB设备的USB接口，USB接口具备基本的数据传输的开启功能和关闭功能。你能不能用USB进行连接，或是否具备USB通信功能，就看你能否遵循USB接口规范</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220517211517846.png" alt="image-20220517211517846" style="zoom:67%;"></p><ul><li>例如：Java程序是否能够连接使用某种数据库产品，那么要看该数据库产品能否实现Java设计的JDBC规范</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220325235434103.png" alt="image-20220325235434103" style="zoom:67%;"></p><blockquote><p>接口的本质是契约、标准、规范，就像我们的法律一样。制定好后大家都要遵守。</p></blockquote><h3 id="7-3-定义格式"><a href="#7-3-定义格式" class="headerlink" title="7.3 定义格式"></a>7.3 定义格式</h3><p>接口的定义，它与定义类方式相似，但是使用 <code>interface</code> 关键字。它也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。</p><blockquote><p>引用数据类型：数组，类，枚举，接口，注解。</p></blockquote><h4 id="7-3-1-接口的声明格式"><a href="#7-3-1-接口的声明格式" class="headerlink" title="7.3.1 接口的声明格式"></a>7.3.1 接口的声明格式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] interface 接口名&#123;</span><br><span class="line">    <span class="comment">//接口的成员列表：</span></span><br><span class="line">    <span class="comment">// 公共的静态常量</span></span><br><span class="line">    <span class="comment">// 公共的抽象方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 公共的默认方法（JDK1.8以上）</span></span><br><span class="line">    <span class="comment">// 公共的静态方法（JDK1.8以上）</span></span><br><span class="line">    <span class="comment">// 私有方法（JDK1.9以上）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">USB3</span>&#123;</span><br><span class="line">    <span class="comment">//静态常量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">MAX_SPEED</span> <span class="operator">=</span> <span class="number">500</span>*<span class="number">1024</span>*<span class="number">1024</span>;<span class="comment">//500MB/s</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">in</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认方法</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;USB 3.0可以同步全速地进行读写操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-3-2-接口的成员说明"><a href="#7-3-2-接口的成员说明" class="headerlink" title="7.3.2 接口的成员说明"></a>7.3.2 接口的成员说明</h4><p><strong>在JDK8.0 之前</strong>，接口中只允许出现：</p><p>（1）公共的静态的常量：其中<code>public static final</code>可以省略</p><p>（2）公共的抽象的方法：其中<code>public abstract</code>可以省略</p><blockquote><p>理解：接口是从多个相似类中抽象出来的规范，不需要提供具体实现</p></blockquote><p><strong>在JDK8.0 时</strong>，接口中允许声明<code>默认方法</code>和<code>静态方法</code>：</p><p>（3）公共的默认的方法：其中public 可以省略，建议保留，但是default不能省略</p><p>（4）公共的静态的方法：其中public 可以省略，建议保留，但是static不能省略</p><p><strong>在JDK9.0 时</strong>，接口又增加了：</p><p>（5）私有方法</p><p>除此之外，接口中没有构造器，没有初始化块，因为接口中没有成员变量需要动态初始化。</p><h3 id="7-4-接口的使用规则"><a href="#7-4-接口的使用规则" class="headerlink" title="7.4 接口的使用规则"></a>7.4 接口的使用规则</h3><p><strong>1、类实现接口（implements）</strong></p><p>接口<strong>不能创建对象</strong>，但是可以被类实现（<code>implements</code> ，类似于被继承）。</p><p>类与接口的关系为实现关系，即<strong>类实现接口</strong>，该类可以称为接口的实现类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 <code>implements</code>关键字。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 class 实现类  implements 接口&#123;</span><br><span class="line"><span class="comment">// 重写接口中抽象方法【必须】，当然如果实现类是抽象类，那么可以不重写</span></span><br><span class="line">  <span class="comment">// 重写接口中默认方法【可选】</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【修饰符】 class 实现类 extends 父类 implements 接口&#123;</span><br><span class="line">    <span class="comment">// 重写接口中抽象方法【必须】，当然如果实现类是抽象类，那么可以不重写</span></span><br><span class="line">  <span class="comment">// 重写接口中默认方法【可选】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220514163212312.png" alt="image-20220514163212312" style="zoom:80%;"></p><p>注意：</p><ol><li><p>如果接口的实现类是非抽象类，那么必须<code>重写接口中所有抽象方法</code>。</p></li><li><p>默认方法可以选择保留，也可以重写。</p><blockquote><p>重写时，default单词就不要再写了，它只用于在接口中表示默认方法，到类中就没有默认方法的概念了</p></blockquote></li><li><p>接口中的静态方法不能被继承也不能被重写</p></li></ol><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">USB</span>&#123;<span class="comment">// </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> ;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(USB usb)</span>&#123;</span><br><span class="line">usb.start() ;</span><br><span class="line">System.out.println(<span class="string">&quot;=========== USB 设备工作 ========&quot;</span>) ;</span><br><span class="line">usb.stop() ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Flash</span> <span class="keyword">implements</span> <span class="title class_">USB</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;<span class="comment">// 重写方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;U盘开始工作。&quot;</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;<span class="comment">// 重写方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;U盘停止工作。&quot;</span>) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Print</span> <span class="keyword">implements</span> <span class="title class_">USB</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;<span class="comment">// 重写方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;打印机开始工作。&quot;</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;<span class="comment">// 重写方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;打印机停止工作。&quot;</span>) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceDemo</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">Computer.show(<span class="keyword">new</span> <span class="title class_">Flash</span>()) ;</span><br><span class="line">Computer.show(<span class="keyword">new</span> <span class="title class_">Print</span>()) ;</span><br><span class="line"></span><br><span class="line">c.show(<span class="keyword">new</span> <span class="title class_">USB</span>()&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;移动硬盘开始运行&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;移动硬盘停止运行&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>2、接口的多实现（implements）</strong></p><p>之前学过，在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的<code>多实现</code>。并且，一个类能继承一个父类，同时实现多个接口。</p><p>实现格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 class 实现类  implements 接口<span class="number">1</span>，接口<span class="number">2</span>，接口<span class="number">3</span>。。。&#123;</span><br><span class="line"><span class="comment">// 重写接口中所有抽象方法【必须】，当然如果实现类是抽象类，那么可以不重写</span></span><br><span class="line">  <span class="comment">// 重写接口中默认方法【可选】</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【修饰符】 class 实现类 extends 父类 implements 接口<span class="number">1</span>，接口<span class="number">2</span>，接口<span class="number">3</span>。。。&#123;</span><br><span class="line">    <span class="comment">// 重写接口中所有抽象方法【必须】，当然如果实现类是抽象类，那么可以不重写</span></span><br><span class="line">  <span class="comment">// 重写接口中默认方法【可选】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接口中，有多个抽象方法时，实现类必须重写所有抽象方法。<strong>如果抽象方法有重名的，只需要重写一次</strong>。</p></blockquote><p>举例：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220514163311418.png" alt="image-20220514163311418" style="zoom:80%;"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220325235321778.png" alt="image-20220325235321778" style="zoom:67%;"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/1562216188519.png" alt="1562216188519"></p><p>定义多个接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showA</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showB</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">implements</span> <span class="title class_">A</span>,B &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;showA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;showB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">        c.showA();</span><br><span class="line">        c.showB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、接口的多继承(extends)</strong></p><p>一个接口能继承另一个或者多个接口，接口的继承也使用 <code>extends</code> 关键字，子接口继承父接口的方法。</p><p>定义父接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Chargeable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">charge</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">in</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义子接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UsbC</span> <span class="keyword">extends</span> <span class="title class_">Chargeable</span>,USB3 &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义子接口的实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TypeCConverter</span> <span class="keyword">implements</span> <span class="title class_">UsbC</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正反面都支持&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">charge</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;可充电&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">in</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;输出数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>所有父接口的抽象方法都有重写。</p><p>方法签名相同的抽象方法只需要实现一次。</p></blockquote><p><strong>4、接口与实现类对象构成多态引用</strong></p><p>实现类实现接口，类似于子类继承父类，因此，接口类型的变量与实现类的对象之间，也可以构成多态引用。通过接口类型的变量调用方法，最终执行的是你new的实现类对象实现的方法体。</p><p>接口的不同实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mouse</span> <span class="keyword">implements</span> <span class="title class_">USB3</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送脉冲信号&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">in</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不接收信号&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KeyBoard</span> <span class="keyword">implements</span> <span class="title class_">USB3</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">in</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不接收信号&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送按键信号&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestComputer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="type">USB3</span> <span class="variable">usb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mouse</span>();</span><br><span class="line">        computer.setUsb(usb);</span><br><span class="line">        usb.start();</span><br><span class="line">        usb.out();</span><br><span class="line">        usb.in();</span><br><span class="line">        usb.stop();</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        usb = <span class="keyword">new</span> <span class="title class_">KeyBoard</span>();</span><br><span class="line">        computer.setUsb(usb);</span><br><span class="line">        usb.start();</span><br><span class="line">        usb.out();</span><br><span class="line">        usb.in();</span><br><span class="line">        usb.stop();</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        usb = <span class="keyword">new</span> <span class="title class_">MobileHDD</span>();</span><br><span class="line">        computer.setUsb(usb);</span><br><span class="line">        usb.start();</span><br><span class="line">        usb.out();</span><br><span class="line">        usb.in();</span><br><span class="line">        usb.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5、使用接口的静态成员</strong></p><p>接口不能直接创建对象，但是可以通过接口名直接调用接口的静态方法和静态常量。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestUSB3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//通过“接口名.”调用接口的静态方法 (JDK8.0才能开始使用)</span></span><br><span class="line">        USB3.show();</span><br><span class="line">        <span class="comment">//通过“接口名.”直接使用接口的静态常量</span></span><br><span class="line">        System.out.println(USB3.MAX_SPEED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6、使用接口的非静态方法</strong></p><ul><li>对于接口的静态方法，直接使用“<code>接口名.</code>”进行调用即可<ul><li>也只能使用“接口名.”进行调用，不能通过实现类的对象进行调用</li></ul></li><li>对于接口的抽象方法、默认方法，只能通过实现类对象才可以调用<ul><li>接口不能直接创建对象，只能创建实现类的对象</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMobileHDD</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建实现类对象</span></span><br><span class="line">        <span class="type">MobileHDD</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MobileHDD</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过实现类对象调用重写的抽象方法，以及接口的默认方法，如果实现类重写了就执行重写的默认方法，如果没有重写，就执行接口中的默认方法</span></span><br><span class="line">        b.start();</span><br><span class="line">        b.in();</span><br><span class="line">        b.stop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过接口名调用接口的静态方法</span></span><br><span class="line"><span class="comment">//        MobileHDD.show();</span></span><br><span class="line"><span class="comment">//        b.show();</span></span><br><span class="line">        Usb3.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-5-JDK8中相关冲突问题"><a href="#7-5-JDK8中相关冲突问题" class="headerlink" title="7.5 JDK8中相关冲突问题"></a>7.5 JDK8中相关冲突问题</h3><h4 id="7-5-1-默认方法冲突问题"><a href="#7-5-1-默认方法冲突问题" class="headerlink" title="7.5.1 默认方法冲突问题"></a>7.5.1 默认方法冲突问题</h4><p><strong>（1）类优先原则</strong></p><p>当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的抽象方法重名，子类就近选择执行父类的成员方法。代码如下：</p><p>定义接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Friend</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">date</span><span class="params">()</span>&#123;<span class="comment">//约会</span></span><br><span class="line">        System.out.println(<span class="string">&quot;吃喝玩乐&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义父类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">date</span><span class="params">()</span>&#123;<span class="comment">//约会</span></span><br><span class="line">        System.out.println(<span class="string">&quot;爸爸约吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义子类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> <span class="keyword">implements</span> <span class="title class_">Friend</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">date</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//(1)不重写默认保留父类的</span></span><br><span class="line">        <span class="comment">//(2)调用父类被重写的</span></span><br><span class="line"><span class="comment">//        super.date();</span></span><br><span class="line">        <span class="comment">//(3)保留父接口的</span></span><br><span class="line"><span class="comment">//        Friend.super.date();</span></span><br><span class="line">        <span class="comment">//(4)完全重写</span></span><br><span class="line">        System.out.println(<span class="string">&quot;跟康师傅学Java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSon</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        s.date();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（2）接口冲突（左右为难）</strong></p><ul><li>当一个类同时实现了多个父接口，而多个父接口中包含方法签名相同的默认方法时，怎么办呢？</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/选择困难.jpg" alt></p><p>无论你多难抉择，最终都是要做出选择的。</p><p>声明接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BoyFriend</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">date</span><span class="params">()</span>&#123;<span class="comment">//约会</span></span><br><span class="line">        System.out.println(<span class="string">&quot;神秘约会&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择保留其中一个，通过“<code>接口名.super.方法名</code>“的方法选择保留哪个接口的默认方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Girl</span> <span class="keyword">implements</span> <span class="title class_">Friend</span>,BoyFriend&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">date</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//(1)保留其中一个父接口的</span></span><br><span class="line"><span class="comment">//        Friend.super.date();</span></span><br><span class="line"><span class="comment">//        BoyFriend.super.date();</span></span><br><span class="line">        <span class="comment">//(2)完全重写</span></span><br><span class="line">        System.out.println(<span class="string">&quot;跟康师傅学Java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestGirl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Girl</span> <span class="variable">girl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Girl</span>();</span><br><span class="line">        girl.date();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当一个子接口同时继承了多个接口，而多个父接口中包含方法签名相同的默认方法时，怎么办呢？</li></ul><p>另一个父接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">USB2</span> &#123;</span><br><span class="line">    <span class="comment">//静态常量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">MAX_SPEED</span> <span class="operator">=</span> <span class="number">60</span>*<span class="number">1024</span>*<span class="number">1024</span>;<span class="comment">//60MB/s</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">in</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;USB 2.0可以高速地进行读写操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">USB</span> <span class="keyword">extends</span> <span class="title class_">USB2</span>,USB3 &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Usb.start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Usb.stop&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>小贴士：</p><p>子接口重写默认方法时，default关键字可以保留。</p><p>子类重写默认方法时，default关键字不可以保留。</p></blockquote><h4 id="7-5-2-常量冲突问题"><a href="#7-5-2-常量冲突问题" class="headerlink" title="7.5.2 常量冲突问题"></a>7.5.2 常量冲突问题</h4><ul><li>当子类继承父类又实现父接口，而父类中存在与父接口常量同名的成员变量，并且该成员变量名在子类中仍然可见。</li><li>当子类同时实现多个接口，而多个接口存在相同同名常量。</li></ul><p>此时在子类中想要引用父类或父接口的同名的常量或成员变量时，就会有冲突问题。</p><p>父类和父接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SuperInterface</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MotherInterface</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span> <span class="keyword">implements</span> <span class="title class_">SuperInterface</span>,MotherInterface &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;x = &quot; + x);//模糊不清</span></span><br><span class="line">        System.out.println(<span class="string">&quot;super.x = &quot;</span> + <span class="built_in">super</span>.x);</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperInterface.x = &quot;</span> + SuperInterface.x);</span><br><span class="line">        System.out.println(<span class="string">&quot;MotherInterface.x = &quot;</span> + MotherInterface.x);</span><br><span class="line">        System.out.println(<span class="string">&quot;y = &quot;</span> + y);<span class="comment">//没有重名问题，可以直接访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-6-接口的总结与面试题"><a href="#7-6-接口的总结与面试题" class="headerlink" title="7.6 接口的总结与面试题"></a>7.6 接口的总结与面试题</h3><ul><li>接口本身不能创建对象，只能创建接口的实现类对象，接口类型的变量可以与实现类对象构成多态引用。</li><li>声明接口用interface，接口的成员声明有限制：<ul><li>（1）公共的静态常量</li><li>（2）公共的抽象方法</li><li>（3）公共的默认方法（JDK8.0 及以上）</li><li>（4）公共的静态方法（JDK8.0 及以上）</li><li>（5）私有方法（JDK9.0 及以上）</li></ul></li><li>类可以实现接口，关键字是implements，而且支持多实现。如果实现类不是抽象类，就必须实现接口中所有的抽象方法。如果实现类既要继承父类又要实现父接口，那么继承（extends）在前，实现（implements）在后。</li><li>接口可以继承接口，关键字是extends，而且支持多继承。</li><li>接口的默认方法可以选择重写或不重写。如果有冲突问题，另行处理。子类重写父接口的默认方法，要去掉default，子接口重写父接口的默认方法，不要去掉default。</li><li>接口的静态方法不能被继承，也不能被重写。接口的静态方法只能通过“接口名.静态方法名”进行调用。</li></ul><p><strong>面试题</strong></p><p><strong>1、为什么接口中只能声明公共的静态的常量？</strong></p><p>因为接口是标准规范，那么在规范中需要声明一些底线边界值，当实现者在实现这些规范时，不能去随意修改和触碰这些底线，否则就有“危险”。</p><p>例如：USB1.0规范中规定最大传输速率是1.5Mbps，最大输出电流是5V/500mA</p><p>​           USB3.0规范中规定最大传输速率是5Gbps(500MB/s)，最大输出电流是5V/900mA</p><p>例如：尚硅谷学生行为规范中规定学员，早上8:25之前进班，晚上21:30之后离开等等。</p><p><strong>2、为什么JDK8.0 之后允许接口定义静态方法和默认方法呢？因为它违反了接口作为一个抽象标准定义的概念。</strong></p><p><code>静态方法</code>：因为之前的标准类库设计中，有很多Collection/Colletions或者Path/Paths这样成对的接口和类，后面的类中都是静态方法，而这些静态方法都是为前面的接口服务的，那么这样设计一对API，不如把静态方法直接定义到接口中使用和维护更方便。</p><p><code>默认方法</code>：（1）我们要在已有的老版接口中提供新方法时，如果添加抽象方法，就会涉及到原来使用这些接口的类就会有问题，那么为了保持与旧版本代码的兼容性，只能允许在接口中定义默认方法实现。比如：Java8中对Collection、List、Comparator等接口提供了丰富的默认方法。（2）当我们接口的某个抽象方法，在很多实现类中的实现代码是一样的，此时将这个抽象方法设计为默认方法更为合适，那么实现类就可以选择重写，也可以选择不重写。</p><p><strong>3、为什么JDK1.9要允许接口定义私有方法呢？因为我们说接口是规范，规范是需要公开让大家遵守的。</strong></p><p><strong>私有方法</strong>：因为有了默认方法和静态方法这样具有具体实现的方法，那么就可能出现多个方法由共同的代码可以抽取，而这些共同的代码抽取出来的方法又只希望在接口内部使用，所以就增加了私有方法。</p><h3 id="7-7-接口与抽象类之间的对比"><a href="#7-7-接口与抽象类之间的对比" class="headerlink" title="7.7 接口与抽象类之间的对比"></a>7.7 接口与抽象类之间的对比</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220328002053452.png" alt="image-20220328002053452"></p><blockquote><p>在开发中，常看到一个类不是去继承一个已经实现好的类，而是要么继承抽象类，要么实现接口。</p></blockquote><h3 id="7-8-练习"><a href="#7-8-练习" class="headerlink" title="7.8 练习"></a>7.8 练习</h3><p><strong>笔试题：</strong>排错</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pX</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">C</span>().pX();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>笔试题：</strong>排错</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Playable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bounceable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Rollable</span> <span class="keyword">extends</span> <span class="title class_">Playable</span>, Bounceable &#123;</span><br><span class="line">    <span class="type">Ball</span> <span class="variable">ball</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ball</span>(<span class="string">&quot;PingPang&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ball</span> <span class="keyword">implements</span> <span class="title class_">Rollable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Ball</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        ball = <span class="keyword">new</span> <span class="title class_">Ball</span>(<span class="string">&quot;Football&quot;</span>);</span><br><span class="line">        System.out.println(ball.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>练习1：</strong></p><p>定义一个接口用来实现两个对象的比较。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">CompareObject</span>&#123;</span><br><span class="line"><span class="comment">//若返回值是 0 , 代表相等; 若为正数，代表当前对象大；负数代表当前对象小</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个Circle类，声明redius属性，提供getter和setter方法</p><p>定义一个ComparableCircle类，继承Circle类并且实现CompareObject接口。在ComparableCircle类中给出接口中方法compareTo的实现体，用来比较两个圆的半径大小。</p><p>定义一个测试类InterfaceTest，创建两个ComparableCircle对象，调用compareTo方法比较两个类的半径大小。</p><p>思考：参照上述做法定义矩形类Rectangle和ComparableRectangle类，在ComparableRectangle类中给出compareTo方法的实现，比较两个矩形的面积大小。</p><p><strong>练习2：交通工具案例</strong></p><p>阿里的一个工程师，声明的属性和方法如下：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220504172547709.png" alt="image-20220504172547709"></p><p>其中，有一个乘坐交通工具的方法takingVehicle()，在此方法中调用交通工具的run()。为了出行方便，他买了一辆捷安特自行车、一辆雅迪电动车和一辆奔驰轿车。这里涉及到的相关类及接口关系如下：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220504172918861.png" alt="image-20220504172918861"></p><p>其中，电动车增加动力的方式是充电，轿车增加动力的方式是加油。在具体交通工具的run()中调用其所在类的相关属性信息。</p><p>请编写相关代码，并测试。</p><p>提示：创建Vehicle[]数组，保存阿里工程师的三辆交通工具，并分别在工程师的takingVehicle()中调用。</p><h2 id="8-内部类（InnerClass"><a href="#8-内部类（InnerClass" class="headerlink" title="8. 内部类（InnerClass)"></a>8. 内部类（InnerClass)</h2><h3 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h3><h4 id="8-1-1-什么是内部类"><a href="#8-1-1-什么是内部类" class="headerlink" title="8.1.1 什么是内部类"></a>8.1.1 什么是内部类</h4><p>将一个类A定义在另一个类B里面，里面的那个类A就称为<code>内部类（InnerClass）</code>，类B则称为<code>外部类（OuterClass）</code>。</p><h4 id="8-1-2-为什么要声明内部类呢"><a href="#8-1-2-为什么要声明内部类呢" class="headerlink" title="8.1.2 为什么要声明内部类呢"></a>8.1.2 为什么要声明内部类呢</h4><p>具体来说，当一个事物A的内部，还有一个部分需要一个完整的结构B进行描述，而这个内部的完整的结构B又只为外部事物A提供服务，不在其他地方单独使用，那么整个内部的完整结构B最好使用内部类。</p><p>总的来说，遵循<code>高内聚、低耦合</code>的面向对象开发原则。</p><h4 id="8-1-3-内部类的分类"><a href="#8-1-3-内部类的分类" class="headerlink" title="8.1.3 内部类的分类"></a>8.1.3 内部类的分类</h4><p>根据内部类声明的位置（如同变量的分类），我们可以分为：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20221124223912529.png" alt="image-20221124223912529"></p><h3 id="8-2-成员内部类"><a href="#8-2-成员内部类" class="headerlink" title="8.2 成员内部类"></a>8.2 成员内部类</h3><h4 id="8-2-1-概述"><a href="#8-2-1-概述" class="headerlink" title="8.2.1 概述"></a>8.2.1 概述</h4><p>如果成员内部类中不使用外部类的非静态成员，那么通常将内部类声明为静态内部类，否则声明为非静态内部类。</p><p><strong>语法格式：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] class 外部类&#123;</span><br><span class="line">    [其他修饰符] [<span class="keyword">static</span>] class 内部类&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>成员内部类的使用特征，概括来讲有如下两种角色：</strong></p><ul><li>成员内部类作为<code>类的成员的角色</code>：<ul><li>和外部类不同，Inner class还可以声明为private或protected；</li><li>可以调用外部类的结构。（注意：在静态内部类中不能使用外部类的非静态成员）</li><li>Inner class 可以声明为static的，但此时就不能再使用外层类的非static的成员变量；</li></ul></li><li>成员内部类作为<code>类的角色</code>：<ul><li>可以在内部定义属性、方法、构造器等结构</li><li>可以继承自己的想要继承的父类，实现自己想要实现的父接口们，和外部类的父类和父接口无关</li><li>可以声明为abstract类 ，因此可以被其它的内部类继承</li><li>可以声明为final的，表示不能被继承</li><li>编译以后生成OuterClass$InnerClass.class字节码文件（也适用于局部内部类）</li></ul></li></ul><p>注意点：</p><ol><li><p>外部类访问成员内部类的成员，需要“内部类.成员”或“内部类对象.成员”的方式</p></li><li><p>成员内部类可以直接使用外部类的所有成员，包括私有的数据</p></li><li><p>当想要在外部类的静态成员部分使用内部类时，可以考虑内部类声明为静态的</p></li></ol><h4 id="8-2-2-创建成员内部类对象"><a href="#8-2-2-创建成员内部类对象" class="headerlink" title="8.2.2 创建成员内部类对象"></a>8.2.2 创建成员内部类对象</h4><ul><li>实例化静态内部类</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">外部类名.静态内部类名 变量 = 外部类名.静态内部类名();</span><br><span class="line">变量.非静态方法();</span><br></pre></td></tr></table></figure><ul><li>实例化非静态内部类</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">外部类名 变量1 = new 外部类();</span><br><span class="line">外部类名.非静态内部类名 变量2 = 变量1.new 非静态内部类名();</span><br><span class="line">变量2.非静态方法();</span><br></pre></td></tr></table></figure><h4 id="8-2-3-举例"><a href="#8-2-3-举例" class="headerlink" title="8.2.3 举例"></a>8.2.3 举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMemberInnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建静态内部类实例，并调用方法</span></span><br><span class="line">        Outer.<span class="type">StaticInner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.StaticInner();</span><br><span class="line">        inner.inFun();</span><br><span class="line">        <span class="comment">//调用静态内部类静态方法</span></span><br><span class="line">        Outer.StaticInner.inMethod();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*****************************&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建非静态内部类实例（方式1），并调用方法</span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">NoStaticInner</span> <span class="variable">inner1</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">NoStaticInner</span>();</span><br><span class="line">        inner1.inFun();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建非静态内部类实例（方式2）</span></span><br><span class="line">        Outer.<span class="type">NoStaticInner</span> <span class="variable">inner2</span> <span class="operator">=</span> outer.getNoStaticInner();</span><br><span class="line">        inner1.inFun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;外部类的静态a&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">b</span>  <span class="operator">=</span> <span class="string">&quot;外部类的静态b&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;外部类对象的非静态c&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="string">&quot;外部类对象的非静态d&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInner</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span><span class="string">&quot;静态内部类的静态a&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;静态内部类对象的非静态c&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inMethod</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Inner.a = &quot;</span> + a);</span><br><span class="line">            System.out.println(<span class="string">&quot;Outer.a = &quot;</span> + Outer.a);</span><br><span class="line">            System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inFun</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Inner.inFun&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Outer.a = &quot;</span> + Outer.a);</span><br><span class="line">            System.out.println(<span class="string">&quot;Inner.a = &quot;</span> + a);</span><br><span class="line">            System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">            System.out.println(<span class="string">&quot;c = &quot;</span> + c);</span><br><span class="line"><span class="comment">//            System.out.println(&quot;d = &quot; + d);//不能访问外部类的非静态成员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">NoStaticInner</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;非静态内部类对象的非静态a&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;非静态内部类对象的非静态c&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inFun</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;NoStaticInner.inFun&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Outer.a = &quot;</span> + Outer.a);</span><br><span class="line">            System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">            System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">            System.out.println(<span class="string">&quot;Outer.c = &quot;</span> + Outer.<span class="built_in">this</span>.c);</span><br><span class="line">            System.out.println(<span class="string">&quot;c = &quot;</span> + c);</span><br><span class="line">            System.out.println(<span class="string">&quot;d = &quot;</span> + d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> NoStaticInner <span class="title function_">getNoStaticInner</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NoStaticInner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-局部内部类"><a href="#8-3-局部内部类" class="headerlink" title="8.3 局部内部类"></a>8.3 局部内部类</h3><h4 id="8-3-1-非匿名局部内部类"><a href="#8-3-1-非匿名局部内部类" class="headerlink" title="8.3.1 非匿名局部内部类"></a>8.3.1 非匿名局部内部类</h4><p>语法格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] class 外部类&#123;</span><br><span class="line">    [修饰符] 返回值类型  方法名(形参列表)&#123;</span><br><span class="line">            [<span class="keyword">final</span>/<span class="keyword">abstract</span>] class 内部类&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译后有自己的独立的字节码文件，只不过在内部类名前面冠以外部类名、$符号、编号。<ul><li>这里有编号是因为同一个外部类中，不同的方法中存在相同名称的局部内部类</li></ul></li></ul><ul><li>和成员内部类不同的是，它前面不能有权限修饰符等</li><li>局部内部类如同局部变量一样，有作用域</li><li>局部内部类中是否能访问外部类的非静态的成员，取决于所在的方法</li></ul><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName: TestLocalInner</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Create</span> 17:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLocalInner</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Outer.outMethod();</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        out.outTest();</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Runner</span> <span class="variable">runner</span> <span class="operator">=</span> Outer.getRunner();</span><br><span class="line">        runner.run();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">outMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Outer.outMethod&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;局部变量c&quot;</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inMethod</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Inner.inMethod&quot;</span>);</span><br><span class="line">                System.out.println(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        in.inMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outTest</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inMethod1</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Inner.inMethod1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        in.inMethod1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Runner <span class="title function_">getRunner</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">LocalRunner</span> <span class="keyword">implements</span> <span class="title class_">Runner</span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;LocalRunner.run&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LocalRunner</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Runner</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-2-匿名内部类"><a href="#8-3-2-匿名内部类" class="headerlink" title="8.3.2 匿名内部类"></a>8.3.2 匿名内部类</h4><p>因为考虑到这个子类或实现类是一次性的，那么我们“费尽心机”的给它取名字，就显得多余。那么我们完全可以使用匿名内部类的方式来实现，避免给类命名的问题。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类([实参列表])&#123;</span><br><span class="line">    重写方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 父接口()&#123;</span><br><span class="line">    重写方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例1：使用匿名内部类的对象直接调用方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">A</span>()&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例2：通过父类或父接口的变量多态引用匿名内部类的对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">A</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>()&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    obj.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例3：匿名内部类的对象作为实参</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(A a)</span>&#123;</span><br><span class="line">    a.method();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    test(<span class="keyword">new</span> <span class="title class_">A</span>()&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-4-练习"><a href="#8-4-练习" class="headerlink" title="8.4 练习"></a>8.4 练习</h3><p>练习：判断输出结果为何？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        s1.a = <span class="number">10</span>;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        s2.a = <span class="number">20</span>;</span><br><span class="line">        Test.<span class="type">Inner</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>.Inner();</span><br><span class="line">        System.out.println(s3.a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">r</span> <span class="operator">=</span> t.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        System.out.println(r.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>练习2：</p><p>编写一个匿名内部类，它继承Object，并在匿名内部类中，声明一个方法public void test()打印尚硅谷。</p><p>请编写代码调用这个方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.test01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Object</span>()&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;尚硅谷&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;.test();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="9-枚举类"><a href="#9-枚举类" class="headerlink" title="9. 枚举类"></a>9. 枚举类</h2><h3 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h3><ul><li><p>枚举类型本质上也是一种类，只不过是这个类的对象是有限的、固定的几个，不能让用户随意创建。</p></li><li><p>枚举类的例子举不胜举：</p><ul><li><code>星期</code>：Monday(星期一)……Sunday(星期天)</li><li><code>性别</code>：Man(男)、Woman(女)</li><li><code>月份</code>：January(1月)……December(12月)</li><li><code>季节</code>：Spring(春节)……Winter(冬天)</li><li><code>三原色</code>：red(红色)、green(绿色)、blue(蓝色)</li><li><code>支付方式</code>：Cash（现金）、WeChatPay（微信）、Alipay(支付宝)、BankCard(银行卡)、CreditCard(信用卡)</li><li><code>就职状态</code>：Busy(忙碌)、Free(空闲)、Vocation(休假)、Dimission(离职)</li><li><code>订单状态</code>：Nonpayment（未付款）、Paid（已付款）、Fulfilled（已配货）、Delivered（已发货）、Checked（已确认收货）、Return（退货）、Exchange（换货）、Cancel（取消）</li><li><code>线程状态</code>：创建、就绪、运行、阻塞、死亡</li></ul></li><li><strong>若枚举只有一个对象, 则可以作为一种单例模式的实现方式。</strong></li><li>枚举类的实现：<ul><li>在JDK5.0 之前，需要程序员自定义枚举类型。</li><li>在JDK5.0 之后，Java支持<code>enum</code>关键字来快速定义枚举类型。</li></ul></li></ul><h3 id="9-2-定义枚举类（JDK5-0-之前）"><a href="#9-2-定义枚举类（JDK5-0-之前）" class="headerlink" title="9.2 定义枚举类（JDK5.0 之前）"></a>9.2 定义枚举类（JDK5.0 之前）</h3><p>在JDK5.0 之前如何声明枚举类呢？</p><ul><li><code>私有化</code>类的构造器，保证不能在类的外部创建其对象</li><li>在类的内部创建枚举类的实例。声明为：<code>public static final</code> ，对外暴露这些常量对象</li><li>对象如果有<code>实例变量</code>，应该声明为<code>private final</code>（建议，不是必须），并在构造器中初始化</li></ul><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SEASONNAME;<span class="comment">//季节的名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SEASONDESC;<span class="comment">//季节的描述</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.SEASONNAME = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.SEASONDESC = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;白雪皑皑&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;SEASONNAME=&#x27;&quot;</span> + SEASONNAME + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, SEASONDESC=&#x27;&quot;</span> + SEASONDESC + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeasonTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Season.AUTUMN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-定义枚举类（JDK5-0-之后）"><a href="#9-3-定义枚举类（JDK5-0-之后）" class="headerlink" title="9.3 定义枚举类（JDK5.0 之后）"></a>9.3 定义枚举类（JDK5.0 之后）</h3><h4 id="9-3-1-enum关键字声明枚举"><a href="#9-3-1-enum关键字声明枚举" class="headerlink" title="9.3.1 enum关键字声明枚举"></a>9.3.1 enum关键字声明枚举</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="keyword">enum</span> 枚举类名&#123;</span><br><span class="line">    常量对象列表</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【修饰符】 <span class="keyword">enum</span> 枚举类名&#123;</span><br><span class="line">    常量对象列表;</span><br><span class="line">    </span><br><span class="line">    对象的实例变量列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.enumeration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Week</span> &#123;</span><br><span class="line">    MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY,SUNDAY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestEnum</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Season</span> <span class="variable">spring</span> <span class="operator">=</span> Season.SPRING;</span><br><span class="line">System.out.println(spring);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-3-2-enum方式定义的要求和特点"><a href="#9-3-2-enum方式定义的要求和特点" class="headerlink" title="9.3.2 enum方式定义的要求和特点"></a>9.3.2 enum方式定义的要求和特点</h4><ul><li>枚举类的常量对象列表必须在枚举类的首行，因为是常量，所以建议大写。</li><li>列出的实例系统会自动添加 public static final 修饰。</li><li>如果常量对象列表后面没有其他代码，那么“；”可以省略，否则不可以省略“；”。</li><li>编译器给枚举类默认提供的是private的无参构造，如果枚举类需要的是无参构造，就不需要声明，写常量对象列表时也不用加参数</li><li>如果枚举类需要的是有参构造，需要手动定义，有参构造的private可以省略，调用有参构造的方法就是在常量对象名后面加(实参列表)就可以。</li><li>枚举类默认继承的是java.lang.Enum类，因此不能再继承其他的类型。</li><li>JDK5.0 之后switch，提供支持枚举类型，case后面可以写枚举常量名，无需添加枚举类作为限定。</li></ul><p>举例2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SeasonEnum</span> &#123;</span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春风又绿江南岸&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;映日荷花别样红&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋水共长天一色&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;窗含西岭千秋雪&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SeasonEnum</span><span class="params">(String seasonName, String seasonDesc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>举例3：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.enumeration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Week</span> &#123;</span><br><span class="line">    MONDAY(<span class="string">&quot;星期一&quot;</span>),</span><br><span class="line">    TUESDAY(<span class="string">&quot;星期二&quot;</span>),</span><br><span class="line">    WEDNESDAY(<span class="string">&quot;星期三&quot;</span>),</span><br><span class="line">    THURSDAY(<span class="string">&quot;星期四&quot;</span>),</span><br><span class="line">    FRIDAY(<span class="string">&quot;星期五&quot;</span>),</span><br><span class="line">    SATURDAY(<span class="string">&quot;星期六&quot;</span>),</span><br><span class="line">    SUNDAY(<span class="string">&quot;星期日&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Week</span><span class="params">(String description)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.toString() +<span class="string">&quot;:&quot;</span>+ description;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.enumeration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestWeek</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Week</span> <span class="variable">week</span> <span class="operator">=</span> Week.MONDAY;</span><br><span class="line">        System.out.println(week);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (week)&#123;</span><br><span class="line">            <span class="keyword">case</span> MONDAY:</span><br><span class="line">                System.out.println(<span class="string">&quot;怀念周末，困意很浓&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TUESDAY:</span><br><span class="line">                System.out.println(<span class="string">&quot;进入学习状态&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> WEDNESDAY:</span><br><span class="line">                System.out.println(<span class="string">&quot;死撑&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> THURSDAY:</span><br><span class="line">                System.out.println(<span class="string">&quot;小放松&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FRIDAY:</span><br><span class="line">                System.out.println(<span class="string">&quot;又信心满满&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SATURDAY:</span><br><span class="line">                System.out.println(<span class="string">&quot;开始盼周末，无心学习&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SUNDAY:</span><br><span class="line">                System.out.println(<span class="string">&quot;一觉到下午&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>经验之谈：</p><p>开发中，当需要定义一组常量时，强烈建议使用枚举类。</p></blockquote><h3 id="9-4-enum中常用方法"><a href="#9-4-enum中常用方法" class="headerlink" title="9.4 enum中常用方法"></a>9.4 enum中常用方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String toString(): 默认返回的是常量名（对象名），可以继续手动重写该方法！</span><br><span class="line">    </span><br><span class="line">static 枚举类型[] values():返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值，是一个静态方法</span><br><span class="line">    </span><br><span class="line">static 枚举类型 valueOf(String name)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。</span><br><span class="line">    </span><br><span class="line">String name():得到当前枚举常量的名称。建议优先使用toString()。</span><br><span class="line">    </span><br><span class="line">int ordinal():返回当前枚举常量的次序号，默认从0开始</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.enumeration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestEnumMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//values()</span></span><br><span class="line">        Week[] values = Week.values();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">            <span class="comment">//ordinal()、name()</span></span><br><span class="line">            System.out.println((values[i].ordinal()+<span class="number">1</span>) + <span class="string">&quot;-&gt;&quot;</span> + values[i].name());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入星期值：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">weekValue</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">        <span class="type">Week</span> <span class="variable">week</span> <span class="operator">=</span> values[weekValue-<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//toString()</span></span><br><span class="line">        System.out.println(week);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;请输入星期名：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">weekName</span> <span class="operator">=</span> input.next();</span><br><span class="line">        <span class="comment">//valueOf()</span></span><br><span class="line">        week = Week.valueOf(weekName);</span><br><span class="line">        System.out.println(week);</span><br><span class="line"></span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-5-实现接口的枚举类"><a href="#9-5-实现接口的枚举类" class="headerlink" title="9.5 实现接口的枚举类"></a>9.5 实现接口的枚举类</h3><ul><li>和普通 Java 类一样，枚举类可以实现一个或多个接口</li><li>若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可。</li><li>若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法</li></ul><p>语法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、枚举类可以像普通的类一样，实现接口，并且可以多个，但要求必须实现里面所有的抽象方法！</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">A</span> implements 接口<span class="number">1</span>，接口<span class="number">2</span>&#123;</span><br><span class="line"><span class="comment">//抽象方法的实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、如果枚举类的常量可以继续重写抽象方法!</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">A</span> implements 接口<span class="number">1</span>，接口<span class="number">2</span>&#123;</span><br><span class="line">    常量名<span class="number">1</span>(参数)&#123;</span><br><span class="line">        <span class="comment">//抽象方法的实现或重写</span></span><br><span class="line">    &#125;,</span><br><span class="line">    常量名<span class="number">2</span>(参数)&#123;</span><br><span class="line">        <span class="comment">//抽象方法的实现或重写</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span>&#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用enum关键字定义枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season1</span> <span class="keyword">implements</span> <span class="title class_">Info</span>&#123;</span><br><span class="line"><span class="comment">//1. 创建枚举类中的对象,声明在enum枚举类的首位</span></span><br><span class="line">SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;春天在哪里？&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;宁静的夏天&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;秋天是用来分手的季节&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;白雪皑皑&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;2002年的第一场雪&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 声明每个对象拥有的属性:private final修饰</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String SEASON_NAME;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String SEASON_DESC;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 私有化类的构造器</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Season1</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.SEASON_NAME = seasonName;</span><br><span class="line"><span class="built_in">this</span>.SEASON_DESC = seasonDesc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getSEASON_NAME</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> SEASON_NAME;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getSEASON_DESC</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> SEASON_DESC;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-注解-Annotation"><a href="#10-注解-Annotation" class="headerlink" title="10. 注解(Annotation)"></a>10. 注解(Annotation)</h2><h3 id="10-1-注解概述"><a href="#10-1-注解概述" class="headerlink" title="10.1 注解概述"></a>10.1 注解概述</h3><h4 id="10-1-1-什么是注解"><a href="#10-1-1-什么是注解" class="headerlink" title="10.1.1 什么是注解"></a>10.1.1 什么是注解</h4><p>注解（Annotation）是从<code>JDK5.0</code>开始引入，以“<code>@注解名</code>”在代码中存在。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(value=”unchecked”)</span></span><br></pre></td></tr></table></figure><p>Annotation 可以像修饰符一样被使用，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明。还可以添加一些参数值，这些信息被保存在 Annotation 的 “name=value” 对中。</p><p>注解可以在类编译、运行时进行加载，体现不同的功能。</p><h4 id="10-1-2-注解与注释"><a href="#10-1-2-注解与注释" class="headerlink" title="10.1.2 注解与注释"></a>10.1.2 注解与注释</h4><p>注解也可以看做是一种注释，通过使用 Annotation，程序员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。但是，注解，不同于单行注释和多行注释。</p><ul><li>对于单行注释和多行注释是给程序员看的。</li><li>而注解是可以被编译器或其他程序读取的。程序还可以根据注解的不同，做出相应的处理。</li></ul><h4 id="10-1-3-注解的重要性"><a href="#10-1-3-注解的重要性" class="headerlink" title="10.1.3 注解的重要性"></a>10.1.3 注解的重要性</h4><p>在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在<code>JavaEE/Android中注解占据了更重要的角色</code>，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的<code>繁冗代码</code>和<code>XML配置</code>等。</p><p>未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，Struts2有一部分也是基于注解的了。<code>注解是一种趋势</code>，一定程度上可以说：<code>框架 = 注解 + 反射 + 设计模式</code>。</p><h3 id="10-2-常见的Annotation作用"><a href="#10-2-常见的Annotation作用" class="headerlink" title="10.2 常见的Annotation作用"></a>10.2 常见的Annotation作用</h3><p><strong>示例1：生成文档相关的注解</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@author</span> 标明开发该类模块的作者，多个作者之间使用,分割</span><br><span class="line"><span class="meta">@version</span> 标明该类模块的版本</span><br><span class="line"><span class="meta">@see</span> 参考转向，也就是相关主题</span><br><span class="line"><span class="meta">@since</span> 从哪个版本开始增加的</span><br><span class="line"><span class="meta">@param</span> 对方法中某参数的说明，如果没有参数就不能写</span><br><span class="line"><span class="meta">@return</span> 对方法返回值的说明，如果方法的返回值类型是<span class="keyword">void</span>就不能写</span><br><span class="line"><span class="meta">@exception</span> 对方法可能抛出的异常进行说明 ，如果方法没有用<span class="keyword">throws</span>显式抛出的异常就不能写</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.annotation.javadoc;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Math.java</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavadocTest</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 程序的主方法，程序的入口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args String[] 命令行参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求圆面积的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> radius double 半径值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> double 圆的面积</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getArea</span><span class="params">(<span class="type">double</span> radius)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> Math.PI * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>示例2：在编译时进行格式检查(JDK内置的三个基本注解)</strong></p><p><code>@Override</code>: 限定重写父类方法，该注解只能用于方法</p><p><code>@Deprecated</code>: 用于表示所修饰的元素(类，方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择</p><p><code>@SuppressWarnings</code>: 抑制编译器警告</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.annotation.javadoc;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationTest</span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;过时的方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;重写的toString方法()&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>示例3：跟踪代码依赖性，实现替代配置文件功能</strong></p><ul><li>Servlet3.0提供了注解(annotation)，使得不再需要在web.xml文件中进行Servlet的部署。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>LoginServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.servlet.LoginServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>LoginServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/login<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Spring框架中关于“事务”的管理</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation=Propagation.REQUIRES_NEW,isolation=Isolation.READ_COMMITTED,readOnly=false,timeout=3)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buyBook</span><span class="params">(String username, String isbn)</span> &#123;</span><br><span class="line"><span class="comment">//1.查询书的单价</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> bookShopDao.findBookPriceByIsbn(isbn);</span><br><span class="line">    <span class="comment">//2. 更新库存</span></span><br><span class="line">    bookShopDao.updateBookStock(isbn);</span><br><span class="line">    <span class="comment">//3. 更新用户的余额</span></span><br><span class="line">    bookShopDao.updateUserAccount(username, price);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置事务属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;dataSourceTransactionManager&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 配置每个方法使用的事务属性 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;buyBook&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRES_NEW&quot;</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">isolation</span>=<span class="string">&quot;READ_COMMITTED&quot;</span>  <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span>  <span class="attr">timeout</span>=<span class="string">&quot;3&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="10-3-三个最基本的注解"><a href="#10-3-三个最基本的注解" class="headerlink" title="10.3 三个最基本的注解"></a>10.3 三个最基本的注解</h3><h4 id="10-3-1-Override"><a href="#10-3-1-Override" class="headerlink" title="10.3.1 @Override"></a>10.3.1 @Override</h4><ul><li>用于检测被标记的方法为有效的重写方法，如果不是，则报编译错误！</li></ul><ul><li>只能标记在方法上。</li></ul><ul><li>它会被编译器程序读取。</li></ul><h4 id="10-3-2-Deprecated"><a href="#10-3-2-Deprecated" class="headerlink" title="10.3.2 @Deprecated"></a>10.3.2 @Deprecated</h4><ul><li>用于表示被标记的数据已经过时，不推荐使用。</li></ul><ul><li>可以用于修饰 属性、方法、构造、类、包、局部变量、参数。</li></ul><ul><li>它会被编译器程序读取。</li></ul><h4 id="10-3-3-SuppressWarnings"><a href="#10-3-3-SuppressWarnings" class="headerlink" title="10.3.3 @SuppressWarnings"></a>10.3.3 @SuppressWarnings</h4><ul><li>抑制编译警告。当我们不希望看到警告信息的时候，可以使用 SuppressWarnings 注解来抑制警告信息</li></ul><ul><li>可以用于修饰类、属性、方法、构造、局部变量、参数</li></ul><ul><li><p>它会被编译器程序读取。</p></li><li><p>可以指定的警告类型有（了解）</p><ul><li>all，抑制所有警告</li><li>unchecked，抑制与未检查的作业相关的警告</li><li>unused，抑制与未用的程式码及停用的程式码相关的警告</li><li>deprecation，抑制与淘汰的相关警告</li><li>nls，抑制与非 nls 字串文字相关的警告</li><li>null，抑制与空值分析相关的警告</li><li>rawtypes，抑制与使用 raw 类型相关的警告</li><li>static-access，抑制与静态存取不正确相关的警告</li><li>static-method，抑制与可能宣告为 static 的方法相关的警告</li><li>super，抑制与置换方法相关但不含 super 呼叫的警告</li><li>…</li></ul></li></ul><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAnnotation</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="number">123</span>);</span><br><span class="line">        list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Father</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        f.show();</span><br><span class="line">        f.methodOl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father.show&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodOl</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father Method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"><span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">void method01() &#123;</span></span><br><span class="line"><span class="comment">System.out.println(&quot;Son Method&quot;);</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-4-元注解"><a href="#10-4-元注解" class="headerlink" title="10.4 元注解"></a>10.4 元注解</h3><p>JDK1.5在java.lang.annotation包定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。</p><p>（1）<strong>@Target：</strong>用于描述注解的使用范围</p><ul><li>可以通过枚举类型ElementType的10个常量对象来指定</li><li>TYPE，METHOD，CONSTRUCTOR，PACKAGE…..</li></ul><p>（2）<strong>@Retention：</strong>用于描述注解的生命周期</p><ul><li>可以通过枚举类型RetentionPolicy的3个常量对象来指定</li><li>SOURCE（源代码）、CLASS（字节码）、RUNTIME（运行时）</li><li><code>唯有RUNTIME阶段才能被反射读取到</code>。</li></ul><p>（3）<strong>@Documented</strong>：表明这个注解应该被 javadoc工具记录。</p><p>（4）<strong>@Inherited：</strong>允许子类继承父类中的注解</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>拓展：元数据</p><p>String name = “Tom”;</p></blockquote><h3 id="10-5-自定义注解的使用"><a href="#10-5-自定义注解的使用" class="headerlink" title="10.5 自定义注解的使用"></a>10.5 自定义注解的使用</h3><p>一个完整的注解应该包含三个部分：<br>（1）声明<br>（2）使用<br>（3）读取</p><h4 id="10-5-1-声明自定义注解"><a href="#10-5-1-声明自定义注解" class="headerlink" title="10.5.1 声明自定义注解"></a>10.5.1 声明自定义注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【元注解】</span><br><span class="line">【修饰符】 <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line">    【成员列表】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自定义注解可以通过四个元注解@Retention,@Target，@Inherited,@Documented，分别说明它的声明周期，使用位置，是否被继承，是否被生成到API文档中。</li><li>Annotation 的成员在 Annotation 定义中以无参数有返回值的抽象方法的形式来声明，我们又称为配置参数。返回值类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组</li><li>可以使用 default 关键字为抽象方法指定默认返回值</li><li>如果定义的注解含有抽象方法，那么使用时必须指定返回值，除非它有默认值。格式是“方法名 = 返回值”，如果只有一个抽象方法需要赋值，且方法名为value，可以省略“value=”，所以如果注解只有一个抽象方法成员，建议使用方法名value。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Table &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Column &#123;</span><br><span class="line">    String <span class="title function_">columnName</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">columnType</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-5-2-使用自定义注解"><a href="#10-5-2-使用自定义注解" class="headerlink" title="10.5.2 使用自定义注解"></a>10.5.2 使用自定义注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.annotation;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Table(&quot;t_stu&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="meta">@Column(columnName = &quot;sid&quot;,columnType = &quot;int&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="meta">@Column(columnName = &quot;sname&quot;,columnType = &quot;varchar(20)&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="10-5-3-读取和处理自定义注解"><a href="#10-5-3-读取和处理自定义注解" class="headerlink" title="10.5.3 读取和处理自定义注解"></a>10.5.3 读取和处理自定义注解</h4><p>自定义注解必须配上注解的信息处理流程才有意义。</p><p>我们自己定义的注解，只能使用反射的代码读取。所以自定义注解的声明周期必须是RetentionPolicy.RUNTIME。</p><p>具体的使用见<code>《尚硅谷_宋红康_第17章_反射机制.md》</code>。</p><h3 id="10-6-JUnit单元测试"><a href="#10-6-JUnit单元测试" class="headerlink" title="10.6 JUnit单元测试"></a>10.6 JUnit单元测试</h3><h4 id="10-6-1-测试分类"><a href="#10-6-1-测试分类" class="headerlink" title="10.6.1 测试分类"></a>10.6.1 测试分类</h4><p><strong>黑盒测试：</strong>不需要写代码，给输入值，看程序是否能够输出期望的值。 </p><p><strong>白盒测试：</strong>需要写代码的。关注程序具体的执行流程。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220511181800694.png" alt="image-20220511181800694" style="zoom: 50%;"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220524102038600.png" alt="image-20220524102038600"></p><h4 id="10-6-2-JUnit单元测试介绍"><a href="#10-6-2-JUnit单元测试介绍" class="headerlink" title="10.6.2 JUnit单元测试介绍"></a>10.6.2 JUnit单元测试介绍</h4><p>JUnit 是由 Erich Gamma 和 Kent Beck 编写的一个测试框架（regression testing framework），供Java开发人员编写单元测试之用。</p><p><strong>JUnit测试是程序员测试，即所谓白盒测试，因为程序员知道被测试的软件如何（How）完成功能和完成什么样（What）的功能。</strong></p><p>要使用JUnit，必须在项目的编译路径中<code>引入JUnit的库</code>，即相关的.class文件组成的jar包。jar就是一个压缩包，压缩包都是开发好的第三方（Oracle公司第一方，我们自己第二方，其他都是第三方）工具类，都是以class文件形式存在的。</p><h4 id="10-6-3-引入本地JUnit-jar"><a href="#10-6-3-引入本地JUnit-jar" class="headerlink" title="10.6.3 引入本地JUnit.jar"></a>10.6.3 引入本地JUnit.jar</h4><p>第1步：在项目中File-Project Structure中操作：添加Libraries库</p><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20211228180938922.png" alt="image-20211228180938922" style="zoom:80%;"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20221002195547325.png" alt="image-20221002195547325"></p><p>其中，junit-libs包内容如下：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220813005206452.png" alt="image-20220813005206452"></p><p>第2步：选择要在哪些module中应用JUnit库</p><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220813005511062.png" alt="image-20220813005511062"></p><p>第3步：检查是否应用成功</p><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220813005729233.png" alt="image-20220813005729233"></p><p><strong>注意Scope：选择Compile，否则编译时，无法使用JUnit。</strong></p><p>第4步：下次如果有新的模块要使用该libs库，这样操作即可</p><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220813005944022.png" alt="image-20220813005944022"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220813010018152.png" alt="image-20220813010018152"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220813010055217.png" alt="image-20220813010055217"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220813010124381.png" alt="image-20220813010124381"></p><h4 id="10-6-4-编写和运行-Test单元测试方法"><a href="#10-6-4-编写和运行-Test单元测试方法" class="headerlink" title="10.6.4 编写和运行@Test单元测试方法"></a>10.6.4 编写和运行@Test单元测试方法</h4><p>JUnit4版本，要求@Test标记的方法必须满足如下要求：</p><ul><li>所在的类必须是public的，非抽象的，包含唯一的无参构造器。</li><li>@Test标记的方法本身必须是public，非抽象的，非静态的，void无返回值，()无参数的。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.junit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJUnit</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TestJUnit.test01&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TestJUnit.test02&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TestJUnit.test03&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220106152412245.png" alt="image-20220106152412245"></p><h4 id="10-6-5-设置执行JUnit用例时支持控制台输入"><a href="#10-6-5-设置执行JUnit用例时支持控制台输入" class="headerlink" title="10.6.5 设置执行JUnit用例时支持控制台输入"></a>10.6.5 设置执行JUnit用例时支持控制台输入</h4><p><strong>1. 设置数据：</strong></p><p>默认情况下，在单元测试方法中使用Scanner时，并不能实现控制台数据的输入。需要做如下设置：</p><p>在<code>idea64.exe.vmoptions配置文件</code>中加入下面一行设置，重启idea后生效。</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">-Deditable.java.test.console</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><p><strong>2. 配置文件位置：</strong></p><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220813011625546.png" alt="image-20220813011625546"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220813011642180.png" alt="image-20220813011642180"></p><p>添加完成之后，重启IDEA即可。</p><p><strong>3. 如果上述位置设置不成功，需要继续修改如下位置</strong></p><p>修改位置1：IDEA安装目录的bin目录（例如：<code>D:\develop_tools\IDEA\IntelliJ IDEA 2022.1.2\bin</code>）下的idea64.exe.vmoptions文件。 </p><p>修改位置2：C盘的用户目录<code>C:\Users\用户名\AppData\Roaming\JetBrains\IntelliJIdea2022.1</code> 下的idea64.exe.vmoptions`件。</p><h4 id="10-6-6-定义test测试方法模板"><a href="#10-6-6-定义test测试方法模板" class="headerlink" title="10.6.6 定义test测试方法模板"></a>10.6.6 定义test测试方法模板</h4><p>选中自定义的模板组，点击”+”（1.Live Template）来定义模板。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20211229100040505.png" alt="image-20211229100040505"></p><h2 id="11-包装类"><a href="#11-包装类" class="headerlink" title="11. 包装类"></a>11. 包装类</h2><h3 id="11-1-为什么需要包装类"><a href="#11-1-为什么需要包装类" class="headerlink" title="11.1 为什么需要包装类"></a>11.1 为什么需要包装类</h3><p>Java提供了两个类型系统，<code>基本数据类型</code>与<code>引用数据类型</code>。使用基本数据类型在于效率，然而当要使用只针对对象设计的API或新特性（例如泛型），怎么办呢？例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//情况1：方法形参</span></span><br><span class="line">Object类的equals(Object obj)</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况2：方法形参</span></span><br><span class="line">ArrayList类的add(Object obj)</span><br><span class="line"><span class="comment">//没有如下的方法：</span></span><br><span class="line">add(<span class="type">int</span> number)</span><br><span class="line">add(<span class="type">double</span> d)</span><br><span class="line">add(<span class="type">boolean</span> b)</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况3：泛型</span></span><br><span class="line">Set&lt;T&gt;</span><br><span class="line">List&lt;T&gt;</span><br><span class="line">Cllection&lt;T&gt;</span><br><span class="line">Map&lt;K,V&gt;</span><br></pre></td></tr></table></figure><h3 id="11-2-有哪些包装类"><a href="#11-2-有哪些包装类" class="headerlink" title="11.2 有哪些包装类"></a>11.2 有哪些包装类</h3><p>Java针对八种基本数据类型定义了相应的引用类型：包装类（封装类）。有了类的特点，就可以调用类中的方法，Java才是真正的面向对象。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220329001912486.png" alt="image-20220329001912486" style="zoom:80%;"></p><p>封装以后的，内存结构对比：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">520</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">520</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220514163725830.png" alt="image-20220514163725830" style="zoom:80%;"></p><h3 id="11-3-自定义包装类"><a href="#11-3-自定义包装类" class="headerlink" title="11.3 自定义包装类"></a>11.3 自定义包装类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInteger</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInteger</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInteger</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="11-4-包装类与基本数据类型间的转换"><a href="#11-4-包装类与基本数据类型间的转换" class="headerlink" title="11.4 包装类与基本数据类型间的转换"></a>11.4 包装类与基本数据类型间的转换</h3><h4 id="11-4-1-装箱"><a href="#11-4-1-装箱" class="headerlink" title="11.4.1 装箱"></a>11.4.1 装箱</h4><p> <strong>装箱：把基本数据类型转为包装类对象</strong></p><blockquote><p>转为包装类的对象，是为了使用专门为对象设计的API和特性</p></blockquote><p>基本数值——&gt;包装对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">4</span>);<span class="comment">//使用构造函数函数</span></span><br><span class="line"><span class="type">Float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Float</span>(“<span class="number">4.56</span>”);</span><br><span class="line"><span class="type">Long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Long</span>(“asdf”);  <span class="comment">//NumberFormatException</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">obj2</span> <span class="operator">=</span> Integer.valueOf(<span class="number">4</span>);<span class="comment">//使用包装类中的valueOf方法</span></span><br></pre></td></tr></table></figure><h4 id="11-4-2-拆箱"><a href="#11-4-2-拆箱" class="headerlink" title="11.4.2 拆箱"></a>11.4.2 拆箱</h4><p><strong>拆箱：把包装类对象拆为基本数据类型</strong></p><blockquote><p>转为基本数据类型，一般是因为需要运算，Java中的大多数运算符是为基本数据类型设计的。比较、算术等</p></blockquote><p>包装对象——&gt;基本数值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">4</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> obj.intValue();</span><br></pre></td></tr></table></figure><p><strong>自动装箱与拆箱：</strong></p><p>由于我们经常要做基本类型与包装类之间的转换，从<code>JDK5.0</code>开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>;<span class="comment">//自动装箱。相当于Integer i = Integer.valueOf(4);</span></span><br><span class="line">i = i + <span class="number">5</span>;<span class="comment">//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;</span></span><br><span class="line"><span class="comment">//加法运算完成后，再次装箱，把基本数值转成对象。</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：只能与自己对应的类型之间才能实现自动装箱与拆箱。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//错误的，1是int类型</span></span><br></pre></td></tr></table></figure><h3 id="11-5-基本数据类型、包装类与字符串间的转换"><a href="#11-5-基本数据类型、包装类与字符串间的转换" class="headerlink" title="11.5 基本数据类型、包装类与字符串间的转换"></a>11.5 基本数据类型、包装类与字符串间的转换</h3><p><strong>（1）基本数据类型转为字符串</strong></p><p><strong>方式1：</strong>调用字符串重载的valueOf()方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//String str = a;//错误的</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.valueOf(a);</span><br></pre></td></tr></table></figure><p><strong>方式2：</strong>更直接的方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> a + <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>（2）字符串转为基本数据类型</strong></p><p><strong>方式1：</strong>除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型，例如：</p><ul><li><code>public static int parseInt(String s)</code>：将字符串参数转换为对应的int基本类型。</li><li><code>public static long parseLong(String s)</code>：将字符串参数转换为对应的long基本类型。</li><li><code>public static double parseDouble(String s)</code>：将字符串参数转换为对应的double基本类型。</li></ul><p><strong>方式2：</strong>字符串转为包装类，然后可以自动拆箱为基本数据类型</p><ul><li><code>public static Integer valueOf(String s)</code>：将字符串参数转换为对应的Integer包装类，然后可以自动拆箱为int基本类型</li><li><code>public static Long valueOf(String s)</code>：将字符串参数转换为对应的Long包装类，然后可以自动拆箱为long基本类型</li><li><code>public static Double valueOf(String s)</code>：将字符串参数转换为对应的Double包装类，然后可以自动拆箱为double基本类型</li></ul><p>注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出<code>java.lang.NumberFormatException</code>异常。</p><p><strong>方式3：</strong>通过包装类的构造器实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;整数的字符串&quot;</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> Double.parseDouble(<span class="string">&quot;小数的字符串&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> Boolean.parseBoolean(<span class="string">&quot;true或false&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.valueOf(<span class="string">&quot;整数的字符串&quot;</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> Double.valueOf(<span class="string">&quot;小数的字符串&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> Boolean.valueOf(<span class="string">&quot;true或false&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(“<span class="number">12</span>”);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其他方式小结：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/image-20220813012801907.png" alt="image-20220813012801907"></p><h3 id="11-6-包装类的其它API"><a href="#11-6-包装类的其它API" class="headerlink" title="11.6 包装类的其它API"></a>11.6 包装类的其它API</h3><h4 id="11-6-1-数据类型的最大最小值"><a href="#11-6-1-数据类型的最大最小值" class="headerlink" title="11.6.1 数据类型的最大最小值"></a>11.6.1 数据类型的最大最小值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer.MAX_VALUE和Integer.MIN_VALUE</span><br><span class="line">    </span><br><span class="line">Long.MAX_VALUE和Long.MIN_VALUE</span><br><span class="line">    </span><br><span class="line">Double.MAX_VALUE和Double.MIN_VALUE</span><br></pre></td></tr></table></figure><h4 id="11-6-2-字符转大小写"><a href="#11-6-2-字符转大小写" class="headerlink" title="11.6.2 字符转大小写"></a>11.6.2 字符转大小写</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Character.toUpperCase(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line"></span><br><span class="line">Character.toLowerCase(<span class="string">&#x27;X&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="11-6-3-整数转进制"><a href="#11-6-3-整数转进制" class="headerlink" title="11.6.3 整数转进制"></a>11.6.3 整数转进制</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer.toBinaryString(<span class="type">int</span> i) </span><br><span class="line">    </span><br><span class="line">Integer.toHexString(<span class="type">int</span> i)</span><br><span class="line">    </span><br><span class="line">Integer.toOctalString(<span class="type">int</span> i)</span><br></pre></td></tr></table></figure><h4 id="11-6-4-比较的方法"><a href="#11-6-4-比较的方法" class="headerlink" title="11.6.4 比较的方法"></a>11.6.4 比较的方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Double.compare(<span class="type">double</span> d1, <span class="type">double</span> d2)</span><br><span class="line">    </span><br><span class="line">Integer.compare(<span class="type">int</span> x, <span class="type">int</span> y) </span><br></pre></td></tr></table></figure><h3 id="11-7-包装类对象的特点"><a href="#11-7-包装类对象的特点" class="headerlink" title="11.7 包装类对象的特点"></a>11.7 包装类对象的特点</h3><h4 id="11-7-1-包装类缓存对象"><a href="#11-7-1-包装类缓存对象" class="headerlink" title="11.7.1 包装类缓存对象"></a>11.7.1 包装类缓存对象</h4><div class="table-container"><table><thead><tr><th>包装类</th><th>缓存对象</th></tr></thead><tbody><tr><td>Byte</td><td>-128~127</td></tr><tr><td>Short</td><td>-128~127</td></tr><tr><td>Integer</td><td>-128~127</td></tr><tr><td>Long</td><td>-128~127</td></tr><tr><td>Float</td><td>没有</td></tr><tr><td>Double</td><td>没有</td></tr><tr><td>Character</td><td>0~127</td></tr><tr><td>Boolean</td><td>true和false</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">System.out.println(a == b);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.println(i == j);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);<span class="comment">//新new的在堆中</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//这个用的是缓冲的常量对象，在方法区</span></span><br><span class="line">System.out.println(m == n);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);<span class="comment">//新new的在堆中</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);<span class="comment">//另一个新new的在堆中</span></span><br><span class="line">System.out.println(x == y);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Double</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line"><span class="type">Double</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">System.out.println(d1==d2);<span class="comment">//false 比较地址，没有缓存对象，每一个都是新new的</span></span><br></pre></td></tr></table></figure><h4 id="11-7-2-类型转换问题"><a href="#11-7-2-类型转换问题" class="headerlink" title="11.7.2 类型转换问题"></a>11.7.2 类型转换问题</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">System.out.println(i==j);<span class="comment">//true  会先将i自动拆箱为int，然后根据基本数据类型“自动类型转换”规则，转为double比较</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">System.out.println(i==j);<span class="comment">//true 会自动拆箱，按照基本数据类型进行比较</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1.0</span></span><br><span class="line">System.out.println(i==d);<span class="comment">//编译报错</span></span><br></pre></td></tr></table></figure><h4 id="11-7-3-包装类对象不可变"><a href="#11-7-3-包装类对象不可变" class="headerlink" title="11.7.3 包装类对象不可变"></a>11.7.3 包装类对象不可变</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestExam</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>);</span><br><span class="line"><span class="type">Circle</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">change(i,j,c);</span><br><span class="line">System.out.println(<span class="string">&quot;i = &quot;</span> + i);<span class="comment">//1</span></span><br><span class="line">System.out.println(<span class="string">&quot;j = &quot;</span> + j);<span class="comment">//2</span></span><br><span class="line">System.out.println(<span class="string">&quot;c.radius = &quot;</span> + c.radius);<span class="comment">//10.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 方法的参数传递机制：</span></span><br><span class="line"><span class="comment"> * （1）基本数据类型：形参的修改完全不影响实参</span></span><br><span class="line"><span class="comment"> * （2）引用数据类型：通过形参修改对象的属性值，会影响实参的属性值</span></span><br><span class="line"><span class="comment"> * 这类Integer等包装类对象是“不可变”对象，即一旦修改，就是新对象，和实参就无关了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> a ,Integer b,Circle c )</span>&#123;</span><br><span class="line">a += <span class="number">10</span>;</span><br><span class="line"><span class="comment">//b += 10;//等价于  b = new Integer(b+10);</span></span><br><span class="line">c.radius += <span class="number">10</span>;</span><br><span class="line"><span class="comment">/*c = new Circle();</span></span><br><span class="line"><span class="comment">c.radius+=10;*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line"><span class="type">double</span> radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-8-练习"><a href="#11-8-练习" class="headerlink" title="11.8 练习"></a>11.8 练习</h3><p>笔试题：如下两个题目输出结果相同吗？各是什么。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="literal">true</span> ? <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>) : <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">2.0</span>);</span><br><span class="line">System.out.println(o1);<span class="comment">//1.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object o2;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line">    o2 = <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    o2 = <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">2.0</span>);</span><br><span class="line">System.out.println(o2);<span class="comment">//1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>面试题：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">    System.out.println(i == j);</span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    System.out.println(m == n);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    System.out.println(x == y);<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>练习：</p><p>利用Vector代替数组处理：从键盘读入学生成绩（以负数代表输入结束），找出最高分，并输出学生成绩等级。</p><ul><li><p>提示：数组一旦创建，长度就固定不变，所以在创建数组前就需要知道它的长度。而向量类java.util.Vector可以根据需要动态伸缩。</p></li><li><p>创建Vector对象：Vector v=new Vector();</p></li><li><p>给向量添加元素：v.addElement(Object obj);  //obj必须是对象</p></li><li><p>取出向量中的元素：Object obj=v.elementAt(0);</p><ul><li>注意第一个元素的下标是0，返回值是Object类型的。</li></ul></li><li><p>计算向量的长度：v.size();</p></li><li><p>若与最高分相差10分内：A等；20分内：B等；30分内：C等；其它：D等</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第08章-面向对象编程-高级&quot;&gt;&lt;a href=&quot;#第08章-面向对象编程-高级&quot; class=&quot;headerlink&quot; title=&quot;第08章_面向对象编程(高级)&quot;&gt;&lt;/a&gt;第08章_面向对象编程(高级)&lt;/h1&gt;&lt;p&gt;讲师：尚硅谷-宋红康（江湖人称：康师傅）</summary>
      
    
    
    
    <category term="Java2023" scheme="http://example.com/categories/Java2023/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第10章_多线程</title>
    <link href="http://example.com/2023/02/18/java2023/%E7%AC%AC10%E7%AB%A0_%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://example.com/2023/02/18/java2023/%E7%AC%AC10%E7%AB%A0_%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2023-02-18T12:37:01.000Z</published>
    <updated>2023-02-19T07:45:29.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第10章-多线程"><a href="#第10章-多线程" class="headerlink" title="第10章_多线程"></a>第10章_多线程</h1><p>讲师：尚硅谷-宋红康（江湖人称：康师傅）</p><p>官网：<a href="http://www.atguigu.com/">http://www.atguigu.com</a></p><hr><h2 id="本章专题与脉络"><a href="#本章专题与脉络" class="headerlink" title="本章专题与脉络"></a>本章专题与脉络</h2><p><img src="/2023/02/18/java2023/%E7%AC%AC10%E7%AB%A0_%E5%A4%9A%E7%BA%BF%E7%A8%8B/第3阶段：Java高级应用-第10章.png" alt="第3阶段：Java高级应用-第10章" style="zoom: 50%;"></p><hr><p>我们之前学习的程序在没有跳转语句的情况下，都是由上至下沿着一条路径依次执行。现在想要设计一个程序，可以同时有多条执行路径同时执行。比如，<code>一边游戏，一边qq聊天，一边听歌</code>，怎么设计？</p><p><img src="/2023/02/18/java2023/%E7%AC%AC10%E7%AB%A0_%E5%A4%9A%E7%BA%BF%E7%A8%8B/c3dcb61e3b.png" alt="c3dcb61e3b" style="zoom:50%;"></p><p>要解决上述问题，需要使用<code>多进程</code>或者<code>多线程</code>来解决。</p><h2 id="1-相关概念"><a href="#1-相关概念" class="headerlink" title="1. 相关概念"></a>1. 相关概念</h2><h3 id="1-1-程序、进程与线程"><a href="#1-1-程序、进程与线程" class="headerlink" title="1.1 程序、进程与线程"></a>1.1 程序、进程与线程</h3><ul><li><p><strong>程序（program）</strong>：为完成特定任务，用某种语言编写的<code>一组指令的集合</code>。即指<code>一段静态的代码</code>，静态对象。</p></li><li><p><strong>进程（process）</strong>：程序的一次执行过程，或是正在内存中运行的应用程序。如：运行中的QQ，运行中的网易音乐播放器。</p><ul><li>每个进程都有一个独立的内存空间，系统运行一个程序即是一个进程从创建、运行到消亡的过程。（生命周期）</li><li>程序是静态的，进程是动态的</li><li>进程作为<code>操作系统调度和分配资源的最小单位</code>（亦是系统运行程序的基本单位），系统在运行时会为每个进程分配不同的内存区域。</li><li>现代的操作系统，大都是支持多进程的，支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。</li></ul></li><li><p><strong>线程（thread）</strong>：进程可进一步细化为线程，是程序内部的<code>一条执行路径</code>。一个进程中至少有一个线程。</p><ul><li><p>一个进程同一时间若<code>并行</code>执行多个线程，就是支持多线程的。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC10%E7%AB%A0_%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220331233204504.png" alt="image-20220331233204504" style="zoom:67%;"></p></li><li><p>线程作为<code>CPU调度和执行的最小单位</code>。</p></li><li><p>一个进程中的多个线程共享相同的内存单元，它们从同一个堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来<code>安全的隐患</code>。</p></li><li>下图中，红框的蓝色区域为线程独享，黄色区域为线程共享。</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC10%E7%AB%A0_%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220514175737426.png" alt="image-20220514175737426" style="zoom:80%;"></p><blockquote><p>注意：</p><p>不同的进程之间是不共享内存的。</p><p>进程之间的数据交换和通信的成本很高。</p><h3 id="1-2-查看进程和线程"><a href="#1-2-查看进程和线程" class="headerlink" title="1.2 查看进程和线程"></a>1.2 查看进程和线程</h3></blockquote></li></ul><p>我们可以在电脑底部任务栏，右键——-&gt;打开任务管理器，可以查看当前任务的进程：</p><p>1、每个应用程序的运行都是一个进程</p><p><img src="/2023/02/18/java2023/%E7%AC%AC10%E7%AB%A0_%E5%A4%9A%E7%BA%BF%E7%A8%8B/进程概念.png" style="zoom:80%;"></p><p>2、一个应用程序的多次运行，就是多个进程</p><p><img src="/2023/02/18/java2023/%E7%AC%AC10%E7%AB%A0_%E5%A4%9A%E7%BA%BF%E7%A8%8B/1563267431480.png" alt="1563267431480" style="zoom:80%;"></p><p>3、一个进程中包含多个线程</p><p><img src="/2023/02/18/java2023/%E7%AC%AC10%E7%AB%A0_%E5%A4%9A%E7%BA%BF%E7%A8%8B/1563270525077.png" alt="1563270525077" style="zoom:80%;"></p><h3 id="1-3-线程调度"><a href="#1-3-线程调度" class="headerlink" title="1.3 线程调度"></a>1.3 线程调度</h3><ul><li><p><strong>分时调度</strong></p><p>所有线程<code>轮流使用</code> CPU 的使用权，并且平均分配每个线程占用 CPU 的时间。</p></li><li><p><strong>抢占式调度</strong></p><p>让<code>优先级高</code>的线程以<code>较大的概率</code>优先使用 CPU。如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC10%E7%AB%A0_%E5%A4%9A%E7%BA%BF%E7%A8%8B/抢占式调度.bmp" alt="抢占式调度"></p></li></ul><h3 id="1-4-多线程程序的优点"><a href="#1-4-多线程程序的优点" class="headerlink" title="1.4 多线程程序的优点"></a>1.4 多线程程序的优点</h3><p><strong>背景：</strong>以单核CPU为例，只使用单个线程先后完成多个任务（调用多个方法），肯定比用多个线程来完成用的时间更短，为何仍需多线程呢？</p><p><strong>多线程程序的优点：</strong></p><ol><li><p>提高应用程序的响应。对图形化界面更有意义，可增强用户体验。</p></li><li><p>提高计算机系统CPU的利用率</p></li><li><p>改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改</p></li></ol><h3 id="1-5-补充概念"><a href="#1-5-补充概念" class="headerlink" title="1.5 补充概念"></a>1.5 补充概念</h3><h4 id="1-5-1-单核CPU和多核CPU"><a href="#1-5-1-单核CPU和多核CPU" class="headerlink" title="1.5.1 单核CPU和多核CPU"></a>1.5.1 单核CPU和多核CPU</h4><p>单核CPU，在一个时间单元内，只能执行一个线程的任务。例如，可以把CPU看成是医院的医生诊室，在一定时间内只能给一个病人诊断治疗。所以单核CPU就是，代码经过前面一系列的前导操作（类似于医院挂号，比如有10个窗口挂号），然后到cpu处执行时发现，就只有一个CPU（对应一个医生），大家排队执行。</p><p>这时候想要提升系统性能，只有两个办法，要么提升CPU性能（让医生看病快点），要么多加几个CPU（多整几个医生），即为多核的CPU。</p><p><code>问题：多核的效率是单核的倍数吗？</code>譬如4核A53的cpu，性能是单核A53的4倍吗？理论上是，但是实际不可能，至少有两方面的损耗。</p><ul><li><code>一个是多个核心的其他共用资源限制</code>。譬如，4核CPU对应的内存、cache、寄存器并没有同步扩充4倍。这就好像医院一样，1个医生换4个医生，但是做B超检查的还是一台机器，性能瓶颈就从医生转到B超检查了。</li><li><code>另一个是多核CPU之间的协调管理损耗</code>。譬如多个核心同时运行两个相关的任务，需要考虑任务同步，这也需要消耗额外性能。好比公司工作，一个人的时候至少不用开会浪费时间，自己跟自己商量就行了。两个人就要开会同步工作，协调分配，所以工作效率绝对不可能达到2倍。</li></ul><h4 id="1-5-2-并行与并发"><a href="#1-5-2-并行与并发" class="headerlink" title="1.5.2 并行与并发"></a>1.5.2 并行与并发</h4><ul><li><p><strong>并行（parallel）</strong>：指两个或多个事件在<code>同一时刻</code>发生（同时发生）。指在同一时刻，有<code>多条指令</code>在<code>多个CPU</code>上<code>同时</code>执行。比如：多个人同时做不同的事。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC10%E7%AB%A0_%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220401000804242.png" alt="image-20220401000804242"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC10%E7%AB%A0_%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220513181758585.png" alt="image-20220513181758585" style="zoom: 50%;"></p></li><li><p><strong>并发（concurrency）</strong>：指两个或多个事件在<code>同一个时间段内</code>发生。即在一段时间内，有<code>多条指令</code>在<code>单个CPU</code>上<code>快速轮换、交替</code>执行，使得在宏观上具有多个进程同时执行的效果。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC10%E7%AB%A0_%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220401000515678.png" alt="image-20220401000515678"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC10%E7%AB%A0_%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220513181815978.png" alt="image-20220513181815978" style="zoom:50%;"></p></li></ul><p>在操作系统中，启动了多个程序，<code>并发</code>指的是在一段时间内宏观上有多个程序同时运行，这在单核 CPU 系统中，每一时刻只能有一个程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。</p><p>而在多核 CPU 系统中，则这些可以<code>并发</code>执行的程序便可以分配到多个CPU上，实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核越多，<code>并行</code>处理的程序越多，能大大的提高电脑运行的效率。</p><h2 id="2-创建和启动线程"><a href="#2-创建和启动线程" class="headerlink" title="2.创建和启动线程"></a>2.创建和启动线程</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><ul><li><p>Java语言的JVM允许程序运行多个线程，使用<code>java.lang.Thread</code>类代表<strong>线程</strong>，所有的线程对象都必须是Thread类或其子类的实例。</p></li><li><p>Thread类的特性</p><ul><li>每个线程都是通过某个特定Thread对象的run()方法来完成操作的，因此把run()方法体称为<code>线程执行体</code>。</li><li>通过该Thread对象的start()方法来启动这个线程，而非直接调用run()</li><li>要想实现多线程，必须在主线程中创建新的线程对象。</li></ul></li></ul><h3 id="2-2-方式1：继承Thread类"><a href="#2-2-方式1：继承Thread类" class="headerlink" title="2.2 方式1：继承Thread类"></a>2.2 方式1：继承Thread类</h3><p>Java通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p><ol><li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务</li><li>创建Thread子类的实例，即创建了线程对象</li><li>调用线程对象的start()方法来启动该线程</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.thread;</span><br><span class="line"><span class="comment">//自定义线程类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">//定义指定线程名称的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">//调用父类的String参数的构造方法，指定线程的名称</span></span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写run方法，完成该线程执行的逻辑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">&quot;：正在执行！&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMyThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建自定义线程对象1</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">mt1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;子线程1&quot;</span>);</span><br><span class="line">        <span class="comment">//开启子线程1</span></span><br><span class="line">        mt1.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建自定义线程对象2</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">mt2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;子线程2&quot;</span>);</span><br><span class="line">        <span class="comment">//开启子线程2</span></span><br><span class="line">        mt2.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在主方法中执行for循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main线程！&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC10%E7%AB%A0_%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220401221215860.png" alt="image-20220401221215860" style="zoom:67%;"></p><blockquote><p>注意：</p><ol><li><p>如果自己手动调用run()方法，那么就只是普通方法，没有启动多线程模式。</p></li><li><p>run()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU调度决定。</p></li><li><p>想要启动多线程，必须调用start方法。</p></li><li><p>一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出以上的异常“<code>IllegalThreadStateException</code>”。</p></li></ol></blockquote><h3 id="2-3-方式2：实现Runnable接口"><a href="#2-3-方式2：实现Runnable接口" class="headerlink" title="2.3 方式2：实现Runnable接口"></a>2.3 方式2：实现Runnable接口</h3><p>Java有单继承的限制，当我们无法继承Thread类时，那么该如何做呢？在核心类库中提供了Runnable接口，我们可以实现Runnable接口，重写run()方法，然后再通过Thread类的对象代理启动和执行我们的线程体run()方法</p><p>步骤如下：</p><ol><li>定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li><li><p>创建Runnable实现类的实例，并以此实例作为Thread的target参数来创建Thread对象，该Thread对象才是真正<br>的线程对象。</p></li><li><p>调用线程对象的start()方法，启动线程。调用Runnable接口实现类的run方法。</p></li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMyRunnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建自定义类对象  线程任务对象</span></span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">mr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr, <span class="string">&quot;长江&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;黄河 &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 通过实现Runnable接口，使得该类有了多线程类的特征。所有的分线程要执行的代码都在run方法里面。</p><p>在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的start()方法来运行多线程代码。</p><p>实际上，所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现<br>Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。</p><p>说明：Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。<br>而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC10%E7%AB%A0_%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220401222212377.png" alt="image-20220401222212377"></p><h3 id="2-4-变形写法"><a href="#2-4-变形写法" class="headerlink" title="2.4 变形写法"></a>2.4 变形写法</h3><p><strong>使用匿名内部类对象来实现线程的创建和启动</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;新的线程！&quot;</span>)&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">System.out.println(getName()+<span class="string">&quot;：正在执行！&quot;</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;：&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><h3 id="2-5-对比两种方式"><a href="#2-5-对比两种方式" class="headerlink" title="2.5 对比两种方式"></a>2.5 对比两种方式</h3><p><strong>联系</strong></p><p>Thread类实际上也是实现了Runnable接口的类。即：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br></pre></td></tr></table></figure><p><strong>区别</strong></p><ul><li><p>继承Thread：线程代码存放Thread子类run方法中。</p></li><li><p>实现Runnable：线程代码存在接口的子类的run方法。</p></li></ul><p><strong>实现Runnable接口比继承Thread类所具有的优势</strong></p><ul><li>避免了单继承的局限性</li><li>多个线程可以共享同一个接口实现类的对象，非常适合多个相同线程来处理同一份资源。</li><li>增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。</li></ul><h3 id="2-6-练习"><a href="#2-6-练习" class="headerlink" title="2.6 练习"></a>2.6 练习</h3><p>创建两个分线程，让其中一个线程输出1-100之间的偶数，另一个线程输出1-100之间的奇数。</p><h2 id="3-Thread类的常用结构"><a href="#3-Thread类的常用结构" class="headerlink" title="3. Thread类的常用结构"></a>3. Thread类的常用结构</h2><h3 id="3-1-构造器"><a href="#3-1-构造器" class="headerlink" title="3.1 构造器"></a>3.1 构造器</h3><ul><li>public Thread() :分配一个新的线程对象。</li><li>public Thread(String name) :分配一个指定名字的新的线程对象。</li><li>public Thread(Runnable target) :指定创建线程的目标对象，它实现了Runnable接口中的run方法</li><li>public Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字。</li></ul><h3 id="3-2-常用方法系列1"><a href="#3-2-常用方法系列1" class="headerlink" title="3.2 常用方法系列1"></a>3.2 常用方法系列1</h3><ul><li>public void run() :此线程要执行的任务在此处定义代码。</li><li>public void start() :导致此线程开始执行; Java虚拟机调用此线程的run方法。</li><li>public String getName() :获取当前线程名称。</li><li>public void setName(String name)：设置该线程名称。</li><li>public static Thread currentThread() :返回对当前正在执行的线程对象的引用。在Thread子类中就是this，通常用于主线程和Runnable实现类</li><li>public static void sleep(long millis) :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。</li><li>public static void yield()：yield只是让当前线程暂停一下，让系统的线程调度器重新调度一次，希望优先级与当前线程相同或更高的其他线程能够获得执行机会，但是这个不能保证，完全有可能的情况是，当某个线程调用了yield方法暂停之后，线程调度器又将其调度出来重新执行。</li></ul><h3 id="3-3-常用方法系列2"><a href="#3-3-常用方法系列2" class="headerlink" title="3.3 常用方法系列2"></a>3.3 常用方法系列2</h3><ul><li><p>public final boolean isAlive()：测试线程是否处于活动状态。如果线程已经启动且尚未终止，则为活动状态。 </p></li><li><p>void join() ：等待该线程终止。 </p><p>void join(long millis) ：等待该线程终止的时间最长为 millis 毫秒。如果millis时间到，将不再等待。 </p><p>void join(long millis, int nanos) ：等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。 </p></li><li><p>public final void stop()：<code>已过时</code>，不建议使用。强行结束一个线程的执行，直接进入死亡状态。run()即刻停止，可能会导致一些清理性的工作得不到完成，如文件，数据库等的关闭。同时，会立即释放该线程所持有的所有的锁，导致数据得不到同步的处理，出现数据不一致的问题。</p></li><li><p>void suspend() / void resume() : 这两个操作就好比播放器的暂停和恢复。二者必须成对出现，否则非常容易发生死锁。suspend()调用会导致线程暂停，但不会释放任何锁资源，导致其它线程都无法访问被它占用的锁，直到调用resume()。<code>已过时</code>，不建议使用。</p></li></ul><h3 id="3-4-常用方法系列3"><a href="#3-4-常用方法系列3" class="headerlink" title="3.4 常用方法系列3"></a>3.4 常用方法系列3</h3><p>每个线程都有一定的优先级，同优先级线程组成先进先出队列（先到先服务），使用分时调度策略。优先级高的线程采用抢占式策略，获得较多的执行机会。每个线程默认的优先级都与创建它的父线程具有相同的优先级。</p><ul><li>Thread类的三个优先级常量：<ul><li>MAX_PRIORITY（10）：最高优先级 </li><li>MIN _PRIORITY （1）：最低优先级</li><li>NORM_PRIORITY （5）：普通优先级，默认情况下main线程具有普通优先级。</li></ul></li></ul><ul><li>public final int getPriority() ：返回线程优先级 </li><li>public final void setPriority(int newPriority) ：改变线程的优先级，范围在[1,10]之间。</li></ul><p>练习：获取main线程对象的名称和优先级。</p><p>声明一个匿名内部类继承Thread类，重写run方法，在run方法中获取线程名称和优先级。设置该线程优先级为最高优先级并启动该线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(getName() + <span class="string">&quot;的优先级：&quot;</span> + getPriority());</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">t.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">t.start();</span><br><span class="line"></span><br><span class="line">System.out.println(Thread.currentThread().getName() +<span class="string">&quot;的优先级：&quot;</span> +                                           Thread.currentThread().getPriority());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例：</p><ul><li><p>声明一个匿名内部类继承Thread类，重写run方法，实现打印[1,100]之间的偶数，要求每隔1秒打印1个偶数。</p></li><li><p>声明一个匿名内部类继承Thread类，重写run方法，实现打印[1,100]之间的奇数，</p><ul><li>当打印到5时，让奇数线程暂停一下，再继续。</li><li>当打印到5时，让奇数线程停下来，让偶数线程执行完再打印。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.api;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThreadStateChange</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">te</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= <span class="number">100</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;偶数线程：&quot;</span> + i);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        te.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">to</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;奇数线程：&quot;</span> + i);</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line"><span class="comment">//                        Thread.yield();</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            te.join();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        to.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产实践中的趣事：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC10%E7%AB%A0_%E5%A4%9A%E7%BA%BF%E7%A8%8B/这是要闹哪样.jpg" alt></p><h3 id="3-5-守护线程（了解）"><a href="#3-5-守护线程（了解）" class="headerlink" title="3.5 守护线程（了解）"></a>3.5 守护线程（了解）</h3><p>有一种线程，它是在后台运行的，它的任务是为其他线程提供服务的，这种线程被称为“守护线程”。JVM的垃圾回收线程就是典型的守护线程。</p><p>守护线程有个特点，就是如果所有非守护线程都死亡，那么守护线程自动死亡。形象理解：<code>兔死狗烹</code>，<code>鸟尽弓藏</code></p><p>调用setDaemon(true)方法可将指定线程设置为守护线程。必须在线程启动之前设置，否则会报IllegalThreadStateException异常。</p><p>调用isDaemon()可以判断线程是否是守护线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">MyDaemon</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyDaemon</span>();</span><br><span class="line">m.setDaemon(<span class="literal">true</span>);</span><br><span class="line">m.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;main:&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDaemon</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;我一直守护者你...&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-多线程的生命周期"><a href="#4-多线程的生命周期" class="headerlink" title="4. 多线程的生命周期"></a>4. 多线程的生命周期</h2><p>Java语言使用Thread类及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下一些状态：</p><h3 id="4-1-JDK1-5之前：5种状态"><a href="#4-1-JDK1-5之前：5种状态" class="headerlink" title="4.1 JDK1.5之前：5种状态"></a>4.1 JDK1.5之前：5种状态</h3><p>线程的生命周期有五种状态：新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）、死亡（Dead）。CPU需要在多条线程之间切换，于是线程状态会多次在运行、阻塞、就绪之间切换。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC10%E7%AB%A0_%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220401002307038.png" alt="image-20220401002307038" style="zoom: 67%;"></p><p><strong>1.新建</strong></p><p>当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态。此时它和其他Java对象一样，仅仅由JVM为其分配了内存，并初始化了实例变量的值。此时的线程对象并没有任何线程的动态特征，程序也不会执行它的线程体run()。</p><p><strong>2.就绪</strong></p><p>但是当线程对象调用了start()方法之后，就不一样了，线程就从新建状态转为就绪状态。JVM会为其创建方法调用栈和程序计数器，当然，处于这个状态中的线程并没有开始运行，只是表示已具备了运行的条件，随时可以被调度。至于什么时候被调度，取决于JVM里线程调度器的调度。</p><blockquote><p>注意：</p><p>程序只能对新建状态的线程调用start()，并且只能调用一次，如果对非新建状态的线程，如已启动的线程或已死亡的线程调用start()都会报错IllegalThreadStateException异常。</p></blockquote><p><strong>3.运行</strong></p><p>如果处于就绪状态的线程获得了CPU资源时，开始执行run()方法的线程体代码，则该线程处于运行状态。如果计算机只有一个CPU核心，在任何时刻只有一个线程处于运行状态，如果计算机有多个核心，将会有多个线程并行(Parallel)执行。</p><p>当然，美好的时光总是短暂的，而且CPU讲究雨露均沾。对于抢占式策略的系统而言，系统会给每个可执行的线程一个小时间段来处理任务，当该时间用完，系统会剥夺该线程所占用的资源，让其回到就绪状态等待下一次被调度。此时其他线程将获得执行机会，而在选择下一个线程时，系统会适当考虑线程的优先级。</p><p><strong>4.阻塞</strong></p><p>当在运行过程中的线程遇到如下情况时，会让出 CPU 并临时中止自己的执行，进入阻塞状态：</p><ul><li>线程调用了sleep()方法，主动放弃所占用的CPU资源；</li><li>线程试图获取一个同步监视器，但该同步监视器正被其他线程持有；</li><li>线程执行过程中，同步监视器调用了wait()，让它等待某个通知（notify）；</li><li>线程执行过程中，同步监视器调用了wait(time)</li><li>线程执行过程中，遇到了其他线程对象的加塞（join）；</li><li>线程被调用suspend方法被挂起（已过时，因为容易发生死锁）；</li></ul><p>当前正在执行的线程被阻塞后，其他线程就有机会执行了。针对如上情况，当发生如下情况时会解除阻塞，让该线程重新进入就绪状态，等待线程调度器再次调度它：</p><ul><li>线程的sleep()时间到；</li><li>线程成功获得了同步监视器；</li><li>线程等到了通知(notify)；</li><li>线程wait的时间到了</li><li>加塞的线程结束了；</li><li>被挂起的线程又被调用了resume恢复方法（已过时，因为容易发生死锁）；</li></ul><p><strong>5.死亡</strong></p><p>线程会以以下三种方式之一结束，结束后的线程就处于死亡状态：</p><ul><li>run()方法执行完成，线程正常结束</li><li>线程执行过程中抛出了一个未捕获的异常（Exception）或错误（Error）</li><li>直接调用该线程的stop()来结束该线程（已过时）</li></ul><h3 id="4-2-JDK1-5及之后：6种状态"><a href="#4-2-JDK1-5及之后：6种状态" class="headerlink" title="4.2 JDK1.5及之后：6种状态"></a>4.2 JDK1.5及之后：6种状态</h3><p>在java.lang.Thread.State的枚举类中这样定义：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">NEW,</span><br><span class="line">RUNNABLE,</span><br><span class="line">BLOCKED,</span><br><span class="line">WAITING,</span><br><span class="line">TIMED_WAITING,</span><br><span class="line">TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>NEW（新建）</code>：线程刚被创建，但是并未启动。还没调用start方法。</p></li><li><p><code>RUNNABLE（可运行）</code>：这里没有区分就绪和运行状态。因为对于Java对象来说，只能标记为可运行，至于什么时候运行，不是JVM来控制的了，是OS来进行调度的，而且时间非常短暂，因此对于Java对象的状态来说，无法区分。</p></li><li><p><code>Teminated（被终止）</code>：表明此线程已经结束生命周期，终止运行。</p></li><li><p>重点说明，根据Thread.State的定义，<strong>阻塞状态分为三种</strong>：<code>BLOCKED</code>、<code>WAITING</code>、<code>TIMED_WAITING</code>。</p><ul><li><code>BLOCKED（锁阻塞）</code>：在API中的介绍为：一个正在阻塞、等待一个监视器锁（锁对象）的线程处于这一状态。只有获得锁对象的线程才能有执行机会。<ul><li>比如，线程A与线程B代码中使用同一锁，如果线程A获取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。</li></ul></li><li><code>TIMED_WAITING（计时等待）</code>：在API中的介绍为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。<ul><li>当前线程执行过程中遇到Thread类的<code>sleep</code>或<code>join</code>，Object类的<code>wait</code>，LockSupport类的<code>park</code>方法，并且在调用这些方法时，<code>设置了时间</code>，那么当前线程会进入TIMED_WAITING，直到时间到，或被中断。</li></ul></li><li><code>WAITING（无限等待）</code>：在API中介绍为：一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。<ul><li>当前线程执行过程中遇到遇到Object类的<code>wait</code>，Thread类的<code>join</code>，LockSupport类的<code>park</code>方法，并且在调用这些方法时，<code>没有指定时间</code>，那么当前线程会进入WAITING状态，直到被唤醒。<ul><li>通过Object类的wait进入WAITING状态的要有Object的notify/notifyAll唤醒；</li><li>通过Condition的await进入WAITING状态的要有Condition的signal方法唤醒；</li><li>通过LockSupport类的park方法进入WAITING状态的要有LockSupport类的unpark方法唤醒</li><li>通过Thread类的join进入WAITING状态，只有调用join方法的线程对象结束才能让当前线程恢复；</li></ul></li></ul></li></ul></li></ul><p>说明：当从WAITING或TIMED_WAITING恢复到Runnable状态时，如果发现当前线程没有得到监视器锁，那么会立刻转入BLOCKED状态。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC10%E7%AB%A0_%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220524203355448.png" alt="image-20220524203355448"></p><p>或</p><p><img src="/2023/02/18/java2023/%E7%AC%AC10%E7%AB%A0_%E5%A4%9A%E7%BA%BF%E7%A8%8B/线程的生命周期Thread.State.jpg" alt="线程的生命周期Thread.State"></p><blockquote><p>我们在翻阅API的时候会发现Timed Waiting（计时等待） 与 Waiting（无限等待） 状态联系还是很紧密的，<br>比如Waiting（无限等待） 状态中wait方法是空参的，而timed waiting（计时等待） 中wait方法是带参的。<br>这种带参的方法，其实是一种倒计时操作，相当于我们生活中的小闹钟，我们设定好时间，到时通知，可是<br>如果提前得到（唤醒）通知，那么设定好时间在通知也就显得多此一举了，那么这种设计方案其实是一举两<br>得。如果没有得到（唤醒）通知，那么线程就处于Timed Waiting状态，直到倒计时完毕自动醒来；如果在倒<br>计时期间得到（唤醒）通知，那么线程从Timed Waiting状态立刻唤醒。</p></blockquote><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 22:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadStateTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">SubThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubThread</span>();</span><br><span class="line">        System.out.println(t.getName() + <span class="string">&quot; 状态 &quot;</span> + t.getState());</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (Thread.State.TERMINATED != t.getState()) &#123;</span><br><span class="line">            System.out.println(t.getName() + <span class="string">&quot; 状态 &quot;</span> + t.getState());</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(t.getName() + <span class="string">&quot; 状态 &quot;</span> + t.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;打印：&quot;</span> + i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>命令行演示：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC10%E7%AB%A0_%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220524195035355.png" alt="image-20220524195035355"></p><h2 id="5-线程安全问题及解决"><a href="#5-线程安全问题及解决" class="headerlink" title="5. 线程安全问题及解决"></a>5. 线程安全问题及解决</h2><p>当我们使用多个线程访问<strong>同一资源</strong>（可以是同一个变量、同一个文件、同一条记录等）的时候，若多个线程<code>只有读操作</code>，那么不会发生线程安全问题。但是如果多个线程中对资源有<code>读和写</code>的操作，就容易出现线程安全问题。</p><p>举例：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC10%E7%AB%A0_%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20220401233218326.png" alt="image-20220401233218326" style="zoom:67%;"></p><p>类比：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC10%E7%AB%A0_%E5%A4%9A%E7%BA%BF%E7%A8%8B/当我以为我的代码很安全时，等等.gif" alt></p><h3 id="5-1-同一个资源问题和线程安全问题"><a href="#5-1-同一个资源问题和线程安全问题" class="headerlink" title="5.1 同一个资源问题和线程安全问题"></a>5.1 同一个资源问题和线程安全问题</h3><p>案例：</p><p>火车站要卖票，我们模拟火车站的卖票过程。因为疫情期间，本次列车的座位共100个（即，只能出售100张火车票）。我们来模拟车站的售票窗口，实现多个窗口同时售票的过程。注意：不能出现错票、重票。</p><h4 id="5-1-1-局部变量不能共享"><a href="#5-1-1-局部变量不能共享" class="headerlink" title="5.1.1 局部变量不能共享"></a>5.1.1 局部变量不能共享</h4><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">while</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;卖出一张票，票号:&quot;</span> + ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicketDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Window</span> <span class="variable">w1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window</span>();</span><br><span class="line">        <span class="type">Window</span> <span class="variable">w2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window</span>();</span><br><span class="line">        <span class="type">Window</span> <span class="variable">w3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window</span>();</span><br><span class="line"></span><br><span class="line">        w1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        w2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        w3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        w1.start();</span><br><span class="line">        w2.start();</span><br><span class="line">        w3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：发现卖出300张票。</p><p>问题：局部变量是每次调用方法都是独立的，那么每个线程的run()的ticket是独立的，不是共享数据。</p><h4 id="5-1-2-不同对象的实例变量不共享"><a href="#5-1-2-不同对象的实例变量不共享" class="headerlink" title="5.1.2 不同对象的实例变量不共享"></a>5.1.2 不同对象的实例变量不共享</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TicketWindow</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;卖出一张票，票号:&quot;</span> + ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicketDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TicketWindow</span> <span class="variable">w1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TicketWindow</span>();</span><br><span class="line">        <span class="type">TicketWindow</span> <span class="variable">w2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TicketWindow</span>();</span><br><span class="line">        <span class="type">TicketWindow</span> <span class="variable">w3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TicketWindow</span>();</span><br><span class="line"></span><br><span class="line">        w1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        w2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        w3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        w1.start();</span><br><span class="line">        w2.start();</span><br><span class="line">        w3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果：发现卖出300张票。</p><p>问题：不同的实例对象的实例变量是独立的。</p><h4 id="5-1-3-静态变量是共享的"><a href="#5-1-3-静态变量是共享的" class="headerlink" title="5.1.3 静态变量是共享的"></a>5.1.3 静态变量是共享的</h4><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TicketSaleThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);<span class="comment">//加入这个，使得问题暴露的更明显</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;卖出一张票，票号:&quot;</span> + ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicketDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TicketSaleThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TicketSaleThread</span>();</span><br><span class="line">        <span class="type">TicketSaleThread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TicketSaleThread</span>();</span><br><span class="line">        <span class="type">TicketSaleThread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TicketSaleThread</span>();</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        t3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">100</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">100</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">100</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">97</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">97</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">97</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">94</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">94</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">94</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">91</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">91</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">91</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">88</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">88</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">88</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">85</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">85</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">85</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">82</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">82</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">82</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">79</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">79</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">79</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">76</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">76</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">76</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">73</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">73</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">73</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">70</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">70</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">70</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">67</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">67</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">67</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">64</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">64</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">64</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">61</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">61</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">61</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">58</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">58</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">58</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">55</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">55</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">55</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">52</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">52</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">52</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">49</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">49</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">49</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">46</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">46</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">46</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">43</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">43</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">43</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">40</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">40</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">40</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">37</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">37</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">37</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">34</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">34</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">34</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">31</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">31</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">31</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">28</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">28</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">28</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">25</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">25</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">25</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">22</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">22</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">22</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">19</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">19</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">19</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">16</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">16</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">16</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">13</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">13</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">13</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">10</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">10</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">10</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">7</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">7</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">7</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">4</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">4</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">4</span></span><br><span class="line">窗口<span class="number">3</span>卖出一张票，票号:<span class="number">1</span></span><br><span class="line">窗口<span class="number">2</span>卖出一张票，票号:<span class="number">1</span></span><br><span class="line">窗口<span class="number">1</span>卖出一张票，票号:<span class="number">1</span></span><br></pre></td></tr></table></figure><p>结果：发现卖出近100张票。</p><p>问题1：但是有重复票或负数票问题。</p><p>原因：线程安全问题</p><p>问题2：如果要考虑有两场电影，各卖100张票等</p><p>原因：TicketThread类的静态变量，是所有TicketThread类的对象共享</p><h4 id="5-1-4-同一个对象的实例变量共享"><a href="#5-1-4-同一个对象的实例变量共享" class="headerlink" title="5.1.4 同一个对象的实例变量共享"></a>5.1.4 同一个对象的实例变量共享</h4><p>示例代码：多个Thread线程使用同一个Runnable对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.safe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TicketSaleRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);<span class="comment">//加入这个，使得问题暴露的更明显</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖出一张票，票号:&quot;</span> + ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicketDemo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TicketSaleRunnable</span> <span class="variable">tr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TicketSaleRunnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(tr, <span class="string">&quot;窗口一&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(tr, <span class="string">&quot;窗口二&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(tr, <span class="string">&quot;窗口三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果：发现卖出近100张票。</p><p>问题：但是有重复票或负数票问题。</p><p>原因：线程安全问题</p><h4 id="5-1-5-抽取资源类，共享同一个资源对象"><a href="#5-1-5-抽取资源类，共享同一个资源对象" class="headerlink" title="5.1.5 抽取资源类，共享同一个资源对象"></a>5.1.5 抽取资源类，共享同一个资源对象</h4><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.unsafe;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、编写资源类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);<span class="comment">//加入这个，使得问题暴露的更明显</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖出一张票，票号:&quot;</span> + ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;没有票了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getTicket</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ticket;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicketDemo5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//2、创建资源对象</span></span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、启动多个线程操作资源类的对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;窗口一&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    ticket.sale();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;窗口二&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    ticket.sale();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;窗口三&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：发现卖出近100张票。</p><p>问题：但是有重复票或负数票问题。</p><p>原因：线程安全问题</p><h3 id="5-2-同步机制解决线程安全问题"><a href="#5-2-同步机制解决线程安全问题" class="headerlink" title="5.2 同步机制解决线程安全问题"></a>5.2 同步机制解决线程安全问题</h3><p>要解决上述多线程并发访问一个资源的安全性问题:也就是解决重复票与不存在票问题，Java中提供了同步机制<br>(synchronized)来解决。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC10%E7%AB%A0_%E5%A4%9A%E7%BA%BF%E7%A8%8B/1563372934332.png" alt="1563372934332"></p><p>根据案例简述：</p><p>窗口1线程进入操作的时候，窗口2和窗口3线程只能在外等着，窗口1操作结束，窗口1和窗口2和窗口3才有机会进入代码去执行。也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。</p><p>为了保证每个线程都能正常执行原子操作，Java引入了线程同步机制。注意:在任何时候,最多允许一个线程拥有同步锁，谁拿到锁就进入代码块，其他的线程只能在外等着(BLOCKED)。</p><h4 id="5-2-1-同步机制解决线程安全问题的原理"><a href="#5-2-1-同步机制解决线程安全问题的原理" class="headerlink" title="5.2.1 同步机制解决线程安全问题的原理"></a>5.2.1 同步机制解决线程安全问题的原理</h4><p>同步机制的原理，其实就相当于给某段代码加“锁”，任何线程想要执行这段代码，都要先获得“锁”，我们称它为同步锁。因为Java对象在堆中的数据分为分为对象头、实例变量、空白的填充。而对象头中包含：</p><ul><li>Mark Word：记录了和当前对象有关的GC、锁标记等信息。</li><li>指向类的指针：每一个对象需要记录它是由哪个类创建出来的。</li><li>数组长度（只有数组对象才有）</li></ul><p>哪个线程获得了“同步锁”对象之后，”同步锁“对象就会记录这个线程的ID，这样其他线程就只能等待了，除非这个线程”释放“了锁对象，其他线程才能重新获得/占用”同步锁“对象。</p><h4 id="5-2-2-同步代码块和同步方法"><a href="#5-2-2-同步代码块和同步方法" class="headerlink" title="5.2.2 同步代码块和同步方法"></a>5.2.2 同步代码块和同步方法</h4><p><strong>同步代码块</strong>：synchronized 关键字可以用于某个区块前面，表示只对这个区块的资源实行互斥访问。<br>格式:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步锁)&#123;</span><br><span class="line">     需要同步操作的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>同步方法：</strong>synchronized 关键字直接修饰方法，表示同一时刻只有一个线程能进入这个方法，其他线程在外面等着。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">    可能会产生线程安全问题的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-3-同步锁机制"><a href="#5-2-3-同步锁机制" class="headerlink" title="5.2.3 同步锁机制"></a>5.2.3 同步锁机制</h4><p>在《Thinking in Java》中，是这么说的：对于并发工作，你需要某种方式来防止两个任务访问相同的资源（其实就是共享资源竞争）。 防止这种冲突的方法就是当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须锁定这项资源，使其他任务在其被解锁之前，就无法访问它了，而在其被解锁之时，另一个任务就可以锁定并使用它了。</p><h4 id="5-2-4-synchronized的锁是什么"><a href="#5-2-4-synchronized的锁是什么" class="headerlink" title="5.2.4 synchronized的锁是什么"></a>5.2.4 synchronized的锁是什么</h4><p>同步锁对象可以是任意类型，但是必须保证竞争“同一个共享资源”的多个线程必须使用同一个“同步锁对象”。</p><p>对于同步代码块来说，同步锁对象是由程序员手动指定的（很多时候也是指定为this或类名.class），但是对于同步方法来说，同步锁对象只能是默认的：</p><ul><li><p>静态方法：当前类的Class对象（类名.class）</p></li><li><p>非静态方法：this</p></li></ul><h4 id="5-2-5-同步操作的思考顺序"><a href="#5-2-5-同步操作的思考顺序" class="headerlink" title="5.2.5 同步操作的思考顺序"></a>5.2.5 同步操作的思考顺序</h4><p>1、如何找问题，即代码是否存在线程安全？（非常重要）<br>（1）明确哪些代码是多线程运行的代码<br>（2）明确多个线程是否有共享数据<br>（3）明确多线程运行代码中是否有多条语句操作共享数据</p><p>2、如何解决呢？（非常重要）<br>对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。<br>即所有操作共享数据的这些语句都要放在同步范围中</p><p>3、切记：</p><p>范围太小：不能解决安全问题</p><p>范围太大：因为一旦某个线程抢到锁，其他线程就只能等待，所以范围太大，效率会降低，不能合理利用CPU资源。</p><h4 id="5-2-6-代码演示"><a href="#5-2-6-代码演示" class="headerlink" title="5.2.6 代码演示"></a>5.2.6 代码演示</h4><h5 id="示例一：静态方法加锁"><a href="#示例一：静态方法加锁" class="headerlink" title="示例一：静态方法加锁"></a>示例一：静态方法加锁</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.safe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TicketSaleThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;<span class="comment">//直接锁这里，肯定不行，会导致，只有一个窗口卖票</span></span><br><span class="line">        <span class="keyword">while</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            saleOneTicket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saleOneTicket</span><span class="params">()</span>&#123;<span class="comment">//锁对象是TicketSaleThread类的Class对象，而一个类的Class对象在内存中肯定只有一个</span></span><br><span class="line">        <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;<span class="comment">//不加条件，相当于条件判断没有进入锁管控，线程安全问题就没有解决</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖出一张票，票号:&quot;</span> + ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicketDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TicketSaleThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TicketSaleThread</span>();</span><br><span class="line">        <span class="type">TicketSaleThread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TicketSaleThread</span>();</span><br><span class="line">        <span class="type">TicketSaleThread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TicketSaleThread</span>();</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        t3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="示例二：非静态方法加锁"><a href="#示例二：非静态方法加锁" class="headerlink" title="示例二：非静态方法加锁"></a>示例二：非静态方法加锁</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.safe;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicketDemo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TicketSaleRunnable</span> <span class="variable">tr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TicketSaleRunnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(tr, <span class="string">&quot;窗口一&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(tr, <span class="string">&quot;窗口二&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(tr, <span class="string">&quot;窗口三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TicketSaleRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;<span class="comment">//直接锁这里，肯定不行，会导致，只有一个窗口卖票</span></span><br><span class="line">        <span class="keyword">while</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            saleOneTicket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">saleOneTicket</span><span class="params">()</span> &#123;<span class="comment">//锁对象是this，这里就是TicketSaleRunnable对象，因为上面3个线程使用同一个TicketSaleRunnable对象，所以可以</span></span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;<span class="comment">//不加条件，相当于条件判断没有进入锁管控，线程安全问题就没有解决</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖出一张票，票号:&quot;</span> + ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="示例三：同步代码块"><a href="#示例三：同步代码块" class="headerlink" title="示例三：同步代码块"></a>示例三：同步代码块</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.safe;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicketDemo5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//2、创建资源对象</span></span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、启动多个线程操作资源类的对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;窗口一&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;<span class="comment">//不能给run()直接加锁，因为t1,t2,t3的三个run方法分别属于三个Thread类对象，</span></span><br><span class="line">                <span class="comment">// run方法是非静态方法，那么锁对象默认选this，那么锁对象根本不是同一个</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (ticket) &#123;</span><br><span class="line">                        ticket.sale();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;窗口二&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (ticket) &#123;</span><br><span class="line">                        ticket.sale();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (ticket) &#123;</span><br><span class="line">                        ticket.sale();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;窗口三&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、编写资源类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;<span class="comment">//也可以直接给这个方法加锁，锁对象是this，这里就是Ticket对象</span></span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖出一张票，票号:&quot;</span> + ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;没有票了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getTicket</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ticket;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-3-练习"><a href="#5-3-练习" class="headerlink" title="5.3 练习"></a>5.3 练习</h3><p>银行有一个账户。<br>有两个储户分别向同一个账户存3000元，每次存1000，存3次。每次存完打印账户余额。</p><p>问题：该程序是否有安全问题，如果有，如何解决？</p><p>【提示】<br>1，明确哪些代码是多线程运行代码，须写入run()方法<br>2，明确什么是共享数据。<br>3，明确多线程运行代码中哪些语句是操作共享数据的。</p><p>【拓展问题】可否实现两个储户交替存钱的操作</p><h2 id="6-再谈同步"><a href="#6-再谈同步" class="headerlink" title="6. 再谈同步"></a>6. 再谈同步</h2><h3 id="6-1-单例设计模式的线程安全问题"><a href="#6-1-单例设计模式的线程安全问题" class="headerlink" title="6.1 单例设计模式的线程安全问题"></a>6.1 单例设计模式的线程安全问题</h3><h4 id="6-1-1-饿汉式没有线程安全问题"><a href="#6-1-1-饿汉式没有线程安全问题" class="headerlink" title="6.1.1 饿汉式没有线程安全问题"></a>6.1.1 饿汉式没有线程安全问题</h4><p>饿汉式：在类初始化时就直接创建单例对象，而类初始化过程是没有线程安全问题的</p><p>形式一：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.single.hungry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HungrySingle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">HungrySingle</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HungrySingle</span>(); <span class="comment">//对象是否声明为final 都可以</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">HungrySingle</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HungrySingle <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>形式二：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class HungryOne&#123;</span></span><br><span class="line"><span class="comment">    public static final HungryOne INSTANCE = new HungryOne();</span></span><br><span class="line"><span class="comment">    private HungryOne()&#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">HungryOne</span>&#123;</span><br><span class="line">    INSTANCE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.single.hungry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HungrySingleTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">HungrySingle</span> <span class="variable">hs1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">HungrySingle</span> <span class="variable">hs2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//演示存在的线程安全问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                hs1 = HungrySingle.getInstance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                hs2 = HungrySingle.getInstance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(hs1);</span><br><span class="line">        System.out.println(hs2);</span><br><span class="line">        System.out.println(hs1 == hs2);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-1-2-懒汉式线程安全问题"><a href="#6-1-2-懒汉式线程安全问题" class="headerlink" title="6.1.2 懒汉式线程安全问题"></a>6.1.2 懒汉式线程安全问题</h4><p>懒汉式：延迟创建对象，第一次调用getInstance方法再创建对象</p><p>形式一：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.single.lazy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyOne</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyOne instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazyOne</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式1：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazyOne <span class="title function_">getInstance1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazyOne</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方式2：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazyOne <span class="title function_">getInstance2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(LazyOne.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">LazyOne</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方式3：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazyOne <span class="title function_">getInstance3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyOne.class) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);<span class="comment">//加这个代码，暴露问题</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">LazyOne</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    注意：上述方式3中，有指令重排问题</span></span><br><span class="line"><span class="comment">    mem = allocate(); 为单例对象分配内存空间</span></span><br><span class="line"><span class="comment">    instance = mem;   instance引用现在非空，但还未初始化</span></span><br><span class="line"><span class="comment">    ctorSingleton(instance); 为单例对象通过instance调用构造器</span></span><br><span class="line"><span class="comment">    从JDK2开始，分配空间、初始化、调用构造器会在线程的工作存储区一次性完成，然后复制到主存储区。但是需要   </span></span><br><span class="line"><span class="comment">    volatile关键字，避免指令重排。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>形式二：使用内部类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.single.lazy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingle</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingle <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Inner.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">LazySingle</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LazySingle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>内部类只有在外部类被调用才加载，产生INSTANCE实例；又不用加锁。</p><p>此模式具有之前两个模式的优点，同时屏蔽了它们的缺点，是最好的单例模式。</p><p>此时的内部类，使用enum进行定义，也是可以的。</p></blockquote><p>测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.single.lazy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLazy</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LazyOne</span> <span class="variable">s1</span> <span class="operator">=</span> LazyOne.getInstance();</span><br><span class="line">        <span class="type">LazyOne</span> <span class="variable">s2</span> <span class="operator">=</span> LazyOne.getInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把s1和s2声明在外面，是想要在线程的匿名内部类中为s1和s2赋值</span></span><br><span class="line">    LazyOne s1;</span><br><span class="line">    LazyOne s2;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                s1 = LazyOne.getInstance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                s2 = LazyOne.getInstance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    LazySingle obj1;</span><br><span class="line">    LazySingle obj2;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                obj1 = LazySingle.getInstance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                obj2 = LazySingle.getInstance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(obj1);</span><br><span class="line">        System.out.println(obj2);</span><br><span class="line">        System.out.println(obj1 == obj2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-2-死锁"><a href="#6-2-死锁" class="headerlink" title="6.2 死锁"></a>6.2 死锁</h3><p>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC10%E7%AB%A0_%E5%A4%9A%E7%BA%BF%E7%A8%8B/thread-lock.png" alt="thread-lock"></p><blockquote><p>【小故事】</p><p>面试官：你能解释清楚什么是死锁，我就录取你！<br>面试者：你录取我，我就告诉你什么是死锁！<br>….<br>恭喜你，面试通过了</p></blockquote><p>一旦出现死锁，整个程序既不会发生异常，也不会给出任何提示，只是所有线程处于阻塞状态，无法继续。</p><p>举例1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (s1) &#123;</span><br><span class="line">s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">s2.append(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">10</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (s2) &#123;</span><br><span class="line">s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">s2.append(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s1);</span><br><span class="line">System.out.println(s2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (s2) &#123;</span><br><span class="line">s1.append(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">s2.append(<span class="string">&quot;3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">10</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (s1) &#123;</span><br><span class="line">s1.append(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">s2.append(<span class="string">&quot;4&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s1);</span><br><span class="line">System.out.println(s2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(B b)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;当前线程名: &quot;</span> + Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">&quot; 进入了A实例的foo方法&quot;</span>); <span class="comment">// ①</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">ex.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;当前线程名: &quot;</span> + Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">&quot; 企图调用B实例的last方法&quot;</span>); <span class="comment">// ③</span></span><br><span class="line">b.last();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">last</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;进入了A类的last方法内部&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">(A a)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;当前线程名: &quot;</span> + Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">&quot; 进入了B实例的bar方法&quot;</span>); <span class="comment">// ②</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">ex.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;当前线程名: &quot;</span> + Thread.currentThread().getName()</span><br><span class="line">+ <span class="string">&quot; 企图调用A实例的last方法&quot;</span>); <span class="comment">// ④</span></span><br><span class="line">a.last();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">last</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;进入了B类的last方法内部&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line"><span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">Thread.currentThread().setName(<span class="string">&quot;主线程&quot;</span>);</span><br><span class="line"><span class="comment">// 调用a对象的foo方法</span></span><br><span class="line">a.foo(b);</span><br><span class="line">System.out.println(<span class="string">&quot;进入了主线程之后&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">Thread.currentThread().setName(<span class="string">&quot;副线程&quot;</span>);</span><br><span class="line"><span class="comment">// 调用b对象的bar方法</span></span><br><span class="line">b.bar(a);</span><br><span class="line">System.out.println(<span class="string">&quot;进入了副线程之后&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">DeadLock</span> <span class="variable">dl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadLock</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(dl).start();</span><br><span class="line">dl.init();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例3：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDeadLock</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">Owner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Owner</span>(g,m);</span><br><span class="line"><span class="type">Customer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(g,m);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(s).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(c).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Owner</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"><span class="keyword">private</span> Object goods;</span><br><span class="line"><span class="keyword">private</span> Object money;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Owner</span><span class="params">(Object goods, Object money)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.goods = goods;</span><br><span class="line"><span class="built_in">this</span>.money = money;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (goods) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;先给钱&quot;</span>);</span><br><span class="line"><span class="keyword">synchronized</span> (money) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;发货&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"><span class="keyword">private</span> Object goods;</span><br><span class="line"><span class="keyword">private</span> Object money;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">(Object goods, Object money)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.goods = goods;</span><br><span class="line"><span class="built_in">this</span>.money = money;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (money) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;先发货&quot;</span>);</span><br><span class="line"><span class="keyword">synchronized</span> (goods) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;再给钱&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>诱发死锁的原因：</strong></p><ul><li>互斥条件</li><li>占用且等待</li><li>不可抢夺（或不可抢占）</li><li>循环等待</li></ul><p>以上4个条件，同时出现就会触发死锁。</p><p><strong>解决死锁：</strong></p><p>死锁一旦出现，基本很难人为干预，只能尽量规避。可以考虑打破上面的诱发条件。</p><p>针对条件1：互斥条件基本上无法被破坏。因为线程需要通过互斥解决安全问题。</p><p>针对条件2：可以考虑一次性申请所有所需的资源，这样就不存在等待的问题。</p><p>针对条件3：占用部分资源的线程在进一步申请其他资源时，如果申请不到，就主动释放掉已经占用的资源。</p><p>针对条件4：可以将资源改为线性顺序。申请资源时，先申请序号较小的，这样避免循环等待问题。</p><h3 id="6-3-JDK5-0新特性：Lock-锁"><a href="#6-3-JDK5-0新特性：Lock-锁" class="headerlink" title="6.3 JDK5.0新特性：Lock(锁)"></a>6.3 JDK5.0新特性：Lock(锁)</h3><ul><li>JDK5.0的新增功能，保证线程的安全。与采用synchronized相比，Lock可提供多种锁方案，更灵活、更强大。Lock通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。</li><li>java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</li><li>在实现线程安全的控制中，比较常用的是<code>ReentrantLock</code>，可以显式加锁、释放锁。<ul><li>ReentrantLock类实现了 Lock 接口，它拥有与 synchronized 相同的并发性和内存语义，但是添加了类似锁投票、定时锁等候和可中断锁等候的一些特性。此外，它还提供了在激烈争用情况下更佳的性能。</li></ul></li><li><p>Lock锁也称同步锁，加锁与释放锁方法，如下：</p><ul><li>public void lock() :加同步锁。</li><li>public void unlock() :释放同步锁。</li></ul></li><li>代码结构</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">//1. 创建Lock的实例，必须确保多个线程共享同一个Lock实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReenTrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//2. 调动lock()，实现需共享的代码的锁定</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//保证线程安全的代码;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//3. 调用unlock()，释放共享代码的锁定</span></span><br><span class="line">lock.unlock();  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意：如果同步代码有异常，要将unlock()写入finally语句块。</p></blockquote><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//1. 创建Lock的实例，必须确保多个线程共享同一个Lock实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//2. 调动lock()，实现需共享的代码的锁定</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">10</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(ticket--);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                <span class="comment">//3. 调用unlock()，释放共享代码的锁定</span></span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLock</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Window</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>synchronized与Lock的对比</strong></p><ol><li>Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁，出了作用域、遇到异常等自动解锁</li><li>Lock只有代码块锁，synchronized有代码块锁和方法锁</li><li>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类），更体现面向对象。</li><li>（了解）Lock锁可以对读不加锁，对写加锁，synchronized不可以</li><li>（了解）Lock锁可以有多种获取锁的方式，可以从sleep的线程中抢到锁，synchronized不可以</li></ol><blockquote><p>说明：开发建议中处理线程安全问题优先使用顺序为：</p><p>•    Lock ——&gt; 同步代码块 ——&gt; 同步方法</p></blockquote><h2 id="7-线程的通信"><a href="#7-线程的通信" class="headerlink" title="7. 线程的通信"></a>7. 线程的通信</h2><h3 id="7-1-线程间通信"><a href="#7-1-线程间通信" class="headerlink" title="7.1 线程间通信"></a>7.1 线程间通信</h3><p><strong>为什么要处理线程间通信：</strong></p><p>当我们<code>需要多个线程</code>来共同完成一件任务，并且我们希望他们<code>有规律的执行</code>，那么多线程之间需要一些通信机制，可以协调它们的工作，以此实现多线程共同操作一份数据。</p><p>比如：线程A用来生产包子的，线程B用来吃包子的，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，此时B线程必须等到A线程完成后才能执行，那么线程A与线程B之间就需要线程通信，即—— <strong>等待唤醒机制。</strong></p><h3 id="7-2-等待唤醒机制"><a href="#7-2-等待唤醒机制" class="headerlink" title="7.2 等待唤醒机制"></a>7.2 等待唤醒机制</h3><p>这是多个线程间的一种<code>协作机制</code>。谈到线程我们经常想到的是线程间的<code>竞争（race）</code>，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。</p><p>在一个线程满足某个条件时，就进入等待状态（<code>wait() / wait(time)</code>）， 等待其他线程执行完他们的指定代码过后再将其唤醒（<code>notify()</code>）;或可以指定wait的时间，等时间到了自动唤醒；在有多个线程进行等待时，如果需要，可以使用 <code>notifyAll()</code>来唤醒所有的等待线程。wait/notify 就是线程间的一种协作机制。</p><ol><li>wait：线程不再活动，不再参与调度，进入 <code>wait set</code> 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态是 WAITING 或 TIMED_WAITING。它还要等着别的线程执行一个<code>特别的动作</code>，也即“<code>通知（notify）</code>”或者等待时间到，在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（<code>ready queue</code>）中</li><li>notify：则选取所通知对象的 wait set 中的一个线程释放；</li><li>notifyAll：则释放所通知对象的 wait set 上的全部线程。</li></ol><blockquote><p>注意：</p><p>被通知的线程被唤醒后也不一定能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以它需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。</p><p>总结如下：</p><ul><li>如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE（可运行） 状态；</li><li>否则，线程就从 WAITING 状态又变成 BLOCKED（等待锁） 状态</li></ul></blockquote><h3 id="7-3-举例"><a href="#7-3-举例" class="headerlink" title="7.3 举例"></a>7.3 举例</h3><p>例题：使用两个线程打印 1-100。线程1, 线程2 交替打印</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Communication</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                notify();</span><br><span class="line">                <span class="keyword">if</span> (i &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i++);</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-调用wait和notify需注意的细节"><a href="#7-4-调用wait和notify需注意的细节" class="headerlink" title="7.4 调用wait和notify需注意的细节"></a>7.4 调用wait和notify需注意的细节</h3><ol><li>wait方法与notify方法必须要由<code>同一个锁对象调用</code>。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。</li><li>wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。</li><li>wait方法与notify方法必须要在<code>同步代码块</code>或者是<code>同步函数</code>中使用。因为：必须要<code>通过锁对象</code>调用这2个方法。否则会报java.lang.IllegalMonitorStateException异常。</li></ol><h3 id="7-5-生产者与消费者问题"><a href="#7-5-生产者与消费者问题" class="headerlink" title="7.5 生产者与消费者问题"></a>7.5 生产者与消费者问题</h3><p>等待唤醒机制可以解决经典的“生产者与消费者”的问题。生产者与消费者问题（英语：Producer-consumer problem），也称有限缓冲问题（英语：Bounded-buffer problem），是一个多线程同步问题的经典案例。该问题描述了两个（多个）<code>共享固定大小缓冲区的线程</code>——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。</p><p>生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。<strong>该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。</strong></p><p><strong>举例：</strong></p><p>生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品，店员一次只能持有固定数量的产品(比如:20），如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。</p><p>类似的场景，比如厨师和服务员等。</p><p><strong>生产者与消费者问题中其实隐含了两个问题：</strong></p><ul><li>线程安全问题：因为生产者与消费者共享数据缓冲区，产生安全问题。不过这个问题可以使用同步解决。</li><li>线程的协调工作问题：<ul><li>要解决该问题，就必须让生产者线程在缓冲区满时等待(wait)，暂停进入阻塞状态，等到下次消费者消耗了缓冲区中的数据的时候，通知(notify)正在等待的线程恢复到就绪状态，重新开始往缓冲区添加数据。同样，也可以让消费者线程在缓冲区空时进入等待(wait)，暂停进入阻塞状态，等到生产者往缓冲区添加数据之后，再通知(notify)正在等待的线程恢复到就绪状态。通过这样的通信机制来解决此类问题。</li></ul></li></ul><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerProducerTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Clerk</span> <span class="variable">clerk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Clerk</span>();</span><br><span class="line"><span class="type">Producer</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(clerk);</span><br><span class="line"></span><br><span class="line"><span class="type">Consumer</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(clerk);</span><br><span class="line"><span class="type">Consumer</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(clerk);</span><br><span class="line"></span><br><span class="line">p1.setName(<span class="string">&quot;生产者1&quot;</span>);</span><br><span class="line">c1.setName(<span class="string">&quot;消费者1&quot;</span>);</span><br><span class="line">c2.setName(<span class="string">&quot;消费者2&quot;</span>);</span><br><span class="line"></span><br><span class="line">p1.start();</span><br><span class="line">c1.start();</span><br><span class="line">c2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"><span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Clerk clerk)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.clerk = clerk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;=========生产者开始生产产品========&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">40</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要求clerk去增加产品</span></span><br><span class="line">clerk.addProduct();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"><span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Clerk clerk)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.clerk = clerk;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;=========消费者开始消费产品========&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">90</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要求clerk去减少产品</span></span><br><span class="line">clerk.minusProduct();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//资源类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clerk</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">productNum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//产品数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_PRODUCT</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_PRODUCT</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addProduct</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(productNum &lt; MAX_PRODUCT)&#123;</span><br><span class="line">productNum++;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + </span><br><span class="line"><span class="string">&quot;生产了第&quot;</span> + productNum + <span class="string">&quot;个产品&quot;</span>);</span><br><span class="line"><span class="comment">//唤醒消费者</span></span><br><span class="line"><span class="built_in">this</span>.notifyAll();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.wait();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减少产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">minusProduct</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(productNum &gt;= MIN_PRODUCT)&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + </span><br><span class="line"><span class="string">&quot;消费了第&quot;</span> + productNum + <span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">productNum--;</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒生产者</span></span><br><span class="line"><span class="built_in">this</span>.notifyAll();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.wait();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-6-面试题：区分sleep-和wait"><a href="#7-6-面试题：区分sleep-和wait" class="headerlink" title="7.6 面试题：区分sleep()和wait()"></a>7.6 面试题：区分sleep()和wait()</h3><p>相同点：一旦执行，都会使得当前线程结束执行状态，进入阻塞状态。</p><p>不同点：</p><p> ① 定义方法所属的类：sleep():Thread中定义。  wait():Object中定义</p><p>② 使用范围的不同：sleep()可以在任何需要使用的位置被调用； wait():必须使用在同步代码块或同步方法中</p><p>③ 都在同步结构中使用的时候，是否释放同步监视器的操作不同：sleep():不会释放同步监视器 ;wait():会释放同步监视器</p><p>④ 结束等待的方式不同：sleep()：指定时间一到就结束阻塞。 wait():可以指定时间也可以无限等待直到notify或notifyAll。</p><h3 id="7-7-是否释放锁的操作"><a href="#7-7-是否释放锁的操作" class="headerlink" title="7.7 是否释放锁的操作"></a>7.7 是否释放锁的操作</h3><p>任何线程进入同步代码块、同步方法之前，必须先获得对同步监视器的锁定，那么何时会释放对同步监视器的锁定呢？</p><h4 id="7-7-1-释放锁的操作"><a href="#7-7-1-释放锁的操作" class="headerlink" title="7.7.1 释放锁的操作"></a>7.7.1 释放锁的操作</h4><p>当前线程的同步方法、同步代码块执行结束。</p><p>当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行。</p><p>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致当前线程异常结束。</p><p>当前线程在同步代码块、同步方法中执行了锁对象的wait()方法，当前线程被挂起，并释放锁。</p><h4 id="7-7-2-不会释放锁的操作"><a href="#7-7-2-不会释放锁的操作" class="headerlink" title="7.7.2 不会释放锁的操作"></a>7.7.2 不会释放锁的操作</h4><p>线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行。</p><p>线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该该线程挂起，该线程不会释放锁（同步监视器）。</p><ul><li>应尽量避免使用suspend()和resume()这样的过时来控制线程。</li></ul><h2 id="8-JDK5-0新增线程创建方式"><a href="#8-JDK5-0新增线程创建方式" class="headerlink" title="8. JDK5.0新增线程创建方式"></a>8. JDK5.0新增线程创建方式</h2><h3 id="8-1-新增方式一：实现Callable接口"><a href="#8-1-新增方式一：实现Callable接口" class="headerlink" title="8.1 新增方式一：实现Callable接口"></a>8.1 新增方式一：实现Callable接口</h3><ul><li>与使用Runnable相比， Callable功能更强大些<ul><li>相比run()方法，可以有返回值</li><li>方法可以抛出异常</li><li>支持泛型的返回值（需要借助FutureTask类，获取返回结果）</li></ul></li><li>Future接口（了解）<ul><li>可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。</li><li>FutureTask是Futrue接口的唯一的实现类</li><li>FutureTask 同时实现了Runnable, Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值</li></ul></li><li>缺点：在获取分线程执行结果的时候，当前线程（或是主线程）受阻塞，效率较低。</li><li>代码举例</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建多线程的方式三：实现Callable （jdk5.0新增的）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//1.创建一个实现Callable的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line">    <span class="comment">//2.实现call方法，将此线程需要执行的操作声明在call()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//3.创建Callable接口实现类的对象</span></span><br><span class="line">        <span class="type">NumThread</span> <span class="variable">numThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumThread</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</span></span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(numThread);</span><br><span class="line">        <span class="comment">//5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//      接收返回值</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//6.获取Callable中call方法的返回值</span></span><br><span class="line">            <span class="comment">//get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">sum</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;总和为：&quot;</span> + sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-新增方式二：使用线程池"><a href="#8-2-新增方式二：使用线程池" class="headerlink" title="8.2 新增方式二：使用线程池"></a>8.2 新增方式二：使用线程池</h3><p><strong>现有问题：</strong></p><p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p><p>那么有没有一种办法使得线程可以复用，即执行完一个任务，并不被销毁，而是可以继续执行其他的任务？</p><p><strong>思路：</strong>提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC10%E7%AB%A0_%E5%A4%9A%E7%BA%BF%E7%A8%8B/线程池的理解.jpg" alt="线程池的理解"></p><p><strong>好处：</strong></p><ul><li><p>提高响应速度（减少了创建新线程的时间）</p></li><li><p>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</p></li><li><p>便于线程管理</p><ul><li>corePoolSize：核心池的大小</li><li>maximumPoolSize：最大线程数</li><li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li><li>…</li></ul></li></ul><p><strong>线程池相关API</strong></p><ul><li>JDK5.0之前，我们必须手动自定义线程池。从JDK5.0开始，Java内置线程池相关的API。在java.util.concurrent包下提供了线程池相关API：<code>ExecutorService</code> 和 <code>Executors</code>。</li><li><code>ExecutorService</code>：真正的线程池接口。常见子类ThreadPoolExecutor<ul><li><code>void execute(Runnable command)</code> ：执行任务/命令，没有返回值，一般用来执行Runnable</li><li><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code>：执行任务，有返回值，一般又来执行Callable</li><li><code>void shutdown()</code> ：关闭连接池</li></ul></li><li><code>Executors</code>：一个线程池的工厂类，通过此类的静态工厂方法可以创建多种类型的线程池对象。<ul><li><code>Executors.newCachedThreadPool()</code>：创建一个可根据需要创建新线程的线程池</li><li><code>Executors.newFixedThreadPool(int nThreads)</code>; 创建一个可重用固定线程数的线程池</li><li><code>Executors.newSingleThreadExecutor()</code> ：创建一个只有一个线程的线程池</li><li><code>Executors.newScheduledThreadPool(int corePoolSize)</code>：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</li></ul></li></ul><p><strong>代码举例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread2</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">evenSum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录偶数的和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                evenSum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> evenSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 提供指定线程数量的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">service1</span> <span class="operator">=</span> (ThreadPoolExecutor) service;</span><br><span class="line"><span class="comment">//        //设置线程池的属性</span></span><br><span class="line"><span class="comment">//        System.out.println(service.getClass());//ThreadPoolExecutor</span></span><br><span class="line">        service1.setMaximumPoolSize(<span class="number">50</span>); <span class="comment">//设置线程池中线程数的上限</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread</span>());<span class="comment">//适合适用于Runnable</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread1</span>());<span class="comment">//适合适用于Runnable</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Future</span> <span class="variable">future</span> <span class="operator">=</span> service.submit(<span class="keyword">new</span> <span class="title class_">NumberThread2</span>());<span class="comment">//适合使用于Callable</span></span><br><span class="line">            System.out.println(<span class="string">&quot;总和为：&quot;</span> + future.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.关闭连接池</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第10章-多线程&quot;&gt;&lt;a href=&quot;#第10章-多线程&quot; class=&quot;headerlink&quot; title=&quot;第10章_多线程&quot;&gt;&lt;/a&gt;第10章_多线程&lt;/h1&gt;&lt;p&gt;讲师：尚硅谷-宋红康（江湖人称：康师傅）&lt;/p&gt;
&lt;p&gt;官网：&lt;a href=&quot;http:/</summary>
      
    
    
    
    <category term="Java2023" scheme="http://example.com/categories/Java2023/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第11章_常用类和基础API</title>
    <link href="http://example.com/2023/02/18/java2023/%E7%AC%AC11%E7%AB%A0_%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%A1%80API/"/>
    <id>http://example.com/2023/02/18/java2023/%E7%AC%AC11%E7%AB%A0_%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%A1%80API/</id>
    <published>2023-02-18T12:37:01.000Z</published>
    <updated>2023-02-19T07:38:43.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第11章-常用类和基础API"><a href="#第11章-常用类和基础API" class="headerlink" title="第11章_常用类和基础API"></a>第11章_常用类和基础API</h1><p>讲师：尚硅谷-宋红康（江湖人称：康师傅）</p><p>官网：<a href="http://www.atguigu.com/">http://www.atguigu.com</a></p><hr><h2 id="本章专题与脉络"><a href="#本章专题与脉络" class="headerlink" title="本章专题与脉络"></a>本章专题与脉络</h2><p><img src="/2023/02/18/java2023/%E7%AC%AC11%E7%AB%A0_%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%A1%80API/第3阶段：Java高级应用-第11章.png" alt="第3阶段：Java高级应用-第11章" style="zoom:50%;"></p><h2 id="1-字符串相关类之不可变字符序列：String"><a href="#1-字符串相关类之不可变字符序列：String" class="headerlink" title="1. 字符串相关类之不可变字符序列：String"></a>1. 字符串相关类之不可变字符序列：String</h2><h3 id="1-1-String的特性"><a href="#1-1-String的特性" class="headerlink" title="1.1 String的特性"></a>1.1 String的特性</h3><ul><li><p><code>java.lang.String</code> 类代表字符串。Java程序中所有的字符串文字（例如<code>&quot;hello&quot;</code> ）都可以看作是实现此类的实例。</p></li><li><p>字符串是常量，用双引号引起来表示。它们的值在创建之后不能更改。</p></li><li><p>字符串String类型本身是final声明的，意味着我们不能继承String。</p></li><li><p>String对象的字符内容是存储在一个字符数组value[]中的。<code>&quot;abc&quot;</code> 等效于 <code>char[] data=&#123;&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;&#125;</code>。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC11%E7%AB%A0_%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%A1%80API/image-20220514184404024.png" alt="image-20220514184404024" style="zoom:80%;"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//jdk8中的String源码：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[]; <span class="comment">//String对象的字符内容是存储在此数组中</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>private意味着外面无法直接获取字符数组，而且String没有提供value的get和set方法。</p></li><li><p>final意味着字符数组的引用不可改变，而且String也没有提供方法来修改value数组某个元素值</p></li><li><p>因此字符串的字符数组内容也不可变的，即String代表着不可变的字符序列。即，一旦对字符串进行修改，就会产生新对象。</p></li><li><p>JDK9只有，底层使用byte[]数组。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; </span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//官方说明：... that most String objects contain only Latin-1 characters. Such characters require only one byte of storage, hence half of the space in the internal char arrays of such String objects is going unused.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//细节：... The new String class will store characters encoded either as ISO-8859-1/Latin-1 (one byte per character), or as UTF-16 (two bytes per character), based upon the contents of the string. The encoding flag will indicate which encoding is used.</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Java 语言提供对字符串串联符号（”+”）以及将其他对象转换为字符串的特殊支持（toString()方法）。</p></li></ul><h3 id="1-2-String的内存结构"><a href="#1-2-String的内存结构" class="headerlink" title="1.2 String的内存结构"></a>1.2 String的内存结构</h3><h4 id="1-2-1-概述"><a href="#1-2-1-概述" class="headerlink" title="1.2.1 概述"></a>1.2.1 概述</h4><p>因为字符串对象设计为不可变，那么所以字符串有常量池来保存很多常量对象。</p><p>JDK6中，字符串常量池在方法区。JDK7开始，就移到堆空间，直到目前JDK17版本。</p><p>举例内存结构分配：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC11%E7%AB%A0_%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%A1%80API/1562945799274.png" alt="image-20220405160036240"></p><h4 id="1-2-2-练习类型1：拼接"><a href="#1-2-2-练习类型1：拼接" class="headerlink" title="1.2.2 练习类型1：拼接"></a>1.2.2 练习类型1：拼接</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2);</span><br><span class="line"><span class="comment">// 内存中只有一个&quot;hello&quot;对象被创建，同时被s1和s2共享。</span></span><br></pre></td></tr></table></figure><p>对应内存结构为：（以下内存结构以<code>JDK6为例</code>绘制）：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC11%E7%AB%A0_%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%A1%80API/image-20220405152839525.png" alt="image-20220405152839525" style="zoom:67%;"></p><p>进一步：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC11%E7%AB%A0_%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%A1%80API/image-20220405152941599.png" alt="image-20220405152941599" style="zoom:67%;"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p1.name = “Tom<span class="string">&quot;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Person p2 = new Person();</span></span><br><span class="line"><span class="string">p2.name = “Tom&quot;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(p1.name.equals( p2.name)); <span class="comment">//</span></span><br><span class="line">System.out.println(p1.name == p2.name); <span class="comment">//</span></span><br><span class="line">System.out.println(p1.name == <span class="string">&quot;Tom&quot;</span>); <span class="comment">//</span></span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC11%E7%AB%A0_%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%A1%80API/image-20220405153027693.png" alt="image-20220405153027693" style="zoom:67%;"></p><h4 id="1-2-3-练习类型2：new"><a href="#1-2-3-练习类型2：new" class="headerlink" title="1.2.3 练习类型2：new"></a>1.2.3 练习类型2：new</h4><p>String str1 = “abc”; 与 String str2 = new String(“abc”);的区别？</p><p><img src="/2023/02/18/java2023/%E7%AC%AC11%E7%AB%A0_%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%A1%80API/image-20220405160149200.png" alt="image-20220405160149200" style="zoom:67%;"></p><p>str2 首先指向堆中的一个字符串对象，然后堆中字符串的value数组指向常量池中常量对象的value数组。</p><blockquote><ul><li><p>字符串常量存储在字符串常量池，目的是共享。</p></li><li><p>字符串非常量对象存储在堆中。</p></li></ul></blockquote><p>练习：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;javaEE&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;javaEE&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//true</span></span><br><span class="line">System.out.println(s1 == s3);<span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s4);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC11%E7%AB%A0_%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%A1%80API/image-20220405160321172.png" alt="image-20220405160321172" style="zoom:67%;"></p><p>练习：String str2 = new String(“hello”); 在内存中创建了几个对象？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">两个</span><br></pre></td></tr></table></figure><h4 id="1-2-4-练习类型3：intern"><a href="#1-2-4-练习类型3：intern" class="headerlink" title="1.2.4 练习类型3：intern()"></a>1.2.4 练习类型3：intern()</h4><ul><li><strong>String s1 = “a”;</strong> </li></ul><p>说明：在字符串常量池中创建了一个字面量为”a”的字符串。</p><ul><li><strong>s1 = s1 + “b”;</strong> </li></ul><p>说明：实际上原来的“a”字符串对象已经丢弃了，现在在堆空间中产生了一个字符串s1+”b”（也就是”ab”)。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能。</p><ul><li><strong>String s2 = “ab”;</strong></li></ul><p>说明：直接在字符串常量池中创建一个字面量为”ab”的字符串。</p><ul><li><strong>String s3 = “a” + “b”;</strong></li></ul><p>说明：s3指向字符串常量池中已经创建的”ab”的字符串。</p><ul><li><strong>String s4 = s1.intern();</strong></li></ul><p>说明：堆空间的s1对象在调用intern()之后，会将常量池中已经存在的”ab”字符串赋值给s4。</p><p>练习：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> (s1 + s2).intern();</span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4);</span><br><span class="line">System.out.println(s3 == s5);</span><br><span class="line">System.out.println(s4 == s5);</span><br><span class="line">System.out.println(s3 == s6);</span><br></pre></td></tr></table></figure><blockquote><p><strong>结论：</strong></p><p>（1）常量+常量：结果是常量池。且常量池中不会存在相同内容的常量。</p><p>（2）常量与变量 或 变量与变量：结果在堆中</p><p>（3）拼接后调用intern方法：返回值在常量池中</p></blockquote><p>练习：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + <span class="string">&quot;world&quot;</span>;<span class="comment">//s4字符串内容也helloworld，s1是变量，&quot;world&quot;常量，变量 + 常量的结果在堆中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + s2;<span class="comment">//s5字符串内容也helloworld，s1和s2都是变量，变量 + 变量的结果在堆中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;world&quot;</span>;<span class="comment">//常量+ 常量 结果在常量池中，因为编译期间就可以确定结果</span></span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s6);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + <span class="string">&quot;world&quot;</span>;<span class="comment">//s4字符串内容也helloworld，s1是常量，&quot;world&quot;常量，常量+常量结果在常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + s2;<span class="comment">//s5字符串内容也helloworld，s1和s2都是常量，常量+ 常量 结果在常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;world&quot;</span>;<span class="comment">//常量+ 常量 结果在常量池中，因为编译期间就可以确定结果</span></span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s5);<span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s6);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> (s1 + <span class="string">&quot;world&quot;</span>).intern();<span class="comment">//把拼接的结果放到常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> (s1 + s2).intern();</span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s5);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习：下列程序运行的结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestString</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span><span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>.concat(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>+<span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>concat方法拼接，哪怕是两个常量对象拼接，结果也是在堆。</p></blockquote><p>练习：下列程序运行的结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">    <span class="type">char</span>[] ch = &#123; <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String str, <span class="type">char</span> ch[])</span> &#123;</span><br><span class="line">        str = <span class="string">&quot;test ok&quot;</span>;</span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringTest</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTest</span>();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.print(ex.str + <span class="string">&quot; and &quot;</span>);<span class="comment">//</span></span><br><span class="line">        System.out.println(ex.ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-3-String的常用API-1"><a href="#1-3-String的常用API-1" class="headerlink" title="1.3 String的常用API-1"></a>1.3 String的常用API-1</h3><h4 id="1-3-1-构造器"><a href="#1-3-1-构造器" class="headerlink" title="1.3.1 构造器"></a>1.3.1 构造器</h4><ul><li><code>public String()</code> ：初始化新创建的 String对象，以使其表示空字符序列。</li><li><code>String(String original)</code>： 初始化一个新创建的 <code>String</code> 对象，使其表示一个与参数相同的字符序列；换句话说，新创建的字符串是该参数字符串的副本。</li><li><code>public String(char[] value)</code> ：通过当前参数中的字符数组来构造新的String。</li><li><code>public String(char[] value,int offset, int count)</code> ：通过字符数组的一部分来构造新的String。</li><li><code>public String(byte[] bytes)</code> ：通过使用平台的<strong>默认字符集</strong>解码当前参数中的字节数组来构造新的String。</li><li><code>public String(byte[] bytes,String charsetName)</code> ：通过使用指定的字符集解码当前参数中的字节数组来构造新的String。</li></ul><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字面量定义方式：字符串常量对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器定义方式：无参构造</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器定义方式：创建&quot;hello&quot;字符串常量的副本</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器定义方式：通过字符数组构造</span></span><br><span class="line"><span class="type">char</span> chars[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>&#125;;     </span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars,<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器定义方式：通过字节数组构造</span></span><br><span class="line"><span class="type">byte</span> bytes[] = &#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span> &#125;;     </span><br><span class="line"><span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes);</span><br><span class="line"><span class="type">String</span> <span class="variable">str6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="string">&quot;GBK&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">char</span>[] data = &#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> String.copyValueOf(data);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> String.copyValueOf(data,<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">123456</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> String.valueOf(num);</span><br><span class="line"></span><br><span class="line">    System.out.println(s1);</span><br><span class="line">System.out.println(s2);</span><br><span class="line">System.out.println(s3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-2-String与其他结构间的转换"><a href="#1-3-2-String与其他结构间的转换" class="headerlink" title="1.3.2 String与其他结构间的转换"></a>1.3.2 String与其他结构间的转换</h4><p><strong>字符串 —&gt; 基本数据类型、包装类：</strong></p><ul><li>Integer包装类的public static int parseInt(String s)：可以将由“数字”字符组成的字符串转换为整型。</li><li>类似地，使用java.lang包中的Byte、Short、Long、Float、Double类调相应的类方法可以将由“数字”字符组成的字符串，转化为相应的基本数据类型。</li></ul><p><strong>基本数据类型、包装类 —&gt; 字符串：</strong></p><ul><li>调用String类的public String valueOf(int n)可将int型转换为字符串</li><li><p>相应的valueOf(byte b)、valueOf(long l)、valueOf(float f)、valueOf(double d)、valueOf(boolean b)可由参数的相应类型到字符串的转换。</p><p><strong>字符数组 —&gt;  字符串：</strong></p></li><li><p>String 类的构造器：String(char[]) 和 String(char[]，int offset，int length) 分别用字符数组中的全部字符和部分字符创建字符串对象。 </p><p><strong>字符串 —&gt;  字符数组：</strong></p></li><li><p>public char[] toCharArray()：将字符串中的全部字符存放在一个字符数组中的方法。</p></li><li><p>public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)：提供了将指定索引范围内的字符串存放到数组中的方法。</p></li></ul><p><strong>字符串 —&gt; 字节数组：（编码）</strong></p><ul><li>public byte[] getBytes() ：使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</li><li><p>public byte[] getBytes(String charsetName) ：使用指定的字符集将此 String 编码到 byte 序列，并将结果存储到新的 byte 数组。</p><p><strong>字节数组 —&gt; 字符串：（解码）</strong></p></li><li><p>String(byte[])：通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String。</p></li><li>String(byte[]，int offset，int length) ：用指定的字节数组的一部分，即从数组起始位置offset开始取length个字节构造一个字符串对象。</li><li>String(byte[], String charsetName ) 或 new String(byte[], int, int,String charsetName )：解码，按照指定的编码方式进行解码。</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;中国&quot;</span>;</span><br><span class="line">    System.out.println(str.getBytes(<span class="string">&quot;ISO8859-1&quot;</span>).length);<span class="comment">// 2</span></span><br><span class="line">    <span class="comment">// ISO8859-1把所有的字符都当做一个byte处理，处理不了多个字节</span></span><br><span class="line">    System.out.println(str.getBytes(<span class="string">&quot;GBK&quot;</span>).length);<span class="comment">// 4 每一个中文都是对应2个字节</span></span><br><span class="line">    System.out.println(str.getBytes(<span class="string">&quot;UTF-8&quot;</span>).length);<span class="comment">// 6 常规的中文都是3个字节</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 不乱码：（1）保证编码与解码的字符集名称一样（2）不缺字节</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(str.getBytes(<span class="string">&quot;ISO8859-1&quot;</span>), <span class="string">&quot;ISO8859-1&quot;</span>));<span class="comment">// 乱码</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(str.getBytes(<span class="string">&quot;GBK&quot;</span>), <span class="string">&quot;GBK&quot;</span>));<span class="comment">// 中国</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(str.getBytes(<span class="string">&quot;UTF-8&quot;</span>), <span class="string">&quot;UTF-8&quot;</span>));<span class="comment">// 中国</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-String的常用API-2"><a href="#1-4-String的常用API-2" class="headerlink" title="1.4 String的常用API-2"></a>1.4 String的常用API-2</h3><p><code>String</code> 类包括的方法可用于检查序列的单个字符、比较字符串、搜索字符串、提取子字符串、创建字符串副本并将所有字符全部转换为大写或小写。 </p><h4 id="1-4-1-系列1：常用方法"><a href="#1-4-1-系列1：常用方法" class="headerlink" title="1.4.1 系列1：常用方法"></a>1.4.1 系列1：常用方法</h4><p>（1）boolean isEmpty()：字符串是否为空<br>（2）int length()：返回字符串的长度<br>（3）String concat(xx)：拼接<br>（4）boolean equals(Object obj)：比较字符串是否相等，区分大小写<br>（5）boolean equalsIgnoreCase(Object obj)：比较字符串是否相等，不区分大小写<br>（6）int compareTo(String other)：比较字符串大小，区分大小写，按照Unicode编码值比较大小<br>（7）int compareToIgnoreCase(String other)：比较字符串大小，不区分大小写<br>（8）String toLowerCase()：将字符串中大写字母转为小写<br>（9）String toUpperCase()：将字符串中小写字母转为大写<br>（10）String trim()：去掉字符串前后空白符<br>（11）public String intern()：结果在常量池中共享</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//将用户输入的单词全部转为小写，如果用户没有输入单词，重新输入</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">String word;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">System.out.print(<span class="string">&quot;请输入单词：&quot;</span>);</span><br><span class="line">word = input.nextLine();</span><br><span class="line"><span class="keyword">if</span>(word.trim().length()!=<span class="number">0</span>)&#123;</span><br><span class="line">word = word.toLowerCase();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(word);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//随机生成验证码，验证码由0-9，A-Z,a-z的字符组成</span></span><br><span class="line"><span class="type">char</span>[] array = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">26</span>*<span class="number">2</span>+<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">array[i] = (<span class="type">char</span>)(<span class="string">&#x27;0&#x27;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>,j=<span class="number">0</span>; i &lt; <span class="number">10</span>+<span class="number">26</span>; i++,j++) &#123;</span><br><span class="line">array[i] = (<span class="type">char</span>)(<span class="string">&#x27;A&#x27;</span> + j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>+<span class="number">26</span>,j=<span class="number">0</span>; i &lt; array.length; i++,j++) &#123;</span><br><span class="line">array[i] = (<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span> + j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">code += array[rand.nextInt(array.length)];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;验证码：&quot;</span> + code);</span><br><span class="line"><span class="comment">//将用户输入的单词全部转为小写，如果用户没有输入单词，重新输入</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.print(<span class="string">&quot;请输入验证码：&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">inputCode</span> <span class="operator">=</span> input.nextLine();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!code.equalsIgnoreCase(inputCode))&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;验证码输入不正确&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-2-系列2：查找"><a href="#1-4-2-系列2：查找" class="headerlink" title="1.4.2 系列2：查找"></a>1.4.2 系列2：查找</h4><p>（11）boolean contains(xx)：是否包含xx<br>（12）int indexOf(xx)：从前往后找当前字符串中xx，即如果有返回第一次出现的下标，要是没有返回-1<br>（13）int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始<br>（14）int lastIndexOf(xx)：从后往前找当前字符串中xx，即如果有返回最后一次出现的下标，要是没有返回-1<br>（15）int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;尚硅谷是一家靠谱的培训机构，尚硅谷可以说是IT培训的小清华，JavaEE是尚硅谷的当家学科，尚硅谷的大数据培训是行业独角兽。尚硅谷的前端和UI专业一样独领风骚。&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;是否包含清华：&quot;</span> + str.contains(<span class="string">&quot;清华&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;培训出现的第一次下标：&quot;</span> + str.indexOf(<span class="string">&quot;培训&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;培训出现的最后一次下标：&quot;</span> + str.lastIndexOf(<span class="string">&quot;培训&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-3-系列3：字符串截取"><a href="#1-4-3-系列3：字符串截取" class="headerlink" title="1.4.3 系列3：字符串截取"></a>1.4.3 系列3：字符串截取</h4><p>（16）String substring(int beginIndex) ：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。<br>（17）String substring(int beginIndex, int endIndex) ：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;helloworldjavaatguigu&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sub1</span> <span class="operator">=</span> str.substring(<span class="number">5</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">sub2</span> <span class="operator">=</span> str.substring(<span class="number">5</span>,<span class="number">10</span>);</span><br><span class="line">    System.out.println(sub1);</span><br><span class="line">    System.out.println(sub2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;快速学习Java的秘诀.dat&quot;</span>;</span><br><span class="line">    <span class="comment">//截取文件名</span></span><br><span class="line">    System.out.println(<span class="string">&quot;文件名：&quot;</span> + fileName.substring(<span class="number">0</span>,fileName.lastIndexOf(<span class="string">&quot;.&quot;</span>)));</span><br><span class="line">    <span class="comment">//截取后缀名</span></span><br><span class="line">    System.out.println(<span class="string">&quot;后缀名：&quot;</span> + fileName.substring(fileName.lastIndexOf(<span class="string">&quot;.&quot;</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-4-系列4：和字符-字符数组相关"><a href="#1-4-4-系列4：和字符-字符数组相关" class="headerlink" title="1.4.4 系列4：和字符/字符数组相关"></a>1.4.4 系列4：和字符/字符数组相关</h4><p>（18）char charAt(index)：返回[index]位置的字符<br>（19）char[] toCharArray()： 将此字符串转换为一个新的字符数组返回<br>（20）static String valueOf(char[] data)  ：返回指定数组中表示该字符序列的 String<br>（21）static String valueOf(char[] data, int offset, int count) ： 返回指定数组中表示该字符序列的 String<br>（22）static String copyValueOf(char[] data)： 返回指定数组中表示该字符序列的 String<br>（23）static String copyValueOf(char[] data, int offset, int count)：返回指定数组中表示该字符序列的 String</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//将字符串中的字符按照大小顺序排列</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;helloworldjavaatguigu&quot;</span>;</span><br><span class="line"><span class="type">char</span>[] array = str.toCharArray();</span><br><span class="line">Arrays.sort(array);</span><br><span class="line">str = <span class="keyword">new</span> <span class="title class_">String</span>(array);</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//将首字母转为大写</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;jack&quot;</span>;</span><br><span class="line">str = Character.toUpperCase(str.charAt(<span class="number">0</span>))+str.substring(<span class="number">1</span>);</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">char</span>[] data = &#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> String.copyValueOf(data);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> String.copyValueOf(data,<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">123456</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> String.valueOf(num);</span><br><span class="line"></span><br><span class="line">   System.out.println(s1);</span><br><span class="line">System.out.println(s2);</span><br><span class="line">System.out.println(s3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-5-系列5：开头与结尾"><a href="#1-4-5-系列5：开头与结尾" class="headerlink" title="1.4.5 系列5：开头与结尾"></a>1.4.5 系列5：开头与结尾</h4><p>（24）boolean startsWith(xx)：测试此字符串是否以指定的前缀开始<br>（25）boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始<br>（26）boolean endsWith(xx)：测试此字符串是否以指定的后缀结束 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">System.out.println(name.startsWith(<span class="string">&quot;张&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">file</span> <span class="operator">=</span> <span class="string">&quot;Hello.txt&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(file.endsWith(<span class="string">&quot;.java&quot;</span>))&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Java源文件&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(file.endsWith(<span class="string">&quot;.class&quot;</span>))&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Java字节码文件&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;其他文件&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-6-系列6：替换"><a href="#1-4-6-系列6：替换" class="headerlink" title="1.4.6 系列6：替换"></a>1.4.6 系列6：替换</h4><p>（27）String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 不支持正则。<br>（28）String replace(CharSequence target, CharSequence replacement)：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。<br>（29）String replaceAll(String regex, String replacement)：使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。<br>（30）String replaceFirst(String regex, String replacement)：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello244world.java;887&quot;</span>;</span><br><span class="line">    <span class="comment">//把其中的非字母去掉</span></span><br><span class="line">    str1 = str1.replaceAll(<span class="string">&quot;[^a-zA-Z]&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    System.out.println(str1);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;12hello34world5java7891mysql456&quot;</span>;</span><br><span class="line">    <span class="comment">//把字符串中的数字替换成,，如果结果中开头和结尾有，的话去掉</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> str2.replaceAll(<span class="string">&quot;\\d+&quot;</span>, <span class="string">&quot;,&quot;</span>).replaceAll(<span class="string">&quot;^,|,$&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    System.out.println(string);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-常见算法题目"><a href="#1-5-常见算法题目" class="headerlink" title="1.5 常见算法题目"></a>1.5 常见算法题目</h3><p><strong>题目1：</strong>模拟一个trim方法，去除字符串两端的空格。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">myTrim</span><span class="params">(String str)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (str != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 用于记录从前往后首次索引位置不是空格的位置的索引</span></span><br><span class="line"><span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> str.length() - <span class="number">1</span>;<span class="comment">// 用于记录从后往前首次索引位置不是空格的位置的索引</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (start &lt; end &amp;&amp; str.charAt(start) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">start++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (start &lt; end &amp;&amp; str.charAt(end) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (str.charAt(start) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> str.substring(start, end + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMyTrim</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;   a   &quot;</span>;</span><br><span class="line"><span class="comment">// str = &quot; &quot;;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">newStr</span> <span class="operator">=</span> myTrim(str);</span><br><span class="line">System.out.println(<span class="string">&quot;---&quot;</span> + newStr + <span class="string">&quot;---&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题目2：</strong>将一个字符串进行反转。将字符串中指定部分进行反转。比如“ab<code>cdef</code>g”反转为”ab<code>fedc</code>g”</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一：</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">reverse1</span><span class="params">(String str, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;<span class="comment">// start:2,end:5</span></span><br><span class="line"><span class="keyword">if</span> (str != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="type">char</span>[] charArray = str.toCharArray();</span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line"><span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> charArray[i];</span><br><span class="line">charArray[i] = charArray[j];</span><br><span class="line">charArray[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(charArray);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">reverse2</span><span class="params">(String str, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="type">String</span> <span class="variable">newStr</span> <span class="operator">=</span> str.substring(<span class="number">0</span>, start);<span class="comment">// ab</span></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> end; i &gt;= start; i--) &#123;</span><br><span class="line">newStr += str.charAt(i);</span><br><span class="line">&#125; <span class="comment">// abfedc</span></span><br><span class="line"><span class="comment">// 3.</span></span><br><span class="line">newStr += str.substring(end + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> newStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三：推荐 （相较于方式二做的改进）</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">reverse3</span><span class="params">(String str, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;<span class="comment">// ArrayList list = new ArrayList(80);</span></span><br><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str.length());</span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line">s.append(str.substring(<span class="number">0</span>, start));<span class="comment">// ab</span></span><br><span class="line"><span class="comment">// 3.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> end; i &gt;= start; i--) &#123;</span><br><span class="line">s.append(str.charAt(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.</span></span><br><span class="line">s.append(str.substring(end + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.</span></span><br><span class="line"><span class="keyword">return</span> s.toString();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testReverse</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> reverse3(str, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">System.out.println(str1);<span class="comment">// abfedcg</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题目3：</strong>获取一个字符串在另一个字符串中出现的次数。<br>              比如：获取“ ab”在 “abkkcadkabkebfkabkskab” 中出现的次数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第3题</span></span><br><span class="line"><span class="comment">// 判断str2在str1中出现的次数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">(String mainStr, String subStr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (mainStr.length() &gt;= subStr.length()) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// while((index = mainStr.indexOf(subStr)) != -1)&#123;</span></span><br><span class="line"><span class="comment">// count++;</span></span><br><span class="line"><span class="comment">// mainStr = mainStr.substring(index + subStr.length());</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 改进：</span></span><br><span class="line"><span class="keyword">while</span> ((index = mainStr.indexOf(subStr, index)) != -<span class="number">1</span>) &#123;</span><br><span class="line">index += subStr.length();</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetCount</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;cdabkkcadkabkebfkabkskab&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> getCount(str1, str2);</span><br><span class="line">System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题目4：</strong>获取两个字符串中最大相同子串。比如：<br>              str1 = “abcwerthelloyuiodef“;str2 = “cvhellobnm”<br>              提示：将短的那个串进行长度依次递减的子串与较长的串比较。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第4题</span></span><br><span class="line"><span class="comment">// 如果只存在一个最大长度的相同子串</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getMaxSameSubString</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (str1 != <span class="literal">null</span> &amp;&amp; str2 != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">maxStr</span> <span class="operator">=</span> (str1.length() &gt; str2.length()) ? str1 : str2;</span><br><span class="line"><span class="type">String</span> <span class="variable">minStr</span> <span class="operator">=</span> (str1.length() &gt; str2.length()) ? str2 : str1;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> minStr.length();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;<span class="comment">// 0 1 2 3 4 此层循环决定要去几个字符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = len - i; y &lt;= len; x++, y++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (maxStr.contains(minStr.substring(x, y))) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> minStr.substring(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果存在多个长度相同的最大相同子串</span></span><br><span class="line"><span class="comment">// 此时先返回String[]，后面可以用集合中的ArrayList替换，较方便</span></span><br><span class="line"><span class="keyword">public</span> String[] getMaxSameSubString1(String str1, String str2) &#123;</span><br><span class="line"><span class="keyword">if</span> (str1 != <span class="literal">null</span> &amp;&amp; str2 != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">maxString</span> <span class="operator">=</span> (str1.length() &gt; str2.length()) ? str1 : str2;</span><br><span class="line"><span class="type">String</span> <span class="variable">minString</span> <span class="operator">=</span> (str1.length() &gt; str2.length()) ? str2 : str1;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> minString.length();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = len - i; y &lt;= len; x++, y++) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">subString</span> <span class="operator">=</span> minString.substring(x, y);</span><br><span class="line"><span class="keyword">if</span> (maxString.contains(subString)) &#123;</span><br><span class="line">sBuffer.append(subString + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sBuffer);</span><br><span class="line"><span class="keyword">if</span> (sBuffer.length() != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">String[] split = sBuffer.toString().replaceAll(<span class="string">&quot;,$&quot;</span>, <span class="string">&quot;&quot;</span>).split(<span class="string">&quot;\\,&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> split;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果存在多个长度相同的最大相同子串：使用ArrayList</span></span><br><span class="line"><span class="comment">//public List&lt;String&gt; getMaxSameSubString1(String str1, String str2) &#123;</span></span><br><span class="line"><span class="comment">//if (str1 != null &amp;&amp; str2 != null) &#123;</span></span><br><span class="line"><span class="comment">//List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span></span><br><span class="line"><span class="comment">//String maxString = (str1.length() &gt; str2.length()) ? str1 : str2;</span></span><br><span class="line"><span class="comment">//String minString = (str1.length() &gt; str2.length()) ? str2 : str1;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//int len = minString.length();</span></span><br><span class="line"><span class="comment">//for (int i = 0; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="comment">//for (int x = 0, y = len - i; y &lt;= len; x++, y++) &#123;</span></span><br><span class="line"><span class="comment">//String subString = minString.substring(x, y);</span></span><br><span class="line"><span class="comment">//if (maxString.contains(subString)) &#123;</span></span><br><span class="line"><span class="comment">//list.add(subString);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//if (list.size() != 0) &#123;</span></span><br><span class="line"><span class="comment">//break;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//return list;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//return null;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetMaxSameSubString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abcwerthelloyuiodef&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;cvhellobnmiodef&quot;</span>;</span><br><span class="line">String[] strs = getMaxSameSubString1(str1, str2);</span><br><span class="line">System.out.println(Arrays.toString(strs));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题目5：</strong>对字符串中字符进行自然顺序排序。<br>提示：<br>1）字符串变成字符数组。<br>2）对数组排序，选择，冒泡，Arrays.sort();<br>3）将排序后的数组变成字符串。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第5题</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSort</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abcwerthelloyuiodef&quot;</span>;</span><br><span class="line"><span class="type">char</span>[] arr = str.toCharArray();</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">newStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br><span class="line">System.out.println(newStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-字符串相关类之可变字符序列：StringBuffer、StringBuilder"><a href="#2-字符串相关类之可变字符序列：StringBuffer、StringBuilder" class="headerlink" title="2. 字符串相关类之可变字符序列：StringBuffer、StringBuilder"></a>2. 字符串相关类之可变字符序列：StringBuffer、StringBuilder</h2><p>因为String对象是不可变对象，虽然可以共享常量对象，但是对于频繁字符串的修改和拼接操作，效率极低，空间消耗也比较高。因此，JDK又在java.lang包提供了可变字符序列StringBuffer和StringBuilder类型。</p><h3 id="2-1-StringBuffer与StringBuilder的理解"><a href="#2-1-StringBuffer与StringBuilder的理解" class="headerlink" title="2.1 StringBuffer与StringBuilder的理解"></a>2.1 StringBuffer与StringBuilder的理解</h3><ul><li><p>java.lang.StringBuffer代表<code>可变的字符序列</code>，JDK1.0中声明，可以对字符串内容进行增删，此时不会产生新的对象。比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//情况1:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;我喜欢学习&quot;</span>); </span><br><span class="line"><span class="comment">//情况2：</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;我喜欢学习&quot;</span>); </span><br><span class="line">buffer.append(<span class="string">&quot;数学&quot;</span>); </span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC11%E7%AB%A0_%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%A1%80API/image-20220405221714261.png" alt="image-20220405221714261"></p></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC11%E7%AB%A0_%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%A1%80API/image-20220228153030902.png" alt="image-20220228153030902" style="zoom:80%;"></p><ul><li>继承结构：</li></ul><p> <img src="/2023/02/18/java2023/%E7%AC%AC11%E7%AB%A0_%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%A1%80API/image-20220405174233055.png" alt="image-20220405174233055"></p><p> <img src="/2023/02/18/java2023/%E7%AC%AC11%E7%AB%A0_%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%A1%80API/image-20220405174414780.png" alt="image-20220405174414780" style="zoom:67%;"></p><ul><li>StringBuilder 和 StringBuffer 非常类似，均代表可变的字符序列，而且提供相关功能的方法也一样。</li><li>区分String、StringBuffer、StringBuilder<ul><li>String:不可变的字符序列； 底层使用char[]数组存储(JDK8.0中)</li><li>StringBuffer:可变的字符序列；线程安全（方法有synchronized修饰），效率低；底层使用char[]数组存储 (JDK8.0中)</li><li>StringBuilder:可变的字符序列； jdk1.5引入，线程不安全的，效率高；底层使用char[]数组存储(JDK8.0中)</li></ul></li></ul><h3 id="2-2-StringBuilder、StringBuffer的API"><a href="#2-2-StringBuilder、StringBuffer的API" class="headerlink" title="2.2 StringBuilder、StringBuffer的API"></a>2.2 StringBuilder、StringBuffer的API</h3><p>StringBuilder、StringBuffer的API是完全一致的，并且很多方法与String相同。</p><p><strong>1、常用API</strong></p><p>（1）StringBuffer append(xx)：提供了很多的append()方法，用于进行字符串追加的方式拼接<br>（2）StringBuffer delete(int start, int end)：删除[start,end)之间字符<br>（3）StringBuffer deleteCharAt(int index)：删除[index]位置字符<br>（4）StringBuffer replace(int start, int end, String str)：替换[start,end)范围的字符序列为str<br>（5）void setCharAt(int index, char c)：替换[index]位置字符<br>（6）char charAt(int index)：查找指定index位置上的字符<br>（7）StringBuffer insert(int index, xx)：在[index]位置插入xx<br>（8）int length()：返回存储的字符数据的长度<br>（9）StringBuffer reverse()：反转</p><blockquote><ul><li><p>当append和insert时，如果原来value数组长度不够，可扩容。</p></li><li><p>如上(1)(2)(3)(4)(9)这些方法支持<code>方法链操作</code>。原理：</p><p> <img src="/2023/02/18/java2023/%E7%AC%AC11%E7%AB%A0_%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%A1%80API/image-20220405223542750.png" alt="image-20220405223542750"></p></li></ul></blockquote><p><strong>2、其它API</strong></p><p>（1）int indexOf(String str)：在当前字符序列中查询str的第一次出现下标<br>（2）int indexOf(String str, int fromIndex)：在当前字符序列[fromIndex,最后]中查询str的第一次出现下标<br>（3）int lastIndexOf(String str)：在当前字符序列中查询str的最后一次出现下标<br>（4）int lastIndexOf(String str, int fromIndex)：在当前字符序列[fromIndex,最后]中查询str的最后一次出现下标<br>（5）String substring(int start)：截取当前字符序列[start,最后]<br>（6）String substring(int start, int end)：截取当前字符序列[start,end)<br>（7）String toString()：返回此序列中数据的字符串表示形式<br>（8）void setLength(int newLength) ：设置当前字符序列长度为newLength</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    s.append(<span class="string">&quot;hello&quot;</span>).append(<span class="literal">true</span>).append(<span class="string">&#x27;a&#x27;</span>).append(<span class="number">12</span>).append(<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">    System.out.println(s.length());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">    s.insert(<span class="number">5</span>, <span class="string">&quot;java&quot;</span>);</span><br><span class="line">    s.insert(<span class="number">5</span>, <span class="string">&quot;chailinyan&quot;</span>);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">    s.delete(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    s.deleteCharAt(<span class="number">4</span>);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">    s.reverse();</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">    s.setCharAt(<span class="number">2</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">    s.setLength(<span class="number">30</span>);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-效率测试"><a href="#2-3-效率测试" class="headerlink" title="2.3 效率测试"></a>2.3 效率测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始设置</span></span><br><span class="line"><span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始对比</span></span><br><span class="line">startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">    buffer.append(String.valueOf(i));</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;StringBuffer的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">    builder.append(String.valueOf(i));</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;StringBuilder的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">    text = text + i;</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;String的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-4-练习"><a href="#2-4-练习" class="headerlink" title="2.4 练习"></a>2.4 练习</h3><p>笔试题：程序输出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">sb.append(str);</span><br><span class="line"></span><br><span class="line">System.out.println(sb.length());<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">System.out.println(sb);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str);</span><br><span class="line">System.out.println(sb1);<span class="comment">//</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-JDK8之前：日期时间API"><a href="#3-JDK8之前：日期时间API" class="headerlink" title="3. JDK8之前：日期时间API"></a>3. JDK8之前：日期时间API</h2><h3 id="3-1-java-lang-System类的方法"><a href="#3-1-java-lang-System类的方法" class="headerlink" title="3.1 java.lang.System类的方法"></a>3.1 java.lang.System类的方法</h3><ul><li><p>System类提供的public static long currentTimeMillis()：用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。</p><ul><li>此方法适于计算时间差。</li></ul></li><li><p>计算世界时间的主要标准有：</p><ul><li>UTC(Coordinated Universal Time)</li><li>GMT(Greenwich Mean Time)</li><li>CST(Central Standard Time)</li></ul><blockquote><p>在国际无线电通信场合，为了统一起见，使用一个统一的时间，称为通用协调时(UTC, Universal Time Coordinated)。UTC与格林尼治平均时(GMT, Greenwich Mean Time)一样，都与英国伦敦的本地时相同。这里，UTC与GMT含义完全相同。 </p></blockquote></li></ul><h3 id="3-2-java-util-Date"><a href="#3-2-java-util-Date" class="headerlink" title="3.2 java.util.Date"></a>3.2 java.util.Date</h3><p>表示特定的瞬间，精确到毫秒。</p><ul><li>构造器：<ul><li>Date()：使用无参构造器创建的对象可以获取本地当前时间。</li><li>Date(long 毫秒数)：把该毫秒值换算成日期时间对象</li></ul></li><li>常用方法<ul><li>getTime(): 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。</li><li>toString(): 把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)，zzz是时间标准。</li><li>其它很多方法都过时了。</li></ul></li><li>举例：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    System.out.println(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(time);<span class="comment">//1559806982971</span></span><br><span class="line">    <span class="comment">//当前系统时间距离1970-1-1 0:0:0 0毫秒的时间差，毫秒为单位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> d.getTime();</span><br><span class="line">    System.out.println(time);<span class="comment">//1559807047979</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> <span class="number">1559807047979L</span>;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(time);</span><br><span class="line">    System.out.println(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(time);</span><br><span class="line">    System.out.println(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-java-text-SimpleDateFormat"><a href="#3-3-java-text-SimpleDateFormat" class="headerlink" title="3.3 java.text.SimpleDateFormat"></a>3.3 java.text.SimpleDateFormat</h3><ul><li>java.text.SimpleDateFormat类是一个不与语言环境有关的方式来格式化和解析日期的具体类。</li><li>可以进行格式化：日期 —&gt; 文本</li><li>可以进行解析：文本 —&gt; 日期</li><li><strong>构造器：</strong><ul><li>SimpleDateFormat() ：默认的模式和语言环境创建对象</li><li>public SimpleDateFormat(String pattern)：该构造方法可以用参数pattern指定的格式创建一个对象</li></ul></li><li><strong>格式化：</strong><ul><li>public String format(Date date)：方法格式化时间对象date</li></ul></li><li><strong>解析：</strong><ul><li>public Date parse(String source)：从给定字符串的开始解析文本，以生成一个日期。</li></ul></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC11%E7%AB%A0_%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%A1%80API/1572599023197.png" alt="1572599023197"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式化</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 HH时mm分ss秒 SSS毫秒  E Z&quot;</span>);</span><br><span class="line">    <span class="comment">//把Date日期转成字符串，按照指定的格式转</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sf.format(d);</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解析</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> ParseException&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;2022年06月06日 16时03分14秒 545毫秒  星期四 +0800&quot;</span>;</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 HH时mm分ss秒 SSS毫秒  E Z&quot;</span>);</span><br><span class="line">    <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> sf.parse(str);</span><br><span class="line">    System.out.println(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-java-util-Calendar-日历"><a href="#3-4-java-util-Calendar-日历" class="headerlink" title="3.4 java.util.Calendar(日历)"></a>3.4 java.util.Calendar(日历)</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC11%E7%AB%A0_%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%A1%80API/image-20220511105252261.png" alt="image-20220511105252261" style="zoom:67%;"></p><ul><li><p>Date类的API大部分被废弃了，替换为Calendar。</p></li><li><p><code>Calendar</code> 类是一个抽象类，主用用于完成日期字段之间相互操作的功能。</p></li><li><p>获取Calendar实例的方法</p><ul><li><p>使用<code>Calendar.getInstance()</code>方法</p><p><img src="/2023/02/18/java2023/%E7%AC%AC11%E7%AB%A0_%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%A1%80API/image-20220123184906903.png" alt="image-20220123184906903"></p></li><li><p>调用它的子类GregorianCalendar（公历）的构造器。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC11%E7%AB%A0_%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%A1%80API/image-20220405225828816.png" alt="image-20220405225828816"></p></li></ul></li><li><p>一个Calendar的实例是系统时间的抽象表示，可以修改或获取 YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY 、MINUTE、SECOND等 <code>日历字段</code>对应的时间值。</p><ul><li>public int get(int field)：返回给定日历字段的值</li><li>public void set(int field,int value) ：将给定的日历字段设置为指定的值</li><li>public void add(int field,int amount)：根据日历的规则，为给定的日历字段添加或者减去指定的时间量</li><li>public final Date getTime()：将Calendar转成Date对象</li><li>public final void setTime(Date date)：使用指定的Date对象重置Calendar的时间</li></ul></li><li><p>常用字段</p><p><img src="/2023/02/18/java2023/%E7%AC%AC11%E7%AB%A0_%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%A1%80API/1620277709044.png" alt="1620277709044"></p></li><li><p>注意：</p><ul><li>获取月份时：一月是0，二月是1，以此类推，12月是11</li><li>获取星期时：周日是1，周二是2 ， 。。。。周六是7</li></ul></li><li><p>示例代码：</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.TimeZone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCalendar</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        System.out.println(c);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> c.get(Calendar.YEAR);</span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> c.get(Calendar.MONTH)+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> c.get(Calendar.DATE);</span><br><span class="line">        <span class="type">int</span> <span class="variable">hour</span> <span class="operator">=</span> c.get(Calendar.HOUR_OF_DAY);</span><br><span class="line">        <span class="type">int</span> <span class="variable">minute</span> <span class="operator">=</span> c.get(Calendar.MINUTE);</span><br><span class="line"></span><br><span class="line">        System.out.println(year + <span class="string">&quot;-&quot;</span> + month + <span class="string">&quot;-&quot;</span> + day + <span class="string">&quot; &quot;</span> + hour + <span class="string">&quot;:&quot;</span> + minute);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">TimeZone</span> <span class="variable">t</span> <span class="operator">=</span> TimeZone.getTimeZone(<span class="string">&quot;America/Los_Angeles&quot;</span>);</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance(t);</span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> c.get(Calendar.YEAR);</span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> c.get(Calendar.MONTH)+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> c.get(Calendar.DATE);</span><br><span class="line">        <span class="type">int</span> <span class="variable">hour</span> <span class="operator">=</span> c.get(Calendar.HOUR_OF_DAY);</span><br><span class="line">        <span class="type">int</span> <span class="variable">minute</span> <span class="operator">=</span> c.get(Calendar.MINUTE);</span><br><span class="line"></span><br><span class="line">        System.out.println(year + <span class="string">&quot;-&quot;</span> + month + <span class="string">&quot;-&quot;</span> + day + <span class="string">&quot; &quot;</span> + hour + <span class="string">&quot;:&quot;</span> + minute);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"><span class="comment">// 从一个 Calendar 对象中获取 Date 对象</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 使用给定的 Date 设置此 Calendar 的时间</span></span><br><span class="line">date = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">234234235235L</span>);</span><br><span class="line">calendar.setTime(date);</span><br><span class="line">calendar.set(Calendar.DAY_OF_MONTH, <span class="number">8</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;当前时间日设置为8后,时间是:&quot;</span> + calendar.getTime());</span><br><span class="line">        </span><br><span class="line">calendar.add(Calendar.HOUR, <span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;当前时间加2小时后,时间是:&quot;</span> + calendar.getTime());</span><br><span class="line">        </span><br><span class="line">calendar.add(Calendar.MONTH, -<span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;当前日期减2个月后,时间是:&quot;</span> + calendar.getTime());  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-练习"><a href="#3-5-练习" class="headerlink" title="3.5 练习"></a>3.5 练习</h3><p>输入年份和月份，输出该月日历。</p><p>闰年计算公式：年份可以被4整除但不能被100整除，或者可以被400整除。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC11%E7%AB%A0_%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%A1%80API/image-20220503120722810.png" alt="image-20220503120722810" style="zoom:67%;"></p><h2 id="4-JDK8：新的日期时间API"><a href="#4-JDK8：新的日期时间API" class="headerlink" title="4. JDK8：新的日期时间API"></a>4. JDK8：新的日期时间API</h2><p>如果我们可以跟别人说：“我们在1502643933071见面，别晚了！”那么就再简单不过了。但是我们希望时间与昼夜和四季有关，于是事情就变复杂了。JDK 1.0中包含了一个java.util.Date类，但是它的大多数方法已经在JDK 1.1引入Calendar类之后被弃用了。而Calendar并不比Date好多少。它们面临的问题是：</p><ul><li><p>可变性：像日期和时间这样的类应该是不可变的。</p></li><li><p>偏移性：Date中的年份是从1900开始的，而月份都从0开始。</p></li><li><p>格式化：格式化只对Date有用，Calendar则不行。</p></li><li><p>此外，它们也不是线程安全的；不能处理闰秒等。</p><blockquote><p>闰秒，是指为保持协调世界时接近于世界时时刻，由国际计量局统一规定在年底或年中（也可能在季末）对协调世界时增加或减少1秒的调整。由于地球自转的不均匀性和长期变慢性（主要由潮汐摩擦引起的），会使世界时（民用时）和原子时之间相差超过到±0.9秒时，就把协调世界时向前拨1秒（负闰秒，最后一分钟为59秒）或向后拨1秒（正闰秒，最后一分钟为61秒）； 闰秒一般加在公历年末或公历六月末。</p><p>目前，全球已经进行了27次闰秒，均为正闰秒。</p></blockquote></li></ul><p>总结：<code>对日期和时间的操作一直是Java程序员最痛苦的地方之一</code>。</p><p>第三次引入的API是成功的，并且Java 8中引入的java.time API 已经纠正了过去的缺陷，将来很长一段时间内它都会为我们服务。</p><p>Java 8 以一个新的开始为 Java 创建优秀的 API。新的日期时间API包含：</p><ul><li><code>java.time</code> – 包含值对象的基础包</li><li><code>java.time.chrono</code> – 提供对不同的日历系统的访问。</li><li><code>java.time.format</code> – 格式化和解析时间和日期</li><li><code>java.time.temporal</code> – 包括底层框架和扩展特性</li><li><code>java.time.zone</code> – 包含时区支持的类</li></ul><p>说明：新的 java.time 中包含了所有关于时钟（Clock），本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）、时区（ZonedDateTime）和持续时间（Duration）的类。</p><p>尽管有68个新的公开类型，但是大多数开发者只会用到基础包和format包，大概占总数的三分之一。</p><h3 id="4-1-本地日期时间：LocalDate、LocalTime、LocalDateTime"><a href="#4-1-本地日期时间：LocalDate、LocalTime、LocalDateTime" class="headerlink" title="4.1 本地日期时间：LocalDate、LocalTime、LocalDateTime"></a>4.1 本地日期时间：LocalDate、LocalTime、LocalDateTime</h3><div class="table-container"><table><thead><tr><th>方法</th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>now()</code>/ now(ZoneId zone)</td><td>静态方法，根据当前时间创建对象/指定时区的对象</td></tr><tr><td><code>of(xx,xx,xx,xx,xx,xxx)</code></td><td>静态方法，根据指定日期/时间创建对象</td></tr><tr><td>getDayOfMonth()/getDayOfYear()</td><td>获得月份天数(1-31) /获得年份天数(1-366)</td></tr><tr><td>getDayOfWeek()</td><td>获得星期几(返回一个 DayOfWeek 枚举值)</td></tr><tr><td>getMonth()</td><td>获得月份, 返回一个 Month 枚举值</td></tr><tr><td>getMonthValue() / getYear()</td><td>获得月份(1-12) /获得年份</td></tr><tr><td>getHours()/getMinute()/getSecond()</td><td>获得当前对象对应的小时、分钟、秒</td></tr><tr><td>withDayOfMonth()/withDayOfYear()/withMonth()/withYear()</td><td>将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象</td></tr><tr><td>with(TemporalAdjuster  t)</td><td>将当前日期时间设置为校对器指定的日期时间</td></tr><tr><td>plusDays(), plusWeeks(), plusMonths(), plusYears(),plusHours()</td><td>向当前对象添加几天、几周、几个月、几年、几小时</td></tr><tr><td>minusMonths() / minusWeeks()/minusDays()/minusYears()/minusHours()</td><td>从当前对象减去几月、几周、几天、几年、几小时</td></tr><tr><td>plus(TemporalAmount t)/minus(TemporalAmount t)</td><td>添加或减少一个 Duration 或 Period</td></tr><tr><td>isBefore()/isAfter()</td><td>比较两个 LocalDate</td></tr><tr><td>isLeapYear()</td><td>判断是否是闰年（在LocalDate类中声明）</td></tr><tr><td>format(DateTimeFormatter  t)</td><td>格式化本地日期、时间，返回一个字符串</td></tr><tr><td>parse(Charsequence text)</td><td>将指定格式的字符串解析为日期、时间</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLocalDateTime</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">now</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        System.out.println(now);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">        System.out.println(now);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        System.out.println(now);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">lai</span> <span class="operator">=</span> LocalDate.of(<span class="number">2019</span>, <span class="number">5</span>, <span class="number">13</span>);</span><br><span class="line">        System.out.println(lai);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">lai</span> <span class="operator">=</span> LocalDate.of(<span class="number">2019</span>, <span class="number">5</span>, <span class="number">13</span>);</span><br><span class="line">        System.out.println(lai.getDayOfYear());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test06</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">lai</span> <span class="operator">=</span> LocalDate.of(<span class="number">2019</span>, <span class="number">5</span>, <span class="number">13</span>);</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">go</span> <span class="operator">=</span> lai.plusDays(<span class="number">160</span>);</span><br><span class="line">        System.out.println(go);<span class="comment">//2019-10-20</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">now</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">before</span> <span class="operator">=</span> now.minusDays(<span class="number">100</span>);</span><br><span class="line">        System.out.println(before);<span class="comment">//2019-02-26</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-瞬时：Instant"><a href="#4-2-瞬时：Instant" class="headerlink" title="4.2 瞬时：Instant"></a>4.2 瞬时：Instant</h3><ul><li>Instant：时间线上的一个瞬时点。 这可能被用来记录应用程序中的事件时间戳。<ul><li>时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。</li></ul></li><li><code>java.time.Instant</code>表示时间线上的一点，而不需要任何上下文信息，例如，时区。概念上讲，<code>它只是简单的表示自1970年1月1日0时0分0秒（UTC）开始的秒数。</code></li></ul><div class="table-container"><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>now()</code></td><td>静态方法，返回默认UTC时区的Instant类的对象</td></tr><tr><td><code>ofEpochMilli(long epochMilli)</code></td><td>静态方法，返回在1970-01-01 00:00:00基础上加上指定毫秒数之后的Instant类的对象</td></tr><tr><td>atOffset(ZoneOffset offset)</td><td>结合即时的偏移来创建一个 OffsetDateTime</td></tr><tr><td><code>toEpochMilli()</code></td><td>返回1970-01-01 00:00:00到当前时间的毫秒数，即为时间戳</td></tr></tbody></table></div><blockquote><p>中国大陆、中国香港、中国澳门、中国台湾、蒙古国、新加坡、马来西亚、菲律宾、西澳大利亚州的时间与UTC的时差均为+8，也就是UTC+8。</p><p>instant.atOffset(ZoneOffset.ofHours(8));</p></blockquote><p><img src="/2023/02/18/java2023/%E7%AC%AC11%E7%AB%A0_%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%A1%80API/image-20220406000442908.png" alt="image-20220406000442908"></p><blockquote><p>整个地球分为二十四时区，每个时区都有自己的本地时间。北京时区是东八区，领先UTC八个小时，在电子邮件信头的Date域记为+0800。如果在电子邮件的信头中有这么一行： </p><p> Date: Fri, 08 Nov 2002 09:42:22 +0800 </p><p> 说明信件的发送地的地方时间是二○○二年十一月八号，星期五，早上九点四十二分（二十二秒），这个地方的本地时领先UTC八个小时(+0800， 就是东八区时间)。电子邮件信头的Date域使用二十四小时的时钟，而不使用AM和PM来标记上下午。 </p></blockquote><h3 id="4-3-日期时间格式化：DateTimeFormatter"><a href="#4-3-日期时间格式化：DateTimeFormatter" class="headerlink" title="4.3 日期时间格式化：DateTimeFormatter"></a>4.3 日期时间格式化：DateTimeFormatter</h3><p>该类提供了三种格式化方法：</p><ul><li>(了解)预定义的标准格式。如：ISO_LOCAL_DATE_TIME、ISO_LOCAL_DATE、ISO_LOCAL_TIME</li></ul><ul><li><p>(了解)本地化相关的格式。如：ofLocalizedDate(FormatStyle.LONG)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 本地化相关的格式。如：ofLocalizedDateTime()</span></span><br><span class="line"><span class="comment">// FormatStyle.MEDIUM / FormatStyle.SHORT :适用于LocalDateTime</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地化相关的格式。如：ofLocalizedDate()</span></span><br><span class="line"><span class="comment">// FormatStyle.FULL / FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT : 适用于LocalDate</span></span><br></pre></td></tr></table></figure></li><li><p>自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)</p></li></ul><div class="table-container"><table><thead><tr><th><strong>方</strong>   <strong>法</strong></th><th><strong>描</strong>   <strong>述</strong></th></tr></thead><tbody><tr><td><strong>ofPattern(String</strong>  <strong>pattern)</strong></td><td>静态方法，返回一个指定字符串格式的DateTimeFormatter</td></tr><tr><td><strong>format(TemporalAccessor</strong> <strong>t)</strong></td><td>格式化一个日期、时间，返回字符串</td></tr><tr><td><strong>parse(CharSequence</strong>  <strong>text)</strong></td><td>将指定格式的字符序列解析为一个日期、时间</td></tr></tbody></table></div><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.ZoneId;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> java.time.format.FormatStyle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDatetimeFormatter</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 方式一：预定义的标准格式。如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME</span></span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ISO_LOCAL_DATE_TIME;</span><br><span class="line">        <span class="comment">// 格式化:日期--&gt;字符串</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> formatter.format(localDateTime);</span><br><span class="line">        System.out.println(localDateTime);</span><br><span class="line">        System.out.println(str1);<span class="comment">//2022-12-04T21:02:14.808</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析：字符串 --&gt;日期</span></span><br><span class="line">        <span class="type">TemporalAccessor</span> <span class="variable">parse</span> <span class="operator">=</span> formatter.parse(<span class="string">&quot;2022-12-04T21:02:14.808&quot;</span>);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">dateTime</span> <span class="operator">=</span> LocalDateTime.from(parse);</span><br><span class="line">        System.out.println(dateTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="comment">// 方式二：</span></span><br><span class="line">        <span class="comment">// 本地化相关的格式。如：ofLocalizedDateTime()</span></span><br><span class="line">        <span class="comment">// FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT :适用于LocalDateTime</span></span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">formatter1</span> <span class="operator">=</span> DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 格式化</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> formatter1.format(localDateTime);</span><br><span class="line">        System.out.println(str2);<span class="comment">// 2022年12月4日 下午09时03分55秒</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 本地化相关的格式。如：ofLocalizedDate()</span></span><br><span class="line">        <span class="comment">// FormatStyle.FULL / FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT : 适用于LocalDate</span></span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">formatter2</span> <span class="operator">=</span> DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL);</span><br><span class="line">        <span class="comment">// 格式化</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> formatter2.format(LocalDate.now());</span><br><span class="line">        System.out.println(str3);<span class="comment">// 2022年12月4日 星期日</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//方式三：自定义的方式（关注、重点）</span></span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">dateTimeFormatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="comment">//格式化</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">strDateTime</span> <span class="operator">=</span> dateTimeFormatter.format(LocalDateTime.now());</span><br><span class="line">        System.out.println(strDateTime); <span class="comment">//2022/12/04 21:05:42</span></span><br><span class="line">        <span class="comment">//解析</span></span><br><span class="line">        <span class="type">TemporalAccessor</span> <span class="variable">accessor</span> <span class="operator">=</span> dateTimeFormatter.parse(<span class="string">&quot;2022/12/04 21:05:42&quot;</span>);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.from(accessor);</span><br><span class="line">        System.out.println(localDateTime); <span class="comment">//2022-12-04T21:05:42</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-其它API"><a href="#4-4-其它API" class="headerlink" title="4.4 其它API"></a>4.4 其它API</h3><p><strong>1、指定时区日期时间：ZondId和ZonedDateTime</strong></p><ul><li><p>ZoneId：该类中包含了所有的时区信息，一个时区的ID，如 Europe/Paris</p></li><li><p>ZonedDateTime：一个在ISO-8601日历系统时区的日期时间，如 2007-12-03T10:15:30+01:00 Europe/Paris。</p><ul><li>其中每个时区都对应着ID，地区ID都为“{区域}/{城市}”的格式，例如：Asia/Shanghai等</li></ul></li><li><p>常见时区ID：</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Asia/Shanghai</span><br><span class="line">UTC</span><br><span class="line">America/New_York</span><br></pre></td></tr></table></figure><ul><li>可以通过ZondId获取所有可用的时区ID：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.ZoneId;</span><br><span class="line"><span class="keyword">import</span> java.time.ZonedDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestZone</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//需要知道一些时区的id</span></span><br><span class="line">        <span class="comment">//Set&lt;String&gt;是一个集合，容器</span></span><br><span class="line">        Set&lt;String&gt; availableZoneIds = ZoneId.getAvailableZoneIds();</span><br><span class="line">        <span class="comment">//快捷模板iter</span></span><br><span class="line">        <span class="keyword">for</span> (String availableZoneId : availableZoneIds) &#123;</span><br><span class="line">            System.out.println(availableZoneId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ZonedDateTime</span> <span class="variable">t1</span> <span class="operator">=</span> ZonedDateTime.now();</span><br><span class="line">        System.out.println(t1);</span><br><span class="line"></span><br><span class="line">        <span class="type">ZonedDateTime</span> <span class="variable">t2</span> <span class="operator">=</span> ZonedDateTime.now(ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>));</span><br><span class="line">        System.out.println(t2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2、持续日期/时间：Period和Duration</strong></p><ul><li>持续时间：Duration，用于计算两个“时间”间隔</li><li>日期间隔：Period，用于计算两个“日期”间隔</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.Period;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPeriodDuration</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">t1</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">t2</span> <span class="operator">=</span> LocalDate.of(<span class="number">2018</span>, <span class="number">12</span>, <span class="number">31</span>);</span><br><span class="line">        <span class="type">Period</span> <span class="variable">between</span> <span class="operator">=</span> Period.between(t1, t2);</span><br><span class="line">        System.out.println(between);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;相差的年数：&quot;</span>+between.getYears());</span><br><span class="line">        System.out.println(<span class="string">&quot;相差的月数：&quot;</span>+between.getMonths());</span><br><span class="line">        System.out.println(<span class="string">&quot;相差的天数：&quot;</span>+between.getDays());</span><br><span class="line">        System.out.println(<span class="string">&quot;相差的总数：&quot;</span>+between.toTotalMonths());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">t1</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">t2</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2017</span>, <span class="number">8</span>, <span class="number">29</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="type">Duration</span> <span class="variable">between</span> <span class="operator">=</span> Duration.between(t1, t2);</span><br><span class="line">        System.out.println(between);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;相差的总天数：&quot;</span>+between.toDays());</span><br><span class="line">        System.out.println(<span class="string">&quot;相差的总小时数：&quot;</span>+between.toHours());</span><br><span class="line">        System.out.println(<span class="string">&quot;相差的总分钟数：&quot;</span>+between.toMinutes());</span><br><span class="line">        System.out.println(<span class="string">&quot;相差的总秒数：&quot;</span>+between.getSeconds());</span><br><span class="line">        System.out.println(<span class="string">&quot;相差的总毫秒数：&quot;</span>+between.toMillis());</span><br><span class="line">        System.out.println(<span class="string">&quot;相差的总纳秒数：&quot;</span>+between.toNanos());</span><br><span class="line">        System.out.println(<span class="string">&quot;不够一秒的纳秒数：&quot;</span>+between.getNano());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//Duration:用于计算两个“时间”间隔，以秒和纳秒为基准</span></span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">localTime1</span> <span class="operator">=</span> LocalTime.of(<span class="number">15</span>, <span class="number">23</span>, <span class="number">32</span>);</span><br><span class="line"><span class="comment">//between():静态方法，返回Duration对象，表示两个时间的间隔</span></span><br><span class="line"><span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(localTime1, localTime);</span><br><span class="line">System.out.println(duration);</span><br><span class="line"></span><br><span class="line">System.out.println(duration.getSeconds());</span><br><span class="line">System.out.println(duration.getNano());</span><br><span class="line"></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2016</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">32</span>);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime1</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2017</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Duration</span> <span class="variable">duration1</span> <span class="operator">=</span> Duration.between(localDateTime1, localDateTime);</span><br><span class="line">System.out.println(duration1.toDays());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//Period:用于计算两个“日期”间隔，以年、月、日衡量</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate1</span> <span class="operator">=</span> LocalDate.of(<span class="number">2028</span>, <span class="number">3</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Period</span> <span class="variable">period</span> <span class="operator">=</span> Period.between(localDate, localDate1);</span><br><span class="line">System.out.println(period);</span><br><span class="line"></span><br><span class="line">System.out.println(period.getYears());</span><br><span class="line">System.out.println(period.getMonths());</span><br><span class="line">System.out.println(period.getDays());</span><br><span class="line"></span><br><span class="line"><span class="type">Period</span> <span class="variable">period1</span> <span class="operator">=</span> period.withYears(<span class="number">2</span>);</span><br><span class="line">System.out.println(period1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、Clock：使用时区提供对当前即时、日期和时间的访问的时钟。</p><p>4、</p><p>TemporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整到“下一个工作日”等操作。<br>TemporalAdjusters : 该类通过静态方法(firstDayOfXxx()/lastDayOfXxx()/nextXxx())提供了大量的常用 TemporalAdjuster 的实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// TemporalAdjuster:时间校正器</span></span><br><span class="line"><span class="comment">// 获取当前日期的下一个周日是哪天？</span></span><br><span class="line"><span class="type">TemporalAdjuster</span> <span class="variable">temporalAdjuster</span> <span class="operator">=</span> TemporalAdjusters.next(DayOfWeek.SUNDAY);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now().with(temporalAdjuster);</span><br><span class="line">System.out.println(localDateTime);</span><br><span class="line"><span class="comment">// 获取下一个工作日是哪天？</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now().with(<span class="keyword">new</span> <span class="title class_">TemporalAdjuster</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Temporal <span class="title function_">adjustInto</span><span class="params">(Temporal temporal)</span> &#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> (LocalDate) temporal;</span><br><span class="line">       <span class="keyword">if</span> (date.getDayOfWeek().equals(DayOfWeek.FRIDAY)) &#123;</span><br><span class="line">           <span class="keyword">return</span> date.plusDays(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (date.getDayOfWeek().equals(DayOfWeek.SATURDAY)) &#123;</span><br><span class="line">            <span class="keyword">return</span> date.plusDays(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> date.plusDays(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;下一个工作日是：&quot;</span> + localDate);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-与传统日期处理的转换"><a href="#4-5-与传统日期处理的转换" class="headerlink" title="4.5 与传统日期处理的转换"></a>4.5 与传统日期处理的转换</h3><div class="table-container"><table><thead><tr><th><strong>类</strong></th><th><strong>To</strong> <strong>遗留类</strong></th><th><strong>From</strong> <strong>遗留类</strong></th></tr></thead><tbody><tr><td><strong>java.time.Instant与java.util.Date</strong></td><td>Date.from(instant)</td><td>date.toInstant()</td></tr><tr><td><strong>java.time.Instant与java.sql.Timestamp</strong></td><td>Timestamp.from(instant)</td><td>timestamp.toInstant()</td></tr><tr><td><strong>java.time.ZonedDateTime与java.util.GregorianCalendar</strong></td><td>GregorianCalendar.from(zonedDateTime)</td><td>cal.toZonedDateTime()</td></tr><tr><td><strong>java.time.LocalDate与java.sql.Time</strong></td><td>Date.valueOf(localDate)</td><td>date.toLocalDate()</td></tr><tr><td><strong>java.time.LocalTime与java.sql.Time</strong></td><td>Date.valueOf(localDate)</td><td>date.toLocalTime()</td></tr><tr><td><strong>java.time.LocalDateTime与java.sql.Timestamp</strong></td><td>Timestamp.valueOf(localDateTime)</td><td>timestamp.toLocalDateTime()</td></tr><tr><td><strong>java.time.ZoneId与java.util.TimeZone</strong></td><td>Timezone.getTimeZone(id)</td><td>timeZone.toZoneId()</td></tr><tr><td><strong>java.time.format.DateTimeFormatter与java.text.DateFormat</strong></td><td>formatter.toFormat()</td><td>无</td></tr></tbody></table></div><h2 id="5-Java比较器"><a href="#5-Java比较器" class="headerlink" title="5. Java比较器"></a>5. Java比较器</h2><p>我们知道基本数据类型的数据（除boolean类型外）需要比较大小的话，之间使用比较运算符即可，但是引用数据类型是不能直接使用比较运算符来比较大小的。那么，如何解决这个问题呢？</p><p><img src="/2023/02/18/java2023/%E7%AC%AC11%E7%AB%A0_%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%A1%80API/image-20220406001726285.png" alt="image-20220406001726285"></p><ul><li>在Java中经常会涉及到对象数组的排序问题，那么就涉及到对象之间的比较问题。</li></ul><ul><li>Java实现对象排序的方式有两种：<ul><li>自然排序：java.lang.Comparable</li><li>定制排序：java.util.Comparator</li></ul></li></ul><h3 id="5-1-自然排序：java-lang-Comparable"><a href="#5-1-自然排序：java-lang-Comparable" class="headerlink" title="5.1 自然排序：java.lang.Comparable"></a>5.1 自然排序：java.lang.Comparable</h3><ul><li>Comparable接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序。</li><li>实现 Comparable 的类必须实现 <code>compareTo(Object obj)</code>方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。如果当前对象this大于形参对象obj，则返回正整数，如果当前对象this小于形参对象obj，则返回负整数，如果当前对象this等于形参对象obj，则返回零。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object obj)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现Comparable接口的对象列表（和数组）可以通过 Collections.sort 或 Arrays.sort进行自动排序。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</li><li><p>对于类 C 的每一个 e1 和 e2 来说，当且仅当 e1.compareTo(e2) == 0 与 e1.equals(e2) 具有相同的 boolean 值时，类 C 的自然排序才叫做与 equals 一致。建议（虽然不是必需的）<code>最好使自然排序与 equals 一致</code>。</p></li><li><p>Comparable 的典型实现：(<code>默认都是从小到大排列的</code>)</p><ul><li>String：按照字符串中字符的Unicode值进行比较</li><li>Character：按照字符的Unicode值来进行比较</li><li>数值类型对应的包装类以及BigInteger、BigDecimal：按照它们对应的数值大小进行比较</li><li>Boolean：true 对应的包装类实例大于 false 对应的包装类实例</li><li>Date、Time等：后面的日期时间比前面的日期时间大</li></ul></li><li><p>代码示例：</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.api;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, String name, <span class="type">int</span> score, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, score=&quot;</span> + score +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">//这些需要强制，将o对象向下转型为Student类型的变量，才能调用Student类中的属性</span></span><br><span class="line">        <span class="comment">//默认按照学号比较大小</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> (Student) o;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.id - stu.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.api;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStudent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Student[] arr = <span class="keyword">new</span> <span class="title class_">Student</span>[<span class="number">5</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">3</span>,<span class="string">&quot;张三&quot;</span>,<span class="number">90</span>,<span class="number">23</span>);</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1</span>,<span class="string">&quot;熊大&quot;</span>,<span class="number">100</span>,<span class="number">22</span>);</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">5</span>,<span class="string">&quot;王五&quot;</span>,<span class="number">75</span>,<span class="number">25</span>);</span><br><span class="line">        arr[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">4</span>,<span class="string">&quot;李四&quot;</span>,<span class="number">85</span>,<span class="number">24</span>);</span><br><span class="line">        arr[<span class="number">4</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">2</span>,<span class="string">&quot;熊二&quot;</span>,<span class="number">85</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//单独比较两个对象</span></span><br><span class="line">        System.out.println(arr[<span class="number">0</span>].compareTo(arr[<span class="number">1</span>]));</span><br><span class="line">        System.out.println(arr[<span class="number">1</span>].compareTo(arr[<span class="number">2</span>]));</span><br><span class="line">        System.out.println(arr[<span class="number">2</span>].compareTo(arr[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;所有学生：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;按照学号排序：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length-i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j].compareTo(arr[j+<span class="number">1</span>])&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="type">Student</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                    arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, score=&quot;</span> + score +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.score - ((Student)o).score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">Student[] students = <span class="keyword">new</span> <span class="title class_">Student</span>[<span class="number">3</span>];</span><br><span class="line">students[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">96</span>);</span><br><span class="line">students[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">85</span>);</span><br><span class="line">students[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">98</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(students));</span><br><span class="line">Arrays.sort(students);</span><br><span class="line">System.out.println(Arrays.toString(students));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Goods</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按照价格，比较商品的大小</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Goods) &#123;</span><br><span class="line">            <span class="type">Goods</span> <span class="variable">other</span> <span class="operator">=</span> (Goods) o;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.price &gt; other.price) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.price &lt; other.price) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的数据类型不一致&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造器、getter、setter、toString()方法略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComparableTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Goods[] all = <span class="keyword">new</span> <span class="title class_">Goods</span>[<span class="number">4</span>];</span><br><span class="line">        all[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;《红楼梦》&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        all[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;《西游记》&quot;</span>, <span class="number">80</span>);</span><br><span class="line">        all[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;《三国演义》&quot;</span>, <span class="number">140</span>);</span><br><span class="line">        all[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;《水浒传》&quot;</span>, <span class="number">120</span>);</span><br><span class="line"></span><br><span class="line">        Arrays.sort(all);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(all));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-2-定制排序：java-util-Comparator"><a href="#5-2-定制排序：java-util-Comparator" class="headerlink" title="5.2 定制排序：java.util.Comparator"></a>5.2 定制排序：java.util.Comparator</h3><ul><li>思考<ul><li>当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码（例如：一些第三方的类，你只有.class文件，没有源文件）</li><li>如果一个类，实现了Comparable接口，也指定了两个对象的比较大小的规则，但是此时此刻我不想按照它预定义的方法比较大小，但是我又不能随意修改，因为会影响其他地方的使用，怎么办？</li></ul></li><li>JDK在设计类库之初，也考虑到这种情况，所以又增加了一个java.util.Comparator接口。强行对多个对象进行整体排序的比较。<ul><li>重写compare(Object o1,Object o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。</li><li>可以将 Comparator 传递给 sort 方法（如 Collections.sort 或 Arrays.sort），从而允许在排序顺序上实现精确控制。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1,Object o2)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.api;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="comment">//定义定制比较器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentScoreComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span> &#123; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> (Student) o1;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> (Student) o2;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> s1.getScore() - s2.getScore();</span><br><span class="line">        <span class="keyword">return</span> result != <span class="number">0</span> ? result : s1.getId() - s2.getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.api;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStudent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Student[] arr = <span class="keyword">new</span> <span class="title class_">Student</span>[<span class="number">5</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">3</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">90</span>, <span class="number">23</span>);</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1</span>, <span class="string">&quot;熊大&quot;</span>, <span class="number">100</span>, <span class="number">22</span>);</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">5</span>, <span class="string">&quot;王五&quot;</span>, <span class="number">75</span>, <span class="number">25</span>);</span><br><span class="line">        arr[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">4</span>, <span class="string">&quot;李四&quot;</span>, <span class="number">85</span>, <span class="number">24</span>);</span><br><span class="line">        arr[<span class="number">4</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">2</span>, <span class="string">&quot;熊二&quot;</span>, <span class="number">85</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;所有学生：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;按照成绩排序&quot;</span>);</span><br><span class="line">        <span class="type">StudentScoreComparator</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentScoreComparator</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sc.compare(arr[j], arr[j + <span class="number">1</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">Student</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">    Student[] students = <span class="keyword">new</span> <span class="title class_">Student</span>[<span class="number">5</span>];</span><br><span class="line">    students[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">3</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">90</span>, <span class="number">23</span>);</span><br><span class="line">    students[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1</span>, <span class="string">&quot;熊大&quot;</span>, <span class="number">100</span>, <span class="number">22</span>);</span><br><span class="line">    students[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">5</span>, <span class="string">&quot;王五&quot;</span>, <span class="number">75</span>, <span class="number">25</span>);</span><br><span class="line">    students[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">4</span>, <span class="string">&quot;李四&quot;</span>, <span class="number">85</span>, <span class="number">24</span>);</span><br><span class="line">    students[<span class="number">4</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">2</span>, <span class="string">&quot;熊二&quot;</span>, <span class="number">85</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(Arrays.toString(students));</span><br><span class="line">    <span class="comment">//定制排序</span></span><br><span class="line">    <span class="type">StudentScoreComparator</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentScoreComparator</span>();</span><br><span class="line">    Arrays.sort(students, sc);</span><br><span class="line">    System.out.println(<span class="string">&quot;排序之后：&quot;</span>);</span><br><span class="line">    System.out.println(Arrays.toString(students));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Goods[] all = <span class="keyword">new</span> <span class="title class_">Goods</span>[<span class="number">4</span>];</span><br><span class="line">all[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;War and Peace&quot;</span>, <span class="number">100</span>);</span><br><span class="line">all[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;Childhood&quot;</span>, <span class="number">80</span>);</span><br><span class="line">all[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;Scarlet and Black&quot;</span>, <span class="number">140</span>);</span><br><span class="line">all[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;Notre Dame de Paris&quot;</span>, <span class="number">120</span>);</span><br><span class="line"></span><br><span class="line">Arrays.sort(all, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="type">Goods</span> <span class="variable">g1</span> <span class="operator">=</span> (Goods) o1;</span><br><span class="line">        <span class="type">Goods</span> <span class="variable">g2</span> <span class="operator">=</span> (Goods) o2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> g1.getName().compareTo(g2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(all));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-系统相关类"><a href="#6-系统相关类" class="headerlink" title="6. 系统相关类"></a>6. 系统相关类</h2><h3 id="6-1-java-lang-System类"><a href="#6-1-java-lang-System类" class="headerlink" title="6.1 java.lang.System类"></a>6.1 java.lang.System类</h3><ul><li><p>System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于<code>java.lang包</code>。</p></li><li><p>由于该类的构造器是private的，所以无法创建该类的对象。其内部的成员变量和成员方法都是<code>static的</code>，所以也可以很方便的进行调用。</p></li><li><p>成员变量   Scanner scan = new Scanner(System.in);</p><ul><li>System类内部包含<code>in</code>、<code>out</code>和<code>err</code>三个成员变量，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。</li></ul></li><li><p>成员方法</p><ul><li><p><code>native long currentTimeMillis()</code>：<br>该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。</p></li><li><p><code>void exit(int status)</code>：<br>该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等。</p></li><li><p><code>void gc()</code>：<br>该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。</p></li><li><p><code>String getProperty(String key)</code>：<br>该方法的作用是获得系统中属性名为key的属性对应的值。系统中常见的属性名以及属性的作用如下表所示：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC11%E7%AB%A0_%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%A1%80API/image-20220406003340258.png" alt="image-20220406003340258"></p></li></ul></li><li><p>举例</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSystem</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;现在的系统时间距离1970年1月1日凌晨：&quot;</span> + time + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);<span class="comment">//不会执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">javaVersion</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.version&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;java的version:&quot;</span> + javaVersion);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">javaHome</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.home&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;java的home:&quot;</span> + javaHome);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">osName</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;os的name:&quot;</span> + osName);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">osVersion</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.version&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;os的version:&quot;</span> + osVersion);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.name&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;user的name:&quot;</span> + userName);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">userHome</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.home&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;user的home:&quot;</span> + userHome);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">userDir</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;user的dir:&quot;</span> + userDir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i &lt;=<span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="type">MyDemo</span> <span class="variable">my</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyDemo</span>(i);</span><br><span class="line">            <span class="comment">//每一次循环my就会指向新的对象，那么上次的对象就没有变量引用它了，就成垃圾对象</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了看到垃圾回收器工作，我要加下面的代码，让main方法不那么快结束，因为main结束就会导致JVM退出，GC也会跟着结束。</span></span><br><span class="line">        System.gc();<span class="comment">//如果不调用这句代码，GC可能不工作，因为当前内存很充足，GC就觉得不着急回收垃圾对象。</span></span><br><span class="line">        <span class="comment">//调用这句代码，会让GC尽快来工作。</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDemo</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyDemo</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyDemo&#123;&quot;</span> + <span class="string">&quot;value=&quot;</span> + value + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写finalize方法，让大家看一下它的调用效果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="comment">//        正常重写，这里是编写清理系统内存的代码</span></span><br><span class="line"><span class="comment">//        这里写输出语句是为了看到finalize()方法被调用的效果</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>+ <span class="string">&quot;轻轻的我走了，不带走一段代码....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>： </p><p>从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。常用于数组的插入和删除</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSystemArrayCopy</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        System.arraycopy(arr1,<span class="number">0</span>,arr2,<span class="number">3</span>,arr1.length);</span><br><span class="line">        System.out.println(Arrays.toString(arr1));</span><br><span class="line">        System.out.println(Arrays.toString(arr2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        System.arraycopy(arr,<span class="number">0</span>,arr,<span class="number">1</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        System.arraycopy(arr,<span class="number">1</span>,arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-java-lang-Runtime类"><a href="#6-2-java-lang-Runtime类" class="headerlink" title="6.2 java.lang.Runtime类"></a>6.2 java.lang.Runtime类</h3><p>每个 Java 应用程序都有一个 <code>Runtime</code> 类实例，使应用程序能够与其运行的环境相连接。</p><p><code>public static Runtime getRuntime()</code>： 返回与当前 Java 应用程序相关的运行时对象。应用程序不能创建自己的 Runtime 类实例。</p><p><code>public long totalMemory()</code>：返回 Java 虚拟机中初始化时的内存总量。此方法返回的值可能随时间的推移而变化，这取决于主机环境。默认为物理电脑内存的1/64。</p><p><code>public long maxMemory()</code>：返回 Java 虚拟机中最大程度能使用的内存总量。默认为物理电脑内存的1/4。</p><p><code>public long freeMemory()</code>：回 Java 虚拟机中的空闲内存量。调用 gc 方法可能导致 freeMemory 返回值的增加。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.system;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRuntime</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">        <span class="type">long</span> <span class="variable">initialMemory</span> <span class="operator">=</span> runtime.totalMemory(); <span class="comment">//获取虚拟机初始化时堆内存总量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">maxMemory</span> <span class="operator">=</span> runtime.maxMemory(); <span class="comment">//获取虚拟机最大堆内存总量</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//模拟占用内存</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            str += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">freeMemory</span> <span class="operator">=</span> runtime.freeMemory(); <span class="comment">//获取空闲堆内存总量</span></span><br><span class="line">        System.out.println(<span class="string">&quot;总内存：&quot;</span> + initialMemory / <span class="number">1024</span> / <span class="number">1024</span> * <span class="number">64</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;总内存：&quot;</span> + maxMemory / <span class="number">1024</span> / <span class="number">1024</span> * <span class="number">4</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;空闲内存：&quot;</span> + freeMemory / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>) ;</span><br><span class="line">        System.out.println(<span class="string">&quot;已用内存：&quot;</span> + (initialMemory-freeMemory) / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-和数学相关的类"><a href="#7-和数学相关的类" class="headerlink" title="7. 和数学相关的类"></a>7. 和数学相关的类</h2><h3 id="7-1-java-lang-Math"><a href="#7-1-java-lang-Math" class="headerlink" title="7.1 java.lang.Math"></a>7.1 java.lang.Math</h3><p><code>java.lang.Math</code> 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。类似这样的工具类，其所有方法均为静态方法，并且不会创建对象，调用起来非常简单。</p><ul><li><code>public static double abs(double a)</code> ：返回 double 值的绝对值。 </li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> Math.abs(-<span class="number">5</span>); <span class="comment">//d1的值为5</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> Math.abs(<span class="number">5</span>); <span class="comment">//d2的值为5</span></span><br></pre></td></tr></table></figure><ul><li><code>public static double ceil(double a)</code> ：返回大于等于参数的最小的整数。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> Math.ceil(<span class="number">3.3</span>); <span class="comment">//d1的值为 4.0</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> Math.ceil(-<span class="number">3.3</span>); <span class="comment">//d2的值为 -3.0</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d3</span> <span class="operator">=</span> Math.ceil(<span class="number">5.1</span>); <span class="comment">//d3的值为 6.0</span></span><br></pre></td></tr></table></figure><ul><li><code>public static double floor(double a)</code> ：返回小于等于参数最大的整数。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> Math.floor(<span class="number">3.3</span>); <span class="comment">//d1的值为3.0</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> Math.floor(-<span class="number">3.3</span>); <span class="comment">//d2的值为-4.0</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d3</span> <span class="operator">=</span> Math.floor(<span class="number">5.1</span>); <span class="comment">//d3的值为 5.0</span></span><br></pre></td></tr></table></figure><ul><li><code>public static long round(double a)</code> ：返回最接近参数的 long。(相当于四舍五入方法)  </li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">d1</span> <span class="operator">=</span> Math.round(<span class="number">5.5</span>); <span class="comment">//d1的值为6</span></span><br><span class="line"><span class="type">long</span> <span class="variable">d2</span> <span class="operator">=</span> Math.round(<span class="number">5.4</span>); <span class="comment">//d2的值为5</span></span><br><span class="line"><span class="type">long</span> <span class="variable">d3</span> <span class="operator">=</span> Math.round(-<span class="number">3.3</span>); <span class="comment">//d3的值为-3</span></span><br><span class="line"><span class="type">long</span> <span class="variable">d4</span> <span class="operator">=</span> Math.round(-<span class="number">3.8</span>); <span class="comment">//d4的值为-4</span></span><br></pre></td></tr></table></figure><ul><li>public static double pow(double a,double b)：返回a的b幂次方法</li><li>public static double sqrt(double a)：返回a的平方根</li><li><code>public static double random()</code>：返回[0,1)的随机值</li><li>public static final double PI：返回圆周率</li><li>public static double max(double x, double y)：返回x,y中的最大值</li><li>public static double min(double x, double y)：返回x,y中的最小值</li><li>其它：acos,asin,atan,cos,sin,tan 三角函数</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> Math.pow(<span class="number">2</span>,<span class="number">31</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">sqrt</span> <span class="operator">=</span> Math.sqrt(<span class="number">256</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">rand</span> <span class="operator">=</span> Math.random();</span><br><span class="line"><span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> Math.PI;</span><br></pre></td></tr></table></figure><h3 id="7-2-java-math包"><a href="#7-2-java-math包" class="headerlink" title="7.2 java.math包"></a>7.2 java.math包</h3><h4 id="7-2-1-BigInteger"><a href="#7-2-1-BigInteger" class="headerlink" title="7.2.1 BigInteger"></a>7.2.1 BigInteger</h4><ul><li>Integer类作为int的包装类，能存储的最大整型值为2^31-1，Long类也是有限的，最大为2^63-1。如果要表示再大的整数，不管是基本数据类型还是他们的包装类都无能为力，更不用说进行运算了。</li></ul><ul><li>java.math包的BigInteger可以表示<code>不可变的任意精度的整数</code>。BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。 </li></ul><ul><li><p>构造器</p><ul><li>BigInteger(String val)：根据字符串构建BigInteger对象</li></ul></li><li><p>方法</p><ul><li>public BigInteger <code>abs</code>()：返回此 BigInteger 的绝对值的 BigInteger。</li><li>BigInteger <code>add</code>(BigInteger val) ：返回其值为 (this + val) 的 BigInteger</li><li>BigInteger <code>subtract</code>(BigInteger val) ：返回其值为 (this - val) 的 BigInteger</li><li>BigInteger <code>multiply</code>(BigInteger val) ：返回其值为 (this * val) 的 BigInteger</li><li>BigInteger <code>divide</code>(BigInteger val) ：返回其值为 (this / val) 的 BigInteger。整数相除只保留整数部分。</li><li>BigInteger <code>remainder</code>(BigInteger val) ：返回其值为 (this % val) 的 BigInteger。</li><li>BigInteger[] <code>divideAndRemainder</code>(BigInteger val)：返回包含 (this / val) 后跟 (this % val) 的两个 BigInteger 的数组。</li><li>BigInteger <code>pow</code>(int exponent) ：返回其值为 (this^exponent) 的 BigInteger。 </li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//long bigNum = 123456789123456789123456789L;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">BigInteger</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;12345678912345678912345678&quot;</span>);</span><br><span class="line">    <span class="type">BigInteger</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;78923456789123456789123456789&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//System.out.println(&quot;和：&quot; + (b1+b2));//错误的，无法直接使用+进行求和</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;和：&quot;</span> + b1.add(b2));</span><br><span class="line">    System.out.println(<span class="string">&quot;减：&quot;</span> + b1.subtract(b2));</span><br><span class="line">    System.out.println(<span class="string">&quot;乘：&quot;</span> + b1.multiply(b2));</span><br><span class="line">    System.out.println(<span class="string">&quot;除：&quot;</span> + b2.divide(b1));</span><br><span class="line">    System.out.println(<span class="string">&quot;余：&quot;</span> + b2.remainder(b1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-2-2-BigDecimal"><a href="#7-2-2-BigDecimal" class="headerlink" title="7.2.2 BigDecimal"></a>7.2.2 BigDecimal</h4><ul><li><p>一般的Float类和Double类可以用来做科学计算或工程计算，但在<strong>商业计算中，要求数字精度比较高，故用到java.math.BigDecimal类。</strong></p></li><li><p>BigDecimal类支持不可变的、任意精度的有符号十进制定点数。</p></li><li><p>构造器</p><ul><li>public BigDecimal(double val)</li><li>public BigDecimal(String val) —&gt; 推荐</li></ul></li><li><p>常用方法</p><ul><li>public BigDecimal <code>add</code>(BigDecimal augend)</li><li>public BigDecimal <code>subtract</code>(BigDecimal subtrahend)</li><li>public BigDecimal <code>multiply</code>(BigDecimal multiplicand)</li><li>public BigDecimal <code>divide</code>(BigDecimal divisor, int scale, int roundingMode)：divisor是除数，scale指明保留几位小数，roundingMode指明舍入模式（ROUND_UP :向上加1、ROUND_DOWN :直接舍去、ROUND_HALF_UP:四舍五入）</li></ul></li></ul><ul><li>举例</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">BigInteger</span> <span class="variable">bi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;12433241123&quot;</span>);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">bd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;12435.351&quot;</span>);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">bd2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">    System.out.println(bi);</span><br><span class="line">    <span class="comment">// System.out.println(bd.divide(bd2));</span></span><br><span class="line">    System.out.println(bd.divide(bd2, BigDecimal.ROUND_HALF_UP));</span><br><span class="line">    System.out.println(bd.divide(bd2, <span class="number">15</span>, BigDecimal.ROUND_HALF_UP));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-3-java-util-Random"><a href="#7-3-java-util-Random" class="headerlink" title="7.3 java.util.Random"></a>7.3 java.util.Random</h3><p>用于产生随机数</p><ul><li><p><code>boolean nextBoolean()</code>:返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的 boolean 值。 </p></li><li><p><code>void nextBytes(byte[] bytes)</code>:生成随机字节并将其置于用户提供的 byte 数组中。 </p></li><li><p><code>double nextDouble()</code>:返回下一个伪随机数，它是取自此随机数生成器序列的、在 0.0 和 1.0 之间均匀分布的 double 值。 </p></li><li><p><code>float nextFloat()</code>:返回下一个伪随机数，它是取自此随机数生成器序列的、在 0.0 和 1.0 之间均匀分布的 float 值。 </p></li><li><p><code>double nextGaussian()</code>:返回下一个伪随机数，它是取自此随机数生成器序列的、呈高斯（“正态”）分布的 double 值，其平均值是 0.0，标准差是 1.0。 </p></li><li><p><code>int nextInt()</code>:返回下一个伪随机数，它是此随机数生成器的序列中均匀分布的 int 值。 </p></li><li><p><code>int nextInt(int n)</code>:返回一个伪随机数，它是取自此随机数生成器序列的、在 0（包括）和指定值（不包括）之间均匀分布的 int 值。 </p></li><li><p><code>long nextLong()</code>:返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的 long 值。 </p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;随机整数：&quot;</span> + r.nextInt());</span><br><span class="line">    System.out.println(<span class="string">&quot;随机小数：&quot;</span> + r.nextDouble());</span><br><span class="line">    System.out.println(<span class="string">&quot;随机布尔值：&quot;</span> + r.nextBoolean());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第11章-常用类和基础API&quot;&gt;&lt;a href=&quot;#第11章-常用类和基础API&quot; class=&quot;headerlink&quot; title=&quot;第11章_常用类和基础API&quot;&gt;&lt;/a&gt;第11章_常用类和基础API&lt;/h1&gt;&lt;p&gt;讲师：尚硅谷-宋红康（江湖人称：康师傅）&lt;/</summary>
      
    
    
    
    <category term="Java2023" scheme="http://example.com/categories/Java2023/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第12章_集合框架</title>
    <link href="http://example.com/2023/02/18/java2023/%E7%AC%AC12%E7%AB%A0_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <id>http://example.com/2023/02/18/java2023/%E7%AC%AC12%E7%AB%A0_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</id>
    <published>2023-02-18T12:37:01.000Z</published>
    <updated>2023-02-19T07:38:42.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第12章-集合框架"><a href="#第12章-集合框架" class="headerlink" title="第12章_集合框架"></a>第12章_集合框架</h1><p>讲师：尚硅谷-宋红康（江湖人称：康师傅）</p><p>官网：<a href="http://www.atguigu.com/">http://www.atguigu.com</a></p><hr><h2 id="本章专题与脉络"><a href="#本章专题与脉络" class="headerlink" title="本章专题与脉络"></a>本章专题与脉络</h2><p><img src="/2023/02/18/java2023/%E7%AC%AC12%E7%AB%A0_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/第3阶段：Java高级应用-第12章.png" alt="第3阶段：Java高级应用-第12章" style="zoom:50%;"></p><hr><h2 id="1-集合框架概述"><a href="#1-集合框架概述" class="headerlink" title="1. 集合框架概述"></a>1. 集合框架概述</h2><h3 id="1-1-生活中的容器"><a href="#1-1-生活中的容器" class="headerlink" title="1.1 生活中的容器"></a>1.1 生活中的容器</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC12%E7%AB%A0_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20220523190743146.png" alt="image-20220523190743146" style="zoom: 67%;"></p><h3 id="1-2-数组的特点与弊端"><a href="#1-2-数组的特点与弊端" class="headerlink" title="1.2 数组的特点与弊端"></a>1.2 数组的特点与弊端</h3><ul><li>一方面，面向对象语言对事物的体现都是以对象的形式，为了方便对多个对象的操作，就要对对象进行存储。</li><li>另一方面，使用数组存储对象方面具有<code>一些弊端</code>，而Java 集合就像一种容器，可以<code>动态地</code>把多个对象的引用放入容器中。</li><li>数组在内存存储方面的<code>特点</code>：<ul><li>数组初始化以后，长度就确定了。</li><li>数组中的添加的元素是依次紧密排列的，有序的，可以重复的。</li><li>数组声明的类型，就决定了进行元素初始化时的类型。不是此类型的变量，就不能添加。</li><li>可以存储基本数据类型值，也可以存储引用数据类型的变量</li></ul></li><li>数组在存储数据方面的<code>弊端</code>：<ul><li>数组初始化以后，长度就不可变了，不便于扩展</li><li>数组中提供的属性和方法少，不便于进行添加、删除、插入、获取元素个数等操作，且效率不高。</li><li>数组存储数据的特点单一，只能存储有序的、可以重复的数据</li></ul></li><li>Java 集合框架中的类可以用于存储多个<code>对象</code>，还可用于保存具有<code>映射关系</code>的关联数组。</li></ul><h3 id="1-3-Java集合框架体系"><a href="#1-3-Java集合框架体系" class="headerlink" title="1.3 Java集合框架体系"></a>1.3 Java集合框架体系</h3><p>Java 集合可分为 Collection 和 Map 两大体系：</p><ul><li>Collection接口：用于存储一个一个的数据，也称<code>单列数据集合</code>。<ul><li>List子接口：用来存储有序的、可以重复的数据（主要用来替换数组，”动态”数组）<ul><li>实现类：ArrayList(主要实现类)、LinkedList、Vector</li></ul></li></ul></li><li>Set子接口：用来存储无序的、不可重复的数据（类似于高中讲的”集合”）<ul><li>实现类：HashSet(主要实现类)、LinkedHashSet、TreeSet</li></ul></li><li><p>Map接口：用于存储具有映射关系“key-value对”的集合，即一对一对的数据，也称<code>双列数据集合</code>。(类似于高中的函数、映射。(x1,y1),(x2,y2) —-&gt; y = f(x) )</p><ul><li>HashMap(主要实现类)、LinkedHashMap、TreeMap、Hashtable、Properties</li></ul></li><li><p>JDK提供的集合API位于java.util包内</p></li><li>图示：集合框架全图</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC12%E7%AB%A0_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/集合框架全图.png" alt="集合框架全图.png"></p><ul><li>简图1：<strong>Collection接口继承树</strong></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC12%E7%AB%A0_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20220407203244029.png" alt="image-20220407203244029" style="zoom: 67%;"></p><ul><li>简图2：<strong>Map接口继承树</strong></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC12%E7%AB%A0_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20220407203412665.png" alt="image-20220407203412665" style="zoom: 67%;"></p><h3 id="1-4-集合的使用场景"><a href="#1-4-集合的使用场景" class="headerlink" title="1.4 集合的使用场景"></a>1.4 集合的使用场景</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC12%E7%AB%A0_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20220407202630027.png" alt="image-20220407202630027"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC12%E7%AB%A0_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/第12章_集合的使用场景.png" alt="第12章_集合的使用场景"></p><h2 id="2-Collection接口及方法"><a href="#2-Collection接口及方法" class="headerlink" title="2. Collection接口及方法"></a>2. Collection接口及方法</h2><ul><li>JDK不提供此接口的任何直接实现，而是提供更具体的子接口（如：Set和List）去实现。</li><li>Collection 接口是 List和Set接口的父接口，该接口里定义的方法既可用于操作 Set 集合，也可用于操作 List 集合。方法如下：</li></ul><h3 id="2-1-添加"><a href="#2-1-添加" class="headerlink" title="2.1 添加"></a>2.1 添加</h3><p>（1）add(E obj)：添加元素对象到当前集合中<br>（2）addAll(Collection other)：添加other集合中的所有元素对象到当前集合中，即this = this ∪ other</p><p>注意：add和addAll的区别</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollectionAdd</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAdd</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//ArrayList是Collection的子接口List的实现类之一。</span></span><br><span class="line">        <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        coll.add(<span class="string">&quot;小李广&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;扫地僧&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;石破天&quot;</span>);</span><br><span class="line">        System.out.println(coll);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAddAll</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        c1.add(<span class="number">1</span>);</span><br><span class="line">        c1.add(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;c1集合元素的个数：&quot;</span> + c1.size());<span class="comment">//2</span></span><br><span class="line">        System.out.println(<span class="string">&quot;c1 = &quot;</span> + c1);</span><br><span class="line"></span><br><span class="line">        <span class="type">Collection</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        c2.add(<span class="number">1</span>);</span><br><span class="line">        c2.add(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;c2集合元素的个数：&quot;</span> + c2.size());<span class="comment">//2</span></span><br><span class="line">        System.out.println(<span class="string">&quot;c2 = &quot;</span> + c2);</span><br><span class="line"></span><br><span class="line">        <span class="type">Collection</span> <span class="variable">other</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        other.add(<span class="number">1</span>);</span><br><span class="line">        other.add(<span class="number">2</span>);</span><br><span class="line">        other.add(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;other集合元素的个数：&quot;</span> + other.size());<span class="comment">//3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;other = &quot;</span> + other);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        c1.addAll(other);</span><br><span class="line">        System.out.println(<span class="string">&quot;c1集合元素的个数：&quot;</span> + c1.size());<span class="comment">//5</span></span><br><span class="line">        System.out.println(<span class="string">&quot;c1.addAll(other) = &quot;</span> + c1);</span><br><span class="line"></span><br><span class="line">        c2.add(other);</span><br><span class="line">        System.out.println(<span class="string">&quot;c2集合元素的个数：&quot;</span> + c2.size());<span class="comment">//3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;c2.add(other) = &quot;</span> + c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：coll.addAll(other);与coll.add(other);</p></blockquote><p><img src="/2023/02/18/java2023/%E7%AC%AC12%E7%AB%A0_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1563548078274.png" alt></p><h3 id="2-2-判断"><a href="#2-2-判断" class="headerlink" title="2.2 判断"></a>2.2 判断</h3><p>（3）int size()：获取当前集合中实际存储的元素个数<br>（4）boolean isEmpty()：判断当前集合是否为空集合<br>（5）boolean contains(Object obj)：判断当前集合中是否存在一个与obj对象equals返回true的元素<br>（6）boolean containsAll(Collection coll)：判断coll集合中的元素是否在当前集合中都存在。即coll集合是否是当前集合的“子集”<br>（7）boolean equals(Object obj)：判断当前集合与obj是否相等</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollectionContains</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;coll在添加元素之前，isEmpty = &quot;</span> + coll.isEmpty());</span><br><span class="line">        coll.add(<span class="string">&quot;小李广&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;扫地僧&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;石破天&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;佛地魔&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;coll的元素个数&quot;</span> + coll.size());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;coll在添加元素之后，isEmpty = &quot;</span> + coll.isEmpty());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        coll.add(<span class="string">&quot;小李广&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;扫地僧&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;石破天&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;佛地魔&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;coll = &quot;</span> + coll);</span><br><span class="line">        System.out.println(<span class="string">&quot;coll是否包含“小李广” = &quot;</span> + coll.contains(<span class="string">&quot;小李广&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;coll是否包含“宋红康” = &quot;</span> + coll.contains(<span class="string">&quot;宋红康&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Collection</span> <span class="variable">other</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        other.add(<span class="string">&quot;小李广&quot;</span>);</span><br><span class="line">        other.add(<span class="string">&quot;扫地僧&quot;</span>);</span><br><span class="line">        other.add(<span class="string">&quot;尚硅谷&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;other = &quot;</span> + other);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;coll.containsAll(other) = &quot;</span> + coll.containsAll(other));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        c1.add(<span class="number">1</span>);</span><br><span class="line">        c1.add(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;c1集合元素的个数：&quot;</span> + c1.size());<span class="comment">//2</span></span><br><span class="line">        System.out.println(<span class="string">&quot;c1 = &quot;</span> + c1);</span><br><span class="line"></span><br><span class="line">        <span class="type">Collection</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        c2.add(<span class="number">1</span>);</span><br><span class="line">        c2.add(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;c2集合元素的个数：&quot;</span> + c2.size());<span class="comment">//2</span></span><br><span class="line">        System.out.println(<span class="string">&quot;c2 = &quot;</span> + c2);</span><br><span class="line"></span><br><span class="line">        <span class="type">Collection</span> <span class="variable">other</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        other.add(<span class="number">1</span>);</span><br><span class="line">        other.add(<span class="number">2</span>);</span><br><span class="line">        other.add(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;other集合元素的个数：&quot;</span> + other.size());<span class="comment">//3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;other = &quot;</span> + other);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        c1.addAll(other);</span><br><span class="line">        System.out.println(<span class="string">&quot;c1集合元素的个数：&quot;</span> + c1.size());<span class="comment">//5</span></span><br><span class="line">        System.out.println(<span class="string">&quot;c1.addAll(other) = &quot;</span> + c1);</span><br><span class="line">        System.out.println(<span class="string">&quot;c1.contains(other) = &quot;</span> + c1.contains(other));</span><br><span class="line">        System.out.println(<span class="string">&quot;c1.containsAll(other) = &quot;</span> + c1.containsAll(other));</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        c2.add(other);</span><br><span class="line">        System.out.println(<span class="string">&quot;c2集合元素的个数：&quot;</span> + c2.size());</span><br><span class="line">        System.out.println(<span class="string">&quot;c2.add(other) = &quot;</span> + c2);</span><br><span class="line">        System.out.println(<span class="string">&quot;c2.contains(other) = &quot;</span> + c2.contains(other));</span><br><span class="line">        System.out.println(<span class="string">&quot;c2.containsAll(other) = &quot;</span> + c2.containsAll(other));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-删除"><a href="#2-3-删除" class="headerlink" title="2.3 删除"></a>2.3 删除</h3><p>（8）void clear()：清空集合元素<br>（9） boolean remove(Object obj) ：从当前集合中删除第一个找到的与obj对象equals返回true的元素。<br>（10）boolean removeAll(Collection coll)：从当前集合中删除所有与coll集合中相同的元素。即this = this - this ∩ coll<br>（11）boolean retainAll(Collection coll)：从当前集合中删除两个集合中不同的元素，使得当前集合仅保留与coll集合中的元素相同的元素，即当前集合中仅保留两个集合的交集，即this  = this ∩ coll；</p><p>注意几种删除方法的区别</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollectionRemove</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        coll.add(<span class="string">&quot;小李广&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;扫地僧&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;石破天&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;佛地魔&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;coll = &quot;</span> + coll);</span><br><span class="line"></span><br><span class="line">        coll.remove(<span class="string">&quot;小李广&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除元素\&quot;小李广\&quot;之后coll = &quot;</span> + coll);</span><br><span class="line">        </span><br><span class="line">        coll.clear();</span><br><span class="line">        System.out.println(<span class="string">&quot;coll清空之后，coll = &quot;</span> + coll);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        coll.add(<span class="string">&quot;小李广&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;扫地僧&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;石破天&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;佛地魔&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;coll = &quot;</span> + coll);</span><br><span class="line"></span><br><span class="line">        <span class="type">Collection</span> <span class="variable">other</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        other.add(<span class="string">&quot;小李广&quot;</span>);</span><br><span class="line">        other.add(<span class="string">&quot;扫地僧&quot;</span>);</span><br><span class="line">        other.add(<span class="string">&quot;尚硅谷&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;other = &quot;</span> + other);</span><br><span class="line"></span><br><span class="line">        coll.removeAll(other);</span><br><span class="line">        System.out.println(<span class="string">&quot;coll.removeAll(other)之后，coll = &quot;</span> + coll);</span><br><span class="line">        System.out.println(<span class="string">&quot;coll.removeAll(other)之后，other = &quot;</span> + other);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        coll.add(<span class="string">&quot;小李广&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;扫地僧&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;石破天&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;佛地魔&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;coll = &quot;</span> + coll);</span><br><span class="line"></span><br><span class="line">        <span class="type">Collection</span> <span class="variable">other</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        other.add(<span class="string">&quot;小李广&quot;</span>);</span><br><span class="line">        other.add(<span class="string">&quot;扫地僧&quot;</span>);</span><br><span class="line">        other.add(<span class="string">&quot;尚硅谷&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;other = &quot;</span> + other);</span><br><span class="line"></span><br><span class="line">        coll.retainAll(other);</span><br><span class="line">        System.out.println(<span class="string">&quot;coll.retainAll(other)之后，coll = &quot;</span> + coll);</span><br><span class="line">        System.out.println(<span class="string">&quot;coll.retainAll(other)之后，other = &quot;</span> + other);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-其它"><a href="#2-4-其它" class="headerlink" title="2.4 其它"></a>2.4 其它</h3><p>（12）Object[] toArray()：返回包含当前集合中所有元素的数组<br>（13）hashCode()：获取集合对象的哈希值<br>（14）iterator()：返回迭代器对象，用于集合遍历</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollectionContains</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">        coll.add(<span class="string">&quot;小李广&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;扫地僧&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;石破天&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;佛地魔&quot;</span>);</span><br><span class="line"><span class="comment">//集合转换为数组：集合的toArray()方法</span></span><br><span class="line">        Object[] objects = coll.toArray();</span><br><span class="line">        System.out.println(<span class="string">&quot;用数组返回coll中所有元素：&quot;</span> + Arrays.toString(objects));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对应的，数组转换为集合：调用Arrays的asList(Object ...objs)</span></span><br><span class="line">        Object[] arr1 = <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">123</span>,<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;CC&quot;</span>&#125;;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">list</span> <span class="operator">=</span> Arrays.asList(arr1);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Iterator-迭代器-接口"><a href="#3-Iterator-迭代器-接口" class="headerlink" title="3. Iterator(迭代器)接口"></a>3. Iterator(迭代器)接口</h2><h3 id="3-1-Iterator接口"><a href="#3-1-Iterator接口" class="headerlink" title="3.1 Iterator接口"></a>3.1 Iterator接口</h3><ul><li>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口<code>java.util.Iterator</code>。<code>Iterator</code>接口也是Java集合中的一员，但它与<code>Collection</code>、<code>Map</code>接口有所不同。<ul><li>Collection接口与Map接口主要用于<code>存储</code>元素</li><li><code>Iterator</code>，被称为迭代器接口，本身并不提供存储对象的能力，主要用于<code>遍历</code>Collection中的元素</li></ul></li></ul><ul><li><p>Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象。</p><ul><li><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</li><li>集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。</li></ul></li><li><p>Iterator接口的常用方法如下：</p><ul><li><code>public E next()</code>:返回迭代的下一个元素。</li><li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li></ul></li><li><p>注意：在调用it.next()方法之前必须要调用it.hasNext()进行检测。若不调用，且下一条记录无效，直接调用it.next()会抛出<code>NoSuchElementException异常</code>。</p></li></ul><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestIterator</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        coll.add(<span class="string">&quot;小李广&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;扫地僧&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;石破天&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">        System.out.println(iterator.next()); <span class="comment">//报NoSuchElementException异常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        coll.add(<span class="string">&quot;小李广&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;扫地僧&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;石破天&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();<span class="comment">//获取迭代器对象</span></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext()) &#123;<span class="comment">//判断是否还有元素可迭代</span></span><br><span class="line">            System.out.println(iterator.next());<span class="comment">//取出下一个元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-迭代器的执行原理"><a href="#3-2-迭代器的执行原理" class="headerlink" title="3.2 迭代器的执行原理"></a>3.2 迭代器的执行原理</h3><p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，接下来通过一个图例来演示Iterator对象迭代元素的过程：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC12%E7%AB%A0_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20220407235130988.png" alt="image-20220407235130988"></p><p>使用Iterator迭代器删除元素：java.util.Iterator迭代器中有一个方法：void remove() ;</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iter</span> <span class="operator">=</span> coll.iterator();<span class="comment">//回到起点</span></span><br><span class="line"><span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iter.next();</span><br><span class="line">    <span class="keyword">if</span>(obj.equals(<span class="string">&quot;Tom&quot;</span>))&#123;</span><br><span class="line">        iter.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>Iterator可以删除集合的元素，但是遍历过程中通过迭代器对象的remove方法，不是集合对象的remove方法。</li><li><p>如果还未调用next()或在上一次调用 next() 方法之后已经调用了 remove() 方法，再调用remove()都会报IllegalStateException。</p></li><li><p>Collection已经有remove(xx)方法了，为什么Iterator迭代器还要提供删除方法呢？因为迭代器的remove()可以按指定的条件进行删除。</p></li></ul><p>例如：要删除以下集合元素中的偶数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestIteratorRemove</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        coll.add(<span class="number">1</span>);</span><br><span class="line">        coll.add(<span class="number">2</span>);</span><br><span class="line">        coll.add(<span class="number">3</span>);</span><br><span class="line">        coll.add(<span class="number">4</span>);</span><br><span class="line">        coll.add(<span class="number">5</span>);</span><br><span class="line">        coll.add(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">element</span> <span class="operator">=</span> (Integer) iterator.next();</span><br><span class="line">            <span class="keyword">if</span>(element % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(coll);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在JDK8.0时，Collection接口有了removeIf 方法，即可以根据条件删除。（第18章中再讲）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollectionRemoveIf</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        coll.add(<span class="string">&quot;小李广&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;扫地僧&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;石破天&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;佛地魔&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;coll = &quot;</span> + coll);</span><br><span class="line"></span><br><span class="line">        coll.removeIf(<span class="keyword">new</span> <span class="title class_">Predicate</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) o;</span><br><span class="line">                <span class="keyword">return</span> str.contains(<span class="string">&quot;地&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除包含\&quot;地\&quot;字的元素之后coll = &quot;</span> + coll);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-foreach循环"><a href="#3-3-foreach循环" class="headerlink" title="3.3 foreach循环"></a>3.3 foreach循环</h3><ul><li>foreach循环（也称增强for循环）是 JDK5.0 中定义的一个高级for循环，专门用来<code>遍历数组和集合</code>的。</li></ul><ul><li>foreach循环的语法格式：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素的数据类型 局部变量 : Collection集合或数组)&#123; </span><br><span class="line">  <span class="comment">//操作局部变量的输出操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里局部变量就是一个临时变量，自己命名就可以</span></span><br></pre></td></tr></table></figure><ul><li>举例：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestForeach</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        coll.add(<span class="string">&quot;小李广&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;扫地僧&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;石破天&quot;</span>);</span><br><span class="line"><span class="comment">//foreach循环其实就是使用Iterator迭代器来完成元素的遍历的。</span></span><br><span class="line">        <span class="keyword">for</span> (Object o : coll) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于集合的遍历，增强for的内部原理其实是个Iterator迭代器。如下图。</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC12%E7%AB%A0_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20220128010114124.png" alt="image-20220128010114124"></p><ul><li>它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。<ul><li>练习：判断输出结果为何？</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] str = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span> (String myStr : str) &#123;</span><br><span class="line">            myStr = <span class="string">&quot;atguigu&quot;</span>;</span><br><span class="line">            System.out.println(myStr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">            System.out.println(str[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-Collection子接口1：List"><a href="#4-Collection子接口1：List" class="headerlink" title="4. Collection子接口1：List"></a>4. Collection子接口1：List</h2><h3 id="4-1-List接口特点"><a href="#4-1-List接口特点" class="headerlink" title="4.1 List接口特点"></a>4.1 List接口特点</h3><ul><li>鉴于Java中数组用来存储数据的局限性，我们通常使用<code>java.util.List</code>替代数组</li><li><p>List集合类中<code>元素有序</code>、且<code>可重复</code>，集合中的每个元素都有其对应的顺序索引。</p><ul><li>举例：List集合存储数据，就像银行门口客服，给每一个来办理业务的客户分配序号：第一个来的是“张三”，客服给他分配的是0；第二个来的是“李四”，客服给他分配的1；以此类推，最后一个序号应该是“总人数-1”。</li></ul></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC12%E7%AB%A0_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1563549818689.png" alt="1563549818689"></p><ul><li>JDK API中List接口的实现类常用的有：<code>ArrayList</code>、<code>LinkedList</code>和<code>Vector</code>。</li></ul><h3 id="4-2-List接口方法"><a href="#4-2-List接口方法" class="headerlink" title="4.2 List接口方法"></a>4.2 List接口方法</h3><p>List除了从Collection集合继承的方法外，List 集合里添加了一些<code>根据索引</code>来操作集合元素的方法。</p><ul><li>插入元素<ul><li><code>void add(int index, Object ele)</code>:在index位置插入ele元素</li><li>boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</li></ul></li><li>获取元素<ul><li><code>Object get(int index)</code>:获取指定index位置的元素</li><li>List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</li></ul></li><li>获取元素索引<ul><li>int indexOf(Object obj):返回obj在集合中首次出现的位置</li><li>int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置</li></ul></li><li><p>删除和替换元素</p><ul><li><p><code>Object remove(int index)</code>:移除指定index位置的元素，并返回此元素</p></li><li><p><code>Object set(int index, Object ele)</code>:设置指定index位置的元素为ele</p></li></ul></li></ul><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestListMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建List集合对象</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 往 尾部添加 指定元素</span></span><br><span class="line">        list.add(<span class="string">&quot;图图&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;小美&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;不高兴&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">// add(int index,String s) 往指定位置添加</span></span><br><span class="line">        list.add(<span class="number">1</span>,<span class="string">&quot;没头脑&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">// String remove(int index) 删除指定位置元素  返回被删除元素</span></span><br><span class="line">        <span class="comment">// 删除索引位置为2的元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;删除索引位置为2的元素&quot;</span>);</span><br><span class="line">        System.out.println(list.remove(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// String set(int index,String s)</span></span><br><span class="line">        <span class="comment">// 在指定位置 进行 元素替代（改）</span></span><br><span class="line">        <span class="comment">// 修改指定位置元素</span></span><br><span class="line">        list.set(<span class="number">0</span>, <span class="string">&quot;三毛&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// String get(int index)  获取指定位置元素</span></span><br><span class="line">        <span class="comment">// 跟size() 方法一起用  来 遍历的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//还可以使用增强for</span></span><br><span class="line">        <span class="keyword">for</span> (String string : list) &#123;</span><br><span class="line">            System.out.println(string);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：在JavaSE中List名称的类型有两个，一个是java.util.List集合接口，一个是java.awt.List图形界面的组件，别导错包了。</p></blockquote><h3 id="4-3-List接口主要实现类：ArrayList"><a href="#4-3-List接口主要实现类：ArrayList" class="headerlink" title="4.3 List接口主要实现类：ArrayList"></a>4.3 List接口主要实现类：ArrayList</h3><ul><li><p>ArrayList 是 List 接口的<code>主要实现类</code></p></li><li><p>本质上，ArrayList是对象引用的一个”变长”数组</p></li><li><p>Arrays.asList(…) 方法返回的 List 集合，既不是 ArrayList 实例，也不是 Vector 实例。 Arrays.asList(…) 返回值是一个固定长度的 List 集合</p><p><img src="/2023/02/18/java2023/%E7%AC%AC12%E7%AB%A0_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20220408210743342.png" alt="image-20220408210743342"></p></li></ul><h3 id="4-4-List的实现类之二：LinkedList"><a href="#4-4-List的实现类之二：LinkedList" class="headerlink" title="4.4 List的实现类之二：LinkedList"></a>4.4 List的实现类之二：LinkedList</h3><ul><li>对于频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高。这是由底层采用链表（双向链表）结构存储数据决定的。</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC12%E7%AB%A0_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20220408225615829.png" alt="image-20220408225615829"></p><ul><li>特有方法：<ul><li>void addFirst(Object obj)</li><li>void addLast(Object obj)    </li><li>Object getFirst()</li><li>Object getLast()</li><li>Object removeFirst()</li><li>Object removeLast()</li></ul></li></ul><h3 id="4-5-List的实现类之三：Vector"><a href="#4-5-List的实现类之三：Vector" class="headerlink" title="4.5 List的实现类之三：Vector"></a>4.5 List的实现类之三：Vector</h3><ul><li>Vector 是一个<code>古老</code>的集合，JDK1.0就有了。大多数操作与ArrayList相同，区别之处在于Vector是<code>线程安全</code>的。</li><li>在各种List中，最好把<code>ArrayList作为默认选择</code>。当插入、删除频繁时，使用LinkedList；Vector总是比ArrayList慢，所以尽量避免使用。</li><li>特有方法：<ul><li>void addElement(Object obj)</li><li>void insertElementAt(Object obj,int index)</li><li>void setElementAt(Object obj,int index)</li><li>void removeElement(Object obj)</li><li>void removeAllElements()</li></ul></li></ul><h3 id="4-6-练习"><a href="#4-6-练习" class="headerlink" title="4.6 练习"></a>4.6 练习</h3><p><strong>面试题：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testListRemove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    list.add(<span class="number">3</span>);</span><br><span class="line">    updateList(list);</span><br><span class="line">    System.out.println(list);<span class="comment">//[1,2]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">updateList</span><span class="params">(List list)</span> &#123;</span><br><span class="line">    list.remove(<span class="number">2</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>练习1：</strong></p><ul><li>定义学生类，属性为姓名、年龄，提供必要的getter、setter方法，构造器，toString()，equals()方法。</li><li>使用ArrayList集合，保存录入的多个学生对象。</li><li>循环录入的方式，1：继续录入，0：结束录入。</li><li>录入结束后，用foreach遍历集合。</li></ul><ul><li><p>代码实现，效果如图所示：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC12%E7%AB%A0_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1559890098509.png" alt="1559890098509"></p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.test01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">stuList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;选择（录入 1 ；结束 0）&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> scanner.nextInt();<span class="comment">//根据x的值，判断是否需要继续循环</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;姓名&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">                System.out.println(<span class="string">&quot;年龄&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(age, name);</span><br><span class="line">                stuList.add(stu);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;输入有误，请重新输入&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Object stu : stuList) &#123;</span><br><span class="line">            System.out.println(stu);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Student [age=&quot;</span> + age + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习2：</strong></p><p>​    1、请定义方法public static int listTest(Collection list,String s)统计集合中指定元素出现的次数</p><p>​    2、创建集合，集合存放随机生成的30个小写字母</p><p>​    3、用listTest统计，a、b、c、x元素的出现次数</p><p>​    4、效果如下</p><p><img src="/2023/02/18/java2023/%E7%AC%AC12%E7%AB%A0_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1559896150606.png" alt="1559896150606"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.test02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Collection</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">list.add((<span class="type">char</span>)(rand.nextInt(<span class="number">26</span>)+<span class="number">97</span>)+<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br><span class="line">System.out.println(<span class="string">&quot;a:&quot;</span>+listTest(list, <span class="string">&quot;a&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;b:&quot;</span>+listTest(list, <span class="string">&quot;b&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;c:&quot;</span>+listTest(list, <span class="string">&quot;c&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;x:&quot;</span>+listTest(list, <span class="string">&quot;x&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">listTest</span><span class="params">(Collection list, String string)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Object object : list) &#123;</span><br><span class="line"><span class="keyword">if</span>(string.equals(object))&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>练习3：KTV点歌系统</strong></p><p><strong>描述</strong></p><p>分别使用ArrayList和LinkedList集合，编写一个<strong><code>KTV点歌系统</code></strong>的程序。在程序中：</p><ul><li>指令1代表添加歌曲</li><li>指令2代表将所选歌曲置顶</li><li>指令3代表将所选歌曲提前一位</li><li>指令4代表退出该系统</li></ul><p>要求根据用户输入的指令和歌曲名展现歌曲列表。例如输入指令1，输入歌曲名”爱你一万年”，则输出“当前歌曲列表：[爱你一万年]”。</p><p><strong>提示</strong></p><ul><li><p>为了指引用户操作，首先要将各个指令所表示的含义打印到控制台</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;-------------欢迎来到点歌系统------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;1.添加歌曲至列表&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;2.将歌曲置顶&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;3.将歌曲前移一位&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;4.退出&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>程序中需要创建一个集合作为歌曲列表，并向其添加一部分歌曲</p></li><li><p>通过ArrayList或LinkedList集合定义的方法操作歌曲列表</p></li></ul><p><strong>代码</strong></p><ul><li><p>使用ArrayList集合模拟点歌系统的实现代码，如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 20:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KTVByArrayList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ArrayList</span> <span class="variable">musicList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();<span class="comment">// 创建歌曲列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        addMusicList();<span class="comment">// 添加一部分歌曲至歌曲列表</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前歌曲列表：&quot;</span> + musicList);</span><br><span class="line">            System.out.println(<span class="string">&quot;-------------欢迎来到点歌系统------------&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;1.添加歌曲至列表&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;2.将歌曲置顶&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;3.将歌曲前移一位&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;4.退出&quot;</span>);</span><br><span class="line">            System.out.print(<span class="string">&quot;请输入操作序号：&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> sc.nextInt();<span class="comment">// //接收键盘输入的功能选项序号</span></span><br><span class="line">            <span class="comment">// 执行序号对应的功能</span></span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:<span class="comment">// 添加歌曲至列表</span></span><br><span class="line">                    addMusic();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:<span class="comment">// 将歌曲置顶</span></span><br><span class="line">                    setTop();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:<span class="comment">// 将歌曲前移一位</span></span><br><span class="line">                    setBefore();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:<span class="comment">// 退出</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;----------------退出---------------&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;您已退出系统&quot;</span>);</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;----------------------------------&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;功能选择有误，请输入正确的功能序号!&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始时添加歌曲名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addMusicList</span><span class="params">()</span> &#123;</span><br><span class="line">        musicList.add(<span class="string">&quot;本草纲目&quot;</span>);</span><br><span class="line">        musicList.add(<span class="string">&quot;你是我的眼&quot;</span>);</span><br><span class="line">        musicList.add(<span class="string">&quot;老男孩&quot;</span>);</span><br><span class="line">        musicList.add(<span class="string">&quot;白月光与朱砂痣&quot;</span>);</span><br><span class="line">        musicList.add(<span class="string">&quot;不谓侠&quot;</span>);</span><br><span class="line">        musicList.add(<span class="string">&quot;爱你&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行添加歌曲</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addMusic</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入要添加的歌曲名称：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">musicName</span> <span class="operator">=</span> sc.next();<span class="comment">// 获取键盘输入内容</span></span><br><span class="line">        musicList.add(musicName);<span class="comment">// 添加歌曲到列表的最后</span></span><br><span class="line">        System.out.println(<span class="string">&quot;已添加歌曲：&quot;</span> + musicName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行将歌曲置顶</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setTop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入要置顶的歌曲名称：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">musicName</span> <span class="operator">=</span> sc.next();<span class="comment">// 获取键盘输入内容</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">musicIndex</span> <span class="operator">=</span> musicList.indexOf(musicName);<span class="comment">// 查找指定歌曲位置</span></span><br><span class="line">        <span class="keyword">if</span> (musicIndex &lt; <span class="number">0</span>) &#123;<span class="comment">// 判断输入歌曲是否存在</span></span><br><span class="line">            System.out.println(<span class="string">&quot;当前列表中没有输入的歌曲！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(musicIndex == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前歌曲默认已置顶！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            musicList.remove(musicName);<span class="comment">// 移除指定的歌曲</span></span><br><span class="line">            musicList.add(<span class="number">0</span>, musicName);<span class="comment">// 将指定的歌曲放到第一位</span></span><br><span class="line">            System.out.println(<span class="string">&quot;已将歌曲《&quot;</span> + musicName + <span class="string">&quot;》置顶&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行将歌曲置前一位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setBefore</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入要置前的歌曲名称：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">musicName</span> <span class="operator">=</span> sc.next();<span class="comment">// 获取键盘输入内容</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">musicIndex</span> <span class="operator">=</span> musicList.indexOf(musicName);<span class="comment">// 查找指定歌曲位置</span></span><br><span class="line">        <span class="keyword">if</span> (musicIndex &lt; <span class="number">0</span>) &#123;<span class="comment">// 判断输入歌曲是否存在</span></span><br><span class="line">            System.out.println(<span class="string">&quot;当前列表中没有输入的歌曲！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (musicIndex == <span class="number">0</span>) &#123;<span class="comment">// 判断歌曲是否已在第一位</span></span><br><span class="line">            System.out.println(<span class="string">&quot;当前歌曲已在最顶部！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            musicList.remove(musicName);<span class="comment">// 移除指定的歌曲</span></span><br><span class="line">            musicList.add(musicIndex - <span class="number">1</span>, musicName);<span class="comment">// 将指定的歌曲放到前一位</span></span><br><span class="line">            System.out.println(<span class="string">&quot;已将歌曲《&quot;</span> + musicName + <span class="string">&quot;》置前一位&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-Collection子接口2：Set"><a href="#5-Collection子接口2：Set" class="headerlink" title="5. Collection子接口2：Set"></a>5. Collection子接口2：Set</h2><h3 id="5-1-Set接口概述"><a href="#5-1-Set接口概述" class="headerlink" title="5.1 Set接口概述"></a>5.1 Set接口概述</h3><ul><li>Set接口是Collection的子接口，Set接口相较于Collection接口没有提供额外的方法</li><li>Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个 Set 集合中，则添加操作失败。</li><li>Set集合支持的遍历方式和Collection集合一样：foreach和Iterator。</li><li>Set的常用实现类有：HashSet、TreeSet、LinkedHashSet。</li></ul><h3 id="5-2-Set主要实现类：HashSet"><a href="#5-2-Set主要实现类：HashSet" class="headerlink" title="5.2 Set主要实现类：HashSet"></a>5.2 Set主要实现类：HashSet</h3><h4 id="5-2-1-HashSet概述"><a href="#5-2-1-HashSet概述" class="headerlink" title="5.2.1 HashSet概述"></a>5.2.1 HashSet概述</h4><ul><li><p>HashSet 是 Set 接口的主要实现类，大多数时候使用 Set 集合时都使用这个实现类。</p></li><li><p>HashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存储、查找、删除性能。</p></li><li><p>HashSet 具有以下<code>特点</code>：</p><ul><li>不能保证元素的排列顺序</li><li>HashSet 不是线程安全的</li><li>集合元素可以是 null</li></ul></li><li><p>HashSet 集合<code>判断两个元素相等的标准</code>：两个对象通过 <code>hashCode()</code> 方法得到的哈希值相等，并且两个对象的 <code>equals()</code>方法返回值为true。</p></li><li><p>对于存放在Set容器中的对象，<strong>对应的类一定要重写hashCode()和equals(Object obj)方法</strong>，以实现对象相等规则。即：“相等的对象必须具有相等的散列码”。</p></li><li><p>HashSet集合中元素的无序性，不等同于随机性。这里的无序性与元素的添加位置有关。具体来说：我们在添加每一个元素到数组中时，具体的存储位置是由元素的hashCode()调用后返回的hash值决定的。导致在数组中每个元素不是依次紧密存放的，表现出一定的无序性。</p></li></ul><h4 id="5-2-2-HashSet中添加元素的过程："><a href="#5-2-2-HashSet中添加元素的过程：" class="headerlink" title="5.2.2 HashSet中添加元素的过程："></a>5.2.2 HashSet中添加元素的过程：</h4><ul><li><p>第1步：当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法得到该对象的 hashCode值，然后根据 hashCode值，通过某个散列函数决定该对象在 HashSet 底层数组中的存储位置。</p></li><li><p>第2步：如果要在数组中存储的位置上没有元素，则直接添加成功。</p></li><li><p>第3步：如果要在数组中存储的位置上有元素，则继续比较：</p><ul><li>如果两个元素的hashCode值不相等，则添加成功；</li><li>如果两个元素的hashCode()值相等，则会继续调用equals()方法：<ul><li>如果equals()方法结果为false，则添加成功。</li><li>如果equals()方法结果为true，则添加失败。</li></ul></li></ul><blockquote><p>第2步添加成功，元素会保存在底层数组中。</p><p>第3步两种添加成功的操作，由于该底层数组的位置已经有元素了，则会通过<code>链表</code>的方式继续链接，存储。</p></blockquote></li></ul><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDate</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> year;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> month;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> day;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyDate</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.year = year;</span><br><span class="line">        <span class="built_in">this</span>.month = month;</span><br><span class="line">        <span class="built_in">this</span>.day = day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">MyDate</span> <span class="variable">myDate</span> <span class="operator">=</span> (MyDate) o;</span><br><span class="line">        <span class="type">return</span> <span class="variable">year</span> <span class="operator">=</span>= myDate.year &amp;&amp;</span><br><span class="line">                month == myDate.month &amp;&amp;</span><br><span class="line">                day == myDate.day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(year, month, day);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyDate&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;year=&quot;</span> + year +</span><br><span class="line">                <span class="string">&quot;, month=&quot;</span> + month +</span><br><span class="line">                <span class="string">&quot;, day=&quot;</span> + day +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHashSet</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        set.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;赵六&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;set = &quot;</span> + set);<span class="comment">//不允许重复，无序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">MyDate</span>(<span class="number">2021</span>,<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">MyDate</span>(<span class="number">2021</span>,<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">MyDate</span>(<span class="number">2022</span>,<span class="number">2</span>,<span class="number">4</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">MyDate</span>(<span class="number">2022</span>,<span class="number">2</span>,<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;set = &quot;</span> + set);<span class="comment">//不允许重复，无序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-3-重写-hashCode-方法的基本原则"><a href="#5-2-3-重写-hashCode-方法的基本原则" class="headerlink" title="5.2.3 重写 hashCode() 方法的基本原则"></a>5.2.3 重写 hashCode() 方法的基本原则</h4><ul><li>在程序运行时，同一个对象多次调用 hashCode() 方法应该返回相同的值。</li><li>当两个对象的 equals() 方法比较返回 true 时，这两个对象的 hashCode() 方法的返回值也应相等。</li><li>对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。</li></ul><blockquote><p>注意：如果两个元素的 equals() 方法返回 true，但它们的 hashCode() 返回值不相等，hashSet 将会把它们存储在不同的位置，但依然可以添加成功。</p></blockquote><h4 id="5-2-4-重写equals-方法的基本原则"><a href="#5-2-4-重写equals-方法的基本原则" class="headerlink" title="5.2.4 重写equals()方法的基本原则"></a>5.2.4 重写equals()方法的基本原则</h4><ul><li><p>重写equals方法的时候一般都需要同时复写hashCode方法。通常参与计算hashCode的对象的属性也应该参与到equals()中进行计算。</p></li><li><p>推荐：开发中直接调用Eclipse/IDEA里的快捷键自动重写equals()和hashCode()方法即可。</p><ul><li>为什么用Eclipse/IDEA复写hashCode方法，有31这个数字？</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首先，选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的“冲突”就越少，查找起来效率也会提高。（减少冲突）</span><br><span class="line"></span><br><span class="line">其次，31只占用5bits,相乘造成数据溢出的概率较小。</span><br><span class="line"></span><br><span class="line">再次，31可以 由i*31== (i&lt;&lt;5)-1来表示,现在很多虚拟机里面都有做相关优化。（提高算法效率）</span><br><span class="line"></span><br><span class="line">最后，31是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结果只能被素数本身和被乘数还有1来整除！(减少冲突)</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-2-5-练习"><a href="#5-2-5-练习" class="headerlink" title="5.2.5 练习"></a>5.2.5 练习</h4><p><strong>练习1：</strong>在List内去除重复数字值，要求尽量简单</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List <span class="title function_">duplicateList</span><span class="params">(List list)</span> &#123;</span><br><span class="line">      <span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">      set.addAll(list);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(set);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">      list.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>));</span><br><span class="line">      list.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>));</span><br><span class="line">      list.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>));</span><br><span class="line">      list.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">4</span>));</span><br><span class="line">      list.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">4</span>));</span><br><span class="line">      <span class="type">List</span> <span class="variable">list2</span> <span class="operator">=</span> duplicateList(list);</span><br><span class="line">      <span class="keyword">for</span> (Object integer : list2) &#123;</span><br><span class="line">          System.out.println(integer);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>练习2：</strong>获取随机数</p><p>编写一个程序，获取10个1至20的随机数，要求随机数不能重复。并把最终的随机数输出到控制台。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022年5月7日上午12:43:01</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomValueTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">HashSet</span> <span class="variable">hs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>(); <span class="comment">// 创建集合对象</span></span><br><span class="line"><span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="keyword">while</span> (hs.size() &lt; <span class="number">10</span>) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> r.nextInt(<span class="number">20</span>) + <span class="number">1</span>; <span class="comment">// 生成1到20的随机数</span></span><br><span class="line">hs.add(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Integer integer : hs) &#123; <span class="comment">// 遍历集合</span></span><br><span class="line">System.out.println(integer); <span class="comment">// 打印每一个元素</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>练习3：</strong>去重</p><p>使用Scanner从键盘读取一行输入，去掉其中重复字符，打印出不同的那些字符。比如：aaaabbbcccddd</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022年5月7日上午12:44:01</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistinctTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in); <span class="comment">// 创建键盘录入对象</span></span><br><span class="line">System.out.println(<span class="string">&quot;请输入一行字符串:&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> sc.nextLine(); <span class="comment">// 将键盘录入的字符串存储在line中</span></span><br><span class="line"><span class="type">char</span>[] arr = line.toCharArray(); <span class="comment">// 将字符串转换成字符数组</span></span><br><span class="line">        </span><br><span class="line"><span class="type">HashSet</span> <span class="variable">hs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>(); <span class="comment">// 创建HashSet集合对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Object c : arr) &#123; <span class="comment">// 遍历字符数组</span></span><br><span class="line">hs.add(c); <span class="comment">// 将字符数组中的字符添加到集合中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Object ch : hs) &#123; <span class="comment">// 遍历集合</span></span><br><span class="line">System.out.print(ch);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>练习4：</strong>面试题</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;AA&quot;</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1002</span>,<span class="string">&quot;BB&quot;</span>);</span><br><span class="line"></span><br><span class="line">set.add(p1);</span><br><span class="line">set.add(p2);</span><br><span class="line">p1.name = <span class="string">&quot;CC&quot;</span>;</span><br><span class="line">set.remove(p1);</span><br><span class="line">System.out.println(set);</span><br><span class="line"></span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;CC&quot;</span>));</span><br><span class="line">System.out.println(set);</span><br><span class="line"></span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;AA&quot;</span>));</span><br><span class="line">System.out.println(set);</span><br><span class="line"></span><br><span class="line"><span class="comment">//其中Person类中重写了hashCode()和equal()方法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-3-Set实现类之二：LinkedHashSet"><a href="#5-3-Set实现类之二：LinkedHashSet" class="headerlink" title="5.3 Set实现类之二：LinkedHashSet"></a>5.3 Set实现类之二：LinkedHashSet</h3><ul><li><p>LinkedHashSet 是 HashSet 的子类，不允许集合元素重复。</p></li><li><p>LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，但它同时使用<code>双向链表</code>维护元素的次序，这使得元素看起来是以<code>添加顺序</code>保存的。</p></li><li><p>LinkedHashSet<code>插入性能略低</code>于 HashSet，但在<code>迭代访问</code> Set 里的全部元素时有很好的性能。</p></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC12%E7%AB%A0_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20220408235936404.png" alt="image-20220408235936404" style="zoom:67%;"></p><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLinkedHashSet</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LinkedHashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>();</span><br><span class="line">        set.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;赵六&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;set = &quot;</span> + set);<span class="comment">//不允许重复，体现添加顺序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-Set实现类之三：TreeSet"><a href="#5-4-Set实现类之三：TreeSet" class="headerlink" title="5.4 Set实现类之三：TreeSet"></a>5.4 Set实现类之三：TreeSet</h3><h4 id="5-4-1-TreeSet概述"><a href="#5-4-1-TreeSet概述" class="headerlink" title="5.4.1 TreeSet概述"></a>5.4.1 TreeSet概述</h4><ul><li>TreeSet 是 SortedSet 接口的实现类，TreeSet 可以按照添加的元素的指定的属性的大小顺序进行遍历。</li><li>TreeSet底层使用<code>红黑树</code>结构存储数据</li><li>新增的方法如下： (了解)<ul><li>Comparator comparator()</li><li>Object first()</li><li>Object last()</li><li>Object lower(Object e)</li><li>Object higher(Object e)</li><li>SortedSet subSet(fromElement, toElement)</li><li>SortedSet headSet(toElement)</li><li>SortedSet tailSet(fromElement)</li></ul></li><li>TreeSet特点：不允许重复、实现排序（自然排序或定制排序）</li><li>TreeSet 两种排序方法：<code>自然排序</code>和<code>定制排序</code>。默认情况下，TreeSet 采用自然排序。<ul><li><code>自然排序</code>：TreeSet 会调用集合元素的 compareTo(Object obj) 方法来比较元素之间的大小关系，然后将集合元素按升序(默认情况)排列。<ul><li>如果试图把一个对象添加到 TreeSet 时，则该对象的类必须实现 Comparable 接口。</li><li>实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。</li></ul></li><li><code>定制排序</code>：如果元素所属的类没有实现Comparable接口，或不希望按照升序(默认情况)的方式排列元素或希望按照其它属性大小进行排序，则考虑使用定制排序。定制排序，通过Comparator接口来实现。需要重写compare(T o1,T o2)方法。<ul><li>利用int compare(T o1,T o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。</li><li>要实现定制排序，需要将实现Comparator接口的实例作为形参传递给TreeSet的构造器。</li></ul></li></ul></li><li>因为只有相同类的两个实例才会比较大小，所以向 TreeSet 中添加的应该是<code>同一个类的对象</code>。</li><li>对于 TreeSet 集合而言，它判断<code>两个对象是否相等的唯一标准</code>是：两个对象通过 <code>compareTo(Object obj) 或compare(Object o1,Object o2)</code>方法比较返回值。返回值为0，则认为两个对象相等。</li></ul><h4 id="5-4-2-举例"><a href="#5-4-2-举例" class="headerlink" title="5.4.2 举例"></a>5.4.2 举例</h4><p>举例1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.set;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 14:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetTest</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 自然排序：针对String类的对象</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">TreeSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line"></span><br><span class="line">        set.add(<span class="string">&quot;MM&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;DD&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;ZZ&quot;</span>);</span><br><span class="line">        <span class="comment">//set.add(123);  //报ClassCastException的异常</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 自然排序：针对User类的对象</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">TreeSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line"></span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Rose&quot;</span>,<span class="number">23</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">2</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Eric&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tommy&quot;</span>,<span class="number">44</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jim&quot;</span>,<span class="number">23</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Maria&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        <span class="comment">//set.add(&quot;Tom&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(set.contains(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">23</span>))); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，User类定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 14:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    举例：按照age从小到大的顺序排列，如果age相同，则按照name从大到小的顺序排列</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span> == o)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)o;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="built_in">this</span>.age - user.age;</span><br><span class="line">            <span class="keyword">if</span>(value != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> -<span class="built_in">this</span>.name.compareTo(user.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的类型不匹配&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>举例2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定制排序</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//按照User的姓名的从小到大的顺序排列</span></span><br><span class="line">    <span class="type">Comparator</span> <span class="variable">comparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> User &amp;&amp; o2 <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">                <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> (User)o1;</span><br><span class="line">                <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> (User)o2;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> u1.name.compareTo(u2.name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的类型不匹配&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">TreeSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>(comparator);</span><br><span class="line"></span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Rose&quot;</span>,<span class="number">23</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">2</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Eric&quot;</span>,<span class="number">18</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tommy&quot;</span>,<span class="number">44</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jim&quot;</span>,<span class="number">23</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Maria&quot;</span>,<span class="number">18</span>));</span><br><span class="line">    <span class="comment">//set.add(new User(&quot;Maria&quot;,28));</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-4-3-练习"><a href="#5-4-3-练习" class="headerlink" title="5.4.3 练习"></a>5.4.3 练习</h4><p><strong>练习1：</strong>在一个List集合中存储了多个无大小顺序并且有重复的字符串，定义一个方法，让其有序(从小到大排序)，并且不能去除重复元素。</p><p>提示：考查ArrayList、TreeSet</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022年4月7日上午12:50:46</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line">sort(list);</span><br><span class="line">System.out.println(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对集合中的元素排序,并保留重复</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List list)</span> &#123;</span><br><span class="line"><span class="type">TreeSet</span> <span class="variable">ts</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123; </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123; <span class="comment">// 重写compare方法</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> (String)o1;</span><br><span class="line">                <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> (String)o2;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> s1.compareTo(s2); <span class="comment">// 比较内容</span></span><br><span class="line"><span class="type">return</span> <span class="variable">num</span> <span class="operator">=</span>= <span class="number">0</span> ? <span class="number">1</span> : num; <span class="comment">// 如果内容一样返回一个不为0的数字即可</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ts.addAll(list); <span class="comment">// 将list集合中的所有元素添加到ts中</span></span><br><span class="line">list.clear(); <span class="comment">// 清空list</span></span><br><span class="line">list.addAll(ts); <span class="comment">// 将ts中排序并保留重复的结果在添加到list中</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>练习2：</strong>TreeSet的自然排序和定制排序</p><ol><li><p>定义一个Employee类。<br>该类包含：private成员变量name,age,birthday，其中 birthday 为 MyDate 类的对象；<br>并为每一个属性定义 getter, setter 方法；<br>并重写 toString 方法输出 name, age, birthday</p></li><li><p>MyDate类包含:<br>private成员变量year,month,day；并为每一个属性定义 getter, setter 方法；</p></li><li><p>创建该类的 5 个对象，并把这些对象放入 TreeSet 集合中（下一章：TreeSet 需使用泛型来定义）</p></li><li><p>分别按以下两种方式对集合中的元素进行排序，并遍历输出：</p><p>1). 使Employee 实现 Comparable 接口，并按 name 排序<br>2). 创建 TreeSet 时传入 Comparator对象，按生日日期的先后排序。</p></li></ol><p>代码实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDate</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> year;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> month;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> day;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyDate</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyDate</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.year = year;</span><br><span class="line">        <span class="built_in">this</span>.month = month;</span><br><span class="line">        <span class="built_in">this</span>.day = day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getYear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> year;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setYear</span><span class="params">(<span class="type">int</span> year)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.year = year;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMonth</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> month;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMonth</span><span class="params">(<span class="type">int</span> month)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.month = month;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDay</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDay</span><span class="params">(<span class="type">int</span> day)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.day = day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//        return &quot;MyDate&#123;&quot; +</span></span><br><span class="line"><span class="comment">//                &quot;year=&quot; + year +</span></span><br><span class="line"><span class="comment">//                &quot;, month=&quot; + month +</span></span><br><span class="line"><span class="comment">//                &quot;, day=&quot; + day +</span></span><br><span class="line"><span class="comment">//                &#x27;&#125;&#x27;;</span></span><br><span class="line">        <span class="keyword">return</span> year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + day + <span class="string">&quot;日&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span> == o)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> MyDate)&#123;</span><br><span class="line">            <span class="type">MyDate</span> <span class="variable">myDate</span> <span class="operator">=</span> (MyDate) o;</span><br><span class="line">            <span class="type">int</span> <span class="variable">yearDistance</span> <span class="operator">=</span> <span class="built_in">this</span>.getYear() - myDate.getYear();</span><br><span class="line">            <span class="keyword">if</span>(yearDistance != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> yearDistance;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">monthDistance</span> <span class="operator">=</span> <span class="built_in">this</span>.getMonth() - myDate.getMonth();</span><br><span class="line">            <span class="keyword">if</span>(monthDistance != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> monthDistance;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.getDay() - myDate.getDay();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的类型不匹配&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> MyDate birthday;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name, <span class="type">int</span> age, MyDate birthday)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MyDate <span class="title function_">getBirthday</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBirthday</span><span class="params">(MyDate birthday)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Employee&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&#x27;&quot;</span> + age + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, birthday=&quot;</span> + birthday +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(o == <span class="built_in">this</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Employee)&#123;</span><br><span class="line">            <span class="type">Employee</span> <span class="variable">emp</span> <span class="operator">=</span> (Employee) o;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.name.compareTo(emp.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;传入的类型不匹配&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeTest</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    自然排序：</span></span><br><span class="line"><span class="comment">    创建该类的 5 个对象，并把这些对象放入 TreeSet 集合中</span></span><br><span class="line"><span class="comment">    * 需求1：使Employee 实现 Comparable 接口，并按 name 排序</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">TreeSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">23</span>,<span class="keyword">new</span> <span class="title class_">MyDate</span>(<span class="number">1999</span>,<span class="number">7</span>,<span class="number">9</span>));</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Rose&quot;</span>,<span class="number">43</span>,<span class="keyword">new</span> <span class="title class_">MyDate</span>(<span class="number">1999</span>,<span class="number">7</span>,<span class="number">19</span>));</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Jack&quot;</span>,<span class="number">54</span>,<span class="keyword">new</span> <span class="title class_">MyDate</span>(<span class="number">1998</span>,<span class="number">12</span>,<span class="number">21</span>));</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">12</span>,<span class="keyword">new</span> <span class="title class_">MyDate</span>(<span class="number">2002</span>,<span class="number">4</span>,<span class="number">21</span>));</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Tony&quot;</span>,<span class="number">22</span>,<span class="keyword">new</span> <span class="title class_">MyDate</span>(<span class="number">2001</span>,<span class="number">9</span>,<span class="number">12</span>));</span><br><span class="line"></span><br><span class="line">        set.add(e1);</span><br><span class="line">        set.add(e2);</span><br><span class="line">        set.add(e3);</span><br><span class="line">        set.add(e4);</span><br><span class="line">        set.add(e5);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 定制排序：</span></span><br><span class="line"><span class="comment">    * 创建 TreeSet 时传入 Comparator对象，按生日日期的先后排序。</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Comparator</span> <span class="variable">comparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> Employee &amp;&amp; o2 <span class="keyword">instanceof</span> Employee)&#123;</span><br><span class="line">                    <span class="type">Employee</span> <span class="variable">e1</span> <span class="operator">=</span> (Employee) o1;</span><br><span class="line">                    <span class="type">Employee</span> <span class="variable">e2</span> <span class="operator">=</span> (Employee) o2;</span><br><span class="line">                    <span class="comment">//对比两个employee的生日的大小</span></span><br><span class="line">                    <span class="type">MyDate</span> <span class="variable">birth1</span> <span class="operator">=</span> e1.getBirthday();</span><br><span class="line">                    <span class="type">MyDate</span> <span class="variable">birth2</span> <span class="operator">=</span> e2.getBirthday();</span><br><span class="line">                    <span class="comment">//方式1：</span></span><br><span class="line"><span class="comment">//                    int yearDistance = birth1.getYear() - birth2.getYear();</span></span><br><span class="line"><span class="comment">//                    if(yearDistance != 0)&#123;</span></span><br><span class="line"><span class="comment">//                        return yearDistance;</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"><span class="comment">//                    int monthDistance = birth1.getMonth() - birth2.getMonth();</span></span><br><span class="line"><span class="comment">//                    if(monthDistance != 0)&#123;</span></span><br><span class="line"><span class="comment">//                        return monthDistance;</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                    return birth1.getDay() - birth2.getDay();</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//方式2：</span></span><br><span class="line">                    <span class="keyword">return</span> birth1.compareTo(birth2);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的类型不匹配&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">TreeSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>(comparator);</span><br><span class="line"></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">23</span>,<span class="keyword">new</span> <span class="title class_">MyDate</span>(<span class="number">1999</span>,<span class="number">7</span>,<span class="number">9</span>));</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Rose&quot;</span>,<span class="number">43</span>,<span class="keyword">new</span> <span class="title class_">MyDate</span>(<span class="number">1999</span>,<span class="number">7</span>,<span class="number">19</span>));</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Jack&quot;</span>,<span class="number">54</span>,<span class="keyword">new</span> <span class="title class_">MyDate</span>(<span class="number">1998</span>,<span class="number">12</span>,<span class="number">21</span>));</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">12</span>,<span class="keyword">new</span> <span class="title class_">MyDate</span>(<span class="number">2002</span>,<span class="number">4</span>,<span class="number">21</span>));</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Tony&quot;</span>,<span class="number">22</span>,<span class="keyword">new</span> <span class="title class_">MyDate</span>(<span class="number">2001</span>,<span class="number">9</span>,<span class="number">12</span>));</span><br><span class="line"></span><br><span class="line">        set.add(e1);</span><br><span class="line">        set.add(e2);</span><br><span class="line">        set.add(e3);</span><br><span class="line">        set.add(e4);</span><br><span class="line">        set.add(e5);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-Map接口"><a href="#6-Map接口" class="headerlink" title="6. Map接口"></a>6. Map接口</h2><p>现实生活与开发中，我们常会看到这样的一类集合：用户ID与账户信息、学生姓名与考试成绩、IP地址与主机名等，这种一一对应的关系，就称作映射。Java提供了专门的集合框架用来存储这种映射关系的对象，即<code>java.util.Map</code>接口。</p><h3 id="6-1-Map接口概述"><a href="#6-1-Map接口概述" class="headerlink" title="6.1 Map接口概述"></a>6.1 Map接口概述</h3><ul><li><p>Map与Collection并列存在。用于保存具有<code>映射关系</code>的数据：key-value</p><ul><li><code>Collection</code>集合称为单列集合，元素是孤立存在的（理解为单身）。</li><li><code>Map</code>集合称为双列集合，元素是成对存在的(理解为夫妻)。</li></ul></li><li><p>Map 中的 key 和  value 都可以是任何引用类型的数据。但常用String类作为Map的“键”。</p></li><li><p>Map接口的常用实现类：<code>HashMap</code>、<code>LinkedHashMap</code>、<code>TreeMap</code>和<code>`Properties</code>。其中，HashMap是 Map 接口使用<code>频率最高</code>的实现类。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC12%E7%AB%A0_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20220409001015034.png" alt="image-20220409001015034" style="zoom:67%;"></p></li></ul><h3 id="6-2-Map中key-value特点"><a href="#6-2-Map中key-value特点" class="headerlink" title="6.2 Map中key-value特点"></a>6.2 Map中key-value特点</h3><p>这里主要以HashMap为例说明。HashMap中存储的key、value的特点如下：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC12%E7%AB%A0_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20220409001213720.png" alt="image-20220409001213720" style="zoom:67%;"></p><ul><li><p>Map 中的 <code>key用Set来存放</code>，<code>不允许重复</code>，即同一个 Map 对象所对应的类，须重写hashCode()和equals()方法</p><p><img src="/2023/02/18/java2023/%E7%AC%AC12%E7%AB%A0_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20220514190412763.png" alt="image-20220514190412763" style="zoom:67%;"></p></li><li><p>key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到唯一的、确定的 value，不同key对应的<code>value可以重复</code>。value所在的类要重写equals()方法。</p></li><li><p>key和value构成一个entry。所有的entry彼此之间是<code>无序的</code>、<code>不可重复的</code>。</p></li></ul><h3 id="6-2-Map接口的常用方法"><a href="#6-2-Map接口的常用方法" class="headerlink" title="6.2 Map接口的常用方法"></a>6.2 Map接口的常用方法</h3><ul><li><strong>添加、修改操作：</strong><ul><li>Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中</li><li>void putAll(Map m):将m中的所有key-value对存放到当前map中</li></ul></li><li><strong>删除操作：</strong><ul><li>Object remove(Object key)：移除指定key的key-value对，并返回value</li><li>void clear()：清空当前map中的所有数据</li></ul></li><li><strong>元素查询的操作：</strong><ul><li>Object get(Object key)：获取指定key对应的value</li><li>boolean containsKey(Object key)：是否包含指定的key</li><li>boolean containsValue(Object value)：是否包含指定的value</li><li>int size()：返回map中key-value对的个数</li><li>boolean isEmpty()：判断当前map是否为空</li><li>boolean equals(Object obj)：判断当前map和参数对象obj是否相等</li></ul></li><li><strong>元视图操作的方法：</strong><ul><li>Set keySet()：返回所有key构成的Set集合</li><li>Collection values()：返回所有value构成的Collection集合</li><li>Set entrySet()：返回所有key-value对构成的Set集合</li></ul></li></ul><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMapMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建 map对象</span></span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素到集合</span></span><br><span class="line">        map.put(<span class="string">&quot;黄晓明&quot;</span>, <span class="string">&quot;杨颖&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;李晨&quot;</span>, <span class="string">&quot;李小璐&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;李晨&quot;</span>, <span class="string">&quot;范冰冰&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;邓超&quot;</span>, <span class="string">&quot;孙俪&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除指定的key-value</span></span><br><span class="line">        System.out.println(map.remove(<span class="string">&quot;黄晓明&quot;</span>));</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询指定key对应的value</span></span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;邓超&quot;</span>));</span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;黄晓明&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    map.put(<span class="string">&quot;许仙&quot;</span>, <span class="string">&quot;白娘子&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;董永&quot;</span>, <span class="string">&quot;七仙女&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;牛郎&quot;</span>, <span class="string">&quot;织女&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;许仙&quot;</span>, <span class="string">&quot;小青&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;所有的key:&quot;</span>);</span><br><span class="line">    <span class="type">Set</span> <span class="variable">keySet</span> <span class="operator">=</span> map.keySet();</span><br><span class="line">    <span class="keyword">for</span> (Object key : keySet) &#123;</span><br><span class="line">        System.out.println(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;所有的value:&quot;</span>);</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> map.values();</span><br><span class="line">    <span class="keyword">for</span> (Object value : values) &#123;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;所有的映射关系:&quot;</span>);</span><br><span class="line">    <span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line">    <span class="keyword">for</span> (Object mapping : entrySet) &#123;</span><br><span class="line">        <span class="comment">//System.out.println(entry);</span></span><br><span class="line">        Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry) mapping;</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">&quot;-&gt;&quot;</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-Map的主要实现类：HashMap"><a href="#6-3-Map的主要实现类：HashMap" class="headerlink" title="6.3 Map的主要实现类：HashMap"></a>6.3 Map的主要实现类：HashMap</h3><h4 id="6-3-1-HashMap概述"><a href="#6-3-1-HashMap概述" class="headerlink" title="6.3.1 HashMap概述"></a>6.3.1 HashMap概述</h4><ul><li>HashMap是 Map 接口<code>使用频率最高</code>的实现类。</li><li>HashMap是线程不安全的。允许添加 null 键和 null 值。</li><li>存储数据采用的哈希表结构，底层使用<code>一维数组</code>+<code>单向链表</code>+<code>红黑树</code>进行key-value数据的存储。与HashSet一样，元素的存取顺序不能保证一致。</li><li>HashMap <code>判断两个key相等的标准</code>是：两个 key 的hashCode值相等，通过 equals() 方法返回 true。</li><li>HashMap <code>判断两个value相等的标准</code>是：两个 value 通过 equals() 方法返回 true。</li></ul><h4 id="6-3-2-练习"><a href="#6-3-2-练习" class="headerlink" title="6.3.2 练习"></a>6.3.2 练习</h4><p><strong>练习1：</strong>添加你喜欢的歌手以及你喜欢他唱过的歌曲</p><p>例如：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC12%E7%AB%A0_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20220914190805362.png" alt="image-20220914190805362"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式1</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 9:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingerTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个HashMap用于保存歌手和其歌曲集</span></span><br><span class="line"></span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">singers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//声明一组key,value</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">singer1</span> <span class="operator">=</span> <span class="string">&quot;周杰伦&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">songs1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        songs1.add(<span class="string">&quot;双节棍&quot;</span>);</span><br><span class="line">        songs1.add(<span class="string">&quot;本草纲目&quot;</span>);</span><br><span class="line">        songs1.add(<span class="string">&quot;夜曲&quot;</span>);</span><br><span class="line">        songs1.add(<span class="string">&quot;稻香&quot;</span>);</span><br><span class="line">        <span class="comment">//添加到map中</span></span><br><span class="line">        singers.put(singer1,songs1);</span><br><span class="line">        <span class="comment">//声明一组key,value</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">singer2</span> <span class="operator">=</span> <span class="string">&quot;陈奕迅&quot;</span>;</span><br><span class="line">        <span class="type">List</span> <span class="variable">songs2</span> <span class="operator">=</span> Arrays.asList(<span class="string">&quot;浮夸&quot;</span>, <span class="string">&quot;十年&quot;</span>, <span class="string">&quot;红玫瑰&quot;</span>, <span class="string">&quot;好久不见&quot;</span>, <span class="string">&quot;孤勇者&quot;</span>);</span><br><span class="line">        <span class="comment">//添加到map中</span></span><br><span class="line">        singers.put(singer2,songs2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历map</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> singers.entrySet();</span><br><span class="line">        <span class="keyword">for</span>(Object obj : entrySet)&#123;</span><br><span class="line">            Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry)obj;</span><br><span class="line">            <span class="type">String</span> <span class="variable">singer</span> <span class="operator">=</span> (String) entry.getKey();</span><br><span class="line">            <span class="type">List</span> <span class="variable">songs</span> <span class="operator">=</span> (List) entry.getValue();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;歌手：&quot;</span> + singer);</span><br><span class="line">            System.out.println(<span class="string">&quot;歌曲有：&quot;</span> + songs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式2：改为HashSet实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingerTest2</span> &#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">Singer</span> <span class="variable">singer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singer</span>(<span class="string">&quot;周杰伦&quot;</span>);</span><br><span class="line"><span class="type">Singer</span> <span class="variable">singer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singer</span>(<span class="string">&quot;陈奕迅&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Song</span> <span class="variable">song1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Song</span>(<span class="string">&quot;双节棍&quot;</span>);</span><br><span class="line"><span class="type">Song</span> <span class="variable">song2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Song</span>(<span class="string">&quot;本草纲目&quot;</span>);</span><br><span class="line"><span class="type">Song</span> <span class="variable">song3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Song</span>(<span class="string">&quot;夜曲&quot;</span>);</span><br><span class="line"><span class="type">Song</span> <span class="variable">song4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Song</span>(<span class="string">&quot;浮夸&quot;</span>);</span><br><span class="line"><span class="type">Song</span> <span class="variable">song5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Song</span>(<span class="string">&quot;十年&quot;</span>);</span><br><span class="line"><span class="type">Song</span> <span class="variable">song6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Song</span>(<span class="string">&quot;孤勇者&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">HashSet</span> <span class="variable">h1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();<span class="comment">// 放歌手一的歌曲</span></span><br><span class="line">h1.add(song1);</span><br><span class="line">h1.add(song2);</span><br><span class="line">h1.add(song3);</span><br><span class="line"></span><br><span class="line"><span class="type">HashSet</span> <span class="variable">h2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();<span class="comment">// 放歌手二的歌曲</span></span><br><span class="line">h2.add(song4);</span><br><span class="line">h2.add(song5);</span><br><span class="line">h2.add(song6);</span><br><span class="line"></span><br><span class="line"><span class="type">HashMap</span> <span class="variable">hashMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();<span class="comment">// 放歌手和他对应的歌曲</span></span><br><span class="line">hashMap.put(singer1, h1);</span><br><span class="line">hashMap.put(singer2, h2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Object obj : hashMap.keySet()) &#123;</span><br><span class="line">System.out.println(obj + <span class="string">&quot;=&quot;</span> + hashMap.get(obj));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//歌曲</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Song</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&#123;</span><br><span class="line"><span class="keyword">private</span> String songName;<span class="comment">//歌名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Song</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Song</span><span class="params">(String songName)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.songName = songName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getSongName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> songName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSongName</span><span class="params">(String songName)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.songName = songName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;《&quot;</span> + songName + <span class="string">&quot;》&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(o == <span class="built_in">this</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(o <span class="keyword">instanceof</span> Song)&#123;</span><br><span class="line"><span class="type">Song</span> <span class="variable">song</span> <span class="operator">=</span> (Song)o;</span><br><span class="line"><span class="keyword">return</span> songName.compareTo(song.getSongName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//歌手</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singer</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> Song song;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Singer</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Singer</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Song <span class="title function_">getSong</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> song;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSong</span><span class="params">(Song song)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.song = song;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(o == <span class="built_in">this</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(o <span class="keyword">instanceof</span> Singer)&#123;</span><br><span class="line"><span class="type">Singer</span> <span class="variable">singer</span> <span class="operator">=</span> (Singer)o;</span><br><span class="line"><span class="keyword">return</span> name.compareTo(singer.getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习2</strong>：二级联动</p><p>将省份和城市的名称保存在集合中，当用户选择省份以后，二级联动，显示对应省份的地级市供用户选择。</p><p>效果演示：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC12%E7%AB%A0_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/clip_image001.png" alt="img"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康  Email:shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年5月7日上午12:26:59</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CityMap</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Map</span> <span class="variable">model</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">model.put(<span class="string">&quot;北京&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;北京&quot;</span>&#125;);</span><br><span class="line">model.put(<span class="string">&quot;上海&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;上海&quot;</span>&#125;);</span><br><span class="line">model.put(<span class="string">&quot;天津&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;天津&quot;</span>&#125;);</span><br><span class="line">model.put(<span class="string">&quot;重庆&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;重庆&quot;</span>&#125;);</span><br><span class="line">model.put(<span class="string">&quot;黑龙江&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;哈尔滨&quot;</span>,<span class="string">&quot;齐齐哈尔&quot;</span>,<span class="string">&quot;牡丹江&quot;</span>,<span class="string">&quot;大庆&quot;</span>,<span class="string">&quot;伊春&quot;</span>,<span class="string">&quot;双鸭山&quot;</span>,<span class="string">&quot;绥化&quot;</span>&#125;);</span><br><span class="line">model.put(<span class="string">&quot;吉林&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;长春&quot;</span>,<span class="string">&quot;延边&quot;</span>,<span class="string">&quot;吉林&quot;</span>,<span class="string">&quot;白山&quot;</span>,<span class="string">&quot;白城&quot;</span>,<span class="string">&quot;四平&quot;</span>,<span class="string">&quot;松原&quot;</span>&#125;);</span><br><span class="line">model.put(<span class="string">&quot;河北&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;石家庄&quot;</span>,<span class="string">&quot;张家口&quot;</span>,<span class="string">&quot;邯郸&quot;</span>,<span class="string">&quot;邢台&quot;</span>,<span class="string">&quot;唐山&quot;</span>,<span class="string">&quot;保定&quot;</span>,<span class="string">&quot;秦皇岛&quot;</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProvinceTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">Set</span> <span class="variable">keySet</span> <span class="operator">=</span> CityMap.model.keySet();</span><br><span class="line"><span class="keyword">for</span>(Object s : keySet) &#123;</span><br><span class="line">System.out.print(s + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">&quot;请选择你所在的省份：&quot;</span>);</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">province</span> <span class="operator">=</span> scan.next();</span><br><span class="line"></span><br><span class="line">String[] citys = (String[])CityMap.model.get(province);</span><br><span class="line"><span class="keyword">for</span>(String city : citys) &#123;</span><br><span class="line">System.out.print(city + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">&quot;请选择你所在的城市：&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">city</span> <span class="operator">=</span> scan.next();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;信息登记完毕&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>练习3</strong>：WordCount统计</p><p>需求：统计字符串中每个字符出现的次数</p><p>String str = “aaaabbbcccccccccc”;</p><p>提示：</p><p>char[] arr = str.toCharArray();   //将字符串转换成字符数组</p><p>HashMap hm = new HashMap();   //创建双列集合存储键和值，键放字符，值放次数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022年5月7日上午12:26:59</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordCountTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;aaaabbbcccccccccc&quot;</span>;</span><br><span class="line">        <span class="type">char</span>[] arr = str.toCharArray(); <span class="comment">// 将字符串转换成字符数组</span></span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>(); <span class="comment">// 创建双列集合存储键和值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : arr) &#123; <span class="comment">// 遍历字符数组</span></span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(c)) &#123; <span class="comment">// 如果不包含这个键</span></span><br><span class="line">                map.put(c, <span class="number">1</span>); <span class="comment">// 就将键和值为1添加</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果包含这个键</span></span><br><span class="line">                map.put(c, (<span class="type">int</span>)map.get(c) + <span class="number">1</span>); <span class="comment">// 就将键和值再加1添加进来</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Object key : map.keySet()) &#123; <span class="comment">// 遍历双列集合</span></span><br><span class="line">            System.out.println(key + <span class="string">&quot;=&quot;</span> + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-4-Map实现类之二：LinkedHashMap"><a href="#6-4-Map实现类之二：LinkedHashMap" class="headerlink" title="6.4 Map实现类之二：LinkedHashMap"></a>6.4 Map实现类之二：LinkedHashMap</h3><ul><li>LinkedHashMap 是 HashMap 的子类</li><li>存储数据采用的哈希表结构+链表结构，在HashMap存储结构的基础上，使用了一对<code>双向链表</code>来<code>记录添加元素的先后顺序</code>，可以保证遍历元素时，与添加的顺序一致。</li><li>通过哈希表结构可以保证键的唯一、不重复，需要键所在类重写hashCode()方法、equals()方法。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLinkedHashMap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LinkedHashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;王五&quot;</span>, <span class="number">13000.0</span>);</span><br><span class="line">        map.put(<span class="string">&quot;张三&quot;</span>, <span class="number">10000.0</span>);</span><br><span class="line">        <span class="comment">//key相同，新的value会覆盖原来的value</span></span><br><span class="line">        <span class="comment">//因为String重写了hashCode和equals方法</span></span><br><span class="line">        map.put(<span class="string">&quot;张三&quot;</span>, <span class="number">12000.0</span>);</span><br><span class="line">        map.put(<span class="string">&quot;李四&quot;</span>, <span class="number">14000.0</span>);</span><br><span class="line">        <span class="comment">//HashMap支持key和value为null值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Double</span> <span class="variable">salary</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        map.put(name, salary);</span><br><span class="line"></span><br><span class="line">        <span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Object obj : entrySet) &#123;</span><br><span class="line">        Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry)obj;</span><br><span class="line">            System.out.println(entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-5-Map实现类之三：TreeMap"><a href="#6-5-Map实现类之三：TreeMap" class="headerlink" title="6.5 Map实现类之三：TreeMap"></a>6.5 Map实现类之三：TreeMap</h3><ul><li>TreeMap存储 key-value 对时，需要根据 key-value 对进行排序。TreeMap 可以保证所有的 key-value 对处于<code>有序状态</code>。</li><li>TreeSet底层使用<code>红黑树</code>结构存储数据</li><li>TreeMap 的 Key 的排序：<ul><li><code>自然排序</code>：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException</li><li><code>定制排序</code>：创建 TreeMap 时，构造器传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现 Comparable 接口</li></ul></li><li>TreeMap判断<code>两个key相等的标准</code>：两个key通过compareTo()方法或者compare()方法返回0。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 1:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTreeMap</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 自然排序举例</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">TreeMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>();</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">&quot;CC&quot;</span>,<span class="number">45</span>);</span><br><span class="line">        map.put(<span class="string">&quot;MM&quot;</span>,<span class="number">78</span>);</span><br><span class="line">        map.put(<span class="string">&quot;DD&quot;</span>,<span class="number">56</span>);</span><br><span class="line">        map.put(<span class="string">&quot;GG&quot;</span>,<span class="number">89</span>);</span><br><span class="line">        map.put(<span class="string">&quot;JJ&quot;</span>,<span class="number">99</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line">        <span class="keyword">for</span>(Object entry : entrySet)&#123;</span><br><span class="line">            System.out.println(entry);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 定制排序</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//按照User的姓名的从小到大的顺序排列</span></span><br><span class="line"></span><br><span class="line">        <span class="type">TreeMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> User &amp;&amp; o2 <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">                    <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> (User)o1;</span><br><span class="line">                    <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> (User)o2;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> u1.name.compareTo(u2.name);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的类型不匹配&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>),<span class="number">67</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Rose&quot;</span>,<span class="number">23</span>),<span class="string">&quot;87&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">2</span>),<span class="number">88</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Eric&quot;</span>,<span class="number">18</span>),<span class="number">45</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tommy&quot;</span>,<span class="number">44</span>),<span class="number">77</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jim&quot;</span>,<span class="number">23</span>),<span class="number">88</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Maria&quot;</span>,<span class="number">18</span>),<span class="number">34</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line">        <span class="keyword">for</span>(Object entry : entrySet)&#123;</span><br><span class="line">            System.out.println(entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    举例：按照age从小到大的顺序排列，如果age相同，则按照name从大到小的顺序排列</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span> == o)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)o;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="built_in">this</span>.age - user.age;</span><br><span class="line">            <span class="keyword">if</span>(value != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> -<span class="built_in">this</span>.name.compareTo(user.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的类型不匹配&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-6-Map实现类之四：Hashtable"><a href="#6-6-Map实现类之四：Hashtable" class="headerlink" title="6.6 Map实现类之四：Hashtable"></a>6.6 Map实现类之四：Hashtable</h3><ul><li>Hashtable是Map接口的<code>古老实现类</code>，JDK1.0就提供了。不同于HashMap，Hashtable是线程安全的。</li><li>Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构（数组+单向链表），查询速度快。</li><li>与HashMap一样，Hashtable 也不能保证其中 Key-Value 对的顺序</li><li>Hashtable判断两个key相等、两个value相等的标准，与HashMap一致。</li><li>与HashMap不同，Hashtable 不允许使用 null 作为 key 或 value。</li></ul><p>面试题：Hashtable和HashMap的区别</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HashMap:底层是一个哈希表（jdk7:数组+链表;jdk8:数组+链表+红黑树）,是一个线程不安全的集合,执行效率高</span><br><span class="line">Hashtable:底层也是一个哈希表（数组+链表）,是一个线程安全的集合,执行效率低</span><br><span class="line"></span><br><span class="line">HashMap集合:可以存储null的键、null的值</span><br><span class="line">Hashtable集合,不能存储null的键、null的值</span><br><span class="line"></span><br><span class="line">Hashtable和Vector集合一样,在jdk1.2版本之后被更先进的集合(HashMap,ArrayList)取代了。所以HashMap是Map的主要实现类，Hashtable是Map的古老实现类。</span><br><span class="line"></span><br><span class="line">Hashtable的子类Properties（配置文件）依然活跃在历史舞台</span><br><span class="line">Properties集合是一个唯一和IO流相结合的集合</span><br></pre></td></tr></table></figure><h3 id="6-7-Map实现类之五：Properties"><a href="#6-7-Map实现类之五：Properties" class="headerlink" title="6.7 Map实现类之五：Properties"></a>6.7 Map实现类之五：Properties</h3><ul><li><p>Properties 类是 Hashtable 的子类，该对象用于处理属性文件</p></li><li><p>由于属性文件里的 key、value 都是字符串类型，所以 Properties 中要求 key 和 value 都是字符串类型</p></li><li><p>存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> System.getProperties();</span><br><span class="line">    <span class="type">String</span> <span class="variable">fileEncoding</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;file.encoding&quot;</span>);<span class="comment">//当前源文件字符编码</span></span><br><span class="line">    System.out.println(<span class="string">&quot;fileEncoding = &quot;</span> + fileEncoding);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    properties.setProperty(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;songhk&quot;</span>);</span><br><span class="line">    properties.setProperty(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    System.out.println(properties);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    pros.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;jdbc.properties&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-Collections工具类"><a href="#7-Collections工具类" class="headerlink" title="7. Collections工具类"></a>7. Collections工具类</h2><p>参考操作数组的工具类：Arrays，Collections 是一个操作 Set、List 和 Map 等集合的工具类。</p><h3 id="7-1-常用方法"><a href="#7-1-常用方法" class="headerlink" title="7.1 常用方法"></a>7.1 常用方法</h3><p>Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法（均为static方法）：</p><p><strong>排序操作：</strong></p><ul><li>reverse(List)：反转 List 中元素的顺序</li><li>shuffle(List)：对 List 集合元素进行随机排序</li><li>sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序</li><li>sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</li><li>swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</li></ul><p><strong>查找</strong></p><ul><li>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素</li><li>Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素</li><li>Object min(Collection)：根据元素的自然顺序，返回给定集合中的最小元素</li><li>Object min(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最小元素</li><li>int binarySearch(List list,T key)在List集合中查找某个元素的下标，但是List的元素必须是T或T的子类对象，而且必须是可比较大小的，即支持自然排序的。而且集合也事先必须是有序的，否则结果不确定。</li><li>int binarySearch(List list,T key,Comparator c)在List集合中查找某个元素的下标，但是List的元素必须是T或T的子类对象，而且集合也事先必须是按照c比较器规则进行排序过的，否则结果不确定。</li><li>int frequency(Collection c，Object o)：返回指定集合中指定元素的出现次数</li></ul><p><strong>复制、替换</strong></p><ul><li>void copy(List dest,List src)：将src中的内容复制到dest中</li><li>boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值</li><li>提供了多个unmodifiableXxx()方法，该方法返回指定 Xxx的不可修改的视图。</li></ul><p><strong>添加</strong></p><ul><li>boolean addAll(Collection  c,T… elements)将所有指定元素添加到指定 collection 中。</li></ul><p><strong>同步</strong></p><ul><li>Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题：</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC12%E7%AB%A0_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20220409003002526.png" alt="image-20220409003002526"></p><h3 id="7-2-举例"><a href="#7-2-举例" class="headerlink" title="7.2 举例"></a>7.2 举例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.Collator;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCollections</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c,T... elements)</span></span><br><span class="line"><span class="comment">        将所有指定元素添加到指定 collection 中。Collection的集合的元素类型必须&gt;=T类型</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Collection&lt;Object&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(coll, <span class="string">&quot;hello&quot;</span>,<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        Collections.addAll(coll, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        Collection&lt;String&gt; coll2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(coll2, <span class="string">&quot;hello&quot;</span>,<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        <span class="comment">//Collections.addAll(coll2, 1,2,3,4);//String和Integer之间没有父子类关系</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(Collection&lt;? extends T&gt; coll)</span></span><br><span class="line"><span class="comment"> * 在coll集合中找出最大的元素，集合中的对象必须是T或T的子类对象，而且支持自然排序</span></span><br><span class="line"><span class="comment">*  </span></span><br><span class="line"><span class="comment">*  public static &lt;T&gt; T max(Collection&lt;? extends T&gt; coll,Comparator&lt;? super T&gt; comp)</span></span><br><span class="line"><span class="comment">*  在coll集合中找出最大的元素，集合中的对象必须是T或T的子类对象，按照比较器comp找出最大者</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        List&lt;Man&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Man</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">23</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Man</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">24</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Man</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">25</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Man max = Collections.max(list);//要求Man实现Comparable接口，或者父类实现</span></span><br><span class="line"><span class="comment">         * System.out.println(max);</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Man</span> <span class="variable">max</span> <span class="operator">=</span> Collections.max(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Man&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Man o1, Man o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o2.getAge()-o2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * public static void reverse(List&lt;?&gt; list)</span></span><br><span class="line"><span class="comment">         * 反转指定列表List中元素的顺序。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list,<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * public static void shuffle(List&lt;?&gt; list) </span></span><br><span class="line"><span class="comment">         * List 集合元素进行随机排序，类似洗牌，打乱顺序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list,<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list)</span></span><br><span class="line"><span class="comment">         * 根据元素的自然顺序对指定 List 集合元素按升序排序</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * public static &lt;T&gt; void sort(List&lt;T&gt; list,Comparator&lt;? super T&gt; c)</span></span><br><span class="line"><span class="comment">         * 根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        List&lt;Man&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Man</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">23</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Man</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">24</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Man</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">25</span>));</span><br><span class="line"></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Man&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Man o1, Man o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Collator.getInstance(Locale.CHINA).compare(o1.getName(),o2.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test06</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * public static void swap(List&lt;?&gt; list,int i,int j)</span></span><br><span class="line"><span class="comment">         * 将指定 list 集合中的 i 处元素和 j 处元素进行交换</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list,<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Collections.swap(list,<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test07</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * public static int frequency(Collection&lt;?&gt; c,Object o)</span></span><br><span class="line"><span class="comment">         * 返回指定集合中指定元素的出现次数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list,<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="string">&quot;world&quot;</span>,<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> Collections.frequency(list, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test08</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * public static &lt;T&gt; void copy(List&lt;? super T&gt; dest,List&lt;? extends T&gt; src)</span></span><br><span class="line"><span class="comment">         * 将src中的内容复制到dest中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++)&#123;<span class="comment">//1-5</span></span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">11</span>; i&lt;=<span class="number">13</span>; i++)&#123;<span class="comment">//11-13</span></span><br><span class="line">            list2.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Collections.copy(list, list2);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">11</span>; i&lt;=<span class="number">20</span>; i++)&#123;<span class="comment">//11-20</span></span><br><span class="line">            list3.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//java.lang.IndexOutOfBoundsException: Source does not fit in dest</span></span><br><span class="line">        <span class="comment">//Collections.copy(list, list3);</span></span><br><span class="line">        <span class="comment">//System.out.println(list);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test09</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * public static &lt;T&gt; boolean replaceAll(List&lt;T&gt; list，T oldVal，T newVal)</span></span><br><span class="line"><span class="comment">         * 使用新值替换 List 对象的所有旧值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list,<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="string">&quot;world&quot;</span>,<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Collections.replaceAll(list, <span class="string">&quot;hello&quot;</span>,<span class="string">&quot;song&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-3-练习"><a href="#7-3-练习" class="headerlink" title="7.3 练习"></a>7.3 练习</h3><p><strong>练习1：</strong></p><p>请从键盘随机输入10个整数保存到List中，并按倒序、从大到小的顺序显示出来</p><p><strong>练习2：</strong>模拟斗地主洗牌和发牌，牌没有排序</p><p>效果演示：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC12%E7%AB%A0_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20220409011625061.png" alt="image-20220409011625061"></p><p>提示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] num = &#123;<span class="string">&quot;A&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;10&quot;</span>,<span class="string">&quot;J&quot;</span>,<span class="string">&quot;Q&quot;</span>,<span class="string">&quot;K&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">String[] color = &#123;<span class="string">&quot;方片&quot;</span>,<span class="string">&quot;梅花&quot;</span>,<span class="string">&quot;红桃&quot;</span>,<span class="string">&quot;黑桃&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">ArrayList&lt;String&gt; poker = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022年5月7日上午12:26:59</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PokerTest</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">String[] num = &#123;<span class="string">&quot;A&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;10&quot;</span>,<span class="string">&quot;J&quot;</span>,<span class="string">&quot;Q&quot;</span>,<span class="string">&quot;K&quot;</span>&#125;;</span><br><span class="line">String[] color = &#123;<span class="string">&quot;方片&quot;</span>,<span class="string">&quot;梅花&quot;</span>,<span class="string">&quot;红桃&quot;</span>,<span class="string">&quot;黑桃&quot;</span>&#125;;</span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">poker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="comment">//1. 生成54张扑克牌</span></span><br><span class="line"><span class="keyword">for</span> (String s1 : color) &#123;</span><br><span class="line"><span class="keyword">for</span> (String s2 : num) &#123;</span><br><span class="line">poker.add(s1.concat(<span class="string">&quot; &quot;</span> + s2));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">poker.add(<span class="string">&quot;小王&quot;</span>);</span><br><span class="line">poker.add(<span class="string">&quot;大王&quot;</span>);</span><br><span class="line"><span class="comment">//2. 洗牌</span></span><br><span class="line">Collections.shuffle(poker);</span><br><span class="line"><span class="comment">//3. 发牌</span></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">tomCards</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">jerryCards</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">meCards</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">lastCards</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; poker.size(); i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= poker.size() - <span class="number">3</span>)&#123;</span><br><span class="line">                lastCards.add(poker.get(i));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                tomCards.add(poker.get(i));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                jerryCards.add(poker.get(i));</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                meCards.add(poker.get(i));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 看牌</span></span><br><span class="line">System.out.println(<span class="string">&quot;Tom:\n&quot;</span> + tomCards);</span><br><span class="line">        System.out.println(<span class="string">&quot;Jerry:\n&quot;</span> + jerryCards);</span><br><span class="line">        System.out.println(<span class="string">&quot;me:\n&quot;</span> + meCards);</span><br><span class="line">        System.out.println(<span class="string">&quot;底牌:\n&quot;</span> + lastCards);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>练习3：</strong>模拟斗地主洗牌和发牌并对牌进行排序的代码实现。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC12%E7%AB%A0_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20220915002714578.png" alt="image-20220915002714578"></p><p>提示：考查HashMap、TreeSet、ArrayList、Collections</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 0:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PokerTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] num = &#123;<span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;7&quot;</span>, <span class="string">&quot;8&quot;</span>, <span class="string">&quot;9&quot;</span>, <span class="string">&quot;10&quot;</span>, <span class="string">&quot;J&quot;</span>, <span class="string">&quot;Q&quot;</span>, <span class="string">&quot;K&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;2&quot;</span>&#125;;</span><br><span class="line">        String[] color = &#123;<span class="string">&quot;方片&quot;</span>, <span class="string">&quot;梅花&quot;</span>, <span class="string">&quot;红桃&quot;</span>, <span class="string">&quot;黑桃&quot;</span>&#125;;</span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>(); <span class="comment">// 存储索引和扑克牌</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); <span class="comment">// 存储索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 索引的开始值</span></span><br><span class="line">        <span class="keyword">for</span> (String s1 : num) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String s2 : color) &#123;</span><br><span class="line">                map.put(index, s2.concat(s1)); <span class="comment">// 将索引和扑克牌添加到HashMap中</span></span><br><span class="line">                list.add(index); <span class="comment">// 将索引添加到ArrayList集合中</span></span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(index, <span class="string">&quot;小王&quot;</span>);</span><br><span class="line">        list.add(index);</span><br><span class="line">        index++;</span><br><span class="line">        map.put(index, <span class="string">&quot;大王&quot;</span>);</span><br><span class="line">        list.add(index);</span><br><span class="line">        <span class="comment">// 洗牌</span></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        <span class="comment">// 发牌</span></span><br><span class="line">        <span class="type">TreeSet</span> <span class="variable">Tom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line">        <span class="type">TreeSet</span> <span class="variable">Jerry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line">        <span class="type">TreeSet</span> <span class="variable">me</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line">        <span class="type">TreeSet</span> <span class="variable">lastCards</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= list.size() - <span class="number">3</span>) &#123;</span><br><span class="line">                lastCards.add(list.get(i)); <span class="comment">// 将list集合中的索引添加到TreeSet集合中会自动排序</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                Tom.add(list.get(i));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                Jerry.add(list.get(i));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                me.add(list.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 看牌</span></span><br><span class="line">        lookPoker(<span class="string">&quot;Tom&quot;</span>, Tom, map);</span><br><span class="line">        lookPoker(<span class="string">&quot;Jerry&quot;</span>, Jerry, map);</span><br><span class="line">        lookPoker(<span class="string">&quot;康师傅&quot;</span>, me, map);</span><br><span class="line">        lookPoker(<span class="string">&quot;底牌&quot;</span>, lastCards, map);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">lookPoker</span><span class="params">(String name, TreeSet ts, HashMap map)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;的牌是:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object index : ts) &#123;</span><br><span class="line">            System.out.print(map.get(index) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第12章-集合框架&quot;&gt;&lt;a href=&quot;#第12章-集合框架&quot; class=&quot;headerlink&quot; title=&quot;第12章_集合框架&quot;&gt;&lt;/a&gt;第12章_集合框架&lt;/h1&gt;&lt;p&gt;讲师：尚硅谷-宋红康（江湖人称：康师傅）&lt;/p&gt;
&lt;p&gt;官网：&lt;a href=&quot;ht</summary>
      
    
    
    
    <category term="Java2023" scheme="http://example.com/categories/Java2023/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第13章_泛型(Generic)</title>
    <link href="http://example.com/2023/02/18/java2023/%E7%AC%AC13%E7%AB%A0_%E6%B3%9B%E5%9E%8B/"/>
    <id>http://example.com/2023/02/18/java2023/%E7%AC%AC13%E7%AB%A0_%E6%B3%9B%E5%9E%8B/</id>
    <published>2023-02-18T12:37:01.000Z</published>
    <updated>2023-02-19T07:38:43.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第13章-泛型-Generic"><a href="#第13章-泛型-Generic" class="headerlink" title="第13章_泛型(Generic)"></a>第13章_泛型(Generic)</h1><p>讲师：尚硅谷-宋红康（江湖人称：康师傅）</p><p>官网：<a href="http://www.atguigu.com/">http://www.atguigu.com</a></p><hr><h2 id="本章专题与脉络"><a href="#本章专题与脉络" class="headerlink" title="本章专题与脉络"></a>本章专题与脉络</h2><p><img src="/2023/02/18/java2023/%E7%AC%AC13%E7%AB%A0_%E6%B3%9B%E5%9E%8B/第3阶段：Java高级应用-第13章.png" alt="第3阶段：Java高级应用-第13章" style="zoom: 67%;"></p><hr><h2 id="1-泛型概述"><a href="#1-泛型概述" class="headerlink" title="1. 泛型概述"></a>1. 泛型概述</h2><h3 id="1-1-生活中的例子"><a href="#1-1-生活中的例子" class="headerlink" title="1.1 生活中的例子"></a>1.1 生活中的例子</h3><ul><li>举例1：中药店，每个抽屉外面贴着标签</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC13%E7%AB%A0_%E6%B3%9B%E5%9E%8B/image-20220411000757577.png" alt="image-20220411000757577"></p><ul><li>举例2：超市购物架上很多瓶子，每个瓶子装的是什么，有标签</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC13%E7%AB%A0_%E6%B3%9B%E5%9E%8B/image-20220918230534965.png" alt="image-20220918230534965" style="zoom:67%;"></p><ul><li>举例3：家庭厨房中：</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC13%E7%AB%A0_%E6%B3%9B%E5%9E%8B/image-20220514191533296.png" alt="image-20220514191533296" style="zoom:67%;"></p><blockquote><p>Java中的泛型，就类似于上述场景中的<code>标签</code>。</p></blockquote><h3 id="1-2-泛型的引入"><a href="#1-2-泛型的引入" class="headerlink" title="1.2 泛型的引入"></a>1.2 泛型的引入</h3><p>在Java中，我们在声明方法时，当在完成方法功能时如果有<code>未知的数据</code>需要参与，这些未知的数据需要在调用方法时才能确定，那么我们把这样的数据通过<code>形参</code>表示。在方法体中，用这个形参名来代表那个未知的数据，而调用者在调用时，对应的传入<code>实参</code>就可以了。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC13%E7%AB%A0_%E6%B3%9B%E5%9E%8B/1563414367674.png" alt="1563414367674"></p><p>受以上启发，JDK1.5设计了泛型的概念。泛型即为“<code>类型参数</code>”，这个类型参数在声明它的类、接口或方法中，代表未知的某种通用类型。</p><p><strong>举例1：</strong></p><p>集合类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以<strong>在JDK5.0之前只能把元素类型设计为Object，JDK5.0时Java引入了“参数化类型（Parameterized type）”的概念，允许我们在创建集合时指定集合元素的类型</strong>。比如：<code>List&lt;String&gt;</code>，这表明该List只能保存字符串类型的对象。</p><p>使用集合存储数据时，除了元素的类型不确定，其他部分是确定的（例如关于这个元素如何保存，如何管理等）。</p><p><strong>举例2：</strong></p><p><code>java.lang.Comparable</code>接口和<code>java.util.Comparator</code>接口，是用于比较对象大小的接口。这两个接口只是限定了当一个对象大于另一个对象时返回正整数，小于返回负整数，等于返回0，但是并不确定是什么类型的对象比较大小。JDK5.0之前只能用Object类型表示，使用时既麻烦又不安全，因此 JDK5.0 给它们增加了泛型。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC13%E7%AB%A0_%E6%B3%9B%E5%9E%8B/image-20220923154058074.png" alt="image-20220923154058074"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC13%E7%AB%A0_%E6%B3%9B%E5%9E%8B/image-20220923154426871.png" alt="image-20220923154426871"></p><p>其中<code>&lt;T&gt;</code>就是类型参数，即泛型。</p><blockquote><p>所谓泛型，就是允许在定义类、接口时通过一个<code>标识</code>表示类中某个<code>属性的类型</code>或者是某个方法的<code>返回值或参数的类型</code>。这个类型参数将在使用时（例如，继承或实现这个接口、创建对象或调用方法时）确定（即传入实际的类型参数，也称为类型实参）。</p></blockquote><h2 id="2-使用泛型举例"><a href="#2-使用泛型举例" class="headerlink" title="2. 使用泛型举例"></a>2. 使用泛型举例</h2><p>自从JDK5.0引入泛型的概念之后，对之前核心类库中的API做了很大的修改，例如：JDK5.0改写了集合框架中的全部接口和类、java.lang.Comparable接口、java.util.Comparator接口、Class类等。为这些接口、类增加了泛型支持，从而可以在声明变量、创建对象时传入类型实参。</p><h3 id="2-1-集合中使用泛型"><a href="#2-1-集合中使用泛型" class="headerlink" title="2.1 集合中使用泛型"></a>2.1 集合中使用泛型</h3><h4 id="2-1-1-举例"><a href="#2-1-1-举例" class="headerlink" title="2.1.1 举例"></a>2.1.1 举例</h4><p><strong>集合中没有使用泛型时：</strong></p><p><img src="/2023/02/18/java2023/%E7%AC%AC13%E7%AB%A0_%E6%B3%9B%E5%9E%8B/image-20220411001522636.png" alt="image-20220411001522636" style="zoom:80%;"></p><p><strong>集合中使用泛型时：</strong></p><p><img src="/2023/02/18/java2023/%E7%AC%AC13%E7%AB%A0_%E6%B3%9B%E5%9E%8B/image-20220411001549747.png" alt="image-20220411001549747" style="zoom:80%;"></p><blockquote><p>Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。即，把不安全的因素在编译期间就排除了，而不是运行期；既然通过了编译，那么类型一定是符合要求的，就避免了类型转换。</p><p>同时，代码更加简洁、健壮。</p><p><strong>把一个集合中的内容限制为一个特定的数据类型，这就是generic背后的核心思想。</strong></p></blockquote><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//泛型在List中的使用</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//举例：将学生成绩保存在ArrayList中</span></span><br><span class="line">    <span class="comment">//标准写法：</span></span><br><span class="line">    <span class="comment">//ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span></span><br><span class="line">    <span class="comment">//jdk7的新特性：类型推断</span></span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    list.add(<span class="number">56</span>); <span class="comment">//自动装箱</span></span><br><span class="line">    list.add(<span class="number">76</span>);</span><br><span class="line">    list.add(<span class="number">88</span>);</span><br><span class="line">    list.add(<span class="number">89</span>);</span><br><span class="line">    <span class="comment">//当添加非Integer类型数据时，编译不通过</span></span><br><span class="line">    <span class="comment">//list.add(&quot;Tom&quot;);//编译报错</span></span><br><span class="line"></span><br><span class="line">    Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        <span class="comment">//不需要强转，直接可以获取添加时的元素的数据类型</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">score</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        System.out.println(score);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//泛型在Map中的使用</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    HashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    map.put(<span class="string">&quot;Tom&quot;</span>,<span class="number">67</span>);</span><br><span class="line">    map.put(<span class="string">&quot;Jim&quot;</span>,<span class="number">56</span>);</span><br><span class="line">    map.put(<span class="string">&quot;Rose&quot;</span>,<span class="number">88</span>);</span><br><span class="line">    <span class="comment">//编译不通过</span></span><br><span class="line">    <span class="comment">//        map.put(67,&quot;Jack&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历key集</span></span><br><span class="line">    Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line">    <span class="keyword">for</span>(String str:keySet)&#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历value集</span></span><br><span class="line">    Collection&lt;Integer&gt; values = map.values();</span><br><span class="line">    Iterator&lt;Integer&gt; iterator = values.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历entry集</span></span><br><span class="line">    Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator1 = entrySet.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator1.hasNext())&#123;</span><br><span class="line">        Map.Entry&lt;String, Integer&gt; entry = iterator1.next();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">        System.out.println(key + <span class="string">&quot;:&quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-2-练习"><a href="#2-1-2-练习" class="headerlink" title="2.1.2 练习"></a>2.1.2 练习</h4><p>练习1：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）创建一个ArrayList集合对象，并指定泛型为&lt;Integer&gt;</span><br><span class="line"></span><br><span class="line">（2）添加5个[0,100)以内的整数到集合中</span><br><span class="line"></span><br><span class="line">（3）使用foreach遍历输出5个整数</span><br><span class="line"></span><br><span class="line">（4）使用集合的removeIf方法删除偶数，为Predicate接口指定泛型&lt;Ineteger&gt;</span><br><span class="line"></span><br><span class="line">（5）再使用Iterator迭代器输出剩下的元素，为Iterator接口指定泛型&lt;Integer&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.genericclass.use;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNumber</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span> ; i++) &#123;</span><br><span class="line">            coll.add(random.nextInt(<span class="number">100</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;coll中5个随机数是：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : coll) &#123;</span><br><span class="line">            System.out.println(integer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式1：使用集合的removeIf方法删除偶数</span></span><br><span class="line">        coll.removeIf(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Integer integer)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> integer % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//方式2：调用Iterator接口的remove()方法</span></span><br><span class="line">        <span class="comment">//Iterator&lt;Integer&gt; iterator1 = coll.iterator();</span></span><br><span class="line">        <span class="comment">//while(coll.hasNext())&#123;</span></span><br><span class="line">        <span class="comment">//    Integer i = coll.next();</span></span><br><span class="line">        <span class="comment">//   if(i % 2 == 0)&#123;</span></span><br><span class="line">        <span class="comment">//       coll.remove();</span></span><br><span class="line">        <span class="comment">//    &#125;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;coll中删除偶数后：&quot;</span>);</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = coll.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(number);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习2：编写一个简单的同学通迅录</p><p>需求说明：</p><ul><li>查询所有通讯录的同学信息。</li><li>输入姓名，根据姓名查询指定同学信息。如果该姓名不存在，输出提示信息。</li><li>添加同学，姓名重复的不能添加。</li><li>根据学员姓名删除学员。</li><li>按姓名排序查询学员。</li></ul><p>分析：</p><ul><li>使用HashMap<K,V>存储同学信息，使用同学姓名做key，同学对象做value。</K,V></li><li>同学对象包含的属性有：姓名、年龄、住址、爱好等。</li></ul><h3 id="2-2-比较器中使用泛型"><a href="#2-2-比较器中使用泛型" class="headerlink" title="2.2 比较器中使用泛型"></a>2.2 比较器中使用泛型</h3><h4 id="2-2-1-举例"><a href="#2-2-1-举例" class="headerlink" title="2.2.1 举例"></a>2.2.1 举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getRadius</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRadius</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Circle [radius=&quot;</span> + radius + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用泛型之前：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircleComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="comment">//强制类型转换</span></span><br><span class="line">        <span class="type">Circle</span> <span class="variable">c1</span> <span class="operator">=</span> (Circle) o1;</span><br><span class="line">        <span class="type">Circle</span> <span class="variable">c2</span> <span class="operator">=</span> (Circle) o2;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(c1.getRadius(), c2.getRadius());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNoGeneric</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CircleComparator</span> <span class="variable">com</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircleComparator</span>();</span><br><span class="line">        System.out.println(com.compare(<span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">1</span>), <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line">        System.out.println(com.compare(<span class="string">&quot;圆1&quot;</span>, <span class="string">&quot;圆2&quot;</span>));<span class="comment">//运行时异常：ClassCastException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用泛型之后：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircleComparator1</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Circle&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Circle o1, Circle o2)</span> &#123;</span><br><span class="line">        <span class="comment">//不再需要强制类型转换，代码更简洁</span></span><br><span class="line">        <span class="keyword">return</span> Double.compare(o1.getRadius(), o2.getRadius());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHasGeneric</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CircleComparator1</span> <span class="variable">com</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircleComparator1</span>();</span><br><span class="line">        System.out.println(com.compare(<span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">1</span>), <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(com.compare(&quot;圆1&quot;, &quot;圆2&quot;));</span></span><br><span class="line">        <span class="comment">//编译错误，因为&quot;圆1&quot;, &quot;圆2&quot;不是Circle类型，是String类型，编译器提前报错，</span></span><br><span class="line">        <span class="comment">//而不是冒着风险在运行时再报错。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-练习"><a href="#2-2-2-练习" class="headerlink" title="2.2.2 练习"></a>2.2.2 练习</h4><p>（1）声明矩形类Rectangle，包含属性长和宽，属性私有化，提供有参构造、get/set方法、重写toString方法，提供求面积和周长的方法。</p><p>（2）矩形类Rectangle实现java.lang.Comparable<T>接口，并指定泛型为<Rectangle>，重写int compareTo(T t)方法，按照矩形面积比较大小，面积相等的，按照周长比较大小。</Rectangle></T></p><p>（3）在测试类中，创建Rectangle数组，并创建5个矩形对象</p><p>（4）调用Arrays的sort方法，给矩形数组排序，并显示排序前后的结果。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.genericclass.use;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Rectangle&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> length;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(<span class="type">double</span> length, <span class="type">double</span> width)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.length = length;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getLength</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLength</span><span class="params">(<span class="type">double</span> length)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.length = length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getWidth</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWidth</span><span class="params">(<span class="type">double</span> width)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//获取面积</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">area</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length * width;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取周长</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">perimeter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * (length + width);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Rectangle&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;length=&quot;</span> + length +</span><br><span class="line">                <span class="string">&quot;, width=&quot;</span> + width +</span><br><span class="line">                <span class="string">&quot;,area =&quot;</span> + area() +</span><br><span class="line">                <span class="string">&quot;,perimeter = &quot;</span> + perimeter() +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Rectangle o)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">compare</span> <span class="operator">=</span> Double.compare(area(), o.area());</span><br><span class="line">        <span class="keyword">return</span> compare != <span class="number">0</span> ? compare : Double.compare(perimeter(),o.perimeter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.genericclass.use;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRectangle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Rectangle[] arr = <span class="keyword">new</span> <span class="title class_">Rectangle</span>[<span class="number">4</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">6</span>,<span class="number">2</span>);</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">4</span>,<span class="number">3</span>);</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">12</span>,<span class="number">1</span>);</span><br><span class="line">        arr[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">5</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序之前：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Rectangle rectangle : arr) &#123;</span><br><span class="line">            System.out.println(rectangle);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序之后：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Rectangle rectangle : arr) &#123;</span><br><span class="line">            System.out.println(rectangle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-3-相关使用说明"><a href="#2-3-相关使用说明" class="headerlink" title="2.3 相关使用说明"></a>2.3 相关使用说明</h3><ul><li><p>在创建集合对象的时候，可以指明泛型的类型。</p><p>具体格式为：List<Integer> list = new ArrayList<Integer>();</Integer></Integer></p></li><li><p>JDK7.0时，有新特性，可以简写为：</p><p>List<Integer> list = new ArrayList&lt;&gt;(); //类型推断</Integer></p></li><li><p>泛型，也称为泛型参数，即参数的类型，只能使用引用数据类型进行赋值。（不能使用基本数据类型，可以使用包装类替换）</p></li><li><p>集合声明时，声明泛型参数。在使用集合时，可以具体指明泛型的类型。一旦指明，类或接口内部，凡是使用泛型参数的位置，都指定为具体的参数类型。如果没有指明的话，看做是Object类型。</p></li></ul><h2 id="3-自定义泛型结构"><a href="#3-自定义泛型结构" class="headerlink" title="3. 自定义泛型结构"></a>3. 自定义泛型结构</h2><h3 id="3-1-泛型的基础说明"><a href="#3-1-泛型的基础说明" class="headerlink" title="3.1 泛型的基础说明"></a>3.1 泛型的基础说明</h3><p><strong>1、&lt;类型&gt;这种语法形式就叫泛型。</strong></p><ul><li>&lt;类型&gt;的形式我们称为类型参数，这里的”类型”习惯上使用T表示，是Type的缩写。即：<T>。</T></li><li><p><T>：代表未知的数据类型，我们可以指定为<String>，<Integer>，<Circle>等。</Circle></Integer></String></T></p><ul><li>类比方法的参数的概念，我们把<T>，称为类型形参，将<Circle>称为类型实参，有助于我们理解泛型</Circle></T></li></ul></li><li><p>这里的T，可以替换成K，V等任意字母。</p></li></ul><p><strong>2、在哪里可以声明类型变量\<T></T></strong></p><ul><li>声明类或接口时，在类名或接口名后面声明泛型类型，我们把这样的类或接口称为<code>泛型类</code>或<code>泛型接口</code>。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 class 类名&lt;类型变量列表&gt; 【extends 父类】 【implements 接口们】&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">【修饰符】 interface 接口名&lt;类型变量列表&gt; 【implements 接口们】&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt;    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Map</span>&lt;K,V&gt;&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><ul><li>声明方法时，在【修饰符】与返回值类型之间声明类型变量，我们把声明了类型变量的方法，称为泛型方法。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] &lt;类型变量列表&gt; 返回值类型 方法名([形参列表])[<span class="keyword">throws</span> 异常列表]&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例如：java.util.Arrays类中的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">asList</span><span class="params">(T... a)</span>&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-自定义泛型类或泛型接口"><a href="#3-2-自定义泛型类或泛型接口" class="headerlink" title="3.2 自定义泛型类或泛型接口"></a>3.2 自定义泛型类或泛型接口</h3><p>当我们在类或接口中定义某个成员时，该成员的相关类型是不确定的，而这个类型需要在使用这个类或接口时才可以确定，那么我们可以使用泛型类、泛型接口。</p><h4 id="3-2-1-说明"><a href="#3-2-1-说明" class="headerlink" title="3.2.1 说明"></a>3.2.1 说明</h4><p>① 我们在声明完自定义泛型类以后，可以在类的内部（比如：属性、方法、构造器中）使用类的泛型。</p><p>② 我们在创建自定义泛型类的对象时，可以指明泛型参数类型。一旦指明，内部凡是使用类的泛型参数的位置，都具体化为指定的类的泛型类型。</p><p>③ 如果在创建自定义泛型类的对象时，没有指明泛型参数类型，那么泛型将被擦除，泛型对应的类型均按照Object处理，但不等价于Object。</p><ul><li>经验：泛型要使用一路都用。要不用，一路都不要用。</li></ul><p>④ 泛型的指定中必须使用引用数据类型。不能使用基本数据类型，此时只能使用包装类替换。</p><p>⑤ 除创建泛型类对象外，子类继承泛型类时、实现类实现泛型接口时，也可以确定泛型结构中的泛型参数。</p><p>如果我们在给泛型类提供子类时，子类也不确定泛型的类型，则可以继续使用泛型参数。</p><p>我们还可以在现有的父类的泛型参数的基础上，新增泛型参数。</p><h4 id="3-2-2-注意"><a href="#3-2-2-注意" class="headerlink" title="3.2.2 注意"></a>3.2.2 注意</h4><p>① 泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：<E1,E2,E3></E1,E2,E3></p><p>② JDK7.0 开始，泛型的简化操作：ArrayList<Fruit> flist = new ArrayList&lt;&gt;();</Fruit></p><p>③ 如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象。</p><p>④ 不能使用new E[]。但是可以：E[] elements = (E[])new Object[capacity];</p><p>​        参考：ArrayList源码中声明：Object[] elementData，而非泛型参数类型数组。</p><p>⑤ 在类/接口上声明的泛型，在本类或本接口中即代表某种类型，但不可以在静态方法中使用类的泛型。</p><p>⑥ 异常类不能是带泛型的。</p><h4 id="3-2-2-举例"><a href="#3-2-2-举例" class="headerlink" title="3.2.2 举例"></a>3.2.2 举例</h4><p>举例1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 使用T类型定义变量</span></span><br><span class="line">    <span class="keyword">private</span> T info;</span><br><span class="line">    <span class="comment">// 使用T类型定义一般方法</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setInfo</span><span class="params">(T info)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用T类型定义构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(T info)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// static的方法中不能声明泛型</span></span><br><span class="line">    <span class="comment">//public static void show(T t) &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">// 不能在try-catch中使用泛型定义</span></span><br><span class="line">    <span class="comment">//public void test() &#123;</span></span><br><span class="line">        <span class="comment">//try &#123;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//&#125; catch (MyException&lt;T&gt; ex) &#123;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>举例2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&lt;T1, T2&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类不保留父类的泛型</span></span><br><span class="line"><span class="comment">// 1)没有类型 擦除</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;<span class="comment">// 等价于class Son extends Father&lt;Object,Object&gt;&#123;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2)具体类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer, String&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类保留父类的泛型</span></span><br><span class="line"><span class="comment">// 1)全部保留</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>&lt;T1, T2&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;T1, T2&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2)部分保留</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son4</span>&lt;T2&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer, T2&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>举例3：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&lt;T1, T2&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类不保留父类的泛型</span></span><br><span class="line"><span class="comment">// 1)没有类型 擦除</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>&lt;A, B&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;<span class="comment">//等价于class Son extends Father&lt;Object,Object&gt;&#123;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2)具体类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>&lt;A, B&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer, String&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类保留父类的泛型</span></span><br><span class="line"><span class="comment">// 1)全部保留</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>&lt;T1, T2, A, B&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;T1, T2&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2)部分保留</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son4</span>&lt;T2, A, B&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer, T2&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-2-3-练习"><a href="#3-2-3-练习" class="headerlink" title="3.2.3 练习"></a>3.2.3 练习</h4><p><strong>练习1：</strong></p><p>声明一个学生类，该学生包含姓名、成绩，而此时学生的成绩类型不确定，为什么呢，因为，语文老师希望成绩是“优秀”、“良好”、“及格”、“不及格”，数学老师希望成绩是89.5, 65.0，英语老师希望成绩是’A’,’B’,’C’,’D’,’E’。那么我们在设计这个学生类时，就可以使用泛型。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.genericclass.define;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> T score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, T score)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(T score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;姓名：&quot;</span> + name + <span class="string">&quot;, 成绩：&quot;</span> + score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStudent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//语文老师使用时：</span></span><br><span class="line">        Student&lt;String&gt; stu1 = <span class="keyword">new</span> <span class="title class_">Student</span>&lt;String&gt;(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;良好&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数学老师使用时：</span></span><br><span class="line">        <span class="comment">//Student&lt;double&gt; stu2 = new Student&lt;double&gt;(&quot;张三&quot;, 90.5);//错误，必须是引用数据类型</span></span><br><span class="line">        Student&lt;Double&gt; stu2 = <span class="keyword">new</span> <span class="title class_">Student</span>&lt;Double&gt;(<span class="string">&quot;张三&quot;</span>, <span class="number">90.5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//英语老师使用时：</span></span><br><span class="line">        Student&lt;Character&gt; stu3 = <span class="keyword">new</span> <span class="title class_">Student</span>&lt;Character&gt;(<span class="string">&quot;张三&quot;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//错误的指定</span></span><br><span class="line">        <span class="comment">//Student&lt;Object&gt; stu = new Student&lt;String&gt;();//错误的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>练习2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义个泛型类 DAO&lt;T&gt;，在其中定义一个Map 成员变量，Map 的键为 String 类型，值为 T 类型。</span><br><span class="line"></span><br><span class="line">分别创建以下方法：</span><br><span class="line">public void save(String id,T entity)： 保存 T 类型的对象到 Map 成员变量中</span><br><span class="line">public T get(String id)：从 map 中获取 id 对应的对象</span><br><span class="line">public void update(String id,T entity)：替换 map 中key为id的内容,改为 entity 对象</span><br><span class="line">public List&lt;T&gt; list()：返回 map 中存放的所有 T 对象</span><br><span class="line">public void delete(String id)：删除指定 id 对象</span><br><span class="line"></span><br><span class="line">定义一个 User 类：</span><br><span class="line">该类包含：private成员变量（int类型） id，age；（String 类型）name。</span><br><span class="line"></span><br><span class="line">定义一个测试类：</span><br><span class="line">创建 DAO 类的对象， 分别调用其 save、get、update、list、delete 方法来操作 User 对象，</span><br><span class="line">使用 Junit 单元测试类进行测试。</span><br></pre></td></tr></table></figure><p>代码实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 8:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DAO</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,T&gt; map ;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存 T 类型的对象到 Map 成员变量中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(String id,T entity)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(id))&#123;</span><br><span class="line">            map.put(id,entity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从 map 中获取 id 对应的对象</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(String id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//替换 map 中key为id的内容,改为 entity 对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String id,T entity)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(id))&#123;</span><br><span class="line">            map.put(id,entity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回 map 中存放的所有 T 对象</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;T&gt; <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//错误的：</span></span><br><span class="line"><span class="comment">//        Collection&lt;T&gt; values = map.values();</span></span><br><span class="line"><span class="comment">//        System.out.println(values.getClass());</span></span><br><span class="line"><span class="comment">//        return (List&lt;T&gt;) values;</span></span><br><span class="line">        <span class="comment">//正确的方式1：</span></span><br><span class="line"><span class="comment">//        ArrayList&lt;T&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        Collection&lt;T&gt; values = map.values();</span></span><br><span class="line"><span class="comment">//        list.addAll(values);</span></span><br><span class="line"><span class="comment">//        return list;</span></span><br><span class="line">        <span class="comment">//正确的方式2：</span></span><br><span class="line">        Collection&lt;T&gt; values = map.values();</span><br><span class="line">        ArrayList&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(values);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除指定 id 对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String id)</span>&#123;</span><br><span class="line">        map.remove(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu02.selfdefine.exer1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个 User 类：</span></span><br><span class="line"><span class="comment"> * 该类包含：private成员变量（int类型） id，age；（String 类型）name。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 9:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) o;</span><br><span class="line">        <span class="type">return</span> <span class="variable">id</span> <span class="operator">=</span>= user.id &amp;&amp; age == user.age &amp;&amp; Objects.equals(name, user.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(id, age, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu02.selfdefine.exer1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 9:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DAOTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        DAO&lt;User&gt; dao = <span class="keyword">new</span> <span class="title class_">DAO</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        dao.save(<span class="string">&quot;1001&quot;</span>,<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="number">34</span>,<span class="string">&quot;曹操&quot;</span>));</span><br><span class="line">        dao.save(<span class="string">&quot;1002&quot;</span>,<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>,<span class="number">33</span>,<span class="string">&quot;刘备&quot;</span>));</span><br><span class="line">        dao.save(<span class="string">&quot;1003&quot;</span>,<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">3</span>,<span class="number">24</span>,<span class="string">&quot;孙权&quot;</span>));</span><br><span class="line"></span><br><span class="line">        dao.update(<span class="string">&quot;1002&quot;</span>,<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>,<span class="number">23</span>,<span class="string">&quot;刘禅&quot;</span>));</span><br><span class="line"></span><br><span class="line">        dao.delete(<span class="string">&quot;1003&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; list = dao.list();</span><br><span class="line">        <span class="keyword">for</span>(User u : list)&#123;</span><br><span class="line">            System.out.println(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-自定义泛型方法"><a href="#3-3-自定义泛型方法" class="headerlink" title="3.3 自定义泛型方法"></a>3.3 自定义泛型方法</h3><p>如果我们定义类、接口时没有使用&lt;泛型参数&gt;，但是某个方法形参类型不确定时，这个方法可以单独定义&lt;泛型参数&gt;。</p><h4 id="3-3-1-说明"><a href="#3-3-1-说明" class="headerlink" title="3.3.1 说明"></a>3.3.1 说明</h4><ul><li>泛型方法的格式：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[访问权限]  &lt;泛型&gt;  返回值类型  方法名([泛型标识 参数名称])  [抛出的异常]&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法，也可以被泛型化，与其所在的类是否是泛型类没有关系。</li><li>泛型方法中的泛型参数在方法被调用时确定。</li><li>泛型方法可以根据需要，声明为static的。</li></ul><h4 id="3-3-2-举例"><a href="#3-3-2-举例" class="headerlink" title="3.3.2 举例"></a>3.3.2 举例</h4><p>举例1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DAO</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; E <span class="title function_">get</span><span class="params">(<span class="type">int</span> id, E e)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">E</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>举例2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">fromArrayToCollection</span><span class="params">(T[] a, Collection&lt;T&gt; c)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (T o : a) &#123;</span><br><span class="line">        c.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Object[] ao = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">100</span>];</span><br><span class="line">    Collection&lt;Object&gt; co = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">    fromArrayToCollection(ao, co);</span><br><span class="line"></span><br><span class="line">    String[] sa = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">20</span>];</span><br><span class="line">    Collection&lt;String&gt; cs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    fromArrayToCollection(sa, cs);</span><br><span class="line"></span><br><span class="line">    Collection&lt;Double&gt; cd = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 下面代码中T是Double类，但sa是String类型，编译错误。</span></span><br><span class="line">    <span class="comment">// fromArrayToCollection(sa, cd);</span></span><br><span class="line">    <span class="comment">// 下面代码中T是Object类型，sa是String类型，可以赋值成功。</span></span><br><span class="line">    fromArrayToCollection(sa, co);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>举例3：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArrays</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(T[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length-i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(((Comparable&lt;T&gt;)arr[j]).compareTo(arr[j+<span class="number">1</span>])&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="type">T</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                    arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyArraysTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">//MyArrays.sort(arr);//错误的，因为int[]不是对象数组</span></span><br><span class="line"></span><br><span class="line">        String[] strings = &#123;<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="string">&quot;song&quot;</span>&#125;;</span><br><span class="line">        MyArrays.sort(strings);</span><br><span class="line">        System.out.println(Arrays.toString(strings));</span><br><span class="line"></span><br><span class="line">        Circle[] circles = &#123;<span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">2.0</span>),<span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">1.2</span>),<span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">3.0</span>)&#125;;</span><br><span class="line">        MyArrays.sort(circles); <span class="comment">//编译通过，运行报错，因为Circle没有实现Comparable接口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-3-练习"><a href="#3-3-3-练习" class="headerlink" title="3.3.3 练习"></a>3.3.3 练习</h4><p>练习1: 泛型方法</p><p>编写一个泛型方法，实现任意引用类型数组指定位置元素交换。</p><p>public static <E> void method1( E[] e,int a,int b)</E></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 9:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exer01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个泛型方法，实现任意引用类型数组指定位置元素交换。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">method</span><span class="params">( E[] arr,<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">temp</span> <span class="operator">=</span> arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        Integer[] arr = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;;</span><br><span class="line">        method(arr,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Integer i : arr)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习2: 泛型方法</p><p>编写一个泛型方法，接收一个任意引用类型的数组，并反转数组中的所有元素</p><p>public static <E> void method2( E[] e)</E></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 9:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exer01</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个泛型方法，接收一个任意引用类型的数组，并反转数组中的所有元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">( E[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>,max = arr.length - <span class="number">1</span>;min &lt; max; min++,max--)&#123;</span><br><span class="line">            <span class="type">E</span> <span class="variable">temp</span> <span class="operator">=</span> arr[min];</span><br><span class="line">            arr[min] = arr[max];</span><br><span class="line">            arr[max] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod1</span><span class="params">()</span>&#123;</span><br><span class="line">        Integer[] arr = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;;</span><br><span class="line">        method1(arr);</span><br><span class="line">        <span class="keyword">for</span>(Integer i : arr)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-泛型在继承上的体现"><a href="#4-泛型在继承上的体现" class="headerlink" title="4. 泛型在继承上的体现"></a>4. 泛型在继承上的体现</h2><p>如果B是A的一个子类型（子类或者子接口），而G是具有泛型声明的类或接口，G<B>并不是G<A>的子类型！</A></B></p><p>比如：String是Object的子类，但是List<String>并不是List<Object>的子类。</Object></String></p><p><img src="/2023/02/18/java2023/%E7%AC%AC13%E7%AB%A0_%E6%B3%9B%E5%9E%8B/image-20220411003422259.png" alt="image-20220411003422259" style="zoom:67%;"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGenericAndSubClass</span><span class="params">()</span> &#123;</span><br><span class="line">    Person[] persons = <span class="literal">null</span>;</span><br><span class="line">    Man[] mans = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//Person[] 是 Man[] 的父类</span></span><br><span class="line">    persons = mans;</span><br><span class="line"></span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> mans[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在泛型的集合上</span></span><br><span class="line">    List&lt;Person&gt; personList = <span class="literal">null</span>;</span><br><span class="line">    List&lt;Man&gt; manList = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//personList = manList;(报错)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思考：对比如下两段代码有何不同：</strong></p><p>片段1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printCollection</span><span class="params">(Collection c)</span> &#123;</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">i</span> <span class="operator">=</span> c.iterator();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; c.size(); k++) &#123;</span><br><span class="line">        System.out.println(i.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>片段2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printCollection</span><span class="params">(Collection&lt;Object&gt; c)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Object e : c) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-通配符的使用"><a href="#5-通配符的使用" class="headerlink" title="5. 通配符的使用"></a>5. 通配符的使用</h2><p>当我们声明一个变量/形参时，这个变量/形参的类型是一个泛型类或泛型接口，例如：Comparator<T>类型，但是我们仍然无法确定这个泛型类或泛型接口的类型变量<T>的具体类型，此时我们考虑使用类型通配符 ? 。</T></T></p><h3 id="5-1-通配符的理解"><a href="#5-1-通配符的理解" class="headerlink" title="5.1 通配符的理解"></a>5.1 通配符的理解</h3><p>使用类型通配符：？ </p><p>比如：<code>List&lt;?&gt;</code>，<code>Map&lt;?,?&gt;</code></p><p>​            <code>List&lt;?&gt;</code>是<code>List&lt;String&gt;</code>、<code>List&lt;Object&gt;</code>等各种泛型List的父类。</p><h3 id="5-2-通配符的读与写"><a href="#5-2-通配符的读与写" class="headerlink" title="5.2 通配符的读与写"></a>5.2 通配符的读与写</h3><p><strong>写操作：</strong></p><p>将任意元素加入到其中不是类型安全的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;?&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">c.add(<span class="keyword">new</span> <span class="title class_">Object</span>()); <span class="comment">// 编译时错误</span></span><br></pre></td></tr></table></figure><p>因为我们不知道c的元素类型，我们不能向其中添加对象。add方法有类型参数E作为集合的元素类型。我们传给add的任何参数都必须是一个未知类型的子类。因为我们不知道那是什么类型，所以我们无法传任何东西进去。</p><p>唯一可以插入的元素是null，因为它是所有引用类型的默认值。</p><p><strong>读操作：</strong></p><p>另一方面，读取List&lt;?&gt;的对象list中的元素时，永远是安全的，因为不管 list 的真实类型是什么，它包含的都是Object。</p><p>举例1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestWildcard</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">(Collection&lt;?&gt; coll)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Object o : coll) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;?&gt; list = <span class="literal">null</span>;</span><br><span class="line">    list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Double&gt;();</span><br><span class="line">    <span class="comment">// list.add(3);//编译不通过</span></span><br><span class="line">    list.add(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; l1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    List&lt;Integer&gt; l2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    l1.add(<span class="string">&quot;尚硅谷&quot;</span>);</span><br><span class="line">    l2.add(<span class="number">15</span>);</span><br><span class="line">    read(l1);</span><br><span class="line">    read(l2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(List&lt;?&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Object o : list) &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-3-使用注意点"><a href="#5-3-使用注意点" class="headerlink" title="5.3 使用注意点"></a>5.3 使用注意点</h3><p>注意点1：编译错误：不能用在泛型方法声明上，返回值类型前面&lt;&gt;不能使用?</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;?&gt; <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(ArrayList&lt;?&gt; list)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点2：编译错误：不能用在泛型类的声明上</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GenericTypeClass</span>&lt;?&gt;&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点3：编译错误：不能用在创建对象上，右边属于创建集合对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;?&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;?&gt;();</span><br></pre></td></tr></table></figure><h3 id="5-4-有限制的通配符"><a href="#5-4-有限制的通配符" class="headerlink" title="5.4 有限制的通配符"></a>5.4 有限制的通配符</h3><ul><li><p><code>&lt;?&gt;</code></p><ul><li>允许所有泛型的引用调用</li></ul></li><li><p>通配符指定上限：<code>&lt;? extends 类/接口 &gt;</code></p><ul><li>使用时指定的类型必须是继承某个类，或者实现某个接口，即&lt;= </li></ul></li><li><p>通配符指定下限：<code>&lt;? super 类/接口 &gt;</code></p><ul><li>使用时指定的类型必须是操作的类或接口，或者是操作的类的父类或接口的父接口，即&gt;=</li></ul></li><li><p>说明：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt;     <span class="comment">//(无穷小 , Number]</span></span><br><span class="line"><span class="comment">//只允许泛型为Number及Number子类的引用调用</span></span><br><span class="line"></span><br><span class="line">&lt;? <span class="built_in">super</span> Number&gt;      <span class="comment">//[Number , 无穷大)</span></span><br><span class="line"><span class="comment">//只允许泛型为Number及Number父类的引用调用</span></span><br><span class="line"></span><br><span class="line">&lt;? <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt;</span><br><span class="line"><span class="comment">//只允许泛型为实现Comparable接口的实现类的引用调用</span></span><br></pre></td></tr></table></figure></li><li><p>举例1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Creature</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">Creature</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        test(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line">        test(<span class="keyword">new</span> <span class="title class_">Man</span>());</span><br><span class="line">        <span class="comment">//The method test(T) in the type PersonTest is not </span></span><br><span class="line">        <span class="comment">//applicable for the arguments (Creature)</span></span><br><span class="line">        test(<span class="keyword">new</span> <span class="title class_">Creature</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>举例2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Collection&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    Collection&lt;Number&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br><span class="line">    Collection&lt;Object&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">    </span><br><span class="line">    getElement1(list1);</span><br><span class="line">    getElement1(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement1(list3);</span><br><span class="line">    getElement1(list4);<span class="comment">//报错</span></span><br><span class="line">  </span><br><span class="line">    getElement2(list1);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list3);</span><br><span class="line">    getElement2(list4);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getElement1</span><span class="params">(Collection&lt;? extends Number&gt; coll)</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getElement2</span><span class="params">(Collection&lt;? <span class="built_in">super</span> Number&gt; coll)</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>举例3：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printCollection1</span><span class="params">(Collection&lt;? extends Person&gt; coll)</span> &#123;</span><br><span class="line">    <span class="comment">//Iterator只能用Iterator&lt;?&gt;或Iterator&lt;? extends Person&gt;.why?</span></span><br><span class="line">    Iterator&lt;?&gt; iterator = coll.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        System.out.println(per);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printCollection2</span><span class="params">(Collection&lt;? <span class="built_in">super</span> Person&gt; coll)</span> &#123;</span><br><span class="line">    <span class="comment">//Iterator只能用Iterator&lt;?&gt;或Iterator&lt;? super Person&gt;.why?</span></span><br><span class="line">    Iterator&lt;?&gt; iterator = coll.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>举例4:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//List&lt;Object&gt; list1 = null;</span></span><br><span class="line">    List&lt;Person&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">    <span class="comment">//List&lt;Student&gt; list3 = null;</span></span><br><span class="line"></span><br><span class="line">    List&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; list4 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    list2.add(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line">    list4 = list2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取：可以读</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> list4.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入：除了null之外，不能写入</span></span><br><span class="line">    list4.add(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//        list4.add(new Person());</span></span><br><span class="line">    <span class="comment">//        list4.add(new Student());</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//List&lt;Object&gt; list1 = null;</span></span><br><span class="line">    List&lt;Person&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">    <span class="comment">//List&lt;Student&gt; list3 = null;</span></span><br><span class="line"></span><br><span class="line">    List&lt;? <span class="built_in">super</span> Person&gt; list5 = <span class="literal">null</span>;</span><br><span class="line">    list2.add(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line"></span><br><span class="line">    list5 = list2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取：可以实现</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> list5.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入:可以写入Person及Person子类的对象</span></span><br><span class="line">    list5.add(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line">    list5.add(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-泛型应用举例"><a href="#5-5-泛型应用举例" class="headerlink" title="5.5 泛型应用举例"></a>5.5 泛型应用举例</h3><p><strong>举例1：泛型嵌套</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    HashMap&lt;String, ArrayList&lt;Citizen&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, ArrayList&lt;Citizen&gt;&gt;();</span><br><span class="line">    ArrayList&lt;Citizen&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Citizen&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Citizen</span>(<span class="string">&quot;赵又廷&quot;</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Citizen</span>(<span class="string">&quot;高圆圆&quot;</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Citizen</span>(<span class="string">&quot;瑞亚&quot;</span>));</span><br><span class="line">    map.put(<span class="string">&quot;赵又廷&quot;</span>, list);</span><br><span class="line"></span><br><span class="line">    Set&lt;Entry&lt;String, ArrayList&lt;Citizen&gt;&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">    Iterator&lt;Entry&lt;String, ArrayList&lt;Citizen&gt;&gt;&gt; iterator = entrySet.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        Entry&lt;String, ArrayList&lt;Citizen&gt;&gt; entry = iterator.next();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        ArrayList&lt;Citizen&gt; value = entry.getValue();</span><br><span class="line">        System.out.println(<span class="string">&quot;户主：&quot;</span> + key);</span><br><span class="line">        System.out.println(<span class="string">&quot;家庭成员：&quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>举例2：个人信息设计</strong></p><p>用户在设计类的时候往往会使用类的关联关系，例如，一个人中可以定义一个信息的属性，但是一个人可能有各种各样的信息（如联系方式、基本信息等），所以此信息属性的类型就可以通过泛型进行声明，然后只要设计相应的信息类即可。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC13%E7%AB%A0_%E6%B3%9B%E5%9E%8B/image-20220411004301224.png" alt="image-20220411004301224" style="zoom:67%;"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span>&#123;<span class="comment">// 只有此接口的子类才是表示人的信息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Contact</span> <span class="keyword">implements</span> <span class="title class_">Info</span>&#123;<span class="comment">// 表示联系方式</span></span><br><span class="line"><span class="keyword">private</span> String address ;<span class="comment">// 联系地址</span></span><br><span class="line"><span class="keyword">private</span> String telephone ;<span class="comment">// 联系方式</span></span><br><span class="line"><span class="keyword">private</span> String zipcode ;<span class="comment">// 邮政编码</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Contact</span><span class="params">(String address,String telephone,String zipcode)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.address = address;</span><br><span class="line"><span class="built_in">this</span>.telephone = telephone;</span><br><span class="line"><span class="built_in">this</span>.zipcode = zipcode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(String address)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.address = address ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTelephone</span><span class="params">(String telephone)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.telephone = telephone ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setZipcode</span><span class="params">(String zipcode)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.zipcode = zipcode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.address ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getTelephone</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.telephone ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getZipcode</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.zipcode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Contact [address=&quot;</span> + address + <span class="string">&quot;, telephone=&quot;</span> + telephone</span><br><span class="line">+ <span class="string">&quot;, zipcode=&quot;</span> + zipcode + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Introduction</span> <span class="keyword">implements</span> <span class="title class_">Info</span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name ;<span class="comment">// 姓名</span></span><br><span class="line"><span class="keyword">private</span> String sex ;<span class="comment">// 性别</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age ;<span class="comment">// 年龄</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Introduction</span><span class="params">(String name,String sex,<span class="type">int</span> age)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="built_in">this</span>.sex = sex;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = name ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(String sex)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.sex = sex ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.age = age ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.name ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getSex</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.sex ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.age ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Introduction [name=&quot;</span> + name + <span class="string">&quot;, sex=&quot;</span> + sex + <span class="string">&quot;, age=&quot;</span> + age</span><br><span class="line">+ <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Info</span>&gt;&#123;</span><br><span class="line"><span class="keyword">private</span> T info ;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(T info)</span>&#123;<span class="comment">// 通过构造器设置信息属性内容</span></span><br><span class="line"><span class="built_in">this</span>.info = info;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setInfo</span><span class="params">(T info)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.info = info ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">getInfo</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> info ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Person [info=&quot;</span> + info + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericPerson</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">Person&lt;Contact&gt; per = <span class="literal">null</span> ;<span class="comment">// 声明Person对象</span></span><br><span class="line">per = <span class="keyword">new</span> <span class="title class_">Person</span>&lt;Contact&gt;(<span class="keyword">new</span> <span class="title class_">Contact</span>(<span class="string">&quot;北京市&quot;</span>,<span class="string">&quot;01088888888&quot;</span>,<span class="string">&quot;102206&quot;</span>)) ;</span><br><span class="line">System.out.println(per);</span><br><span class="line"></span><br><span class="line">Person&lt;Introduction&gt; per2 = <span class="literal">null</span> ;<span class="comment">// 声明Person对象</span></span><br><span class="line">per2 = <span class="keyword">new</span> <span class="title class_">Person</span>&lt;Introduction&gt;(<span class="keyword">new</span> <span class="title class_">Introduction</span>(<span class="string">&quot;李雷&quot;</span>,<span class="string">&quot;男&quot;</span>,<span class="number">24</span>));</span><br><span class="line">System.out.println(per2) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第13章-泛型-Generic&quot;&gt;&lt;a href=&quot;#第13章-泛型-Generic&quot; class=&quot;headerlink&quot; title=&quot;第13章_泛型(Generic)&quot;&gt;&lt;/a&gt;第13章_泛型(Generic)&lt;/h1&gt;&lt;p&gt;讲师：尚硅谷-宋红康（江湖人称：</summary>
      
    
    
    
    <category term="Java2023" scheme="http://example.com/categories/Java2023/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第14章_数据结构与集合源码</title>
    <link href="http://example.com/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/"/>
    <id>http://example.com/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/</id>
    <published>2023-02-18T12:37:01.000Z</published>
    <updated>2023-02-19T07:38:43.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第14章-数据结构与集合源码"><a href="#第14章-数据结构与集合源码" class="headerlink" title="第14章_数据结构与集合源码"></a>第14章_数据结构与集合源码</h1><p>讲师：尚硅谷-宋红康（江湖人称：康师傅）</p><p>官网：<a href="http://www.atguigu.com/">http://www.atguigu.com</a></p><hr><h2 id="本章专题与脉络"><a href="#本章专题与脉络" class="headerlink" title="本章专题与脉络"></a>本章专题与脉络</h2><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/第3阶段：Java高级应用-第14章.png" alt="第3阶段：Java高级应用-第14章"></p><h2 id="1-数据结构剖析"><a href="#1-数据结构剖析" class="headerlink" title="1. 数据结构剖析"></a>1. 数据结构剖析</h2><p>我们举一个形象的例子来理解数据结构的作用：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/image-20220412011531879.png" alt="image-20220412011531879"></p><blockquote><p><strong>战场：</strong>程序运行所需的软件、硬件环境</p><p><strong>敌人：</strong>项目或模块的功能需求</p><p><strong>指挥官：</strong>编写程序的程序员</p><p><strong>士兵和装备：</strong>一行一行的代码</p><p><strong>战术和策略：</strong>数据结构</p></blockquote><p> <img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/image-20220412011555025.png" alt="image-20220412011555025"></p><p>上图：没有战术，打仗事倍功半</p><p> <img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/image-20220412011600845.png" alt="image-20220412011600845"></p><p>上图：有战术，打仗事半功倍</p><p> 总结：简单来说，数据结构，就是一种程序设计优化的方法论，研究数据的<code>逻辑结构</code>和<code>物理结构</code>以及它们之间相互关系，并对这种结构定义相应的<code>运算</code>，<strong>目的是加快程序的执行速度、减少内存占用的空间。</strong></p><p>具体研究对象如下：</p><h3 id="1-1-研究对象一：数据间逻辑关系"><a href="#1-1-研究对象一：数据间逻辑关系" class="headerlink" title="1.1 研究对象一：数据间逻辑关系"></a>1.1 研究对象一：数据间逻辑关系</h3><p>数据的逻辑结构指反映数据元素之间的逻辑关系，而与数据的存储无关，是独立于计算机的。</p><ul><li><strong>集合结构</strong>：数据结构中的元素之间除了“<code>同属一个集合</code>” 的相互关系外，别无其他关系。集合元素之间没有逻辑关系。</li><li><strong>线性结构</strong>：数据结构中的元素存在<code>一对一</code>的相互关系。比如：排队。结构中必须存在唯一的首元素和唯一的尾元素。体现为：一维数组、链表、栈、队列</li><li><strong>树形结构</strong>：数据结构中的元素存在<code>一对多</code>的相互关系。比如：家谱、文件系统、组织架构</li><li><strong>图形结构</strong>：数据结构中的元素存在<code>多对多</code>的相互关系。比如：全国铁路网、地铁图</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/image-20220824011022664.png" alt="image-20220824011022664" style="zoom:67%;"></p><h3 id="1-2-研究对象二：数据的存储结构（或物理结构）"><a href="#1-2-研究对象二：数据的存储结构（或物理结构）" class="headerlink" title="1.2 研究对象二：数据的存储结构（或物理结构）"></a>1.2 研究对象二：数据的存储结构（或物理结构）</h3><p>数据的物理结构/存储结构：包括<code>数据元素的表示</code>和<code>关系的表示</code>。数据的存储结构是逻辑结构用计算机语言的实现，它依赖于计算机语言。</p><p><strong>结构1：顺序结构</strong></p><ul><li><p>顺序结构就是使用一组连续的存储单元依次存储逻辑上相邻的各个元素。</p></li><li><p>优点： 只需要申请存放数据本身的内存空间即可，支持下标访问，也可以实现随机访问。</p></li><li>缺点： 必须静态分配连续空间，内存空间的利用率比较低。插入或删除可能需要移动大量元素，效率比较低</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/image-20220521100746910.png" alt="image-20220521100746910"></p><p><strong>结构2：链式结构</strong></p><ul><li>不使用连续的存储空间存放结构的元素，而是为每一个元素构造一个节点。节点中除了存放数据本身以外，还需要存放指向下一个节点的指针。</li><li>优点：不采用连续的存储空间导致内存空间利用率比较高，克服顺序存储结构中预知元素个数的缺点。插入或删除元素时，不需要移动大量的元素。</li><li>缺点：需要额外的空间来表达数据之间的逻辑关系，不支持下标访问和随机访问。</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/image-20220521103734742.png" alt="image-20220521103734742"></p><p><strong>结构3：索引结构</strong></p><ul><li>除建立存储节点信息外，还建立附加的<code>索引表</code>来记录每个元素节点的地址。索引表由若干索引项组成。索引项的一般形式是：（关键字，地址）。</li><li>优点：用节点的索引号来确定结点存储地址，检索速度快。</li><li>缺点： 增加了附加的索引表，会占用较多的存储空间。在增加和删除数据时要修改索引表，因而会花费较多的时间。</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/image-20220521115200921.png" alt="image-20220521115200921" style="zoom:67%;"></p><p><strong>结构4：散列结构</strong></p><ul><li>根据元素的关键字直接计算出该元素的存储地址，又称为Hash存储。</li><li>优点：检索、增加和删除结点的操作都很快。</li><li>缺点：不支持排序，一般比用线性表存储需要更多的空间，并且记录的关键字不能重复。</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/image-20220521115734571.png" alt="image-20220521115734571" style="zoom:67%;"></p><h3 id="1-3-研究对象三：运算结构"><a href="#1-3-研究对象三：运算结构" class="headerlink" title="1.3 研究对象三：运算结构"></a>1.3 研究对象三：运算结构</h3><p>施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。</p><ul><li>分配资源，建立结构，释放资源</li><li>插入和删除</li><li>获取和遍历</li><li>修改和排序</li></ul><h3 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/数据结构.png" alt="数据结构" style="zoom: 40%;"></p><h2 id="2-一维数组"><a href="#2-一维数组" class="headerlink" title="2. 一维数组"></a>2. 一维数组</h2><h3 id="2-1-数组的特点"><a href="#2-1-数组的特点" class="headerlink" title="2.1 数组的特点"></a>2.1 数组的特点</h3><ul><li>在Java中，数组是用来存放同一种数据类型的集合，注意只能存放同一种数据类型。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只声明了类型和长度</span></span><br><span class="line">数据类型[]  数组名称 = <span class="keyword">new</span> 数据类型[数组长度];</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明了类型，初始化赋值，大小由元素个数决定</span></span><br><span class="line">数据类型[] 数组名称 = &#123;数组元素<span class="number">1</span>，数组元素<span class="number">2</span>，......&#125;</span><br></pre></td></tr></table></figure><p>例如：整型数组</p><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/1563432676234.png" alt="1563432676234" style="zoom: 80%;"></p><p>例如：对象数组</p><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/1563432696340.png" alt="1563432696340" style="zoom:80%;"></p><ul><li>物理结构特点：<ul><li>申请内存：一次申请一大段连续的空间，一旦申请到了，内存就固定了。</li><li>不能动态扩展(初始化给大了，浪费；给小了，不够用)，插入快，删除和查找慢。</li><li>存储特点：所有数据存储在这个连续的空间中，数组中的每一个元素都是一个具体的数据（或对象），所有数据都紧密排布，不能有间隔。</li></ul></li><li>具体的，如下图：</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/数据结构-一维数组.png" alt="数据结构-一维数组" style="zoom: 50%;"></p><h3 id="2-2-自定义数组"><a href="#2-2-自定义数组" class="headerlink" title="2.2 自定义数组"></a>2.2 自定义数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu01.overview.array;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 14:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Array</span><span class="params">(<span class="type">int</span> capacity)</span>&#123;</span><br><span class="line">        elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Object value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size &gt;= elementData.length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;数组已满，不可添加&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        elementData[size] = value;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询元素value在数组中的索引位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(Object value)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(elementData[i].equals(value))&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从当前数组中移除首次出现的value元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(Object value)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> find(value);</span><br><span class="line">        <span class="keyword">if</span>(index == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;i &lt; size - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            elementData[i] = elementData[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        elementData[size - <span class="number">1</span>] = <span class="literal">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数组中首次出现的oldValue替换为newValue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> oldValue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newValue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">update</span><span class="params">(Object oldValue,Object newValue)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> find(oldValue);</span><br><span class="line">        <span class="keyword">if</span>(index == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        elementData[index] = newValue;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历数组中所有数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;&#123;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == size - <span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(elementData[i] + <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(elementData[i] + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Array</span> <span class="variable">arr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        arr.add(<span class="number">123</span>);</span><br><span class="line">        arr.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        arr.add(<span class="number">345</span>);</span><br><span class="line">        arr.add(<span class="number">345</span>);</span><br><span class="line">        arr.add(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line"></span><br><span class="line">        arr.delete(<span class="number">345</span>);</span><br><span class="line"></span><br><span class="line">        arr.update(<span class="number">345</span>,<span class="number">444</span>);</span><br><span class="line"></span><br><span class="line">        arr.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-链表"><a href="#3-链表" class="headerlink" title="3. 链表"></a>3. 链表</h2><h3 id="3-1-链表的特点"><a href="#3-1-链表的特点" class="headerlink" title="3.1 链表的特点"></a>3.1 链表的特点</h3><ul><li>逻辑结构：线性结构</li></ul><ul><li>物理结构：不要求连续的存储空间</li></ul><ul><li>存储特点：链表由一系列结点node（链表中每一个元素称为结点）组成，结点可以在代码执行过程中动态创建。每个结点包括两个部分：一个是存储数据元素的<code>数据域</code>，另一个是存储下一个结点地址的<code>指针域</code>。</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/image-20220511113744772-1661445988505.png" alt="image-20220511113744772"></p><ul><li>常见的链表结构有如下的形式：</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/1563448858180-1661445988506.png" alt="1563448858180"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/数据结构-链表.png" alt="数据结构-链表" style="zoom:50%;"></p><h3 id="3-2-自定义链表"><a href="#3-2-自定义链表" class="headerlink" title="3.2 自定义链表"></a>3.2 自定义链表</h3><h4 id="3-2-1-自定义单向链表"><a href="#3-2-1-自定义单向链表" class="headerlink" title="3.2.1 自定义单向链表"></a>3.2.1 自定义单向链表</h4><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/image-20221028195106363.png" alt="image-20221028195106363"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">单链表中的节点。</span></span><br><span class="line"><span class="comment">节点是单向链表中基本的单元。</span></span><br><span class="line"><span class="comment">每一个节点Node都有两个属性：</span></span><br><span class="line"><span class="comment">    一个属性：是存储的数据。</span></span><br><span class="line"><span class="comment">    另一个属性：是下一个节点的内存地址。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储的数据</span></span><br><span class="line">    Object data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个节点的内存地址</span></span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Object data, Node next)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">链表类(单向链表)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Link</span>&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头节点</span></span><br><span class="line">    Node header;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向链表中添加元素的方法（向末尾添加）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E data)</span>&#123;</span><br><span class="line">    <span class="comment">//public void add(Object data)&#123;</span></span><br><span class="line">        <span class="comment">// 创建一个新的节点对象</span></span><br><span class="line">        <span class="comment">// 让之前单链表的末尾节点next指向新节点对象。</span></span><br><span class="line">        <span class="comment">// 有可能这个元素是第一个，也可能是第二个，也可能是第三个。</span></span><br><span class="line">        <span class="keyword">if</span>(header == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 说明还没有节点。</span></span><br><span class="line">            <span class="comment">// new一个新的节点对象，作为头节点对象。</span></span><br><span class="line">            <span class="comment">// 这个时候的头节点既是一个头节点，又是一个末尾节点。</span></span><br><span class="line">            header = <span class="keyword">new</span> <span class="title class_">Node</span>(data, <span class="literal">null</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 说明头不是空！</span></span><br><span class="line">            <span class="comment">// 头节点已经存在了！</span></span><br><span class="line">            <span class="comment">// 找出当前末尾节点，让当前末尾节点的next是新节点。</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">currentLastNode</span> <span class="operator">=</span> findLast(header);</span><br><span class="line">            currentLastNode.next = <span class="keyword">new</span> <span class="title class_">Node</span>(data, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 专门查找末尾节点的方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">findLast</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果一个节点的next是null</span></span><br><span class="line">            <span class="comment">// 说明这个节点就是末尾节点。</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 程序能够到这里说明：node不是末尾节点。</span></span><br><span class="line">        <span class="keyword">return</span> findLast(node.next); <span class="comment">// 递归算法！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*// 删除链表中某个数据的方法</span></span><br><span class="line"><span class="comment">    public void remove(Object obj)&#123;</span></span><br><span class="line"><span class="comment">        //略</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 修改链表中某个数据的方法</span></span><br><span class="line"><span class="comment">    public void modify(Object newObj)&#123;</span></span><br><span class="line"><span class="comment">        //略</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 查找链表中某个元素的方法。</span></span><br><span class="line"><span class="comment">    public int find(Object obj)&#123;</span></span><br><span class="line"><span class="comment">        //略</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-自定义双向链表"><a href="#3-2-2-自定义双向链表" class="headerlink" title="3.2.2 自定义双向链表"></a>3.2.2 自定义双向链表</h4><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/image-20220514165707977-1661448081075.png" alt="image-20220514165707977"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">双向链表中的节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    Node prev;</span><br><span class="line">    E data;</span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    Node(Node prev, E data, Node next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表类(双向链表)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 15:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLinkedList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;E&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> Node first;  <span class="comment">//链表的首元素</span></span><br><span class="line">    <span class="keyword">private</span> Node last;   <span class="comment">//链表的尾元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> total;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(last, e, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(first == <span class="literal">null</span>)&#123;</span><br><span class="line">            first = newNode;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            last.next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        last = newNode;</span><br><span class="line">        total++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">find</span> <span class="operator">=</span> findNode(obj);</span><br><span class="line">        <span class="keyword">if</span>(find != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(find.prev != <span class="literal">null</span>)&#123;</span><br><span class="line">                find.prev.next = find.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                first = find.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(find.next != <span class="literal">null</span>)&#123;</span><br><span class="line">                find.next.prev = find.prev;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                last = find.prev;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            find.prev = <span class="literal">null</span>;</span><br><span class="line">            find.next = <span class="literal">null</span>;</span><br><span class="line">            find.data = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            total--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">findNode</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> first;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">find</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(node.data == <span class="literal">null</span>)&#123;</span><br><span class="line">                    find = node;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obj.equals(node.data))&#123;</span><br><span class="line">                    find = node;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> find;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findNode(obj) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(E old, E value)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">find</span> <span class="operator">=</span> findNode(old);</span><br><span class="line">        <span class="keyword">if</span>(find != <span class="literal">null</span>)&#123;</span><br><span class="line">            find.data = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt;&#123;</span><br><span class="line">        <span class="keyword">private</span> Node&lt;E&gt; node = first;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> node!=<span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">E</span> <span class="variable">value</span> <span class="operator">=</span> node.data;</span><br><span class="line">            node = node.next;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义双链表测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLinkedListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyLinkedList&lt;String&gt; my = <span class="keyword">new</span> <span class="title class_">MyLinkedList</span>&lt;&gt;();</span><br><span class="line">        my.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        my.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        my.add(<span class="literal">null</span>);</span><br><span class="line">        my.add(<span class="literal">null</span>);</span><br><span class="line">        my.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        my.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        my.add(<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;一共有：&quot;</span> + my.size());</span><br><span class="line">        System.out.println(<span class="string">&quot;所有元素：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : my) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;查找java,null,haha的结果：&quot;</span>);</span><br><span class="line">        System.out.println(my.contains(<span class="string">&quot;java&quot;</span>));</span><br><span class="line">        System.out.println(my.contains(<span class="literal">null</span>));</span><br><span class="line">        System.out.println(my.contains(<span class="string">&quot;haha&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;替换java,null后：&quot;</span>);</span><br><span class="line">        my.update(<span class="string">&quot;java&quot;</span>,<span class="string">&quot;JAVA&quot;</span>);</span><br><span class="line">        my.update(<span class="literal">null</span>,<span class="string">&quot;songhk&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;所有元素：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : my) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除hello，JAVA,null，atguigu后：&quot;</span>);</span><br><span class="line">        my.delete(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        my.delete(<span class="string">&quot;JAVA&quot;</span>);</span><br><span class="line">        my.delete(<span class="literal">null</span>);</span><br><span class="line">        my.delete(<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;所有元素：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : my) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-栈"><a href="#4-栈" class="headerlink" title="4. 栈"></a>4. 栈</h2><h3 id="4-1-栈的特点"><a href="#4-1-栈的特点" class="headerlink" title="4.1 栈的特点"></a>4.1 栈的特点</h3><ul><li><p>栈（Stack）又称为堆栈或堆叠，是限制仅在表的一端进行插入和删除运算的线性表。</p></li><li><p>栈按照<code>先进后出(FILO,first in last out)</code>的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶。每次删除（退栈）的总是删除当前栈中最后插入（进栈）的元素，而最先插入的是被放在栈的底部，要到最后才能删除。</p><p> <img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/image-20221028192349993.png" alt="image-20221028192349993"></p></li><li><p>核心类库中的栈结构有Stack和LinkedList。</p><ul><li>Stack就是顺序栈，它是Vector的子类。</li><li>LinkedList是链式栈。</li></ul></li><li><p>体现栈结构的操作方法：</p><ul><li>peek()方法：查看栈顶元素，不弹出</li><li>pop()方法：弹出栈</li><li>push(E e)方法：压入栈 </li></ul></li><li><p>时间复杂度:</p><ul><li>索引: <code>O(n)</code></li><li>搜索: <code>O(n)</code></li><li>插入: <code>O(1)</code></li><li>移除: <code>O(1)</code></li></ul></li><li><p>图示：</p></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/image-20220826010258638.png" alt="image-20220826010258638" style="zoom:80%;"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/数据结构-栈.png" alt="数据结构-栈" style="zoom:50%;"></p><h3 id="4-2-Stack使用举例"><a href="#4-2-Stack使用举例" class="headerlink" title="4.2 Stack使用举例"></a>4.2 Stack使用举例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 15:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStack</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 测试Stack</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        list.push(<span class="number">1</span>);</span><br><span class="line">        list.push(<span class="number">2</span>);</span><br><span class="line">        list.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;list.peek()=&quot;</span> + list.peek());</span><br><span class="line">        System.out.println(<span class="string">&quot;list.peek()=&quot;</span> + list.peek());</span><br><span class="line">        System.out.println(<span class="string">&quot;list.peek()=&quot;</span> + list.peek());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">System.out.println(&quot;list.pop() =&quot; + list.pop());</span></span><br><span class="line"><span class="comment">System.out.println(&quot;list.pop() =&quot; + list.pop());</span></span><br><span class="line"><span class="comment">System.out.println(&quot;list.pop() =&quot; + list.pop());</span></span><br><span class="line"><span class="comment">System.out.println(&quot;list.pop() =&quot; + list.pop());//java.util.NoSuchElementException</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!list.empty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;list.pop() =&quot;</span> + list.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 测试LinkedList</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        list.push(<span class="number">1</span>);</span><br><span class="line">        list.push(<span class="number">2</span>);</span><br><span class="line">        list.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;list.peek()=&quot;</span> + list.peek());</span><br><span class="line">        System.out.println(<span class="string">&quot;list.peek()=&quot;</span> + list.peek());</span><br><span class="line">        System.out.println(<span class="string">&quot;list.peek()=&quot;</span> + list.peek());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">System.out.println(&quot;list.pop() =&quot; + list.pop());</span></span><br><span class="line"><span class="comment">System.out.println(&quot;list.pop() =&quot; + list.pop());</span></span><br><span class="line"><span class="comment">System.out.println(&quot;list.pop() =&quot; + list.pop());</span></span><br><span class="line"><span class="comment">System.out.println(&quot;list.pop() =&quot; + list.pop());//java.util.NoSuchElementException</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="keyword">while</span>(!list.isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;list.pop() =&quot;</span> + list.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-自定义栈"><a href="#4-3-自定义栈" class="headerlink" title="4.3 自定义栈"></a>4.3 自定义栈</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    <span class="comment">// 向栈当中存储元素，我们这里使用一维数组模拟。存到栈中，就表示存储到数组中。</span></span><br><span class="line">    <span class="comment">// 为什么选择Object类型数组？因为这个栈可以存储java中的任何引用类型的数据</span></span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈帧，永远指向栈顶部元素</span></span><br><span class="line">    <span class="comment">// 那么这个默认初始值应该是多少。注意：最初的栈是空的，一个元素都没有。</span></span><br><span class="line">    <span class="comment">//private int index = 0; // 如果index采用0，表示栈帧指向了顶部元素的上方。</span></span><br><span class="line">    <span class="comment">//private int index = -1; // 如果index采用-1，表示栈帧指向了顶部元素。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无参数构造方法。默认初始化栈容量10.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 一维数组动态初始化</span></span><br><span class="line">        <span class="comment">// 默认初始化容量是10.</span></span><br><span class="line">        <span class="built_in">this</span>.elements = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">// 给index初始化</span></span><br><span class="line">        <span class="built_in">this</span>.index = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 压栈的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj 被压入的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= elements.length - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//方式1：</span></span><br><span class="line">            <span class="comment">//System.out.println(&quot;压栈失败，栈已满！&quot;);</span></span><br><span class="line">            <span class="comment">//return;</span></span><br><span class="line">            <span class="comment">//方式2：</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;压栈失败，栈已满！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 程序能够走到这里，说明栈没满</span></span><br><span class="line">        <span class="comment">// 向栈中加1个元素，栈帧向上移动一个位置。</span></span><br><span class="line">        index++;</span><br><span class="line">        elements[index] = obj;</span><br><span class="line">        System.out.println(<span class="string">&quot;压栈&quot;</span> + obj + <span class="string">&quot;元素成功，栈帧指向&quot;</span> + index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 弹栈的方法，从数组中往外取元素。每取出一个元素，栈帧向下移动一位。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//方式1：</span></span><br><span class="line">            <span class="comment">//System.out.println(&quot;弹栈失败，栈已空！&quot;);</span></span><br><span class="line">            <span class="comment">//return;</span></span><br><span class="line">            <span class="comment">//方式2：</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;弹栈失败，栈已空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 程序能够执行到此处说明栈没有空。</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> elements[index];</span><br><span class="line">        System.out.print(<span class="string">&quot;弹栈&quot;</span> + obj + <span class="string">&quot;元素成功，&quot;</span>);</span><br><span class="line">        elements[index] = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 栈帧向下移动一位。</span></span><br><span class="line">        index--;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set和get也许用不上，但是你必须写上，这是规矩。你使用IDEA生成就行了。</span></span><br><span class="line">    <span class="comment">// 封装：第一步：属性私有化，第二步：对外提供set和get方法。</span></span><br><span class="line">    <span class="keyword">public</span> Object[] getElements() &#123;</span><br><span class="line">        <span class="keyword">return</span> elements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setElements</span><span class="params">(Object[] elements)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elements = elements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-队列"><a href="#5-队列" class="headerlink" title="5. 队列"></a>5. 队列</h2><ul><li>队列（Queue）是只允许在一端进行插入，而在另一端进行删除的运算受限的线性表。</li></ul><ul><li>队列是逻辑结构，其物理结构可以是数组，也可以是链表。</li></ul><ul><li><p>队列的修改原则：队列的修改是依<code>先进先出（FIFO）的原则</code>进行的。新来的成员总是加入队尾（即不允许”加塞”），每次离开的成员总是队列头上的（不允许中途离队），即当前”最老的”成员离队。</p></li><li><p>图示：</p></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/image-20220826010241172.png" alt="image-20220826010241172"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/数据结构-队列.png" alt="数据结构-队列" style="zoom:50%;"></p><h2 id="6-树与二叉树"><a href="#6-树与二叉树" class="headerlink" title="6. 树与二叉树"></a>6. 树与二叉树</h2><h3 id="6-1-树的理解"><a href="#6-1-树的理解" class="headerlink" title="6.1 树的理解"></a>6.1 树的理解</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/image-20220521111904272.png" alt="image-20220521111904272" style="zoom:67%;"></p><p><strong>专有名词解释：</strong></p><p><code>结点</code>：树中的数据元素都称之为结点</p><p><code>根节点</code>：最上面的结点称之为根，一颗树只有一个根且由根发展而来，从另外一个角度来说，每个结点都可以认为是其子树的根</p><p><code>父节点</code>：结点的上层结点，如图中，结点K的父节点是E、结点L的父节点是G</p><p><code>子节点</code>：节点的下层结点，如图中，节点E的子节点是K节点、节点G的子节点是L节点</p><p><code>兄弟节点</code>：具有相同父节点的结点称为兄弟节点，图中F、G、H互为兄弟节点</p><p><code>结点的度数</code>：每个结点所拥有的子树的个数称之为结点的度，如结点B的度为3</p><p><code>树叶</code>：度数为0的结点，也叫作终端结点，图中D、K、F、L、H、I、J都是树叶</p><p><code>非终端节点（或分支节点）</code>：树叶以外的节点，或度数不为0的节点。图中根、A、B、C、E、G都是</p><p><code>树的深度（或高度）</code>：树中结点的最大层次数，图中树的深度为4</p><p><code>结点的层数</code>：从根节点到树中某结点所经路径上的分支树称为该结点的层数，根节点的层数规定为1，其余结点的层数等于其父亲结点的层数+1</p><p><code>同代</code>：在同一棵树中具有相同层数的节点</p><h3 id="6-2-二叉树的基本概念"><a href="#6-2-二叉树的基本概念" class="headerlink" title="6.2 二叉树的基本概念"></a>6.2 二叉树的基本概念</h3><p>二叉树（Binary tree）是树形结构的一个重要类型。二叉树特点是每个结点最多只能有两棵子树，且有左右之分。许多实际问题抽象出来的数据结构往往是二叉树形式，二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/1563449427345-1661447692846.png" alt="1563449427345"></p><h3 id="6-3-二叉树的遍历"><a href="#6-3-二叉树的遍历" class="headerlink" title="6.3 二叉树的遍历"></a>6.3 二叉树的遍历</h3><ul><li><p><strong>前序遍历：中左右（根左右）</strong></p><p>即先访问根结点，再前序遍历左子树，最后再前序遍历右子 树。前序遍历运算访问二叉树各结点是以根、左、右的顺序进行访问的。</p></li><li><p><strong>中序遍历：左中右（左根右）</strong></p><p>即先中前序遍历左子树，然后再访问根结点，最后再中序遍 历右子树。中序遍历运算访问二叉树各结点是以左、根、右的顺序进行访问的。</p></li><li><p><strong>后序遍历：左右中（左右根）</strong></p><p>即先后序遍历左子树，然后再后序遍历右子树，最后访问根 结点。后序遍历运算访问二叉树各结点是以左、右、根的顺序进行访问的。</p></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/1574575739236-1661447692846.png" alt="1574575739236" style="zoom:80%;"></p><p>前序遍历：ABDHIECFG</p><p>中序遍历：HDIBEAFCG</p><p>后序遍历：HIDEBFGCA</p><h3 id="6-4-经典二叉树"><a href="#6-4-经典二叉树" class="headerlink" title="6.4 经典二叉树"></a>6.4 经典二叉树</h3><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/image-20220521153016348.png" alt="image-20220521153016348" style="zoom: 67%;"></p><p>1、<code>满二叉树</code>： 除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树。 第n层的结点数是2的n-1次方，总的结点个数是2的n次方-1</p><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/1574575163883-1661447692846.png" alt="1574575163883"></p><p>2、<code>完全二叉树</code>： 叶结点只能出现在最底层的两层，且最底层叶结点均处于次底层叶结点的左侧。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/1574575180247-1661447692846.png" alt="1574575180247"></p><p>3、<code>二叉排序/查找/搜索树</code>：即为BST  (binary search/sort tree)。满足如下性质：<br>（1）若它的左子树不为空，则左子树上所有结点的值均小于它的根节点的值；<br>（2）若它的右子树上所有结点的值均大于它的根节点的值；<br>（3）它的左、右子树也分别为二叉排序/查找/搜索树。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/image-20220521145208018.png" alt="image-20220521145208018" style="zoom: 67%;"></p><blockquote><p>对二叉查找树进行中序遍历，得到有序集合。便于检索。</p></blockquote><p>4、<code>平衡二叉树</code>：（Self-balancing binary search tree，AVL）首先是二叉排序树，此外具有以下性质：<br>（1）它是一棵空树或它的左右两个子树的高度差的绝对值不超过1<br>（2）并且左右两个子树也都是一棵平衡二叉树<br>（3）不要求非叶节点都有两个子结点 </p><blockquote><p>平衡二叉树的目的是为了减少二叉查找树的层次，提高查找速度。平衡二叉树的常用实现有红黑树、AVL、替罪羊树、Treap、伸展树等。</p></blockquote><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/image-20220521150151219.png" alt="image-20220521150151219" style="zoom: 50%;"></p><p>6、<code>红黑树</code>：即Red-Black Tree。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。 </p><p>红黑树是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，它是在 1972 年由 Rudolf Bayer 发明的。红黑树是复杂的，但它的操作有着<code>良好的最坏情况运行时间</code>，并且在<code>实践中是高效的</code>：它可以在 O(log n)时间内做查找，插入和删除， 这里的 n 是树中元素的数目。</p><p>红黑树的特性：</p><ul><li>每个节点是红色或者黑色</li><li><p>根节点是黑色</p></li><li><p>每个叶子节点（NIL）是黑色。（注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点）</p></li><li><p>每个红色节点的两个子节点都是黑色的。(从每个叶子到根的所有路径上不能有两个连续的红色节点) </p></li><li><p>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点（确保没有一条路径会比其他路径长出2倍）</p></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/红黑树-1661447692846.jpeg" alt></p><p>当我们插入或删除节点时，可能会破坏已有的红黑树，使得它不满足以上5个要求，那么此时就需要进行处理，使得它继续满足以上的5个要求：</p><p>1、<code>recolor</code> ：将某个节点变红或变黑</p><p>2、<code>rotation</code> ：将红黑树某些结点分支进行旋转（左旋或右旋）</p><p> <img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/image-20221208212053079.png" alt="image-20221208212053079"></p><blockquote><p>红黑树可以通过红色节点和黑色节点尽可能的保证二叉树的平衡。主要是用它来存储有序的数据，它的时间复杂度是O(logN)，效率非常之高。</p></blockquote><h3 id="6-5-二叉树及其结点的表示"><a href="#6-5-二叉树及其结点的表示" class="headerlink" title="6.5 二叉树及其结点的表示"></a>6.5 二叉树及其结点的表示</h3><p>普通二叉树：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTree</span>&lt;E&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode root; <span class="comment">//二叉树的根结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> total;<span class="comment">//结点总个数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">        <span class="comment">//至少有以下几个部分</span></span><br><span class="line">        TreeNode parent;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        E data;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(TreeNode parent, TreeNode left, E data, TreeNode right)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.parent = parent;</span><br><span class="line">            <span class="built_in">this</span>.left = left;</span><br><span class="line">            <span class="built_in">this</span>.data = data;</span><br><span class="line">            <span class="built_in">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TreeMap红黑树：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeMap</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; left;</span><br><span class="line">        Entry&lt;K,V&gt; right;</span><br><span class="line">        Entry&lt;K,V&gt; parent;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">color</span> <span class="operator">=</span> BLACK;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Make a new cell with given key, value, and parent, and with</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@code</span> null&#125; child links, and BLACK color.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-List接口分析"><a href="#7-List接口分析" class="headerlink" title="7. List接口分析"></a>7. List接口分析</h2><h3 id="7-1-List接口特点"><a href="#7-1-List接口特点" class="headerlink" title="7.1 List接口特点"></a>7.1 List接口特点</h3><ul><li>List集合所有的元素是以一种<code>线性方式</code>进行存储的，例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。</li><li>它是一个元素<code>存取有序</code>的集合。即元素的存入顺序和取出顺序有保证。</li><li>它是一个<code>带有索引</code>的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li><li>集合中可以有<code>重复</code>的元素，通过元素的equals方法，来比较是否为重复的元素。</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/1563549818689-1661447917313.png" alt="1563549818689"></p><blockquote><p>注意：</p><p>List集合关心元素是否有序，而不关心是否重复，请大家记住这个原则。例如“张三”可以领取两个号。</p></blockquote><ul><li>List接口的主要实现类<ul><li>ArrayList：动态数组</li><li>Vector：动态数组</li><li>LinkedList：双向链表</li><li>Stack：栈</li></ul></li></ul><h3 id="7-2-动态数组ArrayList与Vector"><a href="#7-2-动态数组ArrayList与Vector" class="headerlink" title="7.2 动态数组ArrayList与Vector"></a>7.2 动态数组ArrayList与Vector</h3><p>Java的List接口的实现类中有两个动态数组的实现：ArrayList 和 Vector。</p><h4 id="7-2-1-ArrayList与Vector的区别"><a href="#7-2-1-ArrayList与Vector的区别" class="headerlink" title="7.2.1 ArrayList与Vector的区别"></a>7.2.1 ArrayList与Vector的区别</h4><p>它们的底层物理结构都是数组，我们称为动态数组。</p><ul><li>ArrayList是新版的动态数组，线程不安全，效率高，Vector是旧版的动态数组，线程安全，效率低。</li><li>动态数组的扩容机制不同，ArrayList默认扩容为原来的1.5倍，Vector默认扩容增加为原来的2倍。</li><li>数组的初始化容量，如果在构建ArrayList与Vector的集合对象时，没有显式指定初始化容量，那么Vector的内部数组的初始容量默认为10，而ArrayList在JDK 6.0 及之前的版本也是10，JDK8.0 之后的版本ArrayList初始化为长度为0的空数组，之后在添加第一个元素时，再创建长度为10的数组。原因：<ul><li>用的时候，再创建数组，避免浪费。因为很多方法的返回值是ArrayList类型，需要返回一个ArrayList的对象，例如：后期从数据库查询对象的方法，返回值很多就是ArrayList。有可能你要查询的数据不存在，要么返回null，要么返回一个没有元素的ArrayList对象。</li></ul></li></ul><h4 id="7-2-2-ArrayList部分源码分析"><a href="#7-2-2-ArrayList部分源码分析" class="headerlink" title="7.2.2 ArrayList部分源码分析"></a>7.2.2 ArrayList部分源码分析</h4><p><strong>JDK1.7.0_07中：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData; <span class="comment">//存储底层数组元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size; <span class="comment">//记录数组中存储的元素的个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">10</span>); <span class="comment">//指定初始容量为10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="comment">//检查初始容量的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+ initialCapacity);</span><br><span class="line">    <span class="comment">//数组初始化为长度为initialCapacity的数组</span></span><br><span class="line">    <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法：add()相关方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">//查看当前数组是否够多存一个元素</span></span><br><span class="line">    elementData[size++] = e; <span class="comment">//将元素e添加到elementData数组中</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 如果if条件满足，则进行数组的扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length; <span class="comment">//当前数组容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); <span class="comment">//新数组容量是旧数组容量的1.5倍</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)  <span class="comment">//判断旧数组的1.5倍是否够</span></span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">//判断旧数组的1.5倍是否超过最大数组限制</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">//复制一个新数组</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法：remove()相关方法</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    rangeCheck(index); <span class="comment">//判断index是否在有效的范围内</span></span><br><span class="line"></span><br><span class="line">    modCount++; <span class="comment">//修改次数加1</span></span><br><span class="line">    <span class="comment">//取出[index]位置的元素，[index]位置的元素就是要被删除的元素，用于最后返回被删除的元素</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index); </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>; <span class="comment">//确定要移动的次数</span></span><br><span class="line">    <span class="comment">//如果需要移动元素，就用System.arraycopy移动元素</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    <span class="comment">//将elementData[size-1]位置置空，让GC回收空间，元素个数减少</span></span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheck</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size) <span class="comment">//index不合法的情况</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E <span class="title function_">elementData</span><span class="params">(<span class="type">int</span> index)</span> &#123; <span class="comment">//返回指定位置的元素</span></span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法：set()方法相关</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    rangeCheck(index); <span class="comment">//检验index是否合法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//取出[index]位置的元素，[index]位置的元素就是要被替换的元素，用于最后返回被替换的元素</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    <span class="comment">//用element替换[index]位置的元素</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法：get()相关方法</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    rangeCheck(index); <span class="comment">//检验index是否合法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index); <span class="comment">//返回[index]位置的元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法：indexOf()</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="comment">//分为o是否为空两种情况</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//从前往后找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法：lastIndexOf()</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="comment">//分为o是否为空两种情况</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//从后往前找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>jdk1.8.0_271中：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//属性</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;  <span class="comment">//初始化为空数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法:add()相关方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">//查看当前数组是否够多存一个元素</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//存入新元素到[size]位置，然后size自增1</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">//如果当前数组还是空数组</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="comment">//那么minCapacity取DEFAULT_CAPACITY与minCapacity的最大值</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看是否需要扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;  <span class="comment">//修改次数加1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果需要的最小容量比当前数组的长度大，即当前数组不够存，就扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length; <span class="comment">//当前数组容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); <span class="comment">//新数组容量是旧数组容量的1.5倍</span></span><br><span class="line">    <span class="comment">//看旧数组的1.5倍是否够</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">//看旧数组的1.5倍是否超过最大数组限制</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">//复制一个新数组</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-2-3-ArrayList相关方法图示"><a href="#7-2-3-ArrayList相关方法图示" class="headerlink" title="7.2.3 ArrayList相关方法图示"></a>7.2.3 ArrayList相关方法图示</h4><ul><li><strong>ArrayList采用数组作为底层实现</strong></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/image-20221029112037297.png" alt="image-20221029112037297" style="zoom:80%;"></p><ul><li><strong>ArrayList自动扩容过程</strong></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/image-20221029112107691.png" alt="image-20221029112107691" style="zoom:80%;"></p><ul><li><strong>ArrayList的add(E e)方法</strong></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/image-20221029112129161.png" alt="image-20221029112129161" style="zoom:80%;"></p><ul><li><strong>ArrayList的add(int index,E e)方法</strong></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/image-20221029112157007.png" alt="image-20221029112157007" style="zoom:80%;"></p><h4 id="7-2-4-Vector部分源码分析"><a href="#7-2-4-Vector部分源码分析" class="headerlink" title="7.2.4 Vector部分源码分析"></a>7.2.4 Vector部分源码分析</h4><p><strong>jdk1.8.0_271中：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//属性</span></span><br><span class="line"><span class="keyword">protected</span> Object[] elementData;</span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> elementCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">this</span>(<span class="number">10</span>); <span class="comment">//指定初始容量initialCapacity为10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>(initialCapacity, <span class="number">0</span>); <span class="comment">//指定capacityIncrement增量为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">int</span> capacityIncrement)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="comment">//判断了形参初始容量initialCapacity的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+ initialCapacity);</span><br><span class="line">    <span class="comment">//创建了一个Object[]类型的数组</span></span><br><span class="line">    <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    <span class="comment">//增量，默认是0，如果是0，后面就按照2倍增加，如果不是0，后面就按照你指定的增量进行增量</span></span><br><span class="line">    <span class="built_in">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法：add()相关方法</span></span><br><span class="line"><span class="comment">//synchronized意味着线程安全的   </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//看是否需要扩容</span></span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//把新的元素存入[elementCount]，存入后，elementCount元素的个数增1</span></span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityHelper</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">     <span class="comment">//看是否超过了当前数组的容量</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity); <span class="comment">//扩容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length; <span class="comment">//获取目前数组的长度</span></span><br><span class="line">    <span class="comment">//如果capacityIncrement增量是0，新容量 = oldCapacity的2倍</span></span><br><span class="line">    <span class="comment">//如果capacityIncrement增量是不是0，新容量 = oldCapacity + capacityIncrement增量;</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="comment">//如果按照上面计算的新容量还不够，就按照你指定的需要的最小容量来扩容minCapacity</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">//如果新容量超过了最大数组限制，那么单独处理</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">//把旧数组中的数据复制到新数组中，新数组的长度为newCapacity</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法：remove()相关方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> removeElement(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">removeElement</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//查找obj在当前Vector中的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexOf(obj);</span><br><span class="line">    <span class="comment">//如果i&gt;=0，说明存在，删除[i]位置的元素</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        removeElementAt(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法：indexOf()</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;<span class="comment">//要查找的元素是null值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index ; i &lt; elementCount ; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)<span class="comment">//如果是null值，用==null判断</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//要查找的元素是非null值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index ; i &lt; elementCount ; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))<span class="comment">//如果是非null值，用equals判断</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法：removeElementAt()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">removeElementAt</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//判断下标的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index + <span class="string">&quot; &gt;= &quot;</span> +</span><br><span class="line">                                                 elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//j是要移动的元素的个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> elementCount - index - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果需要移动元素，就调用System.arraycopy进行移动</span></span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//把index+1位置以及后面的元素往前移动</span></span><br><span class="line">        <span class="comment">//index+1的位置的元素移动到index位置，依次类推</span></span><br><span class="line">        <span class="comment">//一共移动j个</span></span><br><span class="line">        System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//元素的总个数减少</span></span><br><span class="line">    elementCount--;</span><br><span class="line">    <span class="comment">//将elementData[elementCount]这个位置置空，用来添加新元素，位置的元素等着被GC回收</span></span><br><span class="line">    elementData[elementCount] = <span class="literal">null</span>; <span class="comment">/* to let gc do its work */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-链表LinkedList"><a href="#7-3-链表LinkedList" class="headerlink" title="7.3 链表LinkedList"></a>7.3 链表LinkedList</h3><p>Java中有双链表的实现：LinkedList，它是List接口的实现类。</p><p>LinkedList是一个<code>双向链表</code>，如图所示：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/image-20220514165707977-1661448081075.png" alt="image-20220514165707977"></p><h4 id="7-3-1-链表与动态数组的区别"><a href="#7-3-1-链表与动态数组的区别" class="headerlink" title="7.3.1 链表与动态数组的区别"></a>7.3.1 链表与动态数组的区别</h4><p>动态数组底层的物理结构是数组，因此根据索引访问的效率非常高。但是非末尾位置的插入和删除效率不高，因为涉及到移动元素。另外添加操作时涉及到扩容问题，就会增加时空消耗。</p><p>链表底层的物理结构是链表，因此根据索引访问的效率不高，即查找元素慢。但是插入和删除不需要移动元素，只需要修改前后元素的指向关系即可，所以插入、删除元素快。而且链表的添加不会涉及到扩容问题。</p><h4 id="7-3-2-LinkedList源码分析"><a href="#7-3-2-LinkedList源码分析" class="headerlink" title="7.3.2 LinkedList源码分析"></a>7.3.2 LinkedList源码分析</h4><p><strong>jdk1.8.0_271中：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//属性</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first; <span class="comment">//记录第一个结点的位置</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last; <span class="comment">//记录当前链表的尾元素</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//记录最后一个结点的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法：add()相关方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkLast(e); <span class="comment">//默认把新元素链接到链表尾部</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last; <span class="comment">//用 l 记录原来的最后一个结点</span></span><br><span class="line">    <span class="comment">//创建新结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//现在的新结点是最后一个结点了</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">//如果l==null，说明原来的链表是空的</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//那么新结点同时也是第一个结点</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//否则把新结点链接到原来的最后一个结点的next中</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    <span class="comment">//元素个数增加</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">//修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其中，Node类定义如下</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item; <span class="comment">//元素数据</span></span><br><span class="line">    Node&lt;E&gt; next; <span class="comment">//下一个结点</span></span><br><span class="line">    Node&lt;E&gt; prev; <span class="comment">//前一个结点</span></span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法：获取get()相关方法</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//方法：插入add()相关方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    checkPositionIndex(index);<span class="comment">//检查index范围</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)<span class="comment">//如果index==size，连接到当前链表的尾部</span></span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">index &lt; (size &gt;&gt; 1)采用二分思想，先将index与长度size的一半比较，如果index&lt;size/2，就只从位置0</span></span><br><span class="line"><span class="comment">往后遍历到位置index处，而如果index&gt;size/2，就只从位置size往前遍历到位置index处。这样可以减少一部</span></span><br><span class="line"><span class="comment">分不必要的遍历。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="comment">//如果index&lt;size/2，就从前往后找目标结点</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则从后往前找目标结点</span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把新结点插入到[index]位置的结点succ前面</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> &#123;<span class="comment">//succ是[index]位置对应的结点</span></span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev; <span class="comment">//[index]位置的前一个结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//新结点的prev是原来[index]位置的前一个结点</span></span><br><span class="line">    <span class="comment">//新结点的next是原来[index]位置的结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, succ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[index]位置对应的结点的prev指向新结点</span></span><br><span class="line">    succ.prev = newNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果原来[index]位置对应的结点是第一个结点，那么现在新结点是第一个结点</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;<span class="comment">//原来[index]位置的前一个结点的next指向新结点</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法：remove()相关方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="comment">//分o是否为空两种情况</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//找到o对应的结点x</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="literal">null</span>) &#123;</span><br><span class="line">                unlink(x);<span class="comment">//删除x结点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//找到o对应的结点x</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);<span class="comment">//删除x结点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span> &#123;<span class="comment">//x是要被删除的结点</span></span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;<span class="comment">//被删除结点的数据</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;<span class="comment">//被删除结点的下一个结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;<span class="comment">//被删除结点的上一个结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果被删除结点的前面没有结点，说明被删除结点是第一个结点</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//那么被删除结点的下一个结点变为第一个结点</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//被删除结点不是第一个结点</span></span><br><span class="line">        <span class="comment">//被删除结点的上一个结点的next指向被删除结点的下一个结点</span></span><br><span class="line">        prev.next = next;</span><br><span class="line">        <span class="comment">//断开被删除结点与上一个结点的链接</span></span><br><span class="line">        x.prev = <span class="literal">null</span>;<span class="comment">//使得GC回收</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果被删除结点的后面没有结点，说明被删除结点是最后一个结点</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//那么被删除结点的上一个结点变为最后一个结点</span></span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//被删除结点不是最后一个结点</span></span><br><span class="line">        <span class="comment">//被删除结点的下一个结点的prev执行被删除结点的上一个结点</span></span><br><span class="line">        next.prev = prev;</span><br><span class="line">        <span class="comment">//断开被删除结点与下一个结点的连接</span></span><br><span class="line">        x.next = <span class="literal">null</span>;<span class="comment">//使得GC回收</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把被删除结点的数据也置空，使得GC回收</span></span><br><span class="line">    x.item = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//元素个数减少</span></span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">//修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//返回被删除结点的数据</span></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123; <span class="comment">//index是要删除元素的索引位置</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-3-3-LinkedList相关方法图示"><a href="#7-3-3-LinkedList相关方法图示" class="headerlink" title="7.3.3 LinkedList相关方法图示"></a>7.3.3 LinkedList相关方法图示</h4><ul><li><strong>只有1个元素的LinkedList</strong></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/image-20221029134437888.png" alt="image-20221029134437888" style="zoom:80%;"></p><ul><li><strong>包含4个元素的LinkedList</strong></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/image-20221029134534198.png" alt="image-20221029134534198" style="zoom:80%;"></p><ul><li><strong>add(E e)方法</strong></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/image-20221029135013377.png" alt="image-20221029135013377" style="zoom:80%;"></p><ul><li><strong>add(int index,E e)方法</strong></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/image-20221029135045120.png" alt="image-20221029135045120" style="zoom:80%;"></p><ul><li><strong>remove(Object obj)方法</strong></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/image-20221029134721089.png" alt="image-20221029134721089" style="zoom:80%;"></p><ul><li><strong>remove(int index)方法</strong></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/image-20221029134807613.png" alt="image-20221029134807613" style="zoom:80%;"></p><h2 id="8-Map接口分析"><a href="#8-Map接口分析" class="headerlink" title="8. Map接口分析"></a>8. Map接口分析</h2><h3 id="8-1-哈希表的物理结构"><a href="#8-1-哈希表的物理结构" class="headerlink" title="8.1 哈希表的物理结构"></a>8.1 哈希表的物理结构</h3><p>HashMap和Hashtable底层都是哈希表（也称散列表），其中维护了一个长度为<strong>2的幂次方</strong>的Entry类型的数组table，数组的每一个索引位置被称为一个桶(bucket)，你添加的映射关系(key,value)最终都被封装为一个Map.Entry类型的对象，放到某个table[index]桶中。</p><p>使用数组的目的是查询和添加的效率高，可以根据索引直接定位到某个table[index]。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/image-20221029144811305.png" alt="image-20221029144811305" style="zoom:80%;"></p><h3 id="8-2-HashMap中数据添加过程"><a href="#8-2-HashMap中数据添加过程" class="headerlink" title="8.2 HashMap中数据添加过程"></a>8.2 HashMap中数据添加过程</h3><h4 id="8-2-1-JDK7中过程分析"><a href="#8-2-1-JDK7中过程分析" class="headerlink" title="8.2.1 JDK7中过程分析"></a>8.2.1 JDK7中过程分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在底层创建了长度为16的Entry[] table的数组</span></span><br><span class="line"><span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>(); </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.put(key1,value1);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分析过程如下：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">将(key1,value1)添加到当前hashmap的对象中。首先会调用key1所在类的hashCode()方法，计算key1的哈希值1，</span></span><br><span class="line"><span class="comment">此哈希值1再经过某种运算(hash())，得到哈希值2。此哈希值2再经过某种运算(indexFor())，确定在底层table数组中的索引位置i。</span></span><br><span class="line"><span class="comment">   （1）如果数组索引为i上的数据为空，则(key1,value1)直接添加成功   ------位置1</span></span><br><span class="line"><span class="comment">   （2）如果数组索引为i上的数据不为空，有(key2,value2)，则需要进一步判断：</span></span><br><span class="line"><span class="comment">       判断key1的哈希值2与key2的哈希值是否相同：</span></span><br><span class="line"><span class="comment">         （3） 如果哈希值不同，则(key1,value1)直接添加成功   ------位置2</span></span><br><span class="line"><span class="comment">              如果哈希值相同，则需要继续调用key1所在类的equals()方法，将key2放入equals()形参进行判断</span></span><br><span class="line"><span class="comment">                （4） equals方法返回false : 则(key1,value1)直接添加成功   ------位置3</span></span><br><span class="line"><span class="comment">                      equals方法返回true : 默认情况下，value1会覆盖value2。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">位置1：直接将(key1,value1)以Entry对象的方式存放到table数组索引i的位置。</span></span><br><span class="line"><span class="comment">位置2、位置3：(key1,value1) 与现有的元素以链表的方式存储在table数组索引i的位置，新添加的元素指向旧添加的元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">在不断的添加的情况下，满足如下条件的情况下，会进行扩容:</span></span><br><span class="line"><span class="comment">if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) :</span></span><br><span class="line"><span class="comment">默认情况下，当要添加的元素个数超过12(即：数组的长度 * loadFactor得到的结果)时，就要考虑扩容。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">补充：jdk7源码中定义的：</span></span><br><span class="line"><span class="comment">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.get(key1);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">① 计算key1的hash值，用这个方法hash(key1)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">② 找index = table.length-1 &amp; hash;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">③ 如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就返回它的value</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.remove(key1);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">① 计算key1的hash值，用这个方法hash(key1)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">② 找index = table.length-1 &amp; hash;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">③ 如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就删除它，把它前面的Entry的next的值修改为被删除Entry的next</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="8-2-2-JDK8中过程分析"><a href="#8-2-2-JDK8中过程分析" class="headerlink" title="8.2.2 JDK8中过程分析"></a>8.2.2 JDK8中过程分析</h4><p>下面说明是JDK8相较于JDK7的不同之处：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">①</span></span><br><span class="line"><span class="comment">使用HashMap()的构造器创建对象时，并没有在底层初始化长度为16的table数组。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">②</span></span><br><span class="line"><span class="comment">jdk8中添加的key,value封装到了HashMap.Node类的对象中。而非jdk7中的HashMap.Entry。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">③</span></span><br><span class="line"><span class="comment">jdk8中新增的元素所在的索引位置如果有其他元素。在经过一系列判断后，如果能添加，则是旧的元素指向新的元素。而非jdk7中的新的元素指向旧的元素。“七上八下”</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">④</span></span><br><span class="line"><span class="comment">jdk7时底层的数据结构是：数组+单向链表。 而jdk8时，底层的数据结构是：数组+单向链表+红黑树。</span></span><br><span class="line"><span class="comment">红黑树出现的时机：当某个索引位置i上的链表的长度达到8，且数组的长度超过64时，此索引位置上的元素要从单向链表改为红黑树。</span></span><br><span class="line"><span class="comment">如果索引i位置是红黑树的结构，当不断删除元素的情况下，当前索引i位置上的元素的个数低于6时，要从红黑树改为单向链表。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="8-3-HashMap源码剖析"><a href="#8-3-HashMap源码剖析" class="headerlink" title="8.3 HashMap源码剖析"></a>8.3 HashMap源码剖析</h3><h4 id="8-3-1-JDK1-7-0-07中源码"><a href="#8-3-1-JDK1-7-0-07中源码" class="headerlink" title="8.3.1 JDK1.7.0_07中源码"></a>8.3.1 JDK1.7.0_07中源码</h4><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/image-20220514190849626-1661448231966.png" alt="image-20220514190849626"></p><h5 id="1、Entry"><a href="#1、Entry" class="headerlink" title="1、Entry"></a><strong>1、Entry</strong></h5><p>key-value被封装为HashMap.Entry类型，而这个类型实现了Map.Entry接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt;&#123;</span><br><span class="line">    <span class="keyword">transient</span> Entry&lt;K,V&gt;[] table;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line">        <span class="type">int</span> hash;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates new entry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Entry(<span class="type">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">            value = v;</span><br><span class="line">            next = n;</span><br><span class="line">            key = k;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2、属性"><a href="#2、属性" class="headerlink" title="2、属性"></a><strong>2、属性</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//table数组的默认初始化长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"><span class="comment">//哈希表</span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">//哈希表中key-value的个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"><span class="comment">//临界值、阈值（扩容的临界值）</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"><span class="comment">//加载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line"><span class="comment">//默认加载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure><h5 id="3、构造器"><a href="#3、构造器" class="headerlink" title="3、构造器"></a><strong>3、构造器</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//DEFAULT_INITIAL_CAPACITY：默认初始容量16</span></span><br><span class="line">  <span class="comment">//DEFAULT_LOAD_FACTOR：默认加载因子0.75</span></span><br><span class="line">    <span class="built_in">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="comment">//校验initialCapacity合法性</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">    <span class="comment">//校验initialCapacity合法性 </span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">//校验loadFactor合法性</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算得到table数组的长度（保证capacity是2的整次幂）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (capacity &lt; initialCapacity)</span><br><span class="line">        capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"><span class="comment">//加载因子，初始化为0.75</span></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">// threshold 初始为默认容量</span></span><br><span class="line">    threshold = (<span class="type">int</span>)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//初始化table数组</span></span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>[capacity];</span><br><span class="line">    useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">                                       (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4、put-方法"><a href="#4、put-方法" class="headerlink" title="4、put()方法"></a><strong>4、put()方法</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">//如果key是null，单独处理，存储到table[0]中，如果有另一个key为null，value覆盖</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="comment">//对key的hashCode进行干扰，算出一个hash值</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      hashCode值        xxxxxxxxxx</span></span><br><span class="line"><span class="comment">      table.length-1    000001111</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">      hashCode值 xxxxxxxxxx  无符号右移几位和原来的hashCode值做^运算，使得hashCode高位二进制值参与计算，</span></span><br><span class="line"><span class="comment">                            也发挥作用，降低index冲突的概率。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="comment">//计算新的映射关系应该存到table[i]位置，</span></span><br><span class="line">    <span class="comment">//i = hash &amp; table.length-1，可以保证i在[0,table.length-1]范围内</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">//检查table[i]下面有没有key与我新的映射关系的key重复，如果重复替换value</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//添加新的映射关系</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果key是null，直接存入[0]的位置</span></span><br><span class="line"><span class="keyword">private</span> V <span class="title function_">putForNullKey</span><span class="params">(V value)</span> &#123;</span><br><span class="line">    <span class="comment">//判断是否有重复的key，如果有重复的，就替换value</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//把新的映射关系存入[0]的位置，而且key的hash值用0表示</span></span><br><span class="line">    addEntry(<span class="number">0</span>, <span class="literal">null</span>, value, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (useAltHashing) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">        &#125;</span><br><span class="line">        h = hashSeed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    <span class="comment">//判断是否需要库容</span></span><br><span class="line">    <span class="comment">//扩容：（1）size达到阈值（2）table[i]正好非空</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        <span class="comment">//table扩容为原来的2倍，并且扩容后，会重新调整所有key-value的存储位置</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length); </span><br><span class="line">        <span class="comment">//新的key-value的hash和index也会重新计算</span></span><br><span class="line">        hash = (<span class="literal">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//存入table中</span></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">createEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">//原来table[i]下面的映射关系作为新的映射关系next</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">    <span class="comment">//个数增加</span></span><br><span class="line">    size++; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-2-JDK1-8-0-271中源码"><a href="#8-3-2-JDK1-8-0-271中源码" class="headerlink" title="8.3.2 JDK1.8.0_271中源码"></a>8.3.2 JDK1.8.0_271中源码</h4><h5 id="1、Node"><a href="#1、Node" class="headerlink" title="1、Node"></a><strong>1、Node</strong></h5><p>key-value被封装为HashMap.Node类型或HashMap.TreeNode类型，它俩都直接或间接的实现了Map.Entry接口。</p><p>存储到table数组的可能是Node结点对象，也可能是TreeNode结点对象，它们也是Map.Entry接口的实现类。即table[index]下的映射关系可能串起来一个链表或一棵红黑树。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/image-20220514190904009-1661448231966.png" alt="image-20220514190904009"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt;&#123;</span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Node类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.hash = hash;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其它结构：略</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//TreeNode类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;</span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;</span><br><span class="line">        <span class="type">boolean</span> red; <span class="comment">//是红结点还是黑结点</span></span><br><span class="line">        TreeNode(<span class="type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">super</span>(hash, key, val, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2、属性-1"><a href="#2、属性-1" class="headerlink" title="2、属性"></a><strong>2、属性</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// 默认的初始容量 16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>; <span class="comment">//最大容量  1 &lt;&lt; 30</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;  <span class="comment">//默认加载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>; <span class="comment">//默认树化阈值8，当链表的长度达到这个值后，要考虑树化</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;<span class="comment">//默认反树化阈值6，当树中结点的个数达到此阈值后，要考虑变为链表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当单个的链表的结点个数达到8，并且table的长度达到64，才会树化。</span></span><br><span class="line"><span class="comment">//当单个的链表的结点个数达到8，但是table的长度未达到64，会先扩容</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>; <span class="comment">//最小树化容量64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table; <span class="comment">//数组</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;  <span class="comment">//记录有效映射关系的对数，也是Entry对象的个数</span></span><br><span class="line"><span class="type">int</span> threshold; <span class="comment">//阈值，当size达到阈值时，考虑扩容</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor; <span class="comment">//加载因子，影响扩容的频率</span></span><br></pre></td></tr></table></figure><h5 id="3、构造器-1"><a href="#3、构造器-1" class="headerlink" title="3、构造器"></a><strong>3、构造器</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted (其他字段都是默认值)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4、put-方法-1"><a href="#4、put-方法-1" class="headerlink" title="4、put()方法"></a><strong>4、put()方法</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">//如果key是null，hash是0</span></span><br><span class="line"><span class="comment">//如果key非null，用key的hashCode值 与 key的hashCode值高16进行异或</span></span><br><span class="line"><span class="comment">//即就是用key的hashCode值高16位与低16位进行了异或的干扰运算</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">index = hash &amp; table.length-1</span></span><br><span class="line"><span class="comment">如果用key的原始的hashCode值  与 table.length-1 进行按位与，那么基本上高16没机会用上。</span></span><br><span class="line"><span class="comment">这样就会增加冲突的概率，为了降低冲突的概率，把高16位加入到hash信息中。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,<span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="comment">//数组</span></span><br><span class="line">    Node&lt;K,V&gt; p;  <span class="comment">//一个结点</span></span><br><span class="line">    <span class="type">int</span> n, i; <span class="comment">//n是数组的长度   i是下标</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//tab和table等价</span></span><br><span class="line"><span class="comment">//如果table是空的</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)&#123;</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">tab = resize();</span></span><br><span class="line"><span class="comment">n = tab.length;*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果table是空的，resize()完成了①创建了一个长度为16的数组②threshold = 12</span></span><br><span class="line"><span class="comment">n = 16</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//i = (n - 1) &amp; hash ，下标 = 数组长度-1 &amp; hash</span></span><br><span class="line"><span class="comment">//p = tab[i] 第1个结点</span></span><br><span class="line"><span class="comment">//if(p==null) 条件满足的话说明 table[i]还没有元素</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//把新的映射关系直接放入table[i]</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//newNode（）方法就创建了一个Node类型的新结点，新结点的next是null</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//p是table[i]中第一个结点</span></span><br><span class="line"><span class="comment">//if(table[i]的第一个结点与新的映射关系的key重复)</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;<span class="comment">//用e记录这个table[i]的第一个结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)&#123; <span class="comment">//如果table[i]第一个结点是一个树结点</span></span><br><span class="line">            <span class="comment">//单独处理树结点</span></span><br><span class="line">            <span class="comment">//如果树结点中，有key重复的，就返回那个重复的结点用e接收，即e!=null</span></span><br><span class="line">            <span class="comment">//如果树结点中，没有key重复的，就把新结点放到树中，并且返回null，即e=null</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//table[i]的第一个结点不是树结点，也与新的映射关系的key不重复</span></span><br><span class="line"><span class="comment">//binCount记录了table[i]下面的结点的个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//如果p的下一个结点是空的，说明当前的p是最后一个结点</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//把新的结点连接到table[i]的最后</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">//如果binCount&gt;=8-1，达到7个时</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">//要么扩容，要么树化</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果key重复了，就跳出for循环，此时e结点记录的就是那个key重复的结点</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;<span class="comment">//下一次循环，e=p.next，就类似于e=e.next，往链表下移动</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果这个e不是null，说明有key重复，就考虑替换原来的value</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e); <span class="comment">//什么也没干</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//元素个数增加</span></span><br><span class="line"><span class="comment">//size达到阈值</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize(); <span class="comment">//一旦扩容，重新调整所有映射关系的位置</span></span><br><span class="line">    afterNodeInsertion(evict); <span class="comment">//什么也没干</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table; <span class="comment">//oldTab原来的table</span></span><br><span class="line">    <span class="comment">//oldCap：原来数组的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">//oldThr：原来的阈值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;<span class="comment">//最开始threshold是0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//newCap，新容量</span></span><br><span class="line"><span class="comment">//newThr：新阈值</span></span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123; <span class="comment">//说明原来不是空数组</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123; <span class="comment">//是否达到数组最大限制</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">//newCap = 旧的容量*2 ，新容量&lt;最大数组容量限制</span></span><br><span class="line"><span class="comment">//新容量：32,64，...</span></span><br><span class="line"><span class="comment">//oldCap &gt;= 初始容量16</span></span><br><span class="line"><span class="comment">//新阈值重新算 = 24，48 ....</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY; <span class="comment">//新容量是默认初始化容量16</span></span><br><span class="line">        <span class="comment">//新阈值= 默认的加载因子 * 默认的初始化容量 = 0.75*16 = 12</span></span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr; <span class="comment">//阈值赋值为新阈值12，24.。。。</span></span><br><span class="line">    <span class="comment">//创建了一个新数组，长度为newCap，16，32,64.。。</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123; <span class="comment">//原来不是空数组</span></span><br><span class="line">        <span class="comment">//把原来的table中映射关系，倒腾到新的table中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;<span class="comment">//e是table下面的结点</span></span><br><span class="line">                oldTab[j] = <span class="literal">null</span>; <span class="comment">//把旧的table[j]位置清空</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>) <span class="comment">//如果是最后一个结点</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e; <span class="comment">//重新计算e的在新table中的存储位置，然后放入</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode) <span class="comment">//如果e是树结点</span></span><br><span class="line">                    <span class="comment">//把原来的树拆解，放到新的table</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">//把原来table[i]下面的整个链表，重新挪到了新的table中</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node&lt;K,V&gt; <span class="title function_">newNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个新结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; </span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//MIN_TREEIFY_CAPACITY：最小树化容量64</span></span><br><span class="line">    <span class="comment">//如果table是空的，或者  table的长度没有达到64</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();<span class="comment">//先扩容</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//用e记录table[index]的结点的地址</span></span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">do...while，把table[index]链表的Node结点变为TreeNode类型的结点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                hd = p;<span class="comment">//hd记录根结点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果table[index]下面不是空</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">            hd.treeify(tab);<span class="comment">//将table[index]下面的链表进行树化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/image-20220524142524796-1661448231966.png" alt="image-20220524142524796"></p><h3 id="8-4-LinkedHashMap源码剖析"><a href="#8-4-LinkedHashMap源码剖析" class="headerlink" title="8.4 LinkedHashMap源码剖析"></a>8.4 LinkedHashMap源码剖析</h3><h4 id="8-4-1-源码"><a href="#8-4-1-源码" class="headerlink" title="8.4.1 源码"></a>8.4.1 源码</h4><p>内部定义的Entry如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">Entry&lt;K,V&gt; before, after;</span><br><span class="line"></span><br><span class="line">Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line"><span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LinkedHashMap重写了HashMap中的newNode()方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node&lt;K,V&gt; <span class="title function_">newNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeNode&lt;K,V&gt; <span class="title function_">newTreeNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;(hash, key, value, next);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-4-2-图示"><a href="#8-4-2-图示" class="headerlink" title="8.4.2 图示"></a>8.4.2 图示</h4><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/image-20221029145708224.png" alt="image-20221029145708224" style="zoom:80%;"></p><h2 id="9-Set接口分析"><a href="#9-Set接口分析" class="headerlink" title="9. Set接口分析"></a>9. Set接口分析</h2><h3 id="9-1-Set集合与Map集合的关系"><a href="#9-1-Set集合与Map集合的关系" class="headerlink" title="9.1 Set集合与Map集合的关系"></a>9.1 Set集合与Map集合的关系</h3><p>Set的内部实现其实是一个Map，Set中的元素，存储在HashMap的key中。即HashSet的内部实现是一个HashMap，TreeSet的内部实现是一个TreeMap，LinkedHashSet的内部实现是一个LinkedHashMap。</p><h3 id="9-2-源码剖析"><a href="#9-2-源码剖析" class="headerlink" title="9.2 源码剖析"></a>9.2 源码剖析</h3><p><strong>HashSet源码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个构造器是给子类LinkedHashSet调用的</span></span><br><span class="line">HashSet(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//add()方法：</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其中，</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//iterator()方法：</span></span><br><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LinkedHashSet源码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="number">16</span>, <span class="number">.75f</span>, <span class="literal">true</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity, <span class="number">.75f</span>, <span class="literal">true</span>);<span class="comment">//调用HashSet的某个构造器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity, loadFactor, <span class="literal">true</span>);<span class="comment">//调用HashSet的某个构造器</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>TreeSet源码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;</span><br><span class="line">    <span class="built_in">this</span>.m = m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其中，</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="comment">//add()方法：</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其中，</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure><h2 id="10-【拓展】HashMap的相关问题"><a href="#10-【拓展】HashMap的相关问题" class="headerlink" title="10. 【拓展】HashMap的相关问题"></a>10. 【拓展】HashMap的相关问题</h2><h4 id="1、说说你理解的哈希算法"><a href="#1、说说你理解的哈希算法" class="headerlink" title="1、说说你理解的哈希算法"></a>1、说说你理解的哈希算法</h4><p>hash算法是一种可以从任何数据中提取出其“指纹”的数据摘要算法，它将任意大小的数据映射到一个固定大小的序列上，这个序列被称为hash code、数据摘要或者指纹。比较出名的hash算法有MD5、SHA。hash是具有唯一性且不可逆的，唯一性是指相同的“对象”产生的hash code永远是一样的。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/1563797150134-1661448231965.png" alt="1563797150134"></p><h4 id="2、Entry中的hash属性为什么不直接使用key的hashCode-返回值呢？"><a href="#2、Entry中的hash属性为什么不直接使用key的hashCode-返回值呢？" class="headerlink" title="2、Entry中的hash属性为什么不直接使用key的hashCode()返回值呢？"></a>2、Entry中的hash属性为什么不直接使用key的hashCode()返回值呢？</h4><p>不管是JDK1.7还是JDK1.8中，都不是直接用key的hashCode值直接与table.length-1计算求下标的，而是先对key的hashCode值进行了一个运算，JDK1.7和JDK1.8关于hash()的实现代码不一样，但是不管怎么样都是为了提高hash code值与 (table.length-1)的按位与完的结果，尽量的均匀分布。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/image-20220514190454633-1661448231965.png" alt="image-20220514190454633"></p><p>JDK1.7：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK1.8：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">       <span class="type">int</span> h;</span><br><span class="line">       <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>虽然算法不同，但是思路都是将hashCode值的高位二进制与低位二进制值进行了异或，然高位二进制参与到index的计算中。</p><p>为什么要hashCode值的二进制的高位参与到index计算呢？</p><p>因为一个HashMap的table数组一般不会特别大，至少在不断扩容之前，那么table.length-1的大部分高位都是0，直接用hashCode和table.length-1进行&amp;运算的话，就会导致总是只有最低的几位是有效的，那么就算你的hashCode()实现的再好也难以避免发生碰撞，这时让高位参与进来的意义就体现出来了。它对hashcode的低位添加了随机性并且混合了高位的部分特征，显著减少了碰撞冲突的发生。</p><h4 id="3、HashMap是如何决定某个key-value存在哪个桶的呢？"><a href="#3、HashMap是如何决定某个key-value存在哪个桶的呢？" class="headerlink" title="3、HashMap是如何决定某个key-value存在哪个桶的呢？"></a>3、HashMap是如何决定某个key-value存在哪个桶的呢？</h4><p>因为hash值是一个整数，而数组的长度也是一个整数，有两种思路：</p><p>①hash 值 % table.length会得到一个[0,table.length-1]范围的值，正好是下标范围，但是用%运算效率没有位运算符&amp;高。</p><p>②hash 值 &amp; (table.length-1)，任何数 &amp; (table.length-1)的结果也一定在[0, table.length-1]范围。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/1563800372286-1661448231966.png" alt="1563800372286"></p><p>JDK1.7：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>); <span class="comment">//此处h就是hash</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK1.8：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)  <span class="comment">// i = (n - 1) &amp; hash</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//....省略大量代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、为什么要保持table数组一直是2的n次幂呢？"><a href="#4、为什么要保持table数组一直是2的n次幂呢？" class="headerlink" title="4、为什么要保持table数组一直是2的n次幂呢？"></a>4、为什么要保持table数组一直是2的n次幂呢？</h4><p>因为如果数组的长度为2的n次幂，那么table.length-1的二进制就是一个高位全是0，低位全是1的数字，这样才能保证每一个下标位置都有机会被用到。</p><p>举例1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hashCode值是   ？</span><br><span class="line">table.length是<span class="number">10</span></span><br><span class="line">table.length-<span class="number">1</span>是<span class="number">9</span></span><br><span class="line"></span><br><span class="line">？   ????????</span><br><span class="line"><span class="number">9</span> <span class="number">00001001</span></span><br><span class="line">&amp;_____________</span><br><span class="line"> <span class="number">00000000</span>[<span class="number">0</span>]</span><br><span class="line"> <span class="number">00000001</span>[<span class="number">1</span>]</span><br><span class="line"> <span class="number">00001000</span>[<span class="number">8</span>]</span><br><span class="line"> <span class="number">00001001</span>[<span class="number">9</span>]</span><br><span class="line"> 一定[<span class="number">0</span>]~[<span class="number">9</span>]</span><br></pre></td></tr></table></figure><p>举例2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hashCode值是   ？</span><br><span class="line">table.length是<span class="number">16</span></span><br><span class="line">table.length-<span class="number">1</span>是<span class="number">15</span></span><br><span class="line"></span><br><span class="line">？   ????????</span><br><span class="line"><span class="number">15</span> <span class="number">00001111</span></span><br><span class="line">&amp;_____________</span><br><span class="line"> <span class="number">00000000</span>[<span class="number">0</span>]</span><br><span class="line"> <span class="number">00000001</span>[<span class="number">1</span>]</span><br><span class="line"> <span class="number">00000010</span>[<span class="number">2</span>]</span><br><span class="line"> <span class="number">00000011</span>[<span class="number">3</span>]</span><br><span class="line"> ...</span><br><span class="line"> <span class="number">00001111</span>    [<span class="number">15</span>]</span><br><span class="line"> 范围是[<span class="number">0</span>,<span class="number">15</span>]，一定在[<span class="number">0</span>,table.length-<span class="number">1</span>]范围内</span><br></pre></td></tr></table></figure><h4 id="5、解决-index-冲突问题"><a href="#5、解决-index-冲突问题" class="headerlink" title="5、解决[index]冲突问题"></a>5、解决[index]冲突问题</h4><p>虽然从设计hashCode()到上面HashMap的hash()函数，都尽量减少冲突，但是仍然存在两个不同的对象返回的hashCode值相同，或者hashCode值就算不同，通过hash()函数计算后，得到的index也会存在大量的相同，因此key分布完全均匀的情况是不存在的。那么发生碰撞冲突时怎么办？</p><p>JDK1.8之间使用：数组+链表的结构。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/1563802656661-1661448231966.png" alt="1563802656661"></p><p>JDK1.8之后使用：数组+链表/红黑树的结构。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/1563802665708-1661448231966.png" alt="1563802665708"></p><p>即hash相同或hash&amp;(table.lengt-1)的值相同，那么就存入同一个“桶”table[index]中，使用链表或红黑树连接起来。</p><h4 id="6、为什么JDK1-8会出现红黑树和链表共存呢？"><a href="#6、为什么JDK1-8会出现红黑树和链表共存呢？" class="headerlink" title="6、为什么JDK1.8会出现红黑树和链表共存呢？"></a>6、为什么JDK1.8会出现红黑树和链表共存呢？</h4><p>因为当冲突比较严重时，table[index]下面的链表就会很长，那么会导致查找效率大大降低，而如果此时选用二叉树可以大大提高查询效率。</p><p>但是二叉树的结构又过于复杂，占用内存也较多，如果结点个数比较少的时候，那么选择链表反而更简单。所以会出现红黑树和链表共存。</p><h4 id="7、加载因子的值大小有什么关系？"><a href="#7、加载因子的值大小有什么关系？" class="headerlink" title="7、加载因子的值大小有什么关系？"></a>7、加载因子的值大小有什么关系？</h4><p>如果太大，threshold就会很大，那么如果冲突比较严重的话，就会导致table[index]下面的结点个数很多，影响效率。</p><p>如果太小，threshold就会很小，那么数组扩容的频率就会提高，数组的使用率也会降低，那么会造成空间的浪费。</p><h4 id="8、什么时候树化？什么时候反树化？"><a href="#8、什么时候树化？什么时候反树化？" class="headerlink" title="8、什么时候树化？什么时候反树化？"></a>8、什么时候树化？什么时候反树化？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;<span class="comment">//树化阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;<span class="comment">//反树化阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;<span class="comment">//最小树化容量</span></span><br></pre></td></tr></table></figure><ul><li><p>当某table[index]下的链表的结点个数达到8，并且table.length&gt;=64，那么如果新Entry对象还添加到该table[index]中，那么就会将table[index]的链表进行树化。</p></li><li><p>当某table[index]下的红黑树结点个数少于6个，此时，</p><ul><li>当继续删除table[index]下的树结点，最后这个根结点的左右结点有null，或根结点的左结点的左结点为null，会反树化</li><li>当重新添加新的映射关系到map中，导致了map重新扩容了，这个时候如果table[index]下面还是小于等于6的个数，那么会反树化</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyKey</span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyKey</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(num&lt;=<span class="number">20</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">prime</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            result = prime * result + num;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == obj)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">MyKey</span> <span class="variable">other</span> <span class="operator">=</span> (MyKey) obj;</span><br><span class="line">        <span class="keyword">if</span> (num != other.num)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHashMapMyKey</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//这里为了演示的效果，我们造一个特殊的类，这个类的hashCode（）方法返回固定值1</span></span><br><span class="line">        <span class="comment">//因为这样就可以造成冲突问题，使得它们都存到table[1]中</span></span><br><span class="line">        HashMap&lt;MyKey, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">11</span>; i++) &#123;</span><br><span class="line">            map.put(<span class="keyword">new</span> <span class="title class_">MyKey</span>(i), <span class="string">&quot;value&quot;</span>+i);<span class="comment">//树化演示</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        HashMap&lt;MyKey, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">11</span>; i++) &#123;</span><br><span class="line">            map.put(<span class="keyword">new</span> <span class="title class_">MyKey</span>(i), <span class="string">&quot;value&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">11</span>; i++) &#123;</span><br><span class="line">            map.remove(<span class="keyword">new</span> <span class="title class_">MyKey</span>(i));<span class="comment">//反树化演示</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        HashMap&lt;MyKey, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">11</span>; i++) &#123;</span><br><span class="line">            map.put(<span class="keyword">new</span> <span class="title class_">MyKey</span>(i), <span class="string">&quot;value&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">            map.remove(<span class="keyword">new</span> <span class="title class_">MyKey</span>(i));</span><br><span class="line">        &#125;<span class="comment">//table[1]下剩余6个结点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">21</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            map.put(<span class="keyword">new</span> <span class="title class_">MyKey</span>(i), <span class="string">&quot;value&quot;</span>+i);<span class="comment">//添加到扩容时，反树化</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="9、key-value中的key是否可以修改？"><a href="#9、key-value中的key是否可以修改？" class="headerlink" title="9、key-value中的key是否可以修改？"></a>9、key-value中的key是否可以修改？</h4><p>key-value存储到HashMap中会存储key的hash值，这样就不用在每次查找时重新计算每一个Entry或Node（TreeNode）的hash值了，因此如果已经put到Map中的key-value，再修改key的属性，而这个属性又参与hashcode值的计算，那么会导致匹配不上。</p><p>这个规则也同样适用于LinkedHashMap、HashSet、LinkedHashSet、Hashtable等所有散列存储结构的集合。</p><h4 id="10、JDK1-7中HashMap的循环链表是怎么回事？如何解决？"><a href="#10、JDK1-7中HashMap的循环链表是怎么回事？如何解决？" class="headerlink" title="10、JDK1.7中HashMap的循环链表是怎么回事？如何解决？"></a>10、JDK1.7中HashMap的循环链表是怎么回事？如何解决？</h4><p><img src="/2023/02/18/java2023/%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/HashMap的循环引用问题.jpg" alt="HashMap的循环引用问题"></p><p>避免HashMap发生死循环的常用解决方案：</p><ul><li>多线程环境下，使用线程安全的ConcurrentHashMap替代HashMap，推荐</li><li>多线程环境下，使用synchronized或Lock加锁，但会影响性能，不推荐</li><li>多线程环境下，使用线程安全的Hashtable替代，性能低，不推荐</li></ul><p>HashMap死循环只会发生在JDK1.7版本中，主要原因：头插法+链表+多线程并发+扩容。</p><p>在JDK1.8中，HashMap改用尾插法，解决了链表死循环的问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第14章-数据结构与集合源码&quot;&gt;&lt;a href=&quot;#第14章-数据结构与集合源码&quot; class=&quot;headerlink&quot; title=&quot;第14章_数据结构与集合源码&quot;&gt;&lt;/a&gt;第14章_数据结构与集合源码&lt;/h1&gt;&lt;p&gt;讲师：尚硅谷-宋红康（江湖人称：康师傅）&lt;/</summary>
      
    
    
    
    <category term="Java2023" scheme="http://example.com/categories/Java2023/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第16章_网络编程</title>
    <link href="http://example.com/2023/02/18/java2023/%E7%AC%AC16%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2023/02/18/java2023/%E7%AC%AC16%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</id>
    <published>2023-02-18T12:37:01.000Z</published>
    <updated>2023-02-19T07:44:19.536Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第16章-网络编程"><a href="#第16章-网络编程" class="headerlink" title="第16章_网络编程"></a>第16章_网络编程</h1><p>讲师：尚硅谷-宋红康（江湖人称：康师傅）</p><p>官网：<a href="http://www.atguigu.com/">http://www.atguigu.com</a></p><hr><h2 id="本章专题与脉络"><a href="#本章专题与脉络" class="headerlink" title="本章专题与脉络"></a>本章专题与脉络</h2><p><img src="/2023/02/18/java2023/%E7%AC%AC16%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/第3阶段：Java高级应用-第16章.png" alt="第3阶段：Java高级应用-第16章" style="zoom: 50%;"></p><hr><h2 id="1-网络编程概述"><a href="#1-网络编程概述" class="headerlink" title="1. 网络编程概述"></a>1. 网络编程概述</h2><p>Java是 Internet 上的语言，它从语言级上提供了对网络应用程序的支持，程序员能够很容易开发常见的网络应用程序。</p><p>Java提供的网络类库，可以实现无痛的网络连接，联网的底层细节被隐藏在 Java 的本机安装系统里，由 JVM 进行控制。并且 Java 实现了一个跨平台的网络库，<code>程序员面对的是一个统一的网络编程环境</code>。</p><h3 id="1-1-软件架构"><a href="#1-1-软件架构" class="headerlink" title="1.1 软件架构"></a>1.1 软件架构</h3><ul><li><strong>C/S架构</strong> ：全称为Client/Server结构，是指客户端和服务器结构。常见程序有QQ、美团app、360安全卫士等软件。</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC16%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1_cs.jpg" style="zoom:67%;"></p><p><strong>B/S架构</strong> ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有IE、谷歌、火狐等。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC16%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/2_bs.jpg" style="zoom:67%;"></p><p>两种架构各有优势，但是无论哪种架构，都离不开网络的支持。<strong>网络编程</strong>，就是在一定的协议下，实现两台计算机的通信的程序。</p><h3 id="1-2-网络基础"><a href="#1-2-网络基础" class="headerlink" title="1.2 网络基础"></a>1.2 网络基础</h3><ul><li><p><strong>计算机网络：</strong><br>把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规模大、功能强的网络系统，从而使众多的计算机可以方便地互相传递信息、共享硬件、软件、数据信息等资源。</p></li><li><p><strong>网络编程的目的：</strong>直接或间接地通过网络协议与其它计算机实现数据交换，进行通讯。</p></li><li><p><strong>网络编程中有三个主要的问题：</strong></p><ul><li>问题1：如何准确地定位网络上一台或多台主机</li><li>问题2：如何定位主机上的特定的应用</li><li>问题3：找到主机后，如何可靠、高效地进行数据传输</li></ul></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC16%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20220415001614195.png" alt="image-20220415001614195" style="zoom:67%;"></p><h2 id="2-网络通信要素"><a href="#2-网络通信要素" class="headerlink" title="2. 网络通信要素"></a>2. 网络通信要素</h2><h3 id="2-1-如何实现网络中的主机互相通信"><a href="#2-1-如何实现网络中的主机互相通信" class="headerlink" title="2.1 如何实现网络中的主机互相通信"></a>2.1 如何实现网络中的主机互相通信</h3><ul><li>通信双方地址<ul><li>IP</li><li>端口号</li></ul></li><li>一定的规则：不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议，即网络通信协议。</li></ul><p><strong>生活类比：</strong></p><p><img src="/2023/02/18/java2023/%E7%AC%AC16%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20220503144420721.png" alt="image-20220503144420721" style="zoom:67%;"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC16%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20220503144450241.png" alt="image-20220503144450241" style="zoom:67%;"></p><h3 id="2-2-通信要素一：IP地址和域名"><a href="#2-2-通信要素一：IP地址和域名" class="headerlink" title="2.2 通信要素一：IP地址和域名"></a>2.2 通信要素一：IP地址和域名</h3><h4 id="2-2-1-IP地址"><a href="#2-2-1-IP地址" class="headerlink" title="2.2.1 IP地址"></a>2.2.1 IP地址</h4><p><strong>IP地址：指互联网协议地址（Internet Protocol Address）</strong>，俗称IP。IP地址用来给网络中的一台计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。</p><p><strong>IP地址分类方式一：</strong></p><ul><li><p><code>IPv4</code>：是一个32位的二进制数，通常被分为4个字节，表示成<code>a.b.c.d</code> 的形式，以点分<code>十进制</code>表示，例如<code>192.168.65.100</code> 。其中a、b、c、d都是0~255之间的十进制整数。</p><ul><li><p><img src="/2023/02/18/java2023/%E7%AC%AC16%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20220503145929568.png" alt="image-20220503145929568" style="zoom:80%;"></p></li><li><p>这种方式最多可以表示42亿个。其中，30亿都在北美，亚洲4亿，中国2.9亿。2011年初已经用尽。</p></li><li><p>IP地址 = 网络地址 +主机地址</p><ul><li>网络地址：标识计算机或网络设备所在的网段</li><li>主机地址：标识特定主机或网络设备</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC16%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/20220518_101503.jpg" alt="20220518_101503"></p><p>其中，E类用于科研。</p></li></ul></li><li><p><code>IPv6</code>：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。</p><p>为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，共16个字节，写成8个无符号整数，每个整数用四个十六进制位表示，数之间用冒号（：）分开。比如：<code>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</code>，按保守方法估算IPv6实际可分配的地址，整个地球的每平方米面积上仍可分配1000多个地址，这样就解决了网络地址资源数量不够的问题。2012年6月6日，国际互联网协会举行了世界IPv6启动纪念日，这一天，全球IPv6网络正式启动。多家知名网站，如Google、Facebook和Yahoo等，于当天全球标准时间0点（北京时间8点整）开始永久性支持IPv6访问。2018年6月，三大运营商联合阿里云宣布，将全面对外提供IPv6服务，并计划在2025年前助推中国互联网真正实现“IPv6 Only”。</p><p>在IPv6的设计过程中除了一劳永逸地解决了地址短缺问题以外，还考虑了在IPv4中解决不好的其它问题，主要有端到端IP连接、服务质量（QoS）、安全性、多播、移动性、即插即用等。</p></li></ul><p><strong>IP地址分类方式二：</strong></p><p>公网地址( 万维网使用）和 私有地址( 局域网使用）。192.168.开头的就是私有地址，范围即为192.168.0.0—192.168.255.255，专门为组织机构内部使用。</p><p><strong>常用命令：</strong></p><ul><li>查看本机IP地址，在控制台输入：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure><ul><li>检查网络是否连通，在控制台输入：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ping 空格 IP地址</span><br><span class="line">ping <span class="number">220.181</span><span class="number">.57</span><span class="number">.216</span></span><br></pre></td></tr></table></figure><p><strong>特殊的IP地址：</strong></p><ul><li>本地回环地址(hostAddress)：<code>127.0.0.1</code>  </li><li>主机名(hostName)：<code>localhost</code></li></ul><h4 id="2-2-2-域名"><a href="#2-2-2-域名" class="headerlink" title="2.2.2 域名"></a>2.2.2 域名</h4><p>Internet上的主机有两种方式表示地址：</p><ul><li>域名(hostName)：www.atguigu.com</li><li>IP 地址(hostAddress)：202.108.35.210</li></ul><p><strong>域名解析：</strong>因为IP地址数字不便于记忆，因此出现了域名。域名容易记忆，当在连接网络时输入一个主机的域名后，域名服务器(DNS，Domain Name System，域名系统)负责将域名转化成IP地址，这样才能和主机建立连接。 </p><p>简单理解：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC16%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20220415003729013.png" alt="image-20220415003729013" style="zoom:80%;"></p><p>详细理解：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC16%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20220131125934581.png" alt="image-20220131125934581"></p><ol><li>在浏览器中输入www . qq .com 域名，操作系统会先检查自己本地的<code>hosts文件</code>是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。</li><li>如果hosts里没有这个域名的映射，则查找<code>本地DNS解析器缓存</code>，是否有这个网址映射关系，如果有，直接返回，完成域名解析。</li><li>如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器，在此我们叫它<code>本地DNS服务器</code>，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。</li><li>如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已<code>缓存</code>了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。</li><li>如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(<a href="http://qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找（http://qq.com)域服务器，重复上面的动作，进行查询，直至找到www.qq.com主机。">http://qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找（http://qq.com)域服务器，重复上面的动作，进行查询，直至找到www.qq.com主机。</a></li><li>如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。</li></ol><h3 id="2-3-通信要素二：端口号"><a href="#2-3-通信要素二：端口号" class="headerlink" title="2.3 通信要素二：端口号"></a>2.3 通信要素二：端口号</h3><p>网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？</p><p>如果说<strong>IP地址</strong>可以唯一标识网络中的设备，那么<strong>端口号</strong>就可以唯一标识设备中的进程（应用程序）。</p><p>不同的进程，设置不同的端口号。</p><ul><li><strong>端口号：用两个字节表示的整数，它的取值范围是0~65535</strong>。<ul><li>公认端口：0~1023。被预先定义的服务通信占用，如：HTTP（80），FTP（21），Telnet（23）</li><li>注册端口：1024~49151。分配给用户进程或应用程序。如：Tomcat（8080），MySQL（3306），Oracle（1521）。</li><li>动态/ 私有端口：49152~65535。</li></ul></li></ul><p>如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC16%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20220415004400166.png" alt="image-20220415004400166" style="zoom:80%;"></p><h3 id="2-4-通信要素三：网络通信协议"><a href="#2-4-通信要素三：网络通信协议" class="headerlink" title="2.4 通信要素三：网络通信协议"></a>2.4 通信要素三：网络通信协议</h3><p>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。</p><ul><li><code>网络通信协议</code>：在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤、出错控制等做了统一规定，通信双方必须同时遵守才能完成数据交换。</li></ul><p><strong>新的问题：网络协议涉及内容太多、太复杂。如何解决？</strong></p><p>计算机网络通信涉及内容很多，比如指定源地址和目标地址，加密解密，压缩解压缩，差错控制，流量控制，路由控制，如何实现如此复杂的网络协议呢？<code>通信协议分层思想</code>。</p><p>在制定协议时，把复杂成份分解成一些简单的成份，再将它们复合起来。最常用的复合方式是层次方式，即<code>同层间可以通信、上一层可以调用下一层，而与再下一层不发生关系</code>。各层互不影响，利于系统的开发和扩展。</p><p>这里有两套参考模型</p><ul><li>OSI参考模型：模型过于理想化，未能在因特网上进行广泛推广</li><li>TCP/IP参考模型(或TCP/IP协议)：事实上的国际标准。</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC16%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20220514172130459.png" alt="image-20220514172130459"></p><p>上图中，OSI参考模型：模型<code>过于理想化</code>，未能在因特网上进行广泛推广。 TCP/IP参考模型(或TCP/IP协议)：事实上的<code>国际标准</code>。</p><ul><li><p><strong>TCP/IP协议：</strong> 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，TCP/IP 以其两个主要协议：传输控制协议(TCP)和网络互联协议(IP)而得名，实际上是一组协议，包括多个具有不同功能且互为关联的协议。是Internet最基本、最广泛的协议。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC16%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20220512234904047.png" alt="image-20220512234904047" style="zoom:80%;"></p></li></ul><p><strong>TCP/IP协议中的四层介绍：</strong></p><ul><li><code>应用层</code>：应用层决定了向用户提供应用服务时通信的活动。主要协议有：HTTP协议、FTP协议、SNMP（简单网络管理协议）、SMTP（简单邮件传输协议）和POP3（Post Office Protocol 3的简称,即邮局协议的第3个版）等。</li><li><code>传输层</code>：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。TCP（Transmission Control Protocol）协议，即传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议。UDP(User Datagram Protocol，用户数据报协议)：是一个无连接的传输层协议、提供面向事务的简单不可靠的信息传送服务。</li><li><code>网络层</code>：网络层是整个TCP/IP协议的核心，支持网间互连的数据通信。它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。而IP协议是一种非常重要的协议。IP（internet protocal）又称为互联网协议。IP的责任就是把数据从源传送到目的地。它在源地址和目的地址之间传送一种称之为数据包的东西，它还提供对数据大小的重新组装功能，以适应不同网络对包大小的要求。</li></ul><ul><li><code>物理+数据链路层</code>：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC16%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20220514172435398.png" alt="image-20220514172435398"></p><h2 id="2-谈传输层协议：TCP与UDP协议"><a href="#2-谈传输层协议：TCP与UDP协议" class="headerlink" title="2. 谈传输层协议：TCP与UDP协议"></a>2. 谈传输层协议：TCP与UDP协议</h2><p>通信的协议还是比较复杂的，<code>java.net</code> 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。</p><p><code>java.net</code> 包中提供了两种常见的网络协议的支持：</p><ul><li><strong>UDP</strong>：用户数据报协议(User Datagram Protocol)。</li><li><strong>TCP</strong>：传输控制协议 (Transmission Control Protocol)。</li></ul><h3 id="2-1-TCP协议与UDP协议"><a href="#2-1-TCP协议与UDP协议" class="headerlink" title="2.1 TCP协议与UDP协议"></a>2.1 TCP协议与UDP协议</h3><p><strong>TCP协议：</strong></p><ul><li>TCP协议进行通信的两个应用进程：客户端、服务端。</li><li>使用TCP协议前，须先<code>建立TCP连接</code>，形成基于字节流的传输数据通道</li><li>传输前，采用“三次握手”方式，点对点通信，是<code>可靠的</code><ul><li>TCP协议使用<code>重发机制</code>，当一个通信实体发送一个消息给另一个通信实体后，需要收到另一个通信实体确认信息，如果没有收到另一个通信实体确认信息，则会再次重复刚才发送的消息。</li></ul></li><li>在连接中可进行<code>大数据量的传输</code></li><li>传输完毕，需<code>释放已建立的连接，效率低</code></li></ul><p><strong>UDP协议：</strong></p><ul><li>UDP协议进行通信的两个应用进程：发送端、接收端。</li><li>将数据、源、目的封装成数据包（传输的基本单位），<code>不需要建立连接</code></li><li>发送不管对方是否准备好，接收方收到也不确认，不能保证数据的完整性，故是<code>不可靠的</code></li><li>每个数据报的大小限制在<code>64K</code>内</li><li>发送数据结束时<code>无需释放资源，开销小，通信效率高</code></li><li>适用场景：音频、视频和普通数据的传输。例如视频会议</li></ul><blockquote><p>TCP生活案例：打电话</p><p>UDP生活案例：发送短信、发电报</p></blockquote><h3 id="2-2-三次握手"><a href="#2-2-三次握手" class="headerlink" title="2.2 三次握手"></a>2.2 三次握手</h3><p>TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。</p><ul><li>第一次握手，客户端向服务器端发起TCP连接的请求</li><li>第二次握手，服务器端发送针对客户端TCP连接请求的确认</li><li>第三次握手，客户端发送确认的确认</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC16%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20220415010105484.png" alt="image-20220415010105484" style="zoom:80%;"></p><blockquote><p>1、客户端会随机一个初始序列号seq=x，设置SYN=1 ，表示这是SYN握手报文。然后就可以把这个 SYN 报文发送给服务端了，表示向服务端发起连接，之后客户端处于<code>同步已发送</code>状态。</p><p>2、服务端收到客户端的 SYN 报文后，也随机一个初始序列号(seq=y)，设置ack=x+1，表示收到了客户端的x之前的数据，希望客户端下次发送的数据从x+1开始。<br>设置 SYN=1 和 ACK=1。表示这是一个SYN握手和ACK确认应答报文。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于<code>同步已接收</code>状态。</p><p>3、客户端收到服务端报文后，还要向服务端回应最后一个应答报文，将ACK置为 1 ，表示这是一个应答报文<br>ack=y+1 ，表示收到了服务器的y之前的数据，希望服务器下次发送的数据从y+1开始。<br>最后把报文发送给服务端，这次报文可以携带数据，之后客户端处于 连接已建立 状态。服务器收到客户端的应答报文后，也进入<code>连接已建立</code>状态。</p></blockquote><p>完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。</p><h3 id="2-3-四次挥手"><a href="#2-3-四次挥手" class="headerlink" title="2.3 四次挥手"></a>2.3 四次挥手</h3><p>TCP协议中，在发送数据结束后，释放连接时需要经过四次挥手。</p><ul><li>第一次挥手：客户端向服务器端提出结束连接，<code>让服务器做最后的准备工作</code>。此时，客户端处于半关闭状态，即表示不再向服务器发送数据了，但是还可以接受数据。</li><li>第二次挥手：服务器接收到客户端释放连接的请求后，<code>会将最后的数据发给客户端</code>。并告知上层的应用进程不再接收数据。</li><li>第三次挥手：服务器发送完数据后，会给客户端<code>发送一个释放连接的报文</code>。那么客户端接收后就知道可以正式释放连接了。</li><li>第四次挥手：客户端接收到服务器最后的释放连接报文后，要<code>回复一个彻底断开的报文</code>。这样服务器收到后才会彻底释放连接。这里客户端，发送完最后的报文后，会等待2MSL，因为有可能服务器没有收到最后的报文，那么服务器迟迟没收到，就会再次给客户端发送释放连接的报文，此时客户端在等待时间范围内接收到，会重新发送最后的报文，并重新计时。如果等待2MSL后，没有收到，那么彻底断开。</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC16%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20220415010205891.png" alt="image-20220415010205891" style="zoom:80%;"></p><blockquote><p>1、客户端打算断开连接，向服务器发送FIN报文(FIN标记位被设置为1，1表示为FIN，0表示不是)，FIN报文中会指定一个序列号，之后客户端进入FIN_WAIT_1状态。也就是客户端发出连接释放报文段(FIN报文)，指定序列号seq = u，主动关闭TCP连接，等待服务器的确认。</p><p>2、服务器收到连接释放报文段(FIN报文)后，就向客户端发送ACK应答报文，以客户端的FIN报文的序列号 seq+1 作为ACK应答报文段的确认序列号ack = seq+1 = u + 1。接着服务器进入CLOSE_WAIT(等待关闭)状态，此时的TCP处于半关闭状态(下面会说什么是半关闭状态)，客户端到服务器的连接释放。客户端收到来自服务器的ACK应答报文段后，进入FIN_WAIT_2状态。</p><p>3、服务器也打算断开连接，向客户端发送连接释放(FIN)报文段，之后服务器进入LASK_ACK(最后确认)状态，等待客户端的确认。服务器的连接释放(FIN)报文段的FIN=1，ACK=1，序列号seq=m，确认序列号ack=u+1。</p><p>4、客户端收到来自服务器的连接释放(FIN)报文段后，会向服务器发送一个ACK应答报文段，以连接释放(FIN)报文段的确认序号 ack 作为ACK应答报文段的序列号 seq，以连接释放(FIN)报文段的序列号 seq+1作为确认序号ack。</p><p>之后客户端进入TIME_WAIT(时间等待)状态，服务器收到ACK应答报文段后，服务器就进入CLOSE(关闭)状态，到此服务器的连接已经完成关闭。客户端处于TIME_WAIT状态时，此时的TCP还未释放掉，需要等待2MSL后，客户端才进入CLOSE状态。</p></blockquote><h2 id="3-网络编程API"><a href="#3-网络编程API" class="headerlink" title="3. 网络编程API"></a>3. 网络编程API</h2><h3 id="3-1-InetAddress类"><a href="#3-1-InetAddress类" class="headerlink" title="3.1 InetAddress类"></a>3.1 InetAddress类</h3><p>InetAddress类主要表示IP地址，两个子类：Inet4Address、Inet6Address。</p><p>InetAddress 类没有提供公共的构造器，而是提供 了 如下几个 静态方法来获取InetAddress 实例</p><ul><li>public static InetAddress getLocalHost()</li><li>public static InetAddress getByName(String host)</li><li>public static InetAddress getByAddress(byte[] addr)</li></ul><p>InetAddress 提供了如下几个常用的方法</p><ul><li>public String getHostAddress() ：返回 IP 地址字符串（以文本表现形式）</li><li>public String getHostName() ：获取此 IP 地址的主机名</li><li>public boolean isReachable(int timeout)：测试是否可以达到该地址</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.ip;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInetAddress</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> <span class="keyword">throws</span> UnknownHostException&#123;</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">localHost</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        System.out.println(localHost);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span><span class="keyword">throws</span> UnknownHostException&#123;</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">atguigu</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.atguigu.com&quot;</span>);</span><br><span class="line">        System.out.println(atguigu);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span><span class="keyword">throws</span> UnknownHostException&#123;</span><br><span class="line"><span class="comment">//byte[] addr = &#123;112,54,108,98&#125;;</span></span><br><span class="line">        <span class="type">byte</span>[] addr = &#123;(<span class="type">byte</span>)<span class="number">192</span>,(<span class="type">byte</span>)<span class="number">168</span>,<span class="number">24</span>,<span class="number">56</span>&#125;;</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">atguigu</span> <span class="operator">=</span> InetAddress.getByAddress(addr);</span><br><span class="line">        System.out.println(atguigu);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC16%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1564024137998.png" alt="1564024137998"></p><h3 id="3-2-Socket类"><a href="#3-2-Socket类" class="headerlink" title="3.2 Socket类"></a>3.2 Socket类</h3><ul><li>网络上具有唯一标识的IP地址和端口号组合在一起构成唯一能识别的标识符套接字（Socket）。</li><li>利用套接字(Socket)开发网络应用程序早已被广泛的采用，以至于成为事实上的标准。网络通信其实就是Socket间的通信。</li></ul><ul><li><p>通信的两端都要有Socket，是两台机器间通信的端点。</p></li><li><p>Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输。</p></li><li><p>一般主动发起通信的应用程序属客户端，等待通信请求的为服务端。</p></li><li><p>Socket分类：</p><ul><li>流套接字（stream socket）：使用TCP提供可依赖的字节流服务<ul><li>ServerSocket：此类实现TCP服务器套接字。服务器套接字等待请求通过网络传入。</li><li>Socket：此类实现客户端套接字（也可以就叫“套接字”）。套接字是两台机器间通信的端点。</li></ul></li><li>数据报套接字（datagram socket）：使用UDP提供“尽力而为”的数据报服务<ul><li>DatagramSocket：此类表示用来发送和接收UDP数据报包的套接字。 </li></ul></li></ul></li></ul><h3 id="3-3-Socket相关类API"><a href="#3-3-Socket相关类API" class="headerlink" title="3.3 Socket相关类API"></a>3.3 Socket相关类API</h3><h4 id="3-3-1-ServerSocket类"><a href="#3-3-1-ServerSocket类" class="headerlink" title="3.3.1 ServerSocket类"></a>3.3.1 ServerSocket类</h4><p><strong>ServerSocket类的构造方法：</strong></p><ul><li>ServerSocket(int port) ：创建绑定到特定端口的服务器套接字。</li></ul><p><strong>ServerSocket类的常用方法：</strong></p><ul><li>Socket accept()：侦听并接受到此套接字的连接。 </li></ul><h4 id="3-3-2-Socket类"><a href="#3-3-2-Socket类" class="headerlink" title="3.3.2 Socket类"></a>3.3.2 Socket类</h4><p><strong>Socket类的常用构造方法</strong>：</p><ul><li>public Socket(InetAddress address,int port)：创建一个流套接字并将其连接到指定 IP 地址的指定端口号。</li><li>public Socket(String host,int port)：创建一个流套接字并将其连接到指定主机上的指定端口号。</li></ul><p><strong>Socket类的常用方法</strong>：</p><ul><li>public InputStream getInputStream()：返回此套接字的输入流，可以用于接收消息</li><li>public OutputStream getOutputStream()：返回此套接字的输出流，可以用于发送消息</li><li>public InetAddress getInetAddress()：此套接字连接到的远程 IP 地址；如果套接字是未连接的，则返回 null。</li><li>public InetAddress getLocalAddress()：获取套接字绑定的本地地址。</li><li>public int getPort()：此套接字连接到的远程端口号；如果尚未连接套接字，则返回 0。</li><li>public int getLocalPort()：返回此套接字绑定到的本地端口。如果尚未绑定套接字，则返回 -1。</li><li>public void close()：关闭此套接字。套接字被关闭后，便不可在以后的网络连接中使用（即无法重新连接或重新绑定）。需要创建新的套接字对象。 关闭此套接字也将会关闭该套接字的 InputStream 和 OutputStream。 </li><li>public void shutdownInput()：如果在套接字上调用 shutdownInput() 后从套接字输入流读取内容，则流将返回 EOF（文件结束符）。 即不能在从此套接字的输入流中接收任何数据。</li><li>public void shutdownOutput()：禁用此套接字的输出流。对于 TCP 套接字，任何以前写入的数据都将被发送，并且后跟 TCP 的正常连接终止序列。 如果在套接字上调用 shutdownOutput() 后写入套接字输出流，则该流将抛出 IOException。 即不能通过此套接字的输出流发送任何数据。</li></ul><p><strong>注意：</strong>先后调用Socket的shutdownInput()和shutdownOutput()方法，仅仅关闭了输入流和输出流，并不等于调用Socket的close()方法。在通信结束后，仍然要调用Scoket的close()方法，因为只有该方法才会释放Socket占用的资源，比如占用的本地端口号等。</p><h4 id="3-3-3-DatagramSocket类"><a href="#3-3-3-DatagramSocket类" class="headerlink" title="3.3.3 DatagramSocket类"></a>3.3.3 DatagramSocket类</h4><p><strong>DatagramSocket 类的常用方法：</strong></p><ul><li>public DatagramSocket(int port)创建数据报套接字并将其绑定到本地主机上的指定端口。套接字将被绑定到通配符地址，IP 地址由内核来选择。</li><li>public DatagramSocket(int port,InetAddress laddr)创建数据报套接字，将其绑定到指定的本地地址。本地端口必须在 0 到 65535 之间（包括两者）。如果 IP 地址为 0.0.0.0，套接字将被绑定到通配符地址，IP 地址由内核选择。 </li><li>public void close()关闭此数据报套接字。 </li><li>public void send(DatagramPacket p)从此套接字发送数据报包。DatagramPacket 包含的信息指示：将要发送的数据、其长度、远程主机的 IP 地址和远程主机的端口号。 </li><li>public void receive(DatagramPacket p)从此套接字接收数据报包。当此方法返回时，DatagramPacket 的缓冲区填充了接收的数据。数据报包也包含发送方的 IP 地址和发送方机器上的端口号。 此方法在接收到数据报前一直阻塞。数据报包对象的 length 字段包含所接收信息的长度。如果信息比包的长度长，该信息将被截短。 </li><li>public InetAddress getLocalAddress()获取套接字绑定的本地地址。</li><li>public int getLocalPort()返回此套接字绑定的本地主机上的端口号。 </li><li>public InetAddress getInetAddress()返回此套接字连接的地址。如果套接字未连接，则返回 null。</li><li>public int getPort()返回此套接字的端口。如果套接字未连接，则返回 -1。</li></ul><h4 id="3-3-4-DatagramPacket类"><a href="#3-3-4-DatagramPacket类" class="headerlink" title="3.3.4 DatagramPacket类"></a>3.3.4 DatagramPacket类</h4><p><strong>DatagramPacket类的常用方法：</strong></p><ul><li>public DatagramPacket(byte[] buf,int length)构造 DatagramPacket，用来接收长度为 length 的数据包。 length 参数必须小于等于 buf.length。</li><li>public DatagramPacket(byte[] buf,int length,InetAddress address,int port)构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。length 参数必须小于等于 buf.length。</li><li>public InetAddress getAddress()返回某台机器的 IP 地址，此数据报将要发往该机器或者是从该机器接收到的。</li><li>public int getPort()返回某台远程主机的端口号，此数据报将要发往该主机或者是从该主机接收到的。</li><li><code>public byte[] getData()</code>返回数据缓冲区。接收到的或将要发送的数据从缓冲区中的偏移量 offset 处开始，持续 length 长度。</li><li><code>public int getLength()</code>返回将要发送或接收到的数据的长度。</li></ul><h2 id="4-TCP网络编程"><a href="#4-TCP网络编程" class="headerlink" title="4. TCP网络编程"></a>4. TCP网络编程</h2><h3 id="4-1-通信模型"><a href="#4-1-通信模型" class="headerlink" title="4.1 通信模型"></a>4.1 通信模型</h3><p>Java语言的基于套接字TCP编程分为服务端编程和客户端编程，其通信模型如图所示：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC16%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20220514172833216.png" alt="image-20220514172833216" style="zoom:67%;"></p><h3 id="4-2-开发步骤"><a href="#4-2-开发步骤" class="headerlink" title="4.2 开发步骤"></a>4.2 开发步骤</h3><p><strong>客户端程序包含以下四个基本的步骤 ：</strong></p><ul><li>创建 Socket ：根据指定服务端的 IP 地址或端口号构造 Socket 类对象。若服务器端响应，则建立客户端到服务器的通信线路。若连接失败，会出现异常。</li><li>打开连接到 Socket  的输入/ 出流： 使用 getInputStream()方法获得输入流，使用getOutputStream()方法获得输出流，进行数据传输</li><li>按照一定的协议对 Socket 进行读/ 写操作：通过输入流读取服务器放入线路的信息（但不能读取自己放入线路的信息），通过输出流将信息写入线路。</li><li>关闭 Socket ：断开客户端到服务器的连接，释放线路</li></ul><p><strong>服务器端程序包含以下四个基本的 步骤：</strong></p><ul><li>调用 ServerSocket(int port)  ：创建一个服务器端套接字，并绑定到指定端口上。用于监听客户端的请求。</li><li>调用 accept() ：监听连接请求，如果客户端请求连接，则接受连接，返回通信套接字对象。</li><li>调用  该Socket 类对象的 getOutputStream()  和 getInputStream () ：获取输出流和输入流，开始网络数据的发送和接收。</li><li>关闭Socket 对象：客户端访问结束，关闭通信套接字。</li></ul><h3 id="4-3-例题与练习"><a href="#4-3-例题与练习" class="headerlink" title="4.3 例题与练习"></a>4.3 例题与练习</h3><blockquote><p>例题1：客户端发送内容给服务端，服务端将内容打印到控制台上。</p><p>例题2：客户端发送文件给服务端，服务端将文件保存在本地。</p><p>例题3：从客户端发送文件给服务端，服务端保存到本地。并返回“发送成功”给客户端。并关闭相应的连接。</p></blockquote><p>练习1：服务端读取图片并发送给客户端，客户端保存图片到本地</p><p>练习2：客户端给服务端发送文本，服务端会将文本转成大写在返回给客户端。</p><p><strong>演示单个客户端与服务器单次通信：</strong></p><p>需求：客户端连接服务器，连接成功后给服务发送“lalala”，服务器收到消息后，给客户端返回“欢迎登录”，客户端接收消息后，断开连接</p><p><strong>1、服务器端示例代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.tcp.one;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1、准备一个ServerSocket对象，并绑定8888端口</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待连接....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、在8888端口监听客户端的连接，该方法是个阻塞的方法，如果没有客户端连接，将一直等待</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">inetAddress</span> <span class="operator">=</span> socket.getInetAddress();</span><br><span class="line">        System.out.println(inetAddress.getHostAddress() + <span class="string">&quot;客户端连接成功！！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、获取输入流，用来接收该客户端发送给服务器的数据</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="comment">//接收数据</span></span><br><span class="line">        <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = input.read(data)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            s.append(<span class="keyword">new</span> <span class="title class_">String</span>(data, <span class="number">0</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(inetAddress.getHostAddress() + <span class="string">&quot;客户端发送的消息是：&quot;</span> + s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、获取输出流，用来发送数据给该客户端</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//发送数据</span></span><br><span class="line">        out.write(<span class="string">&quot;欢迎登录&quot;</span>.getBytes());</span><br><span class="line">        out.flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5、关闭socket，不再与该客户端通信</span></span><br><span class="line">        <span class="comment">//socket关闭，意味着InputStream和OutputStream也关闭了</span></span><br><span class="line">        socket.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6、如果不再接收任何客户端通信，可以关闭ServerSocket</span></span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2、客户端示例代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.tcp.one;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、准备Socket，连接服务器，需要指定服务器的IP地址和端口号</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、获取输出流，用来发送数据给服务器</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        out.write(<span class="string">&quot;lalala&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">//会在流末尾写入一个“流的末尾”标记，对方才能读到-1，否则对方的读取方法会一致阻塞</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、获取输入流，用来接收服务器发送给该客户端的数据</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = input.read(data)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            s.append(<span class="keyword">new</span> <span class="title class_">String</span>(data, <span class="number">0</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器返回的消息是：&quot;</span> + s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、关闭socket，不再与服务器通信，即断开与服务器的连接</span></span><br><span class="line">        <span class="comment">//socket关闭，意味着InputStream和OutputStream也关闭了</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>演示多个客户端与服务器之间的多次通信：</strong></p><p>通常情况下，服务器不应该只接受一个客户端请求，而应该不断地接受来自客户端的所有请求，所以Java程序通常会通过循环，不断地调用ServerSocket的accept()方法。</p><p>如果服务器端要“同时”处理多个客户端的请求，因此服务器端需要为<strong>每一个客户端单独分配一个线程</strong>来处理，否则无法实现“同时”。</p><p>咱们之前学习IO流的时候，提到过装饰者设计模式，该设计使得不管底层IO流是怎样的节点流：文件流也好，网络Socket产生的流也好，程序都可以将其包装成处理流，甚至可以多层包装，从而提供更多方便的处理。</p><p>案例需求：多个客户端连接服务器，并进行多次通信</p><ul><li>每一个客户端连接成功后，从键盘输入英文单词或中国成语，并发送给服务器</li><li>服务器收到客户端的消息后，把词语“反转”后返回给客户端</li><li>客户端接收服务器返回的“词语”，打印显示</li><li>当客户端输入“stop”时断开与服务器的连接</li><li>多个客户端可以同时给服务器发送“词语”，服务器可以“同时”处理多个客户端的请求</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC16%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20220514173031651.png" alt="image-20220514173031651" style="zoom:80%;"></p><p><strong>1、服务器端示例代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.tcp.many;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1、准备一个ServerSocket</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待连接...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 2、监听一个客户端的连接</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span> + ++count + <span class="string">&quot;个客户端&quot;</span>+socket.getInetAddress().getHostAddress()+<span class="string">&quot;连接成功！！&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">ClientHandlerThread</span> <span class="variable">ct</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClientHandlerThread</span>(socket);</span><br><span class="line">            ct.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里没有关闭server，永远监听</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ClientHandlerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line">        <span class="keyword">private</span> String ip;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ClientHandlerThread</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="built_in">this</span>.socket = socket;</span><br><span class="line">            ip = socket.getInetAddress().getHostAddress();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//（1）获取输入流，用来接收该客户端发送给服务器的数据</span></span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">                <span class="comment">//（2）获取输出流，用来发送数据给该客户端</span></span><br><span class="line">                <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(socket.getOutputStream());</span><br><span class="line">                String str;</span><br><span class="line">                <span class="comment">// （3）接收数据</span></span><br><span class="line">                <span class="keyword">while</span> ((str = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//（4）反转</span></span><br><span class="line">                    <span class="type">StringBuilder</span> <span class="variable">word</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(str);</span><br><span class="line">                    word.reverse();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//（5）返回给客户端</span></span><br><span class="line">                    ps.println(word);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端&quot;</span> + ip+<span class="string">&quot;正常退出&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception  e)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端&quot;</span> + ip+<span class="string">&quot;意外退出&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//（6）断开连接</span></span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2、客户端示例代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.tcp.many;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、准备Socket，连接服务器，需要指定服务器的IP地址和端口号</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、获取输出流，用来发送数据给服务器</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(out);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、获取输入流，用来接收服务器发送给该客户端的数据</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        BufferedReader br;</span><br><span class="line">        <span class="keyword">if</span>(args!= <span class="literal">null</span> &amp;&amp; args.length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">encoding</span> <span class="operator">=</span> args[<span class="number">0</span>];</span><br><span class="line">            br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(input,encoding));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(input));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输入发送给服务器的单词或成语：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            <span class="keyword">if</span>(message.equals(<span class="string">&quot;stop&quot;</span>))&#123;</span><br><span class="line">                socket.shutdownOutput();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4、 发送数据</span></span><br><span class="line">            ps.println(message);</span><br><span class="line">            <span class="comment">// 接收数据</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">feedback</span>  <span class="operator">=</span> br.readLine();</span><br><span class="line">            System.out.println(<span class="string">&quot;从服务器收到的反馈是：&quot;</span> + feedback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5、关闭socket，断开与服务器的连接</span></span><br><span class="line">        scanner.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-案例：聊天室"><a href="#4-4-案例：聊天室" class="headerlink" title="4.4 案例：聊天室"></a>4.4 案例：聊天室</h3><p>服务端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.tcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestChatServer</span> &#123;</span><br><span class="line"><span class="comment">//这个集合用来存储所有在线的客户端</span></span><br><span class="line"><span class="keyword">static</span> ArrayList&lt;Socket&gt; online = <span class="keyword">new</span>  <span class="title class_">ArrayList</span>&lt;Socket&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//1、启动服务器，绑定端口号</span></span><br><span class="line"><span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8989</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、接收n多的客户端同时连接</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> server.accept();</span><br><span class="line"></span><br><span class="line">online.add(accept);<span class="comment">//把新连接的客户端添加到online列表中</span></span><br><span class="line"></span><br><span class="line"><span class="type">MessageHandler</span> <span class="variable">mh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageHandler</span>(accept);</span><br><span class="line">mh.start();<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MessageHandler</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"><span class="keyword">private</span> Socket socket;</span><br><span class="line"><span class="keyword">private</span> String ip;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MessageHandler</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.socket = socket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ip = socket.getInetAddress().getHostAddress();</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入：给其他客户端转发“我上线了”</span></span><br><span class="line">sendToOther(ip+<span class="string">&quot;上线了&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(1)接收该客户端的发送的消息</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(input);</span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(reader);</span><br><span class="line"></span><br><span class="line">String str;</span><br><span class="line"><span class="keyword">while</span>((str = br.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line"><span class="comment">//(2)给其他在线客户端转发</span></span><br><span class="line">sendToOther(ip+<span class="string">&quot;:&quot;</span>+str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sendToOther(ip+<span class="string">&quot;下线了&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">sendToOther(ip+<span class="string">&quot;掉线了&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//从在线人员中移除我</span></span><br><span class="line">online.remove(socket);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//封装一个方法：给其他客户端转发xxx消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendToOther</span><span class="params">(String message)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line"><span class="comment">//遍历所有的在线客户端，一一转发</span></span><br><span class="line"><span class="keyword">for</span> (Socket on : online) &#123;</span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">every</span> <span class="operator">=</span> on.getOutputStream();</span><br><span class="line"><span class="comment">//为什么用PrintStream？目的用它的println方法，按行打印</span></span><br><span class="line"><span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(every);</span><br><span class="line"></span><br><span class="line">ps.println(message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.tcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestChatClient</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//1、连接服务器</span></span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8989</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、开启两个线程</span></span><br><span class="line"><span class="comment">//(1)一个线程负责看别人聊，即接收服务器转发的消息</span></span><br><span class="line"><span class="type">Receive</span> <span class="variable">receive</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Receive</span>(socket);</span><br><span class="line">receive.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2)一个线程负责发送自己的话</span></span><br><span class="line"><span class="type">Send</span> <span class="variable">send</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Send</span>(socket);</span><br><span class="line">send.start();</span><br><span class="line"></span><br><span class="line">send.join();<span class="comment">//等我发送线程结束了，才结束整个程序</span></span><br><span class="line"></span><br><span class="line">socket.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Send</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"><span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Send</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.socket = socket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"><span class="comment">//按行打印</span></span><br><span class="line"><span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(outputStream);</span><br><span class="line"></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line"><span class="comment">//从键盘不断的输入自己的话，给服务器发送，由服务器给其他人转发</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">System.out.print(<span class="string">&quot;自己的话：&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> input.nextLine();</span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;bye&quot;</span>.equals(str))&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">ps.println(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">input.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Receive</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"><span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Receive</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.socket = socket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(inputStream);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(input.hasNextLine())&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> input.nextLine();</span><br><span class="line">System.out.println(line);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-理解客户端、服务端"><a href="#4-5-理解客户端、服务端" class="headerlink" title="4.5 理解客户端、服务端"></a>4.5 理解客户端、服务端</h3><ul><li><p>客户端：</p><ul><li>自定义</li><li>浏览器(browser —- server)</li></ul></li><li><p>服务端：</p><ul><li>自定义</li><li>Tomcat服务器</li></ul></li></ul><h2 id="5-UDP网络编程"><a href="#5-UDP网络编程" class="headerlink" title="5. UDP网络编程"></a>5. UDP网络编程</h2><p>UDP(User Datagram Protocol，用户数据报协议)：是一个无连接的传输层协议、提供面向事务的简单不可靠的信息传送服务，类似于短信。</p><h3 id="5-1-通信模型"><a href="#5-1-通信模型" class="headerlink" title="5.1 通信模型"></a>5.1 通信模型</h3><p>UDP协议是一种<strong>面向非连接</strong>的协议，面向非连接指的是在正式通信前不必与对方先建立连接，不管对方状态就直接发送，至于对方是否可以接收到这些数据内容，UDP协议无法控制，因此说，UDP协议是一种<strong>不可靠的</strong>协议。无连接的好处就是快，省内存空间和流量，因为维护连接需要创建大量的数据结构。UDP会尽最大努力交付数据，但不保证可靠交付，没有TCP的确认机制、重传机制，如果因为网络原因没有传送到对端，UDP也不会给应用层返回错误信息。</p><p>UDP协议是面向数据报文的信息传送服务。UDP在发送端没有缓冲区，对于应用层交付下来的报文在添加了首部之后就直接交付于ip层，不会进行合并，也不会进行拆分，而是一次交付一个完整的报文。比如我们要发送100个字节的报文，我们调用一次send()方法就会发送100字节，接收方也需要用receive()方法一次性接收100字节，不能使用循环每次获取10个字节，获取十次这样的做法。</p><p>UDP协议没有拥塞控制，所以当网络出现的拥塞不会导致主机发送数据的速率降低。虽然UDP的接收端有缓冲区，但是这个缓冲区只负责接收，并不会保证UDP报文的到达顺序是否和发送的顺序一致。因为网络传输的时候，由于网络拥塞的存在是很大的可能导致先发的报文比后发的报文晚到达。如果此时缓冲区满了，后面到达的报文将直接被丢弃。这个对实时应用来说很重要，比如：视频通话、直播等应用。</p><p>因此UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境，数据报大小限制在64K以下。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC16%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20220131144712460.png" alt="image-20220131144712460"></p><p>类 DatagramSocket 和 DatagramPacket 实现了基于 UDP 协议网络程序。</p><p> UDP数据报通过数据报套接字 DatagramSocket 发送和接收，系统不保证  UDP数据报一定能够安全送到目的地，也不能确定什么时候可以抵达。</p><p> DatagramPacket 对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号。</p><p> UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方的连接。如同发快递包裹一样。</p><h3 id="5-2-开发步骤"><a href="#5-2-开发步骤" class="headerlink" title="5.2 开发步骤"></a>5.2 开发步骤</h3><p><strong>发送端程序包含以下四个基本的步骤：</strong></p><ul><li>创建DatagramSocket ：默认使用系统随机分配端口号。</li><li>创建DatagramPacket：将要发送的数据用字节数组表示，并指定要发送的数据长度，接收方的IP地址和端口号。</li><li>调用  该DatagramSocket 类对象的 send方法 ：发送数据报DatagramPacket对象。</li><li>关闭DatagramSocket 对象：发送端程序结束，关闭通信套接字。</li></ul><p><strong>接收端程序包含以下四个基本的步骤 ：</strong></p><ul><li>创建DatagramSocket ：指定监听的端口号。</li><li>创建DatagramPacket：指定接收数据用的字节数组，起到临时数据缓冲区的效果，并指定最大可以接收的数据长度。</li><li>调用  该DatagramSocket 类对象的receive方法 ：接收数据报DatagramPacket对象。。</li><li>关闭DatagramSocket ：接收端程序结束，关闭通信套接字。</li></ul><h3 id="5-3-演示发送和接收消息"><a href="#5-3-演示发送和接收消息" class="headerlink" title="5.3 演示发送和接收消息"></a>5.3 演示发送和接收消息</h3><p>基于UDP协议的网络编程仍然需要在通信实例的两端各建立一个Socket，但这两个Socket之间并没有虚拟链路，这两个Socket只是发送、接收数据报的对象，Java提供了DatagramSocket对象作为基于UDP协议的Socket，使用DatagramPacket代表DatagramSocket发送、接收的数据报。</p><h4 id="举例1："><a href="#举例1：" class="headerlink" title="举例1："></a>举例1：</h4><p>发送端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ds = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">    <span class="type">byte</span>[] by = <span class="string">&quot;hello,atguigu.com&quot;</span>.getBytes();</span><br><span class="line">    <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(by, <span class="number">0</span>, by.length,     InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">10000</span>);</span><br><span class="line">    ds.send(dp);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ds != <span class="literal">null</span>)</span><br><span class="line">        ds.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接收端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ds = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">10000</span>);</span><br><span class="line">    <span class="type">byte</span>[] by = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">64</span>];</span><br><span class="line">    <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(by, by.length);</span><br><span class="line">    ds.receive(dp);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(dp.getData(), <span class="number">0</span>, dp.getLength());</span><br><span class="line">    System.out.println(str + <span class="string">&quot;--&quot;</span> + dp.getAddress());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ds != <span class="literal">null</span>)</span><br><span class="line">        ds.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="举例2："><a href="#举例2：" class="headerlink" title="举例2："></a>举例2：</h4><p><strong>发送端：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.udp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Send</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//1、建立发送端的DatagramSocket</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//要发送的数据</span></span><br><span class="line">        ArrayList&lt;String&gt; all = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        all.add(<span class="string">&quot;尚硅谷让天下没有难学的技术！&quot;</span>);</span><br><span class="line">        all.add(<span class="string">&quot;学高端前沿的IT技术来尚硅谷！&quot;</span>);</span><br><span class="line">        all.add(<span class="string">&quot;尚硅谷让你的梦想变得更具体！&quot;</span>);</span><br><span class="line">        all.add(<span class="string">&quot;尚硅谷让你的努力更有价值！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收方的IP地址</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">ip</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        <span class="comment">//接收方的监听端口号</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">9999</span>;</span><br><span class="line">        <span class="comment">//发送多个数据报</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; all.size(); i++) &#123;</span><br><span class="line"><span class="comment">//2、建立数据包DatagramPacket</span></span><br><span class="line">            <span class="type">byte</span>[] data = all.get(i).getBytes();</span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data, <span class="number">0</span>, data.length, ip, port);</span><br><span class="line"><span class="comment">//3、调用Socket的发送方法</span></span><br><span class="line">            ds.send(dp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、关闭Socket</span></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接收端：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.udp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Receive</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//1、建立接收端的DatagramSocket，需要指定本端的监听端口号</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一直监听数据</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//2、建立数据包DatagramPacket</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">64</span>];</span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer,buffer.length);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3、调用Socket的接收方法</span></span><br><span class="line">            ds.receive(dp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4、拆封数据</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(dp.getData(),<span class="number">0</span>,dp.getLength());</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        ds.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-URL编程"><a href="#6-URL编程" class="headerlink" title="6. URL编程"></a>6. URL编程</h2><h3 id="6-1-URL类"><a href="#6-1-URL类" class="headerlink" title="6.1 URL类"></a>6.1 URL类</h3><ul><li><p>URL(Uniform Resource Locator)：统一资源定位符，它表示 Internet 上某一资源的地址。</p></li><li><p>通过 URL 我们可以访问 Internet 上的各种网络资源，比如最常见的 www，ftp 站点。浏览器通过解析给定的 URL 可以在网络上查找相应的文件或其他资源。 </p></li><li><p>URL的基本结构由5部分组成：</p></li></ul><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">&lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;#片段名?参数列表</span><br></pre></td></tr></table></figure><ul><li><p>例如: <a href="http://192.168.1.100:8080/helloworld/index.jsp#a?username=shkstart&amp;password=123">http://192.168.1.100:8080/helloworld/index.jsp#a?username=shkstart&amp;password=123</a></p><ul><li>片段名：即锚点，例如看小说，直接定位到章节</li><li>参数列表格式：参数名=参数值&amp;参数名=参数值….</li></ul></li><li><p>为了表示URL，java.net 中实现了类 URL。我们可以通过下面的构造器来初始化一个 URL 对象：</p><ul><li><p>public URL (String spec)：通过一个表示URL地址的字符串可以构造一个URL对象。例如：</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">URL url = new URL(&quot;http://www. atguigu.com/&quot;); </span><br></pre></td></tr></table></figure></li><li><p>public URL(URL context, String spec)：通过基 URL 和相对 URL 构造一个 URL 对象。例如：</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">URL downloadUrl = new URL(url, “download.html&quot;)</span><br></pre></td></tr></table></figure><p>public URL(String protocol, String host, String file); 例如：</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">URL url = new URL(&quot;http&quot;, &quot;www.atguigu.com&quot;, “download. html&quot;);</span><br></pre></td></tr></table></figure></li><li><p>public URL(String protocol, String host, int port, String file); 例如: </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">gamelan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http&quot;</span>, <span class="string">&quot;www.atguigu.com&quot;</span>, <span class="number">80</span>, “download.html<span class="string">&quot;);</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>URL类的构造器都声明抛出非运行时异常，必须要对这一异常进行处理，通常是用 try-catch 语句进行捕获。</p></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC16%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20220415013546074.png" alt="image-20220415013546074"></p><h3 id="6-2-URL类常用方法"><a href="#6-2-URL类常用方法" class="headerlink" title="6.2 URL类常用方法"></a>6.2 URL类常用方法</h3><p>一个URL对象生成后，其属性是不能被改变的，但可以通过它给定的方法来获取这些属性：</p><ul><li><p>public String getProtocol( )   获取该URL的协议名</p></li><li><p>public String getHost( )      获取该URL的主机名</p></li><li><p>public String getPort( )      获取该URL的端口号</p></li><li><p>public String getPath( )      获取该URL的文件路径</p></li><li><p>public String getFile( )       获取该URL的文件名</p></li><li><p>public String getQuery(  )    获取该URL的查询名</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:8080/examples/myTest.txt&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;getProtocol() :&quot;</span>+url.getProtocol());</span><br><span class="line">System.out.println(<span class="string">&quot;getHost() :&quot;</span>+url.getHost());</span><br><span class="line">System.out.println(<span class="string">&quot;getPort() :&quot;</span>+url.getPort());</span><br><span class="line">System.out.println(<span class="string">&quot;getPath() :&quot;</span>+url.getPath());</span><br><span class="line">System.out.println(<span class="string">&quot;getFile() :&quot;</span>+url.getFile());</span><br><span class="line">System.out.println(<span class="string">&quot;getQuery() :&quot;</span>+url.getQuery());</span><br></pre></td></tr></table></figure><h3 id="6-3-针对HTTP协议的URLConnection类"><a href="#6-3-针对HTTP协议的URLConnection类" class="headerlink" title="6.3 针对HTTP协议的URLConnection类"></a>6.3 针对HTTP协议的URLConnection类</h3><ul><li>URL的方法 openStream()：能从网络上读取数据</li><li>若希望输出数据，例如向服务器端的 CGI （公共网关接口-Common Gateway Interface-的简称，是用户浏览器和服务器端的应用程序进行连接的接口）程序发送一些数据，则必须先与URL建立连接，然后才能对其进行读写，此时需要使用 URLConnection 。</li><li><p>URLConnection：表示到URL所引用的远程对象的连接。当与一个URL建立连接时，首先要在一个 URL 对象上通过方法 openConnection() 生成对应的 URLConnection 对象。如果连接过程失败，将产生IOException. </p><ul><li>URL netchinaren = new URL (“<a href="http://www.atguigu.com/index.shtml">http://www.atguigu.com/index.shtml</a>“); </li><li>URLConnectonn u = netchinaren.openConnection( ); </li></ul></li><li><p>通过URLConnection对象获取的输入流和输出流，即可以与现有的CGI程序进行交互。</p><ul><li><p>public Object getContent( ) throws IOException</p></li><li><p>public int getContentLength( )</p></li><li>public String getContentType( )</li><li>public long getDate( )</li><li>public long getLastModified( )</li><li><strong>public InputStream getInputStream ( ) throws IOException</strong></li><li>public OutputSteram getOutputStream( )throws IOException</li></ul></li></ul><h3 id="6-4-小结"><a href="#6-4-小结" class="headerlink" title="6.4 小结"></a>6.4 小结</h3><ul><li><p>位于网络中的计算机具有唯一的IP地址，这样不同的主机可以互相区分。</p></li><li><p>客户端－服务器是一种最常见的网络应用程序模型。服务器是一个为其客户端提供某种特定服务的硬件或软件。客户机是一个用户应用程序，用于访问某台服务器提供的服务。端口号是对一个服务的访问场所，它用于区分同一物理计算机上的多个服务。套接字用于连接客户端和服务器，客户端和服务器之间的每个通信会话使用一个不同的套接字。TCP协议用于实现面向连接的会话。</p></li><li><p>Java 中有关网络方面的功能都定义在 java.net 程序包中。Java 用 InetAddress 对象表示 IP 地址，该对象里有两个字段：主机名(String) 和 IP 地址(int)。</p></li><li><p>类 Socket 和 ServerSocket 实现了基于TCP协议的客户端－服务器程序。Socket是客户端和服务器之间的一个连接，连接创建的细节被隐藏了。这个连接提供了一个安全的数据传输通道，这是因为 TCP 协议可以解决数据在传送过程中的丢失、损坏、重复、乱序以及网络拥挤等问题，它保证数据可靠的传送。</p></li><li><p>类 URL 和 URLConnection 提供了最高级网络应用。URL 的网络资源的位置来同一表示 Internet 上各种网络资源。通过URL对象可以创建当前应用程序和 URL 表示的网络资源之间的连接，这样当前程序就可以读取网络资源数据，或者把自己的数据传送到网络上去。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第16章-网络编程&quot;&gt;&lt;a href=&quot;#第16章-网络编程&quot; class=&quot;headerlink&quot; title=&quot;第16章_网络编程&quot;&gt;&lt;/a&gt;第16章_网络编程&lt;/h1&gt;&lt;p&gt;讲师：尚硅谷-宋红康（江湖人称：康师傅）&lt;/p&gt;
&lt;p&gt;官网：&lt;a href=&quot;ht</summary>
      
    
    
    
    <category term="Java2023" scheme="http://example.com/categories/Java2023/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第15章_File类与IO流</title>
    <link href="http://example.com/2023/02/18/java2023/%E7%AC%AC15%E7%AB%A0_File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/"/>
    <id>http://example.com/2023/02/18/java2023/%E7%AC%AC15%E7%AB%A0_File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/</id>
    <published>2023-02-18T12:37:01.000Z</published>
    <updated>2023-02-19T07:38:43.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第15章-File类与IO流"><a href="#第15章-File类与IO流" class="headerlink" title="第15章_File类与IO流"></a>第15章_File类与IO流</h1><p>讲师：尚硅谷-宋红康（江湖人称：康师傅）</p><p>官网：<a href="http://www.atguigu.com/">http://www.atguigu.com</a></p><hr><h2 id="本章专题与脉络"><a href="#本章专题与脉络" class="headerlink" title="本章专题与脉络"></a>本章专题与脉络</h2><p><img src="/2023/02/18/java2023/%E7%AC%AC15%E7%AB%A0_File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/第3阶段：Java高级应用-第15章.png" alt="第3阶段：Java高级应用-第15章" style="zoom:67%;"></p><hr><h2 id="1-java-io-File类的使用"><a href="#1-java-io-File类的使用" class="headerlink" title="1. java.io.File类的使用"></a>1. java.io.File类的使用</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><ul><li>File类及本章下的各种流，都定义在java.io包下。</li><li>一个File对象代表硬盘或网络中可能存在的一个文件或者文件目录（俗称文件夹），与平台无关。（体会万事万物皆对象）</li><li>File 能新建、删除、重命名文件和目录，但 File 不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入/输出流。<ul><li>File对象可以作为参数传递给流的构造器。</li></ul></li><li>想要在Java程序中表示一个真实存在的文件或目录，那么必须有一个File对象，但是Java程序中的一个File对象，可能没有一个真实存在的文件或目录。</li></ul><h3 id="1-2-构造器"><a href="#1-2-构造器" class="headerlink" title="1.2 构造器"></a>1.2 构造器</h3><ul><li><code>public File(String pathname)</code> ：以pathname为路径创建File对象，可以是绝对路径或者相对路径，如果pathname是相对路径，则默认的当前路径在系统属性user.dir中存储。</li><li><code>public File(String parent, String child)</code> ：以parent为父路径，child为子路径创建File对象。</li><li><code>public File(File parent, String child)</code> ：根据一个父File对象和子文件路径创建File对象</li></ul><p>关于路径：</p><ul><li><strong>绝对路径：</strong>从盘符开始的路径，这是一个完整的路径。</li><li><strong>相对路径：</strong>相对于<code>项目目录</code>的路径，这是一个便捷的路径，开发中经常使用。<ul><li>IDEA中，main中的文件的相对路径，是相对于”<code>当前工程</code>“</li><li>IDEA中，单元测试方法中的文件的相对路径，是相对于”<code>当前module</code>“</li></ul></li></ul><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileObjectTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 文件路径名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">pathname</span> <span class="operator">=</span> <span class="string">&quot;D:\\aaa.txt&quot;</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(pathname);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 文件路径名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">pathname2</span> <span class="operator">=</span> <span class="string">&quot;D:\\aaa\\bbb.txt&quot;</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(pathname2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过父路径和子路径字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="string">&quot;d:\\aaa&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">child</span> <span class="operator">=</span> <span class="string">&quot;bbb.txt&quot;</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parent, child);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过父级File对象和子路径字符串</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">parentDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\aaa&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">childFile</span> <span class="operator">=</span> <span class="string">&quot;bbb.txt&quot;</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentDir, childFile);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\atguigu\\javase\\HelloIO.java&quot;</span>); <span class="comment">//绝对路径</span></span><br><span class="line">        System.out.println(<span class="string">&quot;文件/目录的名称：&quot;</span> + f1.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件/目录的构造路径名：&quot;</span> + f1.getPath());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件/目录的绝对路径名：&quot;</span> + f1.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件/目录的父目录名：&quot;</span> + f1.getParent());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span><span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/HelloIO.java&quot;</span>);<span class="comment">//绝对路径，从根路径开始</span></span><br><span class="line">        System.out.println(<span class="string">&quot;文件/目录的名称：&quot;</span> + f2.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件/目录的构造路径名：&quot;</span> + f2.getPath());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件/目录的绝对路径名：&quot;</span> + f2.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件/目录的父目录名：&quot;</span> + f2.getParent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;HelloIO.java&quot;</span>);<span class="comment">//相对路径</span></span><br><span class="line">        System.out.println(<span class="string">&quot;user.dir =&quot;</span> + System.getProperty(<span class="string">&quot;user.dir&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;文件/目录的名称：&quot;</span> + f3.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件/目录的构造路径名：&quot;</span> + f3.getPath());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件/目录的绝对路径名：&quot;</span> + f3.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件/目录的父目录名：&quot;</span> + f3.getParent());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;HelloIO.java&quot;</span>);<span class="comment">//相对路径</span></span><br><span class="line">        System.out.println(<span class="string">&quot;user.dir =&quot;</span> + System.getProperty(<span class="string">&quot;user.dir&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;文件/目录的名称：&quot;</span> + f5.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件/目录的构造路径名：&quot;</span> + f5.getPath());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件/目录的绝对路径名：&quot;</span> + f5.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件/目录的父目录名：&quot;</span> + f5.getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ol><li><p>无论该路径下是否存在文件或者目录，都不影响File对象的创建。</p></li><li><p>window的路径分隔符使用“\”，而Java程序中的“\”表示转义字符，所以在Windows中表示路径，需要用“\”。或者直接使用“/”也可以，Java程序支持将“/”当成平台无关的<code>路径分隔符</code>。或者直接使用File.separator常量值表示。比如：</p><p>File file2 = new File(“d:” + File.separator + “atguigu” + File.separator + “info.txt”);</p></li><li><p>当构造路径是绝对路径时，那么getPath和getAbsolutePath结果一样</p><p>当构造路径是相对路径时，那么getAbsolutePath的路径 = user.dir的路径 + 构造路径</p></li></ol></blockquote><h3 id="1-3-常用方法"><a href="#1-3-常用方法" class="headerlink" title="1.3 常用方法"></a>1.3 常用方法</h3><h4 id="1、获取文件和目录基本信息"><a href="#1、获取文件和目录基本信息" class="headerlink" title="1、获取文件和目录基本信息"></a>1、获取文件和目录基本信息</h4><ul><li>public String getName() ：获取名称</li><li>public String getPath() ：获取路径</li><li><code>public String getAbsolutePath()</code>：获取绝对路径</li><li>public File getAbsoluteFile()：获取绝对路径表示的文件</li><li><code>public String getParent()</code>：获取上层文件目录路径。若无，返回null</li><li>public long length() ：获取文件长度（即：字节数）。不能获取目录的长度。</li><li>public long lastModified() ：获取最后一次的修改时间，毫秒值</li></ul><blockquote><p>如果File对象代表的文件或目录存在，则File对象实例初始化时，就会用硬盘中对应文件或目录的属性信息（例如，时间、类型等）为File对象的属性赋值，否则除了路径和名称，File对象的其他属性将会保留默认值。</p></blockquote><p><img src="/2023/02/18/java2023/%E7%AC%AC15%E7%AB%A0_File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/image-20220412215446368.png" alt="image-20220412215446368" style="zoom:80%;"></p><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.time.Instant;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.ZoneId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInfoMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/aaa/bbb.txt&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;文件构造路径:&quot;</span>+f.getPath());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件名称:&quot;</span>+f.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件长度:&quot;</span>+f.length()+<span class="string">&quot;字节&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;文件最后修改时间：&quot;</span> + LocalDateTime.ofInstant(Instant.ofEpochMilli(f.lastModified()),ZoneId.of(<span class="string">&quot;Asia/Shanghai&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/aaa&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;目录构造路径:&quot;</span>+f2.getPath());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录名称:&quot;</span>+f2.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录长度:&quot;</span>+f2.length()+<span class="string">&quot;字节&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;文件最后修改时间：&quot;</span> + LocalDateTime.ofInstant(Instant.ofEpochMilli(f.lastModified()),ZoneId.of(<span class="string">&quot;Asia/Shanghai&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">文件构造路径:d:\aaa\bbb.java</span><br><span class="line">文件名称:bbb.java</span><br><span class="line">文件长度:<span class="number">636</span>字节</span><br><span class="line">文件最后修改时间：<span class="number">2022</span>-<span class="number">07</span>-23T22:<span class="number">01</span>:<span class="number">32.065</span></span><br><span class="line"></span><br><span class="line">目录构造路径:d:\aaa</span><br><span class="line">目录名称:aaa</span><br><span class="line">目录长度:<span class="number">4096</span>字节</span><br><span class="line">文件最后修改时间：<span class="number">2022</span>-<span class="number">07</span>-23T22:<span class="number">01</span>:<span class="number">32.065</span></span><br></pre></td></tr></table></figure><h4 id="2、列出目录的下一级"><a href="#2、列出目录的下一级" class="headerlink" title="2、列出目录的下一级"></a>2、列出目录的下一级</h4><ul><li>public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。</li><li>public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。 </li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileFilter;</span><br><span class="line"><span class="keyword">import</span> java.io.FilenameFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirListFiles</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/atguigu&quot;</span>);</span><br><span class="line">        String[] subs = dir.list();</span><br><span class="line">        <span class="keyword">for</span> (String sub : subs) &#123;</span><br><span class="line">            System.out.println(sub);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、File类的重命名功能"><a href="#3、File类的重命名功能" class="headerlink" title="3、File类的重命名功能"></a>3、File类的重命名功能</h4><ul><li>public boolean renameTo(File dest):把文件重命名为指定的文件路径。</li></ul><h4 id="4、判断功能的方法"><a href="#4、判断功能的方法" class="headerlink" title="4、判断功能的方法"></a>4、判断功能的方法</h4><ul><li><code>public boolean exists()</code> ：此File表示的文件或目录是否实际存在。</li><li><code>public boolean isDirectory()</code> ：此File表示的是否为目录。</li><li><code>public boolean isFile()</code> ：此File表示的是否为文件。</li><li>public boolean canRead() ：判断是否可读</li><li>public boolean canWrite() ：判断是否可写</li><li>public boolean isHidden() ：判断是否隐藏</li></ul><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileIs</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\aaa\\bbb.java&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\aaa&quot;</span>);</span><br><span class="line">        <span class="comment">// 判断是否存在</span></span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa\\bbb.java 是否存在:&quot;</span>+f.exists());</span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 是否存在:&quot;</span>+f2.exists());</span><br><span class="line">        <span class="comment">// 判断是文件还是目录</span></span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 文件?:&quot;</span>+f2.isFile());</span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 目录?:&quot;</span>+f2.isDirectory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">d:\aaa\bbb.java 是否存在:true</span><br><span class="line">d:\aaa 是否存在:true</span><br><span class="line">d:\aaa 文件?:false</span><br><span class="line">d:\aaa 目录?:true</span><br></pre></td></tr></table></figure><blockquote><p>如果文件或目录不存在，那么exists()、isFile()和isDirectory()都是返回true</p></blockquote><h4 id="5、创建、删除功能"><a href="#5、创建、删除功能" class="headerlink" title="5、创建、删除功能"></a>5、创建、删除功能</h4><ul><li><code>public boolean createNewFile()</code> ：创建文件。若文件存在，则不创建，返回false。</li><li><code>public boolean mkdir()</code> ：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。</li><li><code>public boolean mkdirs()</code> ：创建文件目录。如果上层文件目录不存在，一并创建。</li><li><code>public boolean delete()</code> ：删除文件或者文件夹<br>删除注意事项：① Java中的删除不走回收站。② 要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录。</li></ul><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileCreateDelete</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 文件的创建</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;aaa.txt&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;aaa.txt是否存在:&quot;</span>+f.exists()); </span><br><span class="line">        System.out.println(<span class="string">&quot;aaa.txt是否创建:&quot;</span>+f.createNewFile()); </span><br><span class="line">        System.out.println(<span class="string">&quot;aaa.txt是否存在:&quot;</span>+f.exists()); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目录的创建</span></span><br><span class="line">        File f2= <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;newDir&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;newDir是否存在:&quot;</span>+f2.exists());</span><br><span class="line">        System.out.println(<span class="string">&quot;newDir是否创建:&quot;</span>+f2.mkdir());</span><br><span class="line">        System.out.println(<span class="string">&quot;newDir是否存在:&quot;</span>+f2.exists());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一级目录</span></span><br><span class="line">        File f3= <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;newDira\\newDirb&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;newDira\\newDirb创建：&quot;</span> + f3.mkdir());</span><br><span class="line">        File f4= <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;newDir\\newDirb&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;newDir\\newDirb创建：&quot;</span> + f4.mkdir());</span><br><span class="line">        <span class="comment">// 创建多级目录</span></span><br><span class="line">        File f5= <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;newDira\\newDirb&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;newDira\\newDirb创建：&quot;</span> + f5.mkdirs());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 文件的删除</span></span><br><span class="line">        System.out.println(<span class="string">&quot;aaa.txt删除：&quot;</span> + f.delete());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目录的删除</span></span><br><span class="line">        System.out.println(<span class="string">&quot;newDir删除：&quot;</span> + f2.delete());</span><br><span class="line">        System.out.println(<span class="string">&quot;newDir\\newDirb删除：&quot;</span> + f4.delete());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">aaa.txt是否存在:<span class="literal">false</span></span><br><span class="line">aaa.txt是否创建:<span class="literal">true</span></span><br><span class="line">aaa.txt是否存在:<span class="literal">true</span></span><br><span class="line">newDir是否存在:<span class="literal">false</span></span><br><span class="line">newDir是否创建:<span class="literal">true</span></span><br><span class="line">newDir是否存在:<span class="literal">true</span></span><br><span class="line">newDira\newDirb创建：<span class="literal">false</span></span><br><span class="line">newDir\newDirb创建：<span class="literal">true</span></span><br><span class="line">newDira\newDirb创建：<span class="literal">true</span></span><br><span class="line">aaa.txt删除：<span class="literal">true</span></span><br><span class="line">newDir删除：<span class="literal">false</span></span><br><span class="line">newDir\newDirb删除：<span class="literal">true</span></span><br></pre></td></tr></table></figure><blockquote><p>API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。</p></blockquote><h3 id="1-4-练习"><a href="#1-4-练习" class="headerlink" title="1.4 练习"></a>1.4 练习</h3><p>练习1：利用File构造器，new 一个文件目录file</p><p>​      1) 在其中创建多个文件和目录</p><p>​      2) 编写方法，实现删除file中指定文件的操作</p><p>练习2：判断指定目录下是否有后缀名为.jpg的文件。如果有，就输出该文件名称</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindJPGFileTest</span> &#123;</span><br><span class="line"><span class="comment">//方法1：</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\code&quot;</span>);</span><br><span class="line"></span><br><span class="line">String[] fileNames = srcFile.list();</span><br><span class="line"><span class="keyword">for</span>(String fileName : fileNames)&#123;</span><br><span class="line"><span class="keyword">if</span>(fileName.endsWith(<span class="string">&quot;.jpg&quot;</span>))&#123;</span><br><span class="line">System.out.println(fileName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//方法2：</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\code&quot;</span>);</span><br><span class="line"></span><br><span class="line">File[] listFiles = srcFile.listFiles();</span><br><span class="line"><span class="keyword">for</span>(File file : listFiles)&#123;</span><br><span class="line"><span class="keyword">if</span>(file.getName().endsWith(<span class="string">&quot;.jpg&quot;</span>))&#123;</span><br><span class="line">System.out.println(file.getAbsolutePath());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//方法3：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * File类提供了两个文件过滤器方法</span></span><br><span class="line"><span class="comment"> * public String[] list(FilenameFilter filter)</span></span><br><span class="line"><span class="comment"> * public File[] listFiles(FileFilter filter)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\code&quot;</span>);</span><br><span class="line"></span><br><span class="line">File[] subFiles = srcFile.listFiles(<span class="keyword">new</span> <span class="title class_">FilenameFilter</span>() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File dir, String name)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> name.endsWith(<span class="string">&quot;.jpg&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(File file : subFiles)&#123;</span><br><span class="line">System.out.println(file.getAbsolutePath());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>练习3：遍历指定目录所有文件名称，包括子文件目录中的文件。</p><p>  拓展1：并计算指定目录占用空间的大小</p><p>  拓展2：删除指定文件目录及其下的所有文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListFilesTest</span> &#123;</span><br><span class="line"><span class="comment">//练习3：(方式1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printSubFile</span><span class="params">(File dir)</span> &#123;</span><br><span class="line">        <span class="comment">// 打印目录的子文件</span></span><br><span class="line">        File[] subfiles = dir.listFiles();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (File f : subfiles) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f.isDirectory()) &#123;<span class="comment">// 文件目录</span></span><br><span class="line">                printSubFile(f);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 文件</span></span><br><span class="line">                System.out.println(f.getAbsolutePath());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// //练习3：(方式2)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listAllSubFiles</span><span class="params">(File file)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            File[] all = file.listFiles();</span><br><span class="line">            <span class="comment">// 如果all[i]是文件，直接打印</span></span><br><span class="line">            <span class="comment">// 如果all[i]是目录，接着再获取它的下一级</span></span><br><span class="line">            <span class="keyword">for</span> (File f : all) &#123;</span><br><span class="line">                listAllSubFiles(f);<span class="comment">// 递归调用：自己调用自己就叫递归</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testListAllFiles</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建目录对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\teach\\01_javaSE\\_尚硅谷Java编程语言\\3_软件&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.打印目录的子文件</span></span><br><span class="line">        printSubFile(dir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拓展1：求指定目录所在空间的大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getDirectorySize</span><span class="params">(File file)</span> &#123;</span><br><span class="line">        <span class="comment">// file是文件，那么直接返回file.length()</span></span><br><span class="line">        <span class="comment">// file是目录，把它的下一级的所有file大小加起来就是它的总大小</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">            size = file.length();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            File[] all = file.listFiles();<span class="comment">// 获取file的下一级</span></span><br><span class="line">            <span class="comment">// 累加all[i]的大小</span></span><br><span class="line">            <span class="keyword">for</span> (File f : all) &#123;</span><br><span class="line">                size += getDirectorySize(f);<span class="comment">// f的大小;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拓展2：删除指定的目录</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteDirectory</span><span class="params">(File file)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果file是文件，直接delete</span></span><br><span class="line">        <span class="comment">// 如果file是目录，先把它的下一级干掉，然后删除自己</span></span><br><span class="line">        <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">            File[] all = file.listFiles();</span><br><span class="line">            <span class="comment">// 循环删除的是file的下一级</span></span><br><span class="line">            <span class="keyword">for</span> (File f : all) &#123;<span class="comment">// f代表file的每一个下级</span></span><br><span class="line">                deleteDirectory(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除自己</span></span><br><span class="line">        file.delete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-IO流原理及流的分类"><a href="#2-IO流原理及流的分类" class="headerlink" title="2. IO流原理及流的分类"></a>2. IO流原理及流的分类</h2><p><img src="/2023/02/18/java2023/%E7%AC%AC15%E7%AB%A0_File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/image-20220412224132724.png" alt="image-20220412224132724"></p><h3 id="2-1-Java-IO原理"><a href="#2-1-Java-IO原理" class="headerlink" title="2.1 Java IO原理"></a>2.1 Java IO原理</h3><ul><li><p>Java程序中，对于数据的输入/输出操作以“<code>流(stream)</code>” 的方式进行，可以看做是一种数据的流动。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC15%E7%AB%A0_File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/image-20220503123117300.png" alt="image-20220503123117300" style="zoom: 80%;"></p></li><li><p>I/O流中的I/O是<code>Input/Output</code>的缩写， I/O技术是非常实用的技术，用于处理设备之间的数据传输。如读/写文件，网络通讯等。</p><ul><li><code>输入input</code>：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中。</li><li><code>输出output</code>：将程序（内存）数据输出到磁盘、光盘等存储设备中。</li></ul></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC15%E7%AB%A0_File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/image-20220412224700133.png" alt="image-20220412224700133"></p><h3 id="2-2-流的分类"><a href="#2-2-流的分类" class="headerlink" title="2.2 流的分类"></a>2.2 流的分类</h3><p><code>java.io</code>包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过<code>标准的方法</code>输入或输出数据。</p><ul><li><p>按数据的流向不同分为：<strong>输入流</strong>和<strong>输出流</strong>。</p><ul><li><strong>输入流</strong> ：把数据从<code>其他设备</code>上读取到<code>内存</code>中的流。 <ul><li>以InputStream、Reader结尾</li></ul></li><li><strong>输出流</strong> ：把数据从<code>内存</code> 中写出到<code>其他设备</code>上的流。<ul><li>以OutputStream、Writer结尾</li></ul></li></ul></li><li><p>按操作数据单位的不同分为：<strong>字节流（8bit）</strong>和<strong>字符流（16bit）</strong>。</p><ul><li><strong>字节流</strong> ：以字节为单位，读写数据的流。<ul><li>以InputStream、OutputStream结尾</li></ul></li><li><strong>字符流</strong> ：以字符为单位，读写数据的流。<ul><li>以Reader、Writer结尾</li></ul></li></ul></li><li><p>根据IO流的角色不同分为：<strong>节点流</strong>和<strong>处理流</strong>。</p><ul><li><p><strong>节点流</strong>：直接从数据源或目的地读写数据</p><p><img src="/2023/02/18/java2023/%E7%AC%AC15%E7%AB%A0_File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/image-20220412230745170.png" alt="image-20220412230745170"></p></li><li><p><strong>处理流</strong>：不直接连接到数据源或目的地，而是“连接”在已存在的流（节点流或处理流）之上，通过对数据的处理为程序提供更为强大的读写功能。</p><p><img src="/2023/02/18/java2023/%E7%AC%AC15%E7%AB%A0_File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/image-20220412230751461.png" alt="image-20220412230751461"></p></li></ul></li></ul><p>小结：图解</p><p><img src="/2023/02/18/java2023/%E7%AC%AC15%E7%AB%A0_File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/image-20220412225253349.png" alt="image-20220412225253349" style="zoom:67%;"></p><h3 id="2-3-流的API"><a href="#2-3-流的API" class="headerlink" title="2.3 流的API"></a>2.3 流的API</h3><ul><li>Java的IO流共涉及40多个类，实际上非常规则，都是从如下4个抽象基类派生的。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">（抽象基类）</th><th style="text-align:center">输入流</th><th style="text-align:center">输出流</th></tr></thead><tbody><tr><td style="text-align:center">字节流</td><td style="text-align:center">InputStream</td><td style="text-align:center">OutputStream</td></tr><tr><td style="text-align:center">字符流</td><td style="text-align:center">Reader</td><td style="text-align:center">Writer</td></tr></tbody></table></div><ul><li>由这四个类派生出来的子类名称都是以其父类名作为子类名后缀。</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC15%E7%AB%A0_File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/image-20220412230501953.png" alt="image-20220412230501953"></p><p><strong>常用的节点流：</strong> 　</p><ul><li>文件流： FileInputStream、FileOutputStrean、FileReader、FileWriter </li><li>字节/字符数组流： ByteArrayInputStream、ByteArrayOutputStream、CharArrayReader、CharArrayWriter <ul><li>对数组进行处理的节点流（对应的不再是文件，而是内存中的一个数组）。</li></ul></li></ul><p><strong>常用处理流：</strong></p><ul><li>缓冲流：BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter<ul><li>作用：增加缓冲功能，避免频繁读写硬盘，进而提升读写效率。</li></ul></li><li>转换流：InputStreamReader、OutputStreamReader<ul><li>作用：实现字节流和字符流之间的转换。</li></ul></li><li>对象流：ObjectInputStream、ObjectOutputStream<ul><li>作用：提供直接读写Java对象功能</li></ul></li></ul><h2 id="3-节点流之一：FileReader-FileWriter"><a href="#3-节点流之一：FileReader-FileWriter" class="headerlink" title="3. 节点流之一：FileReader\FileWriter"></a>3. 节点流之一：FileReader\FileWriter</h2><h3 id="3-1-Reader与Writer"><a href="#3-1-Reader与Writer" class="headerlink" title="3.1 Reader与Writer"></a>3.1 Reader与Writer</h3><p>Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。不能操作图片，视频等非文本文件。</p><blockquote><p>常见的文本文件有如下的格式：.txt、.java、.c、.cpp、.py等</p><p>注意：.doc、.xls、.ppt这些都不是文本文件。</p></blockquote><h4 id="3-1-1-字符输入流：Reader"><a href="#3-1-1-字符输入流：Reader" class="headerlink" title="3.1.1 字符输入流：Reader"></a>3.1.1 字符输入流：Reader</h4><p><code>java.io.Reader</code>抽象类是表示用于读取字符流的所有类的父类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。</p><ul><li><code>public int read()</code>： 从输入流读取一个字符。 虽然读取了一个字符，但是会自动提升为int类型。返回该字符的Unicode编码值。如果已经到达流末尾了，则返回-1。</li><li><code>public int read(char[] cbuf)</code>： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。每次最多读取cbuf.length个字符。返回实际读取的字符个数。如果已经到达流末尾，没有数据可读，则返回-1。 </li><li><code>public int read(char[] cbuf,int off,int len)</code>：从输入流中读取一些字符，并将它们存储到字符数组 cbuf中，从cbuf[off]开始的位置存储。每次最多读取len个字符。返回实际读取的字符个数。如果已经到达流末尾，没有数据可读，则返回-1。 </li><li><code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。    </li></ul><blockquote><p>注意：当完成流的操作时，必须调用close()方法，释放系统资源，否则会造成内存泄漏。</p></blockquote><h4 id="3-1-2-字符输出流：Writer"><a href="#3-1-2-字符输出流：Writer" class="headerlink" title="3.1.2 字符输出流：Writer"></a>3.1.2 字符输出流：Writer</h4><p><code>java.io.Writer</code>抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p><ul><li><code>public void write(int c)</code> ：写出单个字符。</li><li><code>public void write(char[] cbuf)</code>：写出字符数组。 </li><li><code>public void write(char[] cbuf, int off, int len)</code>：写出字符数组的某一部分。off：数组的开始索引；len：写出的字符个数。 </li><li><code>public void write(String str)</code>：写出字符串。 </li><li><code>public void write(String str, int off, int len)</code> ：写出字符串的某一部分。off：字符串的开始索引；len：写出的字符个数。</li><li><code>public void flush()</code>：刷新该流的缓冲。  </li><li><code>public void close()</code> ：关闭此流。</li></ul><blockquote><p>注意：当完成流的操作时，必须调用close()方法，释放系统资源，否则会造成内存泄漏。</p></blockquote><h3 id="3-2-FileReader-与-FileWriter"><a href="#3-2-FileReader-与-FileWriter" class="headerlink" title="3.2 FileReader 与 FileWriter"></a>3.2 FileReader 与 FileWriter</h3><h4 id="3-2-1-FileReader"><a href="#3-2-1-FileReader" class="headerlink" title="3.2.1 FileReader"></a>3.2.1 FileReader</h4><p><code>java.io.FileReader</code>类用于读取字符文件，构造时使用系统默认的字符编码和默认字节缓冲区。</p><ul><li><code>FileReader(File file)</code>： 创建一个新的 FileReader ，给定要读取的File对象。   </li><li><code>FileReader(String fileName)</code>： 创建一个新的 FileReader ，给定要读取的文件的名称。  </li></ul><p><strong>举例：</strong>读取hello.txt文件中的字符数据，并显示在控制台上</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 14:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderWriterTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//实现方式1</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1. 创建File类的对象，对应着物理磁盘上的某个文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 创建FileReader流对象，将File类的对象作为参数传递到FileReader的构造器中</span></span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line">        <span class="comment">//3. 通过相关流的方法，读取文件中的数据</span></span><br><span class="line"><span class="comment">//        int data = fr.read(); //每调用一次读取一个字符</span></span><br><span class="line"><span class="comment">//        while (data != -1) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.print((char) data);</span></span><br><span class="line"><span class="comment">//            data = fr.read();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="type">int</span> data;</span><br><span class="line">        <span class="keyword">while</span> ((data = fr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>) data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 关闭相关的流资源，避免出现内存泄漏</span></span><br><span class="line">        fr.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现方式2：在方式1的基础上改进，使用try-catch-finally处理异常。保证流是可以关闭的</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 创建File类的对象，对应着物理磁盘上的某个文件</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">            <span class="comment">//2. 创建FileReader流对象，将File类的对象作为参数传递到FileReader的构造器中</span></span><br><span class="line">            fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line">            <span class="comment">//3. 通过相关流的方法，读取文件中的数据</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * read():每次从对接的文件中读取一个字符。并将此字符返回。</span></span><br><span class="line"><span class="comment">             * 如果返回值为-1,则表示文件到了末尾，可以不再读取。</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line"><span class="comment">//            int data = fr.read();</span></span><br><span class="line"><span class="comment">//            while(data != -1)&#123;</span></span><br><span class="line"><span class="comment">//                System.out.print((char)data);</span></span><br><span class="line"><span class="comment">//                data = fr.read();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> data;</span><br><span class="line">            <span class="keyword">while</span> ((data = fr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println((<span class="type">char</span>) data);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4. 关闭相关的流资源，避免出现内存泄漏</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fr != <span class="literal">null</span>)</span><br><span class="line">                    fr.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现方式3：调用read(char[] cbuf),每次从文件中读取多个字符</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 创建File类的对象，对应着物理磁盘上的某个文件</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">            <span class="comment">//2. 创建FileReader流对象，将File类的对象作为参数传递到FileReader的构造器中</span></span><br><span class="line">            fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line">            <span class="comment">//3. 通过相关流的方法，读取文件中的数据</span></span><br><span class="line">            <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * read(char[] cbuf) : 每次将文件中的数据读入到cbuf数组中，并返回读入到数组中的</span></span><br><span class="line"><span class="comment">             * 字符的个数。</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            <span class="type">int</span> len; <span class="comment">//记录每次读入的字符的个数</span></span><br><span class="line">            <span class="keyword">while</span> ((len = fr.read(cbuf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//处理char[]数组即可</span></span><br><span class="line">                <span class="comment">//错误：</span></span><br><span class="line"><span class="comment">//                for(int i = 0;i &lt; cbuf.length;i++)&#123;</span></span><br><span class="line"><span class="comment">//                    System.out.print(cbuf[i]);</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">                <span class="comment">//错误：</span></span><br><span class="line"><span class="comment">//                String str = new String(cbuf);</span></span><br><span class="line"><span class="comment">//                System.out.print(str);</span></span><br><span class="line">                <span class="comment">//正确：</span></span><br><span class="line"><span class="comment">//                for(int i = 0;i &lt; len;i++)&#123;</span></span><br><span class="line"><span class="comment">//                    System.out.print(cbuf[i]);</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">                <span class="comment">//正确：</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cbuf, <span class="number">0</span>, len);</span><br><span class="line">                System.out.print(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4. 关闭相关的流资源，避免出现内存泄漏</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fr != <span class="literal">null</span>)</span><br><span class="line">                    fr.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同实现方式的类比：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC15%E7%AB%A0_File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/image-20220518095907714.png" alt="image-20220518095907714"></p><h4 id="3-2-2-FileWriter"><a href="#3-2-2-FileWriter" class="headerlink" title="3.2.2 FileWriter"></a>3.2.2 FileWriter</h4><p><code>java.io.FileWriter</code>类用于写出字符到文件，构造时使用系统默认的字符编码和默认字节缓冲区。</p><ul><li><code>FileWriter(File file)</code>： 创建一个新的 FileWriter，给定要读取的File对象。   </li><li><code>FileWriter(String fileName)</code>： 创建一个新的 FileWriter，给定要读取的文件的名称。  </li><li><code>FileWriter(File file,boolean append)</code>： 创建一个新的 FileWriter，指明是否在现有文件末尾追加内容。</li></ul><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FWWrite</span> &#123;</span><br><span class="line">    <span class="comment">//注意：应该使用try-catch-finally处理异常。这里出于方便阅读代码，使用了throws的方式</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span><span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;fw.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 写出数据</span></span><br><span class="line">        fw.write(<span class="number">97</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">        fw.write(<span class="string">&#x27;b&#x27;</span>); <span class="comment">// 写出第2个字符</span></span><br><span class="line">        fw.write(<span class="string">&#x27;C&#x27;</span>); <span class="comment">// 写出第3个字符</span></span><br><span class="line">        fw.write(<span class="number">30000</span>); <span class="comment">// 写出第4个字符，中文编码表中30000对应一个汉字。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//注意：应该使用try-catch-finally处理异常。这里出于方便阅读代码，使用了throws的方式</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span><span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;fw.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">        <span class="type">char</span>[] chars = <span class="string">&quot;尚硅谷&quot;</span>.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写出字符数组</span></span><br><span class="line">        fw.write(chars); <span class="comment">// 尚硅谷</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写出从索引1开始，2个字符。</span></span><br><span class="line">        fw.write(chars,<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// 硅谷</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//注意：应该使用try-catch-finally处理异常。这里出于方便阅读代码，使用了throws的方式</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span><span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;fw.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;尚硅谷&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写出字符数组</span></span><br><span class="line">        fw.write(msg); <span class="comment">//尚硅谷</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写出从索引1开始，2个字符。</span></span><br><span class="line">        fw.write(msg,<span class="number">1</span>,<span class="number">2</span>);<span class="comment">// 硅谷</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 创建File的对象</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;personinfo.txt&quot;</span>);</span><br><span class="line">            <span class="comment">//2. 创建FileWriter的对象，将File对象作为参数传递到FileWriter的构造器中</span></span><br><span class="line">            <span class="comment">//如果输出的文件已存在，则会对现有的文件进行覆盖</span></span><br><span class="line">            fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file);</span><br><span class="line"><span class="comment">//            fw = new FileWriter(file,false);</span></span><br><span class="line">            <span class="comment">//如果输出的文件已存在，则会在现有的文件末尾写入数据</span></span><br><span class="line"><span class="comment">//            fw = new FileWriter(file,true);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//3. 调用相关的方法，实现数据的写出操作</span></span><br><span class="line">            <span class="comment">//write(String str) / write(char[] cbuf)</span></span><br><span class="line">            fw.write(<span class="string">&quot;I love you,&quot;</span>);</span><br><span class="line">            fw.write(<span class="string">&quot;you love him.&quot;</span>);</span><br><span class="line">            fw.write(<span class="string">&quot;so sad&quot;</span>.toCharArray());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4. 关闭资源，避免内存泄漏</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fw != <span class="literal">null</span>)</span><br><span class="line">                    fw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-3-小结"><a href="#3-2-3-小结" class="headerlink" title="3.2.3 小结"></a>3.2.3 小结</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">① </span><br><span class="line">因为出现流资源的调用，为了避免内存泄漏，需要使用try-catch-finally处理异常</span><br><span class="line"></span><br><span class="line">② </span><br><span class="line">对于输入流来说，File类的对象必须在物理磁盘上存在，否则执行就会报FileNotFoundException。如果传入的是一个目录，则会报IOException异常。</span><br><span class="line"></span><br><span class="line">对于输出流来说，File类的对象是可以不存在的。</span><br><span class="line">   &gt; 如果File类的对象不存在，则可以在输出的过程中，自动创建File类的对象</span><br><span class="line">   &gt; 如果File类的对象存在，</span><br><span class="line">      &gt; 如果调用FileWriter(File file)或FileWriter(File file,false)，输出时会新建File文件覆盖已有的文件</span><br><span class="line">      &gt; 如果调用FileWriter(File file,true)构造器，则在现有的文件末尾追加写出内容。</span><br></pre></td></tr></table></figure><h3 id="3-3-关于flush（刷新）"><a href="#3-3-关于flush（刷新）" class="headerlink" title="3.3  关于flush（刷新）"></a>3.3  关于flush（刷新）</h3><p>因为内置缓冲区的原因，如果FileWriter不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要<code>flush()</code> 方法了。</p><ul><li><code>flush()</code> ：刷新缓冲区，流对象可以继续使用。</li><li><code>close()</code>：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</li></ul><p>注意：即便是flush()方法写出了数据，操作的最后还是要调用close方法，释放系统资源。</p><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FWWriteFlush</span> &#123;</span><br><span class="line">    <span class="comment">//注意：应该使用try-catch-finally处理异常。这里出于方便阅读代码，使用了throws的方式</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;fw.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 写出数据，通过flush</span></span><br><span class="line">        fw.write(<span class="string">&#x27;刷&#x27;</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">        fw.flush();</span><br><span class="line">        fw.write(<span class="string">&#x27;新&#x27;</span>); <span class="comment">// 继续写出第2个字符，写出成功</span></span><br><span class="line">        fw.flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写出数据，通过close</span></span><br><span class="line">        fw.write(<span class="string">&#x27;关&#x27;</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">        fw.close();</span><br><span class="line">        fw.write(<span class="string">&#x27;闭&#x27;</span>); <span class="comment">// 继续写出第2个字符,【报错】java.io.IOException: Stream closed</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-节点流之二：FileInputStream-FileOutputStream"><a href="#4-节点流之二：FileInputStream-FileOutputStream" class="headerlink" title="4. 节点流之二：FileInputStream\FileOutputStream"></a>4. 节点流之二：FileInputStream\FileOutputStream</h2><p>如果我们读取或写出的数据是非文本文件，则Reader、Writer就无能为力了，必须使用字节流。</p><h3 id="4-1-InputStream和OutputStream"><a href="#4-1-InputStream和OutputStream" class="headerlink" title="4.1 InputStream和OutputStream"></a>4.1 InputStream和OutputStream</h3><h4 id="4-1-1-字节输入流：InputStream"><a href="#4-1-1-字节输入流：InputStream" class="headerlink" title="4.1.1 字节输入流：InputStream"></a>4.1.1 字节输入流：InputStream</h4><p><code>java.io.InputStream</code>抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p><ul><li><code>public int read()</code>： 从输入流读取一个字节。返回读取的字节值。虽然读取了一个字节，但是会自动提升为int类型。如果已经到达流末尾，没有数据可读，则返回-1。 </li><li><code>public int read(byte[] b)</code>： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。每次最多读取b.length个字节。返回实际读取的字节个数。如果已经到达流末尾，没有数据可读，则返回-1。 </li><li><code>public int read(byte[] b,int off,int len)</code>：从输入流中读取一些字节数，并将它们存储到字节数组 b中，从b[off]开始存储，每次最多读取len个字节 。返回实际读取的字节个数。如果已经到达流末尾，没有数据可读，则返回-1。 </li><li><code>public void close()</code> ：关闭此输入流并释放与此流相关联的任何系统资源。    </li></ul><blockquote><p>说明：close()方法，当完成流的操作时，必须调用此方法，释放系统资源。</p></blockquote><h4 id="4-1-2-字节输出流：OutputStream"><a href="#4-1-2-字节输出流：OutputStream" class="headerlink" title="4.1.2 字节输出流：OutputStream"></a>4.1.2 字节输出流：OutputStream</h4><p><code>java.io.OutputStream</code>抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p><ul><li><code>public void write(int b)</code> ：将指定的字节输出流。虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。</li><li><code>public void write(byte[] b)</code>：将 b.length字节从指定的字节数组写入此输出流。  </li><li><code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。  </li><li><code>public void flush()</code> ：刷新此输出流并强制任何缓冲的输出字节被写出。  </li><li><code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。  </li></ul><blockquote><p>说明：close()方法，当完成流的操作时，必须调用此方法，释放系统资源。</p></blockquote><h3 id="4-2-FileInputStream-与-FileOutputStream"><a href="#4-2-FileInputStream-与-FileOutputStream" class="headerlink" title="4.2 FileInputStream 与 FileOutputStream"></a>4.2 FileInputStream 与 FileOutputStream</h3><h4 id="4-2-1-FileInputStream"><a href="#4-2-1-FileInputStream" class="headerlink" title="4.2.1 FileInputStream"></a>4.2.1 FileInputStream</h4><p><code>java.io.FileInputStream</code>类是文件输入流，从文件中读取字节。</p><ul><li><code>FileInputStream(File file)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 </li><li><code>FileInputStream(String name)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。  </li></ul><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//read.txt文件中的内容如下：</span></span><br><span class="line">abcde</span><br></pre></td></tr></table></figure><p>读取操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FISRead</span> &#123;</span><br><span class="line">    <span class="comment">//注意：应该使用try-catch-finally处理异常。这里出于方便阅读代码，使用了throws的方式</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;read.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 读取数据，返回一个字节</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> fis.read();</span><br><span class="line">        System.out.println((<span class="type">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="type">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="type">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="type">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="type">char</span>) read);</span><br><span class="line">        <span class="comment">// 读取到末尾,返回-1</span></span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println(read);</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        文件内容：abcde</span></span><br><span class="line"><span class="comment">        输出结果：</span></span><br><span class="line"><span class="comment">        a</span></span><br><span class="line"><span class="comment">        b</span></span><br><span class="line"><span class="comment">        c</span></span><br><span class="line"><span class="comment">        d</span></span><br><span class="line"><span class="comment">        e</span></span><br><span class="line"><span class="comment">        -1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span><span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;read.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 定义变量，保存数据</span></span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((b = fis.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="type">char</span>)b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span><span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象.</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;read.txt&quot;</span>); <span class="comment">// 文件中为abcde</span></span><br><span class="line">        <span class="comment">// 定义变量，作为有效个数</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="comment">// 定义字节数组，作为装字节数据的容器</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> (( len= fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 每次读取后,把数组变成字符串打印</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(b));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出结果：</span></span><br><span class="line"><span class="comment">        ab</span></span><br><span class="line"><span class="comment">        cd</span></span><br><span class="line"><span class="comment">        ed</span></span><br><span class="line"><span class="comment">        最后错误数据`d`，是由于最后一次读取时，只读取一个字节`e`，数组中，</span></span><br><span class="line"><span class="comment">        上次读取的数据没有被完全替换，所以要通过`len` ，获取有效的字节</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span><span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象.</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;read.txt&quot;</span>); <span class="comment">// 文件中为abcde</span></span><br><span class="line">        <span class="comment">// 定义变量，作为有效个数</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="comment">// 定义字节数组，作为装字节数据的容器</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> (( len= fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 每次读取后,把数组的有效字节部分，变成字符串打印</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(b,<span class="number">0</span>,len));<span class="comment">//  len 每次读取的有效字节个数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出结果：</span></span><br><span class="line"><span class="comment">        ab</span></span><br><span class="line"><span class="comment">        cd</span></span><br><span class="line"><span class="comment">        e</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-2-FileOutputStream"><a href="#4-2-2-FileOutputStream" class="headerlink" title="4.2.2 FileOutputStream"></a>4.2.2 FileOutputStream</h4><p><code>java.io.FileOutputStream</code>类是文件输出流，用于将数据写出到文件。</p><ul><li><code>public FileOutputStream(File file)</code>：创建文件输出流，写出由指定的 File对象表示的文件。 </li><li><code>public FileOutputStream(String name)</code>： 创建文件输出流，指定的名称为写出文件。</li><li><code>public FileOutputStream(File file, boolean append)</code>：  创建文件输出流，指明是否在现有文件末尾追加内容。</li></ul><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.fileio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FOSWrite</span> &#123;</span><br><span class="line">    <span class="comment">//注意：应该使用try-catch-finally处理异常。这里出于方便阅读代码，使用了throws的方式</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;fos.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 写出数据</span></span><br><span class="line">        fos.write(<span class="number">97</span>); <span class="comment">// 写出第1个字节</span></span><br><span class="line">        fos.write(<span class="number">98</span>); <span class="comment">// 写出第2个字节</span></span><br><span class="line">        fos.write(<span class="number">99</span>); <span class="comment">// 写出第3个字节</span></span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">      <span class="comment">/*  输出结果：abc*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span><span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;fos.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="string">&quot;abcde&quot;</span>.getBytes();</span><br><span class="line">        <span class="comment">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span></span><br><span class="line">        fos.write(b,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这段程序如果多运行几次，每次都会在原来文件末尾追加abcde</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span><span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;fos.txt&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="string">&quot;abcde&quot;</span>.getBytes();</span><br><span class="line">        fos.write(b);</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用FileInputStream\FileOutputStream，实现对文件的复制</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 造文件-造流</span></span><br><span class="line">            <span class="comment">//复制图片：成功</span></span><br><span class="line"><span class="comment">//            fis = new FileInputStream(new File(&quot;pony.jpg&quot;));</span></span><br><span class="line"><span class="comment">//            fos = new FileOutputStream(new File(&quot;pony_copy1.jpg&quot;));</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//复制文本文件：成功</span></span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>));</span><br><span class="line">            fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello1.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2. 复制操作（读、写）</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;<span class="comment">//每次读入到buffer中字节的个数</span></span><br><span class="line">            <span class="keyword">while</span> ((len = fis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line"><span class="comment">//                String str = new String(buffer,0,len);</span></span><br><span class="line"><span class="comment">//                System.out.print(str);</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;复制成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//3. 关闭资源</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fos != <span class="literal">null</span>)</span><br><span class="line">                    fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fis != <span class="literal">null</span>)</span><br><span class="line">                    fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-练习"><a href="#4-3-练习" class="headerlink" title="4.3 练习"></a>4.3 练习</h3><p><strong>练习：</strong>实现图片加密操作。</p><p>提示：</p><p> <img src="/2023/02/18/java2023/%E7%AC%AC15%E7%AB%A0_File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/image-20220413002723838.png" alt="image-20220413002723838"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 8:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileSecretTest</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 图片的加密</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;pony.jpg&quot;</span>);</span><br><span class="line">            <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;pony_secret.jpg&quot;</span>);</span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file1);</span><br><span class="line">            fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file2);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//方式1：每次读入一个字节，效率低</span></span><br><span class="line"><span class="comment">//            int data;</span></span><br><span class="line"><span class="comment">//            while((data = fis.read()) != -1)&#123;</span></span><br><span class="line"><span class="comment">//                fos.write(data ^ 5);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            <span class="comment">//方式2：每次读入一个字节数组，效率高</span></span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">                    buffer[i] = (<span class="type">byte</span>) (buffer[i] ^ <span class="number">5</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;加密成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 图片的解密</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;pony_secret.jpg&quot;</span>);</span><br><span class="line">            <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;pony_unsecret.jpg&quot;</span>);</span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file1);</span><br><span class="line">            fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file2);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//方式1：每次读入一个字节，效率低</span></span><br><span class="line"><span class="comment">//            int data;</span></span><br><span class="line"><span class="comment">//            while((data = fis.read()) != -1)&#123;</span></span><br><span class="line"><span class="comment">//                fos.write(data ^ 5);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            <span class="comment">//方式2：每次读入一个字节数组，效率高</span></span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">                    buffer[i] = (<span class="type">byte</span>) (buffer[i] ^ <span class="number">5</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;解密成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-处理流之一：缓冲流"><a href="#5-处理流之一：缓冲流" class="headerlink" title="5. 处理流之一：缓冲流"></a>5. 处理流之一：缓冲流</h2><ul><li><p><code>为了提高数据读写的速度</code>，Java API提供了带缓冲功能的流类：缓冲流。</p></li><li><p>缓冲流要“套接”在相应的节点流之上，根据数据操作单位可以把缓冲流分为：</p><ul><li><strong>字节缓冲流</strong>：<code>BufferedInputStream</code>，<code>BufferedOutputStream</code> </li><li><strong>字符缓冲流</strong>：<code>BufferedReader</code>，<code>BufferedWriter</code></li></ul></li><li><p>缓冲流的基本原理：在创建流对象时，内部会创建一个缓冲区数组（缺省使用<code>8192个字节(8Kb)</code>的缓冲区），通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</p></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC15%E7%AB%A0_File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/image-20220413002314063.png" alt="image-20220413002314063"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC15%E7%AB%A0_File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/image-20220514183413011.png" alt="image-20220514183413011" style="zoom:80%;"></p><h3 id="5-1-构造器"><a href="#5-1-构造器" class="headerlink" title="5.1 构造器"></a>5.1 构造器</h3><ul><li><code>public BufferedInputStream(InputStream in)</code> ：创建一个 新的字节型的缓冲输入流。 </li><li><code>public BufferedOutputStream(OutputStream out)</code>： 创建一个新的字节型的缓冲输出流。</li></ul><p>代码举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建字节缓冲输入流</span></span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;abc.jpg&quot;</span>));</span><br><span class="line"><span class="comment">// 创建字节缓冲输出流</span></span><br><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;abc_copy.jpg&quot;</span>));</span><br></pre></td></tr></table></figure><ul><li><code>public BufferedReader(Reader in)</code> ：创建一个 新的字符型的缓冲输入流。 </li><li><code>public BufferedWriter(Writer out)</code>： 创建一个新的字符型的缓冲输出流。</li></ul><p>代码举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建字符缓冲输入流</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;br.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 创建字符缓冲输出流</span></span><br><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;bw.txt&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="5-2-效率测试"><a href="#5-2-效率测试" class="headerlink" title="5.2 效率测试"></a>5.2 效率测试</h3><p>查询API，缓冲流读写方法与基本的流是一致的，我们通过复制大文件（375MB），测试它的效率。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法1：使用FileInputStream\FileOutputStream实现非文本文件的复制</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyFileWithFileStream</span><span class="params">(String srcPath,String destPath)</span>&#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1. 造文件-造流</span></span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(srcPath));</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(destPath));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 复制操作（读、写）</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="type">int</span> len;<span class="comment">//每次读入到buffer中字节的个数</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;复制成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//3. 关闭资源</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fos != <span class="literal">null</span>)</span><br><span class="line">                fos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="literal">null</span>)</span><br><span class="line">                fis.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">srcPath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\shkstart\\Desktop\\01-复习.mp4&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">destPath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\shkstart\\Desktop\\01-复习2.mp4&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    copyFileWithFileStream(srcPath,destPath);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//7677毫秒</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2：使用BufferedInputStream\BufferedOuputStream实现非文本文件的复制</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyFileWithBufferedStream</span><span class="params">(String srcPath,String destPath)</span>&#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1. 造文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(srcPath);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(destPath);</span><br><span class="line">        <span class="comment">//2. 造流</span></span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line"></span><br><span class="line">        bis = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fis);</span><br><span class="line">        bos = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fos);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 读写操作</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;复制成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4. 关闭资源(如果有多个流，我们需要先关闭外面的流，再关闭内部的流)</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bos != <span class="literal">null</span>)</span><br><span class="line">                bos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bis != <span class="literal">null</span>)</span><br><span class="line">                bis.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">srcPath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\shkstart\\Desktop\\01-复习.mp4&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">destPath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\shkstart\\Desktop\\01-复习2.mp4&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    copyFileWithBufferedStream(srcPath,destPath);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//415毫秒</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-字符缓冲流特有方法"><a href="#5-3-字符缓冲流特有方法" class="headerlink" title="5.3 字符缓冲流特有方法"></a>5.3 字符缓冲流特有方法</h3><p>字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。</p><ul><li>BufferedReader：<code>public String readLine()</code>: 读一行文字。 </li><li>BufferedWriter：<code>public void newLine()</code>: 写一行行分隔符,由系统属性定义符号。 </li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedIOLine</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testReadLine</span><span class="params">()</span><span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;in.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 定义字符串,保存读取的一行文字</span></span><br><span class="line">        String line;</span><br><span class="line">        <span class="comment">// 循环读取,读取到最后返回null</span></span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine())!=<span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testNewLine</span><span class="params">()</span><span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;out.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 写出数据</span></span><br><span class="line">        bw.write(<span class="string">&quot;尚&quot;</span>);</span><br><span class="line">        <span class="comment">// 写出换行</span></span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.write(<span class="string">&quot;硅&quot;</span>);</span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.write(<span class="string">&quot;谷&quot;</span>);</span><br><span class="line">        bw.newLine();</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>说明：</p><ol><li><p>涉及到嵌套的多个流时，如果都显式关闭的话，需要先关闭外层的流，再关闭内层的流</p></li><li><p>其实在开发中，只需要关闭最外层的流即可，因为在关闭外层流时，内层的流也会被关闭。</p></li></ol></blockquote><h3 id="5-4-练习"><a href="#5-4-练习" class="headerlink" title="5.4 练习"></a>5.4 练习</h3><p><strong>练习1：</strong>分别使用节点流：FileInputStream、FileOutputStream和缓冲流：BufferedInputStream、BufferedOutputStream实现文本文件/图片/视频文件的复制。并比较二者在数据复制方面的效率。</p><p><strong>练习2：</strong></p><p>姓氏统计：一个文本文件中存储着北京所有高校在校生的姓名，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">每行一个名字，姓与名以空格分隔：</span><br><span class="line">张 三</span><br><span class="line">李 四</span><br><span class="line">王 小五</span><br></pre></td></tr></table></figure><p>现在想统计所有的姓氏在文件中出现的次数，请描述一下你的解决方案。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;e:/name.txt&quot;</span>)));</span><br><span class="line">           <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 临时接收文件中的字符串变量</span></span><br><span class="line">           <span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">           flag:</span><br><span class="line">           <span class="keyword">while</span> ((value = br.readLine()) != <span class="literal">null</span>) &#123; <span class="comment">// 开始读取文件中的字符</span></span><br><span class="line">               <span class="type">char</span>[] c = value.toCharArray();</span><br><span class="line">               <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; c.length; i++) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (c[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                       buffer.append(String.valueOf(c[i]));</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="keyword">if</span> (map.containsKey(buffer.toString())) &#123;</span><br><span class="line">                           <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> map.get(buffer.toString());</span><br><span class="line">                           map.put(buffer.toString(), count + <span class="number">1</span>);</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           map.put(buffer.toString(), <span class="number">1</span>);</span><br><span class="line">                       &#125;</span><br><span class="line">                       buffer.delete(<span class="number">0</span>, buffer.length());</span><br><span class="line">                       <span class="keyword">continue</span> flag;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (br != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   br.close();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set = map.entrySet();</span><br><span class="line">       Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; it = set.iterator();</span><br><span class="line">       <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">           Map.Entry&lt;String, Integer&gt; end = (Map.Entry&lt;String, Integer&gt;) it.next();</span><br><span class="line">           System.out.println(end);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="6-处理流之二：转换流"><a href="#6-处理流之二：转换流" class="headerlink" title="6. 处理流之二：转换流"></a>6. 处理流之二：转换流</h2><h3 id="6-1-问题引入"><a href="#6-1-问题引入" class="headerlink" title="6.1 问题引入"></a>6.1 问题引入</h3><p><strong>引入情况1：</strong></p><p>使用<code>FileReader</code> 读取项目中的文本文件。由于IDEA设置中针对项目设置了UTF-8编码，当读取Windows系统中创建的文本文件时，如果Windows系统默认的是GBK编码，则读入内存中会出现乱码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.transfer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Problem</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;E:\\File_GBK.txt&quot;</span>);</span><br><span class="line">        <span class="type">int</span> data;</span><br><span class="line">        <span class="keyword">while</span> ((data = fileReader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>)data);</span><br><span class="line">        &#125;</span><br><span class="line">        fileReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">���</span><br></pre></td></tr></table></figure><p>那么如何读取GBK编码的文件呢？ </p><p><strong>引入情况2：</strong></p><p>针对文本文件，现在使用一个字节流进行数据的读入，希望将数据显示在控制台上。此时针对包含中文的文本数据，可能会出现乱码。</p><h3 id="6-2-转换流的理解"><a href="#6-2-转换流的理解" class="headerlink" title="6.2 转换流的理解"></a>6.2 转换流的理解</h3><p><strong>作用：转换流是字节与字符间的桥梁！</strong></p><p><img src="/2023/02/18/java2023/%E7%AC%AC15%E7%AB%A0_File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/2_zhuanhuan.jpg" style="zoom: 67%;"></p><p>具体来说：</p><p><img src="/2023/02/18/java2023/%E7%AC%AC15%E7%AB%A0_File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/image-20220412231533768.png" alt="image-20220412231533768" style="zoom:85%;"></p><h3 id="6-3-InputStreamReader-与-OutputStreamWriter"><a href="#6-3-InputStreamReader-与-OutputStreamWriter" class="headerlink" title="6.3 InputStreamReader 与 OutputStreamWriter"></a>6.3 InputStreamReader 与 OutputStreamWriter</h3><ul><li><p><strong>InputStreamReader</strong> </p><ul><li><p>转换流<code>java.io.InputStreamReader</code>，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p></li><li><p>构造器</p><ul><li><code>InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的字符流。 </li><li><code>InputStreamReader(InputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li></ul></li><li><p>举例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用默认字符集</span></span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;in.txt&quot;</span>));</span><br><span class="line"><span class="comment">//使用指定字符集</span></span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;in.txt&quot;</span>) , <span class="string">&quot;GBK&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.transfer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReaderDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 定义文件路径,文件为gbk编码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;E:\\file_gbk.txt&quot;</span>;</span><br><span class="line">        <span class="comment">//方式1：</span></span><br><span class="line">        <span class="comment">// 创建流对象,默认UTF8编码</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName));</span><br><span class="line">        <span class="comment">// 定义变量,保存字符</span></span><br><span class="line">        <span class="type">int</span> charData;</span><br><span class="line">        <span class="comment">// 使用默认编码字符流读取,乱码</span></span><br><span class="line">        <span class="keyword">while</span> ((charData = isr1.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>)charData); <span class="comment">// ��Һ�</span></span><br><span class="line">        &#125;</span><br><span class="line">        isr1.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式2：</span></span><br><span class="line">        <span class="comment">// 创建流对象,指定GBK编码</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName) , <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用指定编码字符流读取,正常解析</span></span><br><span class="line">        <span class="keyword">while</span> ((charData = isr2.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>)charData);<span class="comment">// 大家好</span></span><br><span class="line">        &#125;</span><br><span class="line">        isr2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>OutputStreamWriter</strong></p><ul><li><p>转换流<code>java.io.OutputStreamWriter</code> ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p></li><li><p>构造器</p><ul><li><code>OutputStreamWriter(OutputStream in)</code>: 创建一个使用默认字符集的字符流。 </li><li><code>OutputStreamWriter(OutputStream in,String charsetName)</code>: 创建一个指定字符集的字符流。</li></ul></li><li><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用默认字符集</span></span><br><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.txt&quot;</span>));</span><br><span class="line"><span class="comment">//使用指定的字符集</span></span><br><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">isr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.txt&quot;</span>) , <span class="string">&quot;GBK&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.transfer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputStreamWriterDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 定义文件路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">FileName</span> <span class="operator">=</span> <span class="string">&quot;E:\\out_utf8.txt&quot;</span>;</span><br><span class="line">        <span class="comment">// 创建流对象,默认UTF8编码</span></span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(FileName));</span><br><span class="line">        <span class="comment">// 写出数据</span></span><br><span class="line">        osw.write(<span class="string">&quot;你好&quot;</span>); <span class="comment">// 保存为6个字节</span></span><br><span class="line">        osw.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义文件路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">FileName2</span> <span class="operator">=</span> <span class="string">&quot;E:\\out_gbk.txt&quot;</span>;</span><br><span class="line">        <span class="comment">// 创建流对象,指定GBK编码</span></span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">osw2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span>                     </span><br><span class="line">                                                <span class="title class_">FileOutputStream</span>(FileName2),<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        <span class="comment">// 写出数据</span></span><br><span class="line">        osw2.write(<span class="string">&quot;你好&quot;</span>);<span class="comment">// 保存为4个字节</span></span><br><span class="line">        osw2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="6-4-字符编码和字符集"><a href="#6-4-字符编码和字符集" class="headerlink" title="6.4 字符编码和字符集"></a>6.4 字符编码和字符集</h3><h4 id="6-4-1-编码与解码"><a href="#6-4-1-编码与解码" class="headerlink" title="6.4.1 编码与解码"></a>6.4.1 编码与解码</h4><p>计算机中储存的信息都是用<code>二进制数</code>表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为<strong>编码</strong> 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为<strong>解码</strong> 。</p><p><strong>字符编码（Character Encoding）</strong> : 就是一套自然语言的字符与二进制数之间的对应规则。</p><p><strong>编码表</strong>：生活中文字和计算机中二进制的对应规则</p><p><strong>乱码的情况</strong>：按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">编码:字符(人能看懂的)--字节(人看不懂的)</span><br><span class="line"></span><br><span class="line">解码:字节(人看不懂的)--&gt;字符(人能看懂的)</span><br></pre></td></tr></table></figure><h4 id="6-4-2-字符集"><a href="#6-4-2-字符集" class="headerlink" title="6.4.2 字符集"></a>6.4.2 字符集</h4><ul><li><strong>字符集Charset</strong>：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</li></ul><ul><li>计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。</li></ul><p>可见，当指定了<strong>编码</strong>，它所对应的<strong>字符集</strong>自然就指定了，所以<strong>编码</strong>才是我们最终要关心的。</p><ul><li><p><strong>ASCII字符集</strong> ：</p><ul><li>ASCII码（American Standard Code for Information Interchange，美国信息交换标准代码）：上个世纪60年代，美国制定了一套字符编码，对<code>英语字符</code>与二进制位之间的关系，做了统一规定。这被称为ASCII码。</li><li>ASCII码用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</li><li>基本的ASCII字符集，使用7位（bits）表示一个字符（最前面的1位统一规定为0），共<code>128个</code>字符。比如：空格“SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。</li><li>缺点：不能表示所有字符。</li></ul></li><li><p><strong>ISO-8859-1字符集</strong>：</p><ul><li>拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰语、德语、意大利语、葡萄牙语等</li><li>ISO-8859-1使用单字节编码，兼容ASCII编码。</li></ul></li><li><p><strong>GBxxx字符集</strong>：</p><ul><li>GB就是国标的意思，是为了<code>显示中文</code>而设计的一套字符集。</li><li><strong>GB2312</strong>：简体中文码表。一个小于127的字符的意义与原来相同，即向下兼容ASCII码。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含<code>7000多个简体汉字</code>，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，这就是常说的”全角”字符，而原来在127号以下的那些符号就叫”半角”字符了。</li><li><strong>GBK</strong>：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了<code>双字节</code>编码方案，共收录了<code>21003个</code>汉字，完全兼容GB2312标准，同时支持<code>繁体汉字</code>以及日韩汉字等。</li><li><strong>GB18030</strong>：最新的中文码表。收录汉字<code>70244个</code>，采用<code>多字节</code>编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。</li></ul></li><li><p><strong>Unicode字符集</strong> ：</p><ul><li>Unicode编码为表达<code>任意语言的任意字符</code>而设计，也称为统一码、标准万国码。Unicode 将世界上所有的文字用<code>2个字节</code>统一进行编码，为每个字符设定唯一的二进制编码，以满足跨语言、跨平台进行文本处理的要求。</li></ul><ul><li>Unicode 的缺点：这里有三个问题：<ul><li>第一，英文字母只用一个字节表示就够了，如果用更多的字节存储是<code>极大的浪费</code>。</li><li>第二，如何才能<code>区别Unicode和ASCII</code>？计算机怎么知道两个字节表示一个符号，而不是分别表示两个符号呢？</li><li>第三，如果和GBK等双字节编码方式一样，用最高位是1或0表示两个字节和一个字节，就少了很多值无法用于表示字符，<code>不够表示所有字符</code>。</li></ul></li><li>Unicode在很长一段时间内无法推广，直到互联网的出现，为解决Unicode如何在网络上传输的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现。具体来说，有三种编码方案，UTF-8、UTF-16和UTF-32。</li></ul></li><li><p><strong>UTF-8字符集</strong>：</p><ul><li>Unicode是字符集，UTF-8、UTF-16、UTF-32是三种<code>将数字转换到程序数据</code>的编码方案。顾名思义，UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。其中，UTF-8 是在互联网上<code>使用最广</code>的一种 Unicode 的实现方式。</li><li>互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。UTF-8 是一种<code>变长的编码方式</code>。它使用1-4个字节为每个字符编码，编码规则：<ol><li>128个US-ASCII字符，只需一个字节编码。</li><li>拉丁文等字符，需要二个字节编码。 </li><li>大部分常用字（含中文），使用三个字节编码。</li><li>其他极少使用的Unicode辅助字符，使用四字节编码。</li></ol></li></ul></li></ul><ul><li>举例</li></ul><p>Unicode符号范围  | UTF-8编码方式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(十六进制)           | （二进制）</span><br><span class="line"></span><br><span class="line">————————————————————|—–—–—–—–—–—–—–—–—–—–—–—–—–—–</span><br><span class="line"></span><br><span class="line">0000 0000-0000 007F | 0xxxxxxx（兼容原来的ASCII）</span><br><span class="line"></span><br><span class="line">0000 0080-0000 07FF | 110xxxxx 10xxxxxx</span><br><span class="line"></span><br><span class="line">0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line"></span><br><span class="line">0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure><p><img src="/2023/02/18/java2023/%E7%AC%AC15%E7%AB%A0_File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/image-20220525164636164.png" alt="image-20220525164636164"></p><ul><li>小结</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC15%E7%AB%A0_File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/字符集.jpg" alt="字符集"></p><blockquote><p>注意：在中文操作系统上，ANSI（美国国家标准学会、AMERICAN NATIONAL STANDARDS INSTITUTE: ANSI）编码即为GBK；在英文操作系统上，ANSI编码即为ISO-8859-1。</p></blockquote><h3 id="6-5-练习"><a href="#6-5-练习" class="headerlink" title="6.5 练习"></a>6.5 练习</h3><p>把当前module下的《康师傅的话.txt》字符编码为GBK，复制到电脑桌面目录下的《寄语.txt》，<br>字符编码为UTF-8。</p><p>在当前module下的文本内容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">六项精进：</span><br><span class="line">（一）付出不亚于任何人的努力</span><br><span class="line">（二）要谦虚，不要骄傲</span><br><span class="line">（三）要每天反省</span><br><span class="line">（四）活着，就要感谢</span><br><span class="line">（五）积善行、思利他</span><br><span class="line">（六）不要有感性的烦恼</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 9:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReaderDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isr = <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;康师傅的话.txt&quot;</span>),<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line"></span><br><span class="line">            osw = <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:\\Users\\shkstart\\Desktop\\寄语.txt&quot;</span>),<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = isr.read(cbuf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                osw.write(cbuf, <span class="number">0</span>, len);</span><br><span class="line">                osw.flush();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件复制完成&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (isr != <span class="literal">null</span>)</span><br><span class="line">                    isr.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (osw != <span class="literal">null</span>)</span><br><span class="line">                    osw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-处理流之三-四：数据流、对象流"><a href="#7-处理流之三-四：数据流、对象流" class="headerlink" title="7. 处理流之三/四：数据流、对象流"></a>7. 处理流之三/四：数据流、对象流</h2><h3 id="7-1-数据流与对象流说明"><a href="#7-1-数据流与对象流说明" class="headerlink" title="7.1 数据流与对象流说明"></a>7.1 数据流与对象流说明</h3><p>如果需要将内存中定义的变量（包括基本数据类型或引用数据类型）保存在文件中，那怎么办呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">gender</span> <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">energy</span> <span class="operator">=</span> <span class="number">5000</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">75.5</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">relive</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;巫师&quot;</span>;</span><br><span class="line"><span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">23</span>,<span class="number">89</span>);</span><br></pre></td></tr></table></figure><p>Java提供了数据流和对象流来处理这些类型的数据：</p><ul><li><p><strong>数据流：DataOutputStream、DataInputStream</strong></p><ul><li><p>DataOutputStream：允许应用程序将基本数据类型、String类型的变量写入输出流中</p></li><li><p>DataInputStream：允许应用程序以与机器无关的方式从底层输入流中读取基本数据类型、String类型的变量。</p></li></ul></li><li>对象流DataInputStream中的方法：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="title function_">readByte</span><span class="params">()</span>                <span class="type">short</span> <span class="title function_">readShort</span><span class="params">()</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">readInt</span><span class="params">()</span>                  <span class="type">long</span> <span class="title function_">readLong</span><span class="params">()</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">readFloat</span><span class="params">()</span>              <span class="type">double</span> <span class="title function_">readDouble</span><span class="params">()</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">readChar</span><span class="params">()</span> <span class="type">boolean</span> <span class="title function_">readBoolean</span><span class="params">()</span></span><br><span class="line">String <span class="title function_">readUTF</span><span class="params">()</span>               <span class="keyword">void</span> <span class="title function_">readFully</span><span class="params">(<span class="type">byte</span>[] b)</span></span><br></pre></td></tr></table></figure><ul><li>对象流DataOutputStream中的方法：将上述的方法的read改为相应的write即可。</li><li>数据流的弊端：只支持Java基本数据类型和字符串的读写，而不支持其它Java对象的类型。而ObjectOutputStream和ObjectInputStream既支持Java基本数据类型的数据读写，又支持Java对象的读写，所以重点介绍对象流ObjectOutputStream和ObjectInputStream。</li><li><p><strong>对象流：ObjectOutputStream、ObjectInputStream</strong></p><ul><li>ObjectOutputStream：将 Java 基本数据类型和对象写入字节输出流中。通过在流中使用文件可以实现Java各种基本数据类型的数据以及对象的持久存储。</li><li>ObjectInputStream：ObjectInputStream 对以前使用 ObjectOutputStream 写出的基本数据类型的数据和对象进行读入操作，保存在内存中。</li></ul></li></ul><blockquote><p>说明：对象流的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。</p></blockquote><h3 id="7-2-对象流API"><a href="#7-2-对象流API" class="headerlink" title="7.2 对象流API"></a>7.2 对象流API</h3><p><strong>ObjectOutputStream中的构造器：</strong></p><p><code>public ObjectOutputStream(OutputStream out)</code>： 创建一个指定的ObjectOutputStream。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;game.dat&quot;</span>);</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);</span><br></pre></td></tr></table></figure><p><strong>ObjectOutputStream中的方法：</strong></p><ul><li>public void writeBoolean(boolean val)：写出一个 boolean 值。</li><li>public void writeByte(int val)：写出一个8位字节</li><li>public void writeShort(int val)：写出一个16位的 short 值</li><li>public void writeChar(int val)：写出一个16位的 char 值</li><li>public void writeInt(int val)：写出一个32位的 int 值</li><li>public void writeLong(long val)：写出一个64位的 long 值</li><li>public void writeFloat(float val)：写出一个32位的 float 值。</li><li>public void writeDouble(double val)：写出一个64位的 double 值</li><li>public void writeUTF(String str)：将表示长度信息的两个字节写入输出流，后跟字符串 s 中每个字符的 UTF-8 修改版表示形式。根据字符的值，将字符串 s 中每个字符转换成一个字节、两个字节或三个字节的字节组。注意，将 String 作为基本数据写入流中与将它作为 Object 写入流中明显不同。 如果 s 为 null，则抛出 NullPointerException。</li><li><code>public void writeObject(Object obj)</code>：写出一个obj对象</li><li>public void close() ：关闭此输出流并释放与此流相关联的任何系统资源</li></ul><p><strong>ObjectInputStream中的构造器：</strong></p><p><code>public ObjectInputStream(InputStream in)</code>： 创建一个指定的ObjectInputStream。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;game.dat&quot;</span>);</span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fis);</span><br></pre></td></tr></table></figure><p><strong>ObjectInputStream中的方法：</strong></p><ul><li>public boolean readBoolean()：读取一个 boolean 值</li><li>public byte readByte()：读取一个 8 位的字节</li><li>public short readShort()：读取一个 16 位的 short 值</li><li>public char readChar()：读取一个 16 位的 char 值</li><li>public int readInt()：读取一个 32 位的 int 值</li><li>public long readLong()：读取一个 64 位的 long 值</li><li>public float readFloat()：读取一个 32 位的 float 值</li><li>public double readDouble()：读取一个 64 位的 double 值</li><li>public String readUTF()：读取 UTF-8 修改版格式的 String</li><li><code>public void readObject(Object obj)</code>：读入一个obj对象</li><li>public void close() ：关闭此输入流并释放与此流相关联的任何系统资源</li></ul><h3 id="7-3-认识对象序列化机制"><a href="#7-3-认识对象序列化机制" class="headerlink" title="7.3 认识对象序列化机制"></a>7.3 认识对象序列化机制</h3><p><strong>1、何为对象序列化机制？</strong></p><p><code>对象序列化机制</code>允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。//当其它程序获取了这种二进制流，就可以恢复成原来的Java对象。</p><ul><li>序列化过程：用一个字节序列可以表示一个对象，该字节序列包含该<code>对象的类型</code>和<code>对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<code>持久保存</code>了一个对象的信息。 </li></ul><ul><li>反序列化过程：该字节序列还可以从文件中读取回来，重构对象，对它进行<code>反序列化</code>。<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的数据</code>信息，都可以用来在内存中创建对象。</li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC15%E7%AB%A0_File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/image-20220503123328452.png" alt="image-20220503123328452" style="zoom:67%;"></p><p><strong>2、序列化机制的重要性</strong></p><p>序列化是 RMI（Remote Method Invoke、远程方法调用）过程的参数和返回值都必须实现的机制，而 RMI 是 JavaEE 的基础。因此序列化机制是 JavaEE 平台的基础。</p><p>序列化的好处，在于可将任何实现了Serializable接口的对象转化为<strong>字节数据</strong>，使其在保存和传输时可被还原。</p><p><strong>3、实现原理</strong></p><ul><li><p>序列化：用ObjectOutputStream类保存基本类型数据或对象的机制。方法为：</p><ul><li><code>public final void writeObject (Object obj)</code> : 将指定的对象写出。</li></ul></li><li><p>反序列化：用ObjectInputStream类读取基本类型数据或对象的机制。方法为：</p><ul><li><code>public final Object readObject ()</code> : 读取一个对象。</li></ul></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC15%E7%AB%A0_File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/3_xuliehua.jpg" style="zoom:70%;"></p><h3 id="7-4-如何实现序列化机制"><a href="#7-4-如何实现序列化机制" class="headerlink" title="7.4 如何实现序列化机制"></a>7.4 如何实现序列化机制</h3><p>如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现<code>java.io.Serializable</code> 接口。<code>Serializable</code> 是一个<code>标记接口</code>，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出<code>NotSerializableException</code> 。</p><ul><li>如果对象的某个属性也是引用数据类型，那么如果该属性也要序列化的话，也要实现<code>Serializable</code> 接口</li><li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用<code>transient</code> 关键字修饰。</li><li><code>静态（static）变量</code>的值不会序列化。因为静态变量的值不属于某个对象。</li></ul><p>举例1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.object;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteDataOfAnyType</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;巫师&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">gender</span> <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">energy</span> <span class="operator">=</span> <span class="number">5000</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">75.5</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">relive</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;game.dat&quot;</span>));</span><br><span class="line">        oos.writeUTF(name);</span><br><span class="line">        oos.writeInt(age);</span><br><span class="line">        oos.writeChar(gender);</span><br><span class="line">        oos.writeInt(energy);</span><br><span class="line">        oos.writeDouble(price);</span><br><span class="line">        oos.writeBoolean(relive);</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reload</span><span class="params">()</span><span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;game.dat&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> ois.readUTF();</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> ois.readInt();</span><br><span class="line">        <span class="type">char</span> <span class="variable">gender</span> <span class="operator">=</span> ois.readChar();</span><br><span class="line">        <span class="type">int</span> <span class="variable">energy</span> <span class="operator">=</span> ois.readInt();</span><br><span class="line">        <span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> ois.readDouble();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">relive</span> <span class="operator">=</span> ois.readBoolean();</span><br><span class="line"></span><br><span class="line">        System.out.println(name+<span class="string">&quot;,&quot;</span> + age + <span class="string">&quot;,&quot;</span> + gender + <span class="string">&quot;,&quot;</span> + energy + <span class="string">&quot;,&quot;</span> + price + <span class="string">&quot;,&quot;</span> + relive);</span><br><span class="line"></span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>举例2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.object;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">//static final long serialVersionUID = 23234234234L;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String company; <span class="comment">//static修饰的类变量，不会被序列化</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">transient</span> <span class="type">int</span> age; <span class="comment">// transient瞬态修饰成员,不会被序列化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name, String address, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getCompany</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> company;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setCompany</span><span class="params">(String company)</span> &#123;</span><br><span class="line">        Employee.company = company;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Employee&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, address=&#x27;&quot;</span> + address + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, company=&quot;</span> + company +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.object;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteObject</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Employee.setCompany(<span class="string">&quot;尚硅谷&quot;</span>);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;小谷姐姐&quot;</span>, <span class="string">&quot;宏福苑&quot;</span>, <span class="number">23</span>);</span><br><span class="line">        <span class="comment">// 创建序列化流对象</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;employee.dat&quot;</span>));</span><br><span class="line">        <span class="comment">// 写出对象</span></span><br><span class="line">        oos.writeObject(e);</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        oos.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;Serialized data is saved&quot;</span>); <span class="comment">// 姓名，地址被序列化，年龄没有被序列化。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reload</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 创建反序列化流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;employee.dat&quot;</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fis);</span><br><span class="line">        <span class="comment">// 读取一个对象</span></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> (Employee) ois.readObject();</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        ois.close();</span><br><span class="line">        fis.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例3：如果有多个对象需要序列化，则可以将对象放到集合中，再序列化集合对象即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.object;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteCollection</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ArrayList&lt;Employee&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;宏福苑&quot;</span>, <span class="number">23</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;李四&quot;</span>, <span class="string">&quot;白庙&quot;</span>, <span class="number">24</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;王五&quot;</span>, <span class="string">&quot;平西府&quot;</span>, <span class="number">25</span>));</span><br><span class="line">        <span class="comment">// 创建序列化流对象</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;employees.dat&quot;</span>));</span><br><span class="line">        <span class="comment">// 写出对象</span></span><br><span class="line">        oos.writeObject(list);</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reload</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 创建反序列化流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;employees.dat&quot;</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fis);</span><br><span class="line">        <span class="comment">// 读取一个对象</span></span><br><span class="line">        ArrayList&lt;Employee&gt; list = (ArrayList&lt;Employee&gt;) ois.readObject();</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        ois.close();</span><br><span class="line">        fis.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-5-反序列化失败问题"><a href="#7-5-反序列化失败问题" class="headerlink" title="7.5 反序列化失败问题"></a>7.5 反序列化失败问题</h3><p><strong>问题1：</strong></p><p>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 <code>ClassNotFoundException</code> 异常。  </p><p><strong>问题2：</strong></p><p>当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个<code>InvalidClassException</code>异常。发生这个异常的原因如下：</p><ul><li>该类的序列版本号与从流中读取的类描述符的版本号不匹配 </li><li>该类包含未知数据类型  </li></ul><p>解决办法：</p><p><code>Serializable</code> 接口给需要序列化的类，提供了一个序列版本号：<code>serialVersionUID</code> 。凡是实现 Serializable接口的类都应该有一个表示序列化版本标识符的静态变量：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">234242343243L</span>; <span class="comment">//它的值由程序员随意指定即可。</span></span><br></pre></td></tr></table></figure><ul><li>serialVersionUID用来表明类的不同版本间的兼容性。简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常(InvalidCastException)。</li><li>如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节<code>自动生成</code>的。若类的实例变量做了修改，serialVersionUID <code>可能发生变化</code>。因此，建议显式声明。</li><li>如果声明了serialVersionUID，即使在序列化完成之后修改了类导致类重新编译，则原来的数据也能正常反序列化，只是新增的字段值是默认值而已。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.object;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1324234L</span>; <span class="comment">//增加serialVersionUID</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//其它结构：略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-6-面试题-amp-练习"><a href="#7-6-面试题-amp-练习" class="headerlink" title="7.6 面试题&amp;练习"></a>7.6 面试题&amp;练习</h3><p>面试题：谈谈你对java.io.Serializable接口的理解，我们知道它用于序列化，是空方法接口，还有其它认识吗？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">实现了Serializable接口的对象，可将它们转换成一系列字节，并可在以后完全恢复回原来的样子。这一过程亦可通过网络进行。这意味着序列化机制能自动补偿操作系统间的差异。换句话说，可以先在Windows机器上创建一个对象，对其序列化，然后通过网络发给一台Unix机器，然后在那里准确无误地重新“装配”。不必关心数据在不同机器上如何表示，也不必关心字节的顺序或者其他任何细节。</span><br><span class="line">    </span><br><span class="line">由于大部分作为参数的类如String、Integer等都实现了java.io.Serializable的接口，也可以利用多态的性质，作为参数使接口更灵活。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>练习：</p><ul><li><p>需求说明：</p><ul><li>网上购物时某用户填写订单，订单内容为产品列表，保存在“save.bin”中。</li><li>运行时，如果不存在“save.bin”，则进行新订单录入，如果存在，则显示并计算客户所需付款。</li></ul></li><li><p>分析：</p><ul><li>编写Save()方法保存对象到“save.bin”</li><li>编写Load()方法获得对象，计算客户所需付款</li></ul></li></ul><p><img src="/2023/02/18/java2023/%E7%AC%AC15%E7%AB%A0_File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/image-20220503123603551.png" alt="image-20220503123603551" style="zoom:80%;"></p><h2 id="8-其他流的使用"><a href="#8-其他流的使用" class="headerlink" title="8. 其他流的使用"></a>8. 其他流的使用</h2><h3 id="8-1-标准输入、输出流"><a href="#8-1-标准输入、输出流" class="headerlink" title="8.1 标准输入、输出流"></a>8.1 标准输入、输出流</h3><ul><li>System.in和System.out分别代表了系统标准的输入和输出设备</li><li>默认输入设备是：键盘，输出设备是：显示器</li><li>System.in的类型是InputStream</li><li>System.out的类型是PrintStream，其是OutputStream的子类FilterOutputStream 的子类</li><li>重定向：通过System类的setIn，setOut方法对默认设备进行改变。<ul><li>public static void setIn(InputStream in)</li><li>public static void setOut(PrintStream out)</li></ul></li></ul><p><strong>举例：</strong></p><p>从键盘输入字符串，要求将读取到的整行字符串转成大写输出。然后继续进行输入操作，直至当输入“e”或者“exit”时，退出程序。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;请输入信息(退出输入e或exit):&quot;</span>);</span><br><span class="line"><span class="comment">// 把&quot;标准&quot;输入流(键盘输入)这个字节流包装成字符流,再包装成缓冲流</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> ((s = br.readLine()) != <span class="literal">null</span>) &#123; <span class="comment">// 读取用户输入的一行数据 --&gt; 阻塞程序</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;e&quot;</span>.equalsIgnoreCase(s) || <span class="string">&quot;exit&quot;</span>.equalsIgnoreCase(s)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;安全退出!!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将读取到的整行字符串转成大写输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--&gt;:&quot;</span> + s.toUpperCase());</span><br><span class="line">        System.out.println(<span class="string">&quot;继续输入信息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (br != <span class="literal">null</span>) &#123;</span><br><span class="line">            br.close(); <span class="comment">// 关闭过滤流时,会自动关闭它包装的底层节点流</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>拓展：</strong></p><p>System类中有三个常量对象：System.out、System.in、System.err</p><p>查看System类中这三个常量对象的声明：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">PrintStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">PrintStream</span> <span class="variable">err</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>奇怪的是，</p><ul><li>这三个常量对象有final声明，但是却初始化为null。final声明的常量一旦赋值就不能修改，那么null不会空指针异常吗？</li><li>这三个常量对象为什么要小写？final声明的常量按照命名规范不是应该大写吗？</li><li>这三个常量的对象有set方法？final声明的常量不是不能修改值吗？set方法是如何修改它们的值的？</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span>声明的常量，表示在Java的语法体系中它们的值是不能修改的，而这三个常量对象的值是由C/C++等系统函数进行初始化和修改值的，所以它们故意没有用大写，也有set方法。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setOut</span><span class="params">(PrintStream out)</span> &#123;</span><br><span class="line">    checkIO();</span><br><span class="line">    setOut0(out);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setErr</span><span class="params">(PrintStream err)</span> &#123;</span><br><span class="line">    checkIO();</span><br><span class="line">    setErr0(err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setIn</span><span class="params">(InputStream in)</span> &#123;</span><br><span class="line">    checkIO();</span><br><span class="line">    setIn0(in);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkIO</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">        sm.checkPermission(<span class="keyword">new</span> <span class="title class_">RuntimePermission</span>(<span class="string">&quot;setIO&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">setIn0</span><span class="params">(InputStream in)</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">setOut0</span><span class="params">(PrintStream out)</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">setErr0</span><span class="params">(PrintStream err)</span>;</span><br></pre></td></tr></table></figure><p><strong>练习：</strong></p><p>Create a program named MyInput.java: Contain the methods for reading int, double, float, boolean, short, byte and String values from the keyboard.</p><p><img src="/2023/02/18/java2023/%E7%AC%AC15%E7%AB%A0_File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/image-20220412232254819.png" alt="image-20220412232254819" style="zoom:80%;"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.java;</span><br><span class="line"><span class="comment">// MyInput.java: Contain the methods for reading int, double, float, boolean, short, byte and</span></span><br><span class="line"><span class="comment">// string values from the keyboard</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInput</span> &#123;</span><br><span class="line">    <span class="comment">// Read a string from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">readString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Declare and initialize the string</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the string from the keyboard</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            string = br.readLine();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            System.out.println(ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return the string obtained from the keyboard</span></span><br><span class="line">        <span class="keyword">return</span> string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read an int value from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">readInt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(readString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read a double value from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">readDouble</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Double.parseDouble(readString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read a byte value from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">readByte</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Byte.parseByte(readString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read a short value from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">readShort</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Short.parseShort(readString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read a long value from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">readLong</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Long.parseLong(readString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read a float value from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">readFloat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Float.parseFloat(readString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8-2-打印流"><a href="#8-2-打印流" class="headerlink" title="8.2 打印流"></a>8.2 打印流</h3><ul><li>实现将基本数据类型的数据格式转化为字符串输出。</li></ul><ul><li><p>打印流：<code>PrintStream</code>和<code>PrintWriter</code></p><ul><li><p>提供了一系列重载的print()和println()方法，用于多种数据类型的输出</p><p><img src="/2023/02/18/java2023/%E7%AC%AC15%E7%AB%A0_File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/image-20220131021502089.png" alt="image-20220131021502089"></p><p><img src="/2023/02/18/java2023/%E7%AC%AC15%E7%AB%A0_File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/image-20220131021528397.png" alt="image-20220131021528397"></p></li><li><p>PrintStream和PrintWriter的输出不会抛出IOException异常</p></li><li><p>PrintStream和PrintWriter有自动flush功能</p></li><li><p>PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。在需要写入字符而不是写入字节的情况下，应该使用 PrintWriter 类。</p></li><li><p>System.out返回的是PrintStream的实例</p></li></ul></li><li><p>构造器</p><ul><li>PrintStream(File file) ：创建具有指定文件且不带自动行刷新的新打印流。 </li><li>PrintStream(File file, String csn)：创建具有指定文件名称和字符集且不带自动行刷新的新打印流。 </li><li>PrintStream(OutputStream out) ：创建新的打印流。 </li><li>PrintStream(OutputStream out, boolean autoFlush)：创建新的打印流。 autoFlush如果为 true，则每当写入 byte 数组、调用其中一个 println 方法或写入换行符或字节 (‘\n’) 时都会刷新输出缓冲区。</li><li>PrintStream(OutputStream out, boolean autoFlush, String encoding) ：创建新的打印流。 </li><li>PrintStream(String fileName)：创建具有指定文件名称且不带自动行刷新的新打印流。 </li><li>PrintStream(String fileName, String csn) ：创建具有指定文件名称和字符集且不带自动行刷新的新打印流。</li></ul></li><li><p>代码举例1</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.systemio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPrintStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;io.txt&quot;</span>);</span><br><span class="line">        ps.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        ps.println(<span class="number">1</span>);</span><br><span class="line">        ps.println(<span class="number">1.5</span>);</span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>代码举例2</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\text.txt&quot;</span>));</span><br><span class="line">    <span class="comment">// 创建打印输出流,设置为自动刷新模式(写入换行符或字节 &#x27;\n&#x27; 时都会刷新输出缓冲区)</span></span><br><span class="line">    ps = <span class="keyword">new</span> <span class="title class_">PrintStream</span>(fos, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (ps != <span class="literal">null</span>) &#123;<span class="comment">// 把标准输出流(控制台输出)改成文件</span></span><br><span class="line">        System.setOut(ps);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">255</span>; i++) &#123; <span class="comment">// 输出ASCII字符</span></span><br><span class="line">        System.out.print((<span class="type">char</span>) i);</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">50</span> == <span class="number">0</span>) &#123; <span class="comment">// 每50个数据一行</span></span><br><span class="line">            System.out.println(); <span class="comment">// 换行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ps != <span class="literal">null</span>) &#123;</span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>代码举例3：自定义一个日志工具</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">日志工具</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    记录日志的方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 指向一个日志文件</span></span><br><span class="line">            <span class="type">PrintStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;log.txt&quot;</span>, <span class="literal">true</span>));</span><br><span class="line">            <span class="comment">// 改变输出方向</span></span><br><span class="line">            System.setOut(out);</span><br><span class="line">            <span class="comment">// 日期当前时间</span></span><br><span class="line">            <span class="type">Date</span> <span class="variable">nowTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">            <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss SSS&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">strTime</span> <span class="operator">=</span> sdf.format(nowTime);</span><br><span class="line"></span><br><span class="line">            System.out.println(strTime + <span class="string">&quot;: &quot;</span> + msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试工具类是否好用</span></span><br><span class="line">        Logger.log(<span class="string">&quot;调用了System类的gc()方法，建议启动垃圾回收&quot;</span>);</span><br><span class="line">        Logger.log(<span class="string">&quot;调用了TeamView的addMember()方法&quot;</span>);</span><br><span class="line">        Logger.log(<span class="string">&quot;用户尝试进行登录，验证失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-Scanner类"><a href="#8-3-Scanner类" class="headerlink" title="8.3 Scanner类"></a>8.3 Scanner类</h3><p>构造方法</p><ul><li>Scanner(File source) ：构造一个新的 Scanner，它生成的值是从指定文件扫描的。 </li><li>Scanner(File source, String charsetName) ：构造一个新的 Scanner，它生成的值是从指定文件扫描的。 </li><li>Scanner(InputStream source) ：构造一个新的 Scanner，它生成的值是从指定的输入流扫描的。 </li><li>Scanner(InputStream source, String charsetName) ：构造一个新的 Scanner，它生成的值是从指定的输入流扫描的。</li></ul><p>常用方法：</p><ul><li>boolean hasNextXxx()： 如果通过使用nextXxx()方法，此扫描器输入信息中的下一个标记可以解释为默认基数中的一个 Xxx 值，则返回 true。</li><li>Xxx nextXxx()： 将输入信息的下一个标记扫描为一个Xxx</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.systemio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestScanner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;请输入一个单词：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> input.nextLine();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;stop&quot;</span>.equals(str))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ps.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">        input.close();</span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;1.txt&quot;</span>));</span><br><span class="line">        <span class="keyword">while</span>(input.hasNextLine())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> input.nextLine();</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-apache-common包的使用"><a href="#9-apache-common包的使用" class="headerlink" title="9. apache-common包的使用"></a>9. apache-common包的使用</h2><h3 id="9-1-介绍"><a href="#9-1-介绍" class="headerlink" title="9.1 介绍"></a>9.1 介绍</h3><p>IO技术开发中，代码量很大，而且代码的重复率较高，为此Apache软件基金会，开发了IO技术的工具类<code>commonsIO</code>，大大简化了IO开发。</p><p>Apahce软件基金会属于第三方，（Oracle公司第一方，我们自己第二方，其他都是第三方）我们要使用第三方开发好的工具，需要添加jar包。</p><h3 id="9-2-导包及举例"><a href="#9-2-导包及举例" class="headerlink" title="9.2 导包及举例"></a>9.2 导包及举例</h3><ul><li>在导入commons-io-2.5.jar包之后，内部的API都可以使用。</li></ul><p> <img src="/2023/02/18/java2023/%E7%AC%AC15%E7%AB%A0_File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/image-20220416004246436.png" alt="image-20220416004246436"></p><ul><li>IOUtils类的使用</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">- 静态方法：IOUtils.copy(InputStream in,OutputStream out)传递字节流，实现文件复制。</span><br><span class="line">- 静态方法：IOUtils.closeQuietly(任意流对象)悄悄的释放资源，自动处理close()方法抛出的异常。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//- 静态方法：IOUtils.copy(InputStream in,OutputStream out)传递字节流，实现文件复制。</span></span><br><span class="line">        IOUtils.copy(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;E:\\Idea\\io\\1.jpg&quot;</span>),<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;E:\\Idea\\io\\file\\柳岩.jpg&quot;</span>));</span><br><span class="line">        <span class="comment">//- 静态方法：IOUtils.closeQuietly(任意流对象)悄悄的释放资源，自动处理close()方法抛出的异常。</span></span><br><span class="line">       <span class="comment">/* FileWriter fw = null;</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            fw = new FileWriter(&quot;day21\\io\\writer.txt&quot;);</span></span><br><span class="line"><span class="comment">            fw.write(&quot;hahah&quot;);</span></span><br><span class="line"><span class="comment">        &#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125;finally &#123;</span></span><br><span class="line"><span class="comment">           IOUtils.closeQuietly(fw);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>FileUtils类的使用</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">- 静态方法：<span class="keyword">void</span> <span class="title function_">copyDirectoryToDirectory</span><span class="params">(File src,File dest)</span>：整个目录的复制，自动进行递归遍历</span><br><span class="line">          参数:</span><br><span class="line">          src:要复制的文件夹路径</span><br><span class="line">          dest:要将文件夹粘贴到哪里去</span><br><span class="line">             </span><br><span class="line">- 静态方法：<span class="keyword">void</span> <span class="title function_">writeStringToFile</span><span class="params">(File file,String content)</span>：将内容content写入到file中</span><br><span class="line">- 静态方法：String <span class="title function_">readFileToString</span><span class="params">(File file)</span>：读取文件内容，并返回一个String</span><br><span class="line">- 静态方法：<span class="keyword">void</span> <span class="title function_">copyFile</span><span class="params">(File srcFile,File destFile)</span>：文件复制</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//- 静态方法：void copyDirectoryToDirectory(File src,File dest);</span></span><br><span class="line">            FileUtils.copyDirectoryToDirectory(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\Idea\\io\\aa&quot;</span>),<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\Idea\\io\\file&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//- 静态方法：writeStringToFile(File file,String str)</span></span><br><span class="line">            FileUtils.writeStringToFile(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;day21\\io\\commons.txt&quot;</span>),<span class="string">&quot;柳岩你好&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//- 静态方法：String readFileToString(File file)</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> FileUtils.readFileToString(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;day21\\io\\commons.txt&quot;</span>));</span><br><span class="line">            System.out.println(s);</span><br><span class="line">            <span class="comment">//- 静态方法：void copyFile(File srcFile,File destFile)</span></span><br><span class="line">            FileUtils.copyFile(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;io\\yangm.png&quot;</span>),<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;io\\yangm2.png&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;复制成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第15章-File类与IO流&quot;&gt;&lt;a href=&quot;#第15章-File类与IO流&quot; class=&quot;headerlink&quot; title=&quot;第15章_File类与IO流&quot;&gt;&lt;/a&gt;第15章_File类与IO流&lt;/h1&gt;&lt;p&gt;讲师：尚硅谷-宋红康（江湖人称：康师傅）&lt;/</summary>
      
    
    
    
    <category term="Java2023" scheme="http://example.com/categories/Java2023/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
</feed>
