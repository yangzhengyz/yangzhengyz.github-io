<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>01背包</title>
      <link href="/2022/05/11/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/01%E8%83%8C%E5%8C%85/"/>
      <url>/2022/05/11/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/01%E8%83%8C%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划：关于01背包问题，你该了解这些！"><a href="#动态规划：关于01背包问题，你该了解这些！" class="headerlink" title="动态规划：关于01背包问题，你该了解这些！"></a>动态规划：关于01背包问题，你该了解这些！</h1><p>对于面试的话，其实掌握01背包，和完全背包，就够用了，最多可以再来一个多重背包。</p><p>如果这几种背包，分不清，我这里画了一个图，如下：</p><p><img src="https://img-blog.csdnimg.cn/20210117171307407.png" alt="416.分割等和子集1"></p><p>至于背包九讲其其他背包，面试几乎不会问，都是竞赛级别的了，leetcode上连多重背包的题目都没有，所以题库也告诉我们，01背包和完全背包就够用了。</p><p>而完全背包又是也是01背包稍作变化而来，即：完全背包的物品数量是无限的。</p><p><strong>所以背包问题的理论基础重中之重是01背包，一定要理解透！</strong></p><p>leetcode上没有纯01背包的问题，都是01背包应用方面的题目，也就是需要转化为01背包问题。</p><p><strong>所以我先通过纯01背包问题，把01背包原理讲清楚，后续再讲解leetcode题目的时候，重点就是讲解如何转化为01背包问题了</strong>。</p><h2 id="01-背包"><a href="#01-背包" class="headerlink" title="01 背包"></a>01 背包</h2><p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p><img src="https://img-blog.csdnimg.cn/20210117175428387.jpg" alt="动态规划-背包问题"></p><p>这是标准的背包问题，以至于很多同学看了这个自然就会想到背包，甚至都不知道暴力的解法应该怎么解了。</p><p>这样其实是没有从底向上去思考，而是习惯性想到了背包，那么暴力的解法应该是怎么样的呢？</p><p>每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是$o(2^n)$，这里的n表示物品数量。</p><p><strong>所以暴力的解法是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化！</strong></p><p>在下面的讲解中，我举一个例子：</p><p>背包最大重量为4。</p><p>物品为：</p><div class="table-container"><table><thead><tr><th></th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table></div><p>问背包能背的物品最大价值是多少？</p><p>以下讲解和图示中出现的数字都是以这个例子为例。</p><h2 id="二维dp数组01背包"><a href="#二维dp数组01背包" class="headerlink" title="二维dp数组01背包"></a>二维dp数组01背包</h2><p>依然动规五部曲分析一波。</p><h3 id="确定dp数组以及下标的含义"><a href="#确定dp数组以及下标的含义" class="headerlink" title="确定dp数组以及下标的含义"></a>确定dp数组以及下标的含义</h3><p>对于背包问题，有一种写法， 是使用二维数组，即<strong>dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p><p>只看这个二维数组的定义，大家一定会有点懵，看下面这个图：</p><p><img src="https://img-blog.csdnimg.cn/20210110103003361.png" alt="动态规划-背包问题1"></p><p><strong>要时刻记着这个dp数组的含义，下面的一些步骤都围绕这dp数组的含义进行的</strong>，如果哪里看懵了，就来回顾一下i代表什么，j又代表什么。</p><h3 id="确定递推公式"><a href="#确定递推公式" class="headerlink" title="确定递推公式"></a>确定递推公式</h3><p>再回顾一下dp[i][j]的含义：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。</p><p>那么可以有两个方向推出来dp[i][j]，</p><ul><li><strong>不放物品i</strong>：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。)</li><li><strong>放物品i</strong>：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值</li></ul><p>所以递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</p><h3 id="dp数组如何初始化"><a href="#dp数组如何初始化" class="headerlink" title="dp数组如何初始化"></a>dp数组如何初始化</h3><p><strong>关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱</strong>。</p><p>首先从dp[i][j]的定义出发，如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0。如图：</p><p><img src="https://img-blog.csdnimg.cn/2021011010304192.png" alt="动态规划-背包问题2"></p><p>在看其他情况。</p><p>状态转移方程 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。</p><p>dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。</p><p>那么很明显当 j &lt; weight[0]的时候，dp[0][j] 应该是 0，因为背包容量比编号0的物品重量还小。</p><p>当j &gt;= weight[0]时，dp[0][j] 应该是value[0]，因为背包容量放足够放编号0物品。</p><p>代码初始化如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int j = 0 ; j &lt; weight[0]; j++) &#123;  // 当然这一步，如果把dp数组预先初始化为0了，这一步就可以省略，但很多同学应该没有想清楚这一点。</span><br><span class="line">    dp[0][j] = 0;</span><br><span class="line">&#125;</span><br><span class="line">// 正序遍历</span><br><span class="line">for (int j = weight[0]; j &lt;= bagweight; j++) &#123;</span><br><span class="line">    dp[0][j] = value[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时dp数组初始化情况如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20210110103109140.png" alt="动态规划-背包问题7"></p><p>dp[0][j] 和 dp[i][0] 都已经初始化了，那么其他下标应该初始化多少呢？</p><p>其实从递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 可以看出dp[i][j] 是由左上方数值推导出来了，那么 其他下标初始为什么数值都可以，因为都会被覆盖。</p><p><strong>初始-1，初始-2，初始100，都可以！</strong></p><p>但只不过一开始就统一把dp数组统一初始为0，更方便一些。</p><p>如图：</p><p><img src="https://code-thinking.cdn.bcebos.com/pics/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%9810.jpg" alt="动态规划-背包问题10"></p><p>最后初始化代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 初始化 dp</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; dp(weight.size(), vector&lt;int&gt;(bagweight + 1, 0));</span><br><span class="line">for (int j = weight[0]; j &lt;= bagweight; j++) &#123;</span><br><span class="line">    dp[0][j] = value[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>费了这么大的功夫，才把如何初始化讲清楚，相信不少同学平时初始化dp数组是凭感觉来的，但有时候感觉是不靠谱的</strong>。</p><h3 id="确定遍历顺序"><a href="#确定遍历顺序" class="headerlink" title="确定遍历顺序"></a>确定遍历顺序</h3><p>在如下图中，可以看出，有两个遍历的维度：物品与背包重量</p><p><img src="https://img-blog.csdnimg.cn/2021011010314055.png" alt="动态规划-背包问题3"></p><p>那么问题来了，<strong>先遍历 物品还是先遍历背包重量呢？</strong></p><p><strong>其实都可以！！ 但是先遍历物品更好理解</strong>。</p><p>那么我先给出先遍历物品，然后遍历背包重量的代码。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// weight数组的大小 就是物品个数</span><br><span class="line">for(int i = 1; i &lt; weight.size(); i++) &#123; // 遍历物品</span><br><span class="line">    for(int j = 0; j &lt;= bagweight; j++) &#123; // 遍历背包容量</span><br><span class="line">        if (j &lt; weight[i]) dp[i][j] = dp[i - 1][j]; </span><br><span class="line">        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>先遍历背包，再遍历物品，也是可以的！（注意我这里使用的二维dp数组）</strong></p><p>例如这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// weight数组的大小 就是物品个数</span><br><span class="line">for(int j = 0; j &lt;= bagweight; j++) &#123; // 遍历背包容量</span><br><span class="line">    for(int i = 1; i &lt; weight.size(); i++) &#123; // 遍历物品</span><br><span class="line">        if (j &lt; weight[i]) dp[i][j] = dp[i - 1][j];</span><br><span class="line">        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为什么也是可以的呢？</p><p><strong>要理解递归的本质和递推的方向</strong>。</p><p>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 递归公式中可以看出dp[i][j]是靠dp[i-1][j]和dp[i - 1][j - weight[i]]推导出来的。</p><p>dp[i-1][j]和dp[i - 1][j - weight[i]] 都在dp[i][j]的左上角方向（包括正上方向），那么先遍历物品，再遍历背包的过程如图所示：</p><p><img src="https://img-blog.csdnimg.cn/202101101032124.png" alt="动态规划-背包问题5"></p><p>再来看看先遍历背包，再遍历物品呢，如图：</p><p><img src="https://img-blog.csdnimg.cn/20210110103244701.png" alt="动态规划-背包问题6"></p><p><strong>大家可以看出，虽然两个for循环遍历的次序不同，但是dp[i][j]所需要的数据就是左上角，根本不影响dp[i][j]公式的推导！</strong></p><p>但先遍历物品再遍历背包这个顺序更好理解。</p><p><strong>其实背包问题里，两个for循环的先后循序是非常有讲究的，理解遍历顺序其实比理解推导公式难多了</strong>。</p><h3 id="举例推导dp数组"><a href="#举例推导dp数组" class="headerlink" title="举例推导dp数组"></a>举例推导dp数组</h3><p>来看一下对应的dp数组的数值，如图：</p><p><img src="https://img-blog.csdnimg.cn/20210118163425129.jpg" alt="动态规划-背包问题4"></p><p>最终结果就是dp[2][4]。</p><p>建议大家此时自己在纸上推导一遍，看看dp数组里每一个数值是不是这样的。</p><p><strong>做动态规划的题目，最好的过程就是自己在纸上举一个例子把对应的dp数组的数值推导一下，然后在动手写代码！</strong></p><p>很多同学做dp题目，遇到各种问题，然后凭感觉东改改西改改，怎么改都不对，或者稀里糊涂就改过了。</p><p>主要就是自己没有动手推导一下dp数组的演变过程，如果推导明白了，代码写出来就算有问题，只要把dp数组打印出来，对比一下和自己推导的有什么差异，很快就可以发现问题了。</p><h3 id="完整java测试代码"><a href="#完整java测试代码" class="headerlink" title="完整java测试代码"></a>完整java测试代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] weight = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] value = &#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bagsize</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        testweightbagproblem(weight, value, bagsize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testweightbagproblem</span><span class="params">(<span class="type">int</span>[] weight, <span class="type">int</span>[] value, <span class="type">int</span> bagsize)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">wlen</span> <span class="operator">=</span> weight.length, value0 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//定义dp数组：dp[i][j]表示背包容量为j时，前i个物品能获得的最大价值</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[wlen + <span class="number">1</span>][bagsize + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化：背包容量为0时，能获得的价值都为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= wlen; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = value0;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历顺序：先遍历物品，再遍历背包容量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= wlen; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= bagsize; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; weight[i - <span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i - <span class="number">1</span>]] + value[i - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印dp数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= wlen; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= bagsize; j++)&#123;</span><br><span class="line">                System.out.print(dp[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>讲了这么多才刚刚把二维dp的01背包讲完，<strong>这里大家其实可以发现最简单的是推导公式了，推导公式估计看一遍就记下来了，但难就难在如何初始化和遍历顺序上</strong>。</p><p>可能有的同学并没有注意到初始化 和 遍历顺序的重要性，我们后面做力扣上背包面试题目的时候，大家就会感受出来了。</p><p>今天我们就来说一说滚动数组，其实在前面的题目中我们已经用到过滚动数组了，就是把二维dp降为一维dp，一些录友当时还表示比较困惑。</p><h2 id="一维dp数组（滚动数组）"><a href="#一维dp数组（滚动数组）" class="headerlink" title="一维dp数组（滚动数组）"></a>一维dp数组（滚动数组）</h2><p>对于背包问题其实状态都是可以压缩的。</p><p>在使用二维数组的时候，递推公式：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</p><p><strong>其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);</strong></p><p><strong>与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了</strong>，只用dp[j]（一维数组，也可以理解是一个滚动数组）。</p><p>这就是滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。</p><p>读到这里估计大家都忘了 dp[i][j]里的i和j表达的是什么了，i是物品，j是背包容量。</p><p><strong>dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p><p>一定要时刻记住这里i和j的含义，要不然很容易看懵了。</p><p>动规五部曲分析如下：</p><h3 id="确定dp数组的定义"><a href="#确定dp数组的定义" class="headerlink" title="确定dp数组的定义"></a>确定dp数组的定义</h3><p>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。</p><h3 id="一维dp数组的递推公式"><a href="#一维dp数组的递推公式" class="headerlink" title="一维dp数组的递推公式"></a>一维dp数组的递推公式</h3><p>dp[j]为 容量为j的背包所背的最大价值，那么如何推导dp[j]呢？</p><p>dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。</p><p>dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）</p><p>此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，</p><p>所以递归公式为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出相对于二维dp数组的写法，就是把dp[i][j]中i的维度去掉了。</p><h3 id="一维dp数组如何初始化"><a href="#一维dp数组如何初始化" class="headerlink" title="一维dp数组如何初始化"></a>一维dp数组如何初始化</h3><p><strong>关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱</strong>。</p><p>dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。</p><p>那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？</p><p>看一下递归公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</p><p>dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。</p><p><strong>这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了</strong>。</p><p>那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。</p><h3 id="一维dp数组遍历顺序"><a href="#一维dp数组遍历顺序" class="headerlink" title="一维dp数组遍历顺序"></a>一维dp数组遍历顺序</h3><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(int i = 0; i &lt; weight.size(); i++) &#123; // 遍历物品</span><br><span class="line">    for(int j = bagWeight; j &gt;= weight[i]; j--) &#123; // 遍历背包容量</span><br><span class="line">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>这里大家发现和二维dp的写法中，遍历背包的顺序是不一样的！</strong></p><p>二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。</p><p>为什么呢？</p><p><strong>倒序遍历是为了保证物品i只被放入一次！</strong>。但如果一旦正序遍历了，那么物品0就会被重复加入多次！</p><p>举一个例子：物品0的重量weight[0] = 1，价值value[0] = 15</p><p>如果正序遍历</p><p>dp[1] = dp[1 - weight[0]] + value[0] = 15</p><p>dp[2] = dp[2 - weight[0]] + value[0] = 30</p><p>此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。</p><p>为什么倒序遍历，就可以保证物品只放入一次呢？</p><p>倒序就是先算dp[2]</p><p>dp[2] = dp[2 - weight[0]] + value[0] = 15 （dp数组已经都初始化为0）</p><p>dp[1] = dp[1 - weight[0]] + value[0] = 15</p><p>所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。</p><p><strong>那么问题又来了，为什么二维dp数组历的时候不用倒序呢？</strong></p><p>因为对于二维dp，dp[i][j]都是通过上一层即dp[i - 1][j]计算而来，本层的dp[i][j]并不会被覆盖！</p><p>（如何这里读不懂，大家就要动手试一试了，空想还是不靠谱的，实践出真知！）</p><p><strong>再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？</strong></p><p>不可以！</p><p>因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。</p><p>（这里如果读不懂，就在回想一下dp[j]的定义，或者就把两个for循环顺序颠倒一下试试！）</p><p><strong>所以一维dp数组的背包在遍历顺序上和二维其实是有很大差异的！</strong>，这一点大家一定要注意。</p><h3 id="举例推导dp数组-1"><a href="#举例推导dp数组-1" class="headerlink" title="举例推导dp数组"></a>举例推导dp数组</h3><p>一维dp，分别用物品0，物品1，物品2 来遍历背包，最终得到结果如下：</p><p><img src="https://img-blog.csdnimg.cn/20210110103614769.png" alt="动态规划-背包问题9"></p><h3 id="完整java测试代码-1"><a href="#完整java测试代码-1" class="headerlink" title="完整java测试代码"></a>完整java测试代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] weight = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span>[] value = &#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">bagWight</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    testWeightBagProblem(weight, value, bagWight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testWeightBagProblem</span><span class="params">(<span class="type">int</span>[] weight, <span class="type">int</span>[] value, <span class="type">int</span> bagWeight)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">wLen</span> <span class="operator">=</span> weight.length;</span><br><span class="line">    <span class="comment">//定义dp数组：dp[j]表示背包容量为j时，能获得的最大价值</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[bagWeight + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//遍历顺序：先遍历物品，再遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; wLen; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> bagWeight; j &gt;= weight[i]; j--)&#123;</span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印dp数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= bagWeight; j++)&#123;</span><br><span class="line">        System.out.print(dp[j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>以上的讲解可以开发一道面试题目（毕竟力扣上没原题）。</p><p>就是本文中的题目，要求先实现一个纯二维的01背包，如果写出来了，然后再问为什么两个for循环的嵌套顺序这么写？反过来写行不行？再讲一讲初始化的逻辑。</p><p>然后要求实现一个一维数组的01背包，最后再问，一维数组的01背包，两个for循环的顺序反过来写行不行？为什么？</p><p>注意以上问题都是在候选人把代码写出来的情况下才问的。</p><p>就是纯01背包的题目，都不用考01背包应用类的题目就可以看出候选人对算法的理解程度了。</p><p><strong>相信大家读完这篇文章，应该对以上问题都有了答案！</strong></p><p>此时01背包理论基础就讲完了，我用了两篇文章把01背包的dp数组定义、递推公式、初始化、遍历顺序从二维数组到一维数组统统深度剖析了一遍，没有放过任何难点。</p><p>大家可以发现其实信息量还是挺大的。 不用再凭感觉或者记忆去写背包，而是有自己的思考，了解其本质，代码的方方面面都在自己的掌控之中。</p><p>即使代码没有通过，也会有自己的逻辑去debug，这样就思维清晰了。</p><hr><p>本文转自 <a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html#_01-%E8%83%8C%E5%8C%85">https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html#_01-%E8%83%8C%E5%8C%85</a>，如有侵权，请联系删除。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2022/05/11/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2022/05/11/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>动态规划（Dynamic Programming，DP）是运筹学的一个分支，是求解决策过程最优化的过程。</p><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>&emsp;&emsp;动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。<br>&emsp;&emsp;动态规划算法与 <a href="https://baike.baidu.com/item/%E5%88%86%E6%B2%BB%E6%B3%95/2407337?fr=aladdin">分治法</a> 类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。 若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。<br>&emsp;&emsp;如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，<br>这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。 不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。 具体的动态规划算法多种多样，但它们具有相同的填表格式。</p><h2 id="动态规划的解题步骤"><a href="#动态规划的解题步骤" class="headerlink" title="动态规划的解题步骤"></a>动态规划的解题步骤</h2><p>状态转移公式（递推公式）是很重要，但动规不仅仅只有递推公式。<br>对于动态规划问题，将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！  </p><ol><li>确定dp数组（dp table）以及下标的含义  </li><li>确定递推公式  </li><li>dp数组如何初始化  </li><li>确定遍历顺序  </li><li>举例推导dp数组</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决Hexo文章内插入本地图片不显示的问题</title>
      <link href="/2022/05/10/%E8%A7%A3%E5%86%B3Hexo%E6%96%87%E7%AB%A0%E5%86%85%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2022/05/10/%E8%A7%A3%E5%86%B3Hexo%E6%96%87%E7%AB%A0%E5%86%85%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>如果你的博客也是通过Hexo框架建立的，在使用初期你可能也遇到过和我相似的问题：<br>在文章的.md文件中添加本地图片，在编辑器中预览中可以显示，但访问页面显示 <font face="微软雅黑" color="#F0254788"><strong>image not found</strong></font> ，下面分享一种解决此问题的方法：</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="修改博客配置"><a href="#修改博客配置" class="headerlink" title="修改博客配置"></a>修改博客配置</h3><p>修改博客根目录中<code>_config.yml</code>文件的配置项<code>post_asset_folder</code>为<code>true</code> 如下：<br><code>post_asset_folder: true</code><br>完成此设置后，当你通过<code>hexo new 文件名</code>新建博客后，会产生一个和文件同名的文件夹。</p><p><img src="/2022/05/10/%E8%A7%A3%E5%86%B3Hexo%E6%96%87%E7%AB%A0%E5%86%85%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/13713347-8e33caf1f84c415b.png" alt></p><h3 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a>下载插件</h3><p>在博客根目录中下使用npm安装插件：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>当文章需要添加图片时，将需要添加的图片放入同名的文件夹中，同时通过相对路径索引到该图片。<br>例如我在上方修改博客配置中展示的那张图片的md源码为：<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">示例</span>](<span class="link">./解决Hexo博客不显示图片的一种方法/1580801930220.png</span>)</span><br></pre></td></tr></table></figure><br>使用命令<code>hexo s</code>开启服务，若无报错在本地可以看到图片在博客中正确显示。</p>]]></content>
      
      
      <categories>
          
          <category> 关于Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pareto（帕累托）理论</title>
      <link href="/2022/05/10/%E5%A4%9A%E7%9B%AE%E6%A0%87%E4%BC%98%E5%8C%96/Pareto%EF%BC%88%E5%B8%95%E7%B4%AF%E6%89%98%EF%BC%89%E7%90%86%E8%AE%BA/"/>
      <url>/2022/05/10/%E5%A4%9A%E7%9B%AE%E6%A0%87%E4%BC%98%E5%8C%96/Pareto%EF%BC%88%E5%B8%95%E7%B4%AF%E6%89%98%EF%BC%89%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Pareto（帕累托）理论"><a href="#Pareto（帕累托）理论" class="headerlink" title="Pareto（帕累托）理论"></a>Pareto（帕累托）理论</h1><h3 id="1-Pareto理论"><a href="#1-Pareto理论" class="headerlink" title="1. Pareto理论"></a>1. Pareto理论</h3><p>维弗雷多·帕雷托 (Villefredo Pareto) 在1987年提出：社会财富的80%是掌握在20%的人手中，而余下的80%的人只占有20%的财富。渐渐地，这种“关键的少数（vital few）和次要的多数（trivial many）”的理论，被广为应用在社会学和经济学中，并被成之为Pareto原则（Pareto Principle）。Pareto Principle也常被称为80/20原则，或称帕累托法则、帕累托定律、最省力法则或不平衡原则、犹太法则。而帕累托法则认为：原因和结果、投入和产出、努力和报酬之间本来存在着无法解释的不平衡。</p><h3 id="2-Pareto-Analysis"><a href="#2-Pareto-Analysis" class="headerlink" title="2. Pareto Analysis"></a>2. Pareto Analysis</h3><p>Pareto Analysis即为帕累托分析法又称为ABC分类法，也叫主次因素分析法，是项目管理中常用的一种方法。它是根据事物在技术和经济方面的主要特征，进行分类排队，分清重点和一般，从而有区别地确定管理方式的一种分的方法。由于它把被分析的对象分成A、B、C三类，所以又称ABC分类法。ABC分类法是由意大利经济学家帕雷托首创的。1879年，帕累托研究个人收入的分布状态图是地，发现少数人收入占全部人口收入的大部分，而多数人的收入却只占一小部分，他将这一关系用图表示出来，就是著名的帕累托图。该分析方法的核心思想是在决定一事物的众多因素中分清主次，识别出少数但对事物起决定作用的关键因素和多数的但对事物影响较小的次要因素。后来，帕累托法被不断应用于管理的各个方面。1951年，管理学家戴克（H.F.Dickie）将其应用于库存管理，命名为ABC法。1951年—-1956年，朱兰将ABC法引入质量管理，用于质量问题的分析，被称为排列图。1963年，杜拉克（P.F.Drucker）将这一方法推广到全部社会现象，使ABC法成为企业提高效益的普遍应用的管理方法。</p><p>在ABC分析法的分析图中，有两个纵坐标，一个横坐标，几个长方形，一条曲线，左边纵坐标表示频数，右边纵坐标表示频率，以百分数表示。横坐标表示影响质量的各项因素，按影响大小从左向右排列，曲线表示各种影响因素大小的累计百分数。一般地，是将曲线的累计频率分为三级，与之相对应的因素分为三类：<br>A类因素，发生频率为70%～80%，是主要影响因素。<br>B类因素，发生频率为10%～20%，是次要影响因素。<br>C类因素，发生频率为0～10%，是一般影响因素。<br>这种方法有利于人们找出主次矛盾，有针对性地采取措施。ABC法大致可以分五个步骤：<br>（1）收集数据，针对不同的分析对象和分内容，收集有关数据<br>（2）统计汇总<br>（3）编制ABC分析表<br>（4）ABC分析图<br>（5）确定重点管理方式</p><h3 id="3-Pareto解"><a href="#3-Pareto解" class="headerlink" title="3. Pareto解"></a>3. Pareto解</h3><p>Pareto解又称非支配解或不受支配解（nondominated solutions）：在有多个目标时，由于存在目标之间的冲突和无法比较的现象，一个解在某个目标上是最好的，在其他的目标上可能是最差的。这些在改进任何目标函数的同时，必然会削弱至少一个其他目标函数的解称为非支配解或Pareto解。一组目标函数最优解的集合称为Pareto最优集。最优集在空间上形成的曲面称为Pareto前沿面。Pareto 在1986 年提出多目标的解不受支配解(Non-dominated set)的概念，其定义为：假设任何二解S1及S2对所有目标而言，S1均优于S2，则我们称S1 支配S2，若S1没有被其他解所支配，则S1 称为非支配解（不受支配解），也称Pareto解。</p><p>一般地，问题（multi-objective programming,MOP）可以描述成如下形式：</p><p><img src="/2022/05/10/%E5%A4%9A%E7%9B%AE%E6%A0%87%E4%BC%98%E5%8C%96/Pareto%EF%BC%88%E5%B8%95%E7%B4%AF%E6%89%98%EF%BC%89%E7%90%86%E8%AE%BA/2.jpg" alt></p><p>可以通过知乎上一个回答者（查看）的例子来加深了解：</p><p><strong> 举例1：</strong>假设现在有两个人，甲和乙，分10块蛋糕，并且两个人都喜欢吃蛋糕。10块蛋糕无论在两个人之间如何分配，都是帕累托最优，因为你想让某一个人拥有更大利益的唯一办法是从另一个人手里拿走蛋糕，导致的结果是那个被拿走蛋糕的人利益受损。</p><p><strong>举例2：</strong>假设现在有两个人，甲和乙，分10块蛋糕10个包子。甲喜欢吃蛋糕而乙喜欢吃包子，而且甲讨厌吃包子，乙讨厌吃蛋糕（甲包子吃得越多越不开心，乙蛋糕吃得越多越不开心）。这种情形下，帕累托最优应当是：把10块蛋糕全部给甲，把10个包子全部给乙。因为任何其他的分配都会使得至少一个人手里拿着一些自己讨厌的东西，比如甲拥有10块蛋糕以及2个包子，乙拥有8个包子。这个时候，如果把2个包子从甲的手里转移到乙的手里，甲和乙都变得比原来更开心了，同时这样的转移并不会使得任何一方的利益受损。</p><h3 id="4-Pareto改进"><a href="#4-Pareto改进" class="headerlink" title="4. Pareto改进"></a>4. Pareto改进</h3><p>Pareto改进 (Pareto Improvement)是指一种变化，在没有使任何人境况变坏的前提下，使得至少一个人变得更好。一方面，帕累托最优是指没有进行Pareto改进的余地的状态；另一方面，Pareto改进是达到帕累托最优的路径和方法。</p><h3 id="5-Pareto-Front"><a href="#5-Pareto-Front" class="headerlink" title="5.Pareto Front"></a>5.Pareto Front</h3><p>Pareto解的集合即所谓的Pareto Front。在Pareto front中的所有解皆不受Pareto Front之外的解（以及Pareto Front 曲线以内的其它解）所支配，因此这些非支配解较其他解而言拥有最少的目标冲突，可提供决策者一个较佳的选择空间。在某个非支配解的基础上改进任何目标函数的同时，必然会削弱至少一个其他目标函数。</p><h3 id="6-Pareto-Optimal（帕累托最优）"><a href="#6-Pareto-Optimal（帕累托最优）" class="headerlink" title="6. Pareto Optimal（帕累托最优）"></a>6. Pareto Optimal（帕累托最优）</h3><p>Pareto Optimal在维基的解释是：“不可能再改善某些人的境况，而不使任何其他人受损”。帕雷托最优的定义：帕雷托最优是资源分配的一种状态，在不使任何人境况变坏的情况下，不可能再使某些人的处境变好。帕累托最优（Pareto Optimality），也称为帕累托效率、帕累托改善，是博弈论中的重要概念，并且在经济学， 工程学和社会科学中有着广泛的应用。</p>]]></content>
      
      
      <categories>
          
          <category> 多目标优化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>代码演示</title>
      <link href="/2022/05/06/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/"/>
      <url>/2022/05/06/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客文章</title>
      <link href="/2022/05/05/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
      <url>/2022/05/05/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>内容</p><hr><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>内容</p><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>www.codesheep.cn</p><p>npm uninstall hexo-asset-image</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/05/hello-world/"/>
      <url>/2022/05/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 关于Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
